// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/@prisma/client/runtime/library.js
var require_library = __commonJS((exports, module) => {
  function xo(e) {
    return typeof e == "function" ? e : (t3) => t3.$extends(e);
  }
  function vo(e) {
    return e;
  }
  function Po(...e) {
    return (t3) => t3;
  }
  function $(e, t3) {
    let r = new RegExp(`\\x1b\\[${t3}m`, "g"), n3 = `\x1B[${e}m`, i3 = `\x1B[${t3}m`;
    return function(o3) {
      return !Ao.enabled || o3 == null ? o3 : n3 + (~("" + o3).indexOf(i3) ? o3.replace(r, i3 + n3) : o3) + i3;
    };
  }
  function Su(e) {
    let t3 = { color: Io[Cu++ % Io.length], enabled: Gt.enabled(e), namespace: e, log: Gt.log, extend: () => {
    } }, r = (...n3) => {
      let { enabled: i3, namespace: o3, color: s3, log: a } = t3;
      if (n3.length !== 0 && Qt.push([o3, ...n3]), Qt.length > Ru && Qt.shift(), Gt.enabled(o3) || i3) {
        let l3 = n3.map((c3) => typeof c3 == "string" ? c3 : Au(c3)), u3 = `+${Date.now() - Oo}ms`;
        Oo = Date.now(), globalThis.DEBUG_COLORS ? a(Mr[s3](W(o3)), ...l3, Mr[s3](u3)) : a(o3, ...l3, u3);
      }
    };
    return new Proxy(r, { get: (n3, i3) => t3[i3], set: (n3, i3, o3) => t3[i3] = o3 });
  }
  function Au(e, t3 = 2) {
    let r = new Set;
    return JSON.stringify(e, (n3, i3) => {
      if (typeof i3 == "object" && i3 !== null) {
        if (r.has(i3))
          return "[Circular *]";
        r.add(i3);
      } else if (typeof i3 == "bigint")
        return i3.toString();
      return i3;
    }, t3);
  }
  function ko(e = 7500) {
    let t3 = Qt.map(([r, ...n3]) => `${r} ${n3.map((i3) => typeof i3 == "string" ? i3 : JSON.stringify(i3)).join(" ")}`).join(`
`);
    return t3.length < e ? t3 : t3.slice(-e);
  }
  function Do() {
    Qt.length = 0;
  }
  function Hn() {
    let e = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e && _o.default.existsSync(e)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  }
  function qr(e, t3) {
    let r = t3 === "url";
    return e.includes("windows") ? r ? "query_engine.dll.node" : `query_engine-${e}.dll.node` : e.includes("darwin") ? r ? `${$r}.dylib.node` : `${$r}-${e}.dylib.node` : r ? `${$r}.so.node` : `${$r}-${e}.so.node`;
  }
  function me(e) {
    return Object.assign(e, { optional: () => Ou(e), and: (t3) => j(e, t3), or: (t3) => ku(e, t3), select: (t3) => t3 === undefined ? No(e) : No(t3, e) });
  }
  function Ou(e) {
    return me({ [Ne]: () => ({ match: (t3) => {
      let r = {}, n3 = (i3, o3) => {
        r[i3] = o3;
      };
      return t3 === undefined ? (Ge(e).forEach((i3) => n3(i3, undefined)), { matched: true, selections: r }) : { matched: we(e, t3, n3), selections: r };
    }, getSelectionKeys: () => Ge(e), matcherType: "optional" }) });
  }
  function j(...e) {
    return me({ [Ne]: () => ({ match: (t3) => {
      let r = {}, n3 = (i3, o3) => {
        r[i3] = o3;
      };
      return { matched: e.every((i3) => we(i3, t3, n3)), selections: r };
    }, getSelectionKeys: () => Jt(e, Ge), matcherType: "and" }) });
  }
  function ku(...e) {
    return me({ [Ne]: () => ({ match: (t3) => {
      let r = {}, n3 = (i3, o3) => {
        r[i3] = o3;
      };
      return Jt(e, Ge).forEach((i3) => n3(i3, undefined)), { matched: e.some((i3) => we(i3, t3, n3)), selections: r };
    }, getSelectionKeys: () => Jt(e, Ge), matcherType: "or" }) });
  }
  function I(e) {
    return { [Ne]: () => ({ match: (t3) => ({ matched: !!e(t3) }) }) };
  }
  function No(...e) {
    let t3 = typeof e[0] == "string" ? e[0] : undefined, r = e.length === 2 ? e[1] : typeof e[0] == "string" ? undefined : e[0];
    return me({ [Ne]: () => ({ match: (n3) => {
      let i3 = { [t3 ?? jr]: n3 };
      return { matched: r === undefined || we(r, n3, (o3, s3) => {
        i3[o3] = s3;
      }), selections: i3 };
    }, getSelectionKeys: () => [t3 ?? jr].concat(r === undefined ? [] : Ge(r)) }) });
  }
  function Ee(e) {
    return typeof e == "number";
  }
  function je(e) {
    return typeof e == "string";
  }
  function Be(e) {
    return typeof e == "bigint";
  }
  function dt(e) {
    return new Zn(e, zn);
  }
  function Br(e, ...t3) {
    _u.warn() && console.warn(`${Du.warn} ${e}`, ...t3);
  }
  async function qo() {
    let e = Qr.default.platform(), t3 = process.arch;
    if (e === "freebsd") {
      let s3 = await Gr("freebsd-version");
      if (s3 && s3.trim().length > 0) {
        let l3 = /^(\d+)\.?/.exec(s3);
        if (l3)
          return { platform: "freebsd", targetDistro: `freebsd${l3[1]}`, arch: t3 };
      }
    }
    if (e !== "linux")
      return { platform: e, arch: t3 };
    let r = await Mu(), n3 = await Gu(), i3 = qu({ arch: t3, archFromUname: n3, familyDistro: r.familyDistro }), { libssl: o3 } = await Vu(i3);
    return { platform: "linux", libssl: o3, arch: t3, archFromUname: n3, ...r };
  }
  function Fu(e) {
    let t3 = /^ID="?([^"\n]*)"?$/im, r = /^ID_LIKE="?([^"\n]*)"?$/im, n3 = t3.exec(e), i3 = n3 && n3[1] && n3[1].toLowerCase() || "", o3 = r.exec(e), s3 = o3 && o3[1] && o3[1].toLowerCase() || "", a = dt({ id: i3, idLike: s3 }).with({ id: "alpine" }, ({ id: l3 }) => ({ targetDistro: "musl", familyDistro: l3, originalDistro: l3 })).with({ id: "raspbian" }, ({ id: l3 }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l3 })).with({ id: "nixos" }, ({ id: l3 }) => ({ targetDistro: "nixos", originalDistro: l3, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l3 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l3 })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l3 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l3 })).when(({ idLike: l3 }) => l3.includes("debian") || l3.includes("ubuntu"), ({ id: l3 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l3 })).when(({ idLike: l3 }) => i3 === "arch" || l3.includes("arch"), ({ id: l3 }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l3 })).when(({ idLike: l3 }) => l3.includes("centos") || l3.includes("fedora") || l3.includes("rhel") || l3.includes("suse"), ({ id: l3 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l3 })).otherwise(({ id: l3 }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l3 }));
    return ne(`Found distro info:
${JSON.stringify(a, null, 2)}`), a;
  }
  async function Mu() {
    let e = "/etc/os-release";
    try {
      let t3 = await Xn.default.readFile(e, { encoding: "utf-8" });
      return Fu(t3);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  function $u(e) {
    let t3 = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);
    if (t3) {
      let r = `${t3[1]}.x`;
      return Vo(r);
    }
  }
  function Lo(e) {
    let t3 = /libssl\.so\.(\d)(\.\d)?/.exec(e);
    if (t3) {
      let r = `${t3[1]}${t3[2] ?? ".0"}.x`;
      return Vo(r);
    }
  }
  function Vo(e) {
    let t3 = (() => {
      if (Bo(e))
        return e;
      let r = e.split(".");
      return r[1] = "0", r.join(".");
    })();
    if (Lu.includes(t3))
      return t3;
  }
  function qu(e) {
    return dt(e).with({ familyDistro: "musl" }, () => (ne('Trying platform-specific paths for "alpine"'), ["/lib", "/usr/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: t3 }) => (ne('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${t3}-linux-gnu`, `/lib/${t3}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (ne('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: t3, arch: r, archFromUname: n3 }) => (ne(`Don't know any platform-specific paths for "${t3}" on ${r} (${n3})`), []));
  }
  async function Vu(e) {
    let t3 = 'grep -v "libssl.so.0"', r = await Fo(e);
    if (r) {
      ne(`Found libssl.so file using platform-specific paths: ${r}`);
      let o3 = Lo(r);
      if (ne(`The parsed libssl version is: ${o3}`), o3)
        return { libssl: o3, strategy: "libssl-specific-path" };
    }
    ne('Falling back to "ldconfig" and other generic paths');
    let n3 = await Gr(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${t3}`);
    if (n3 || (n3 = await Fo(["/lib64", "/usr/lib64", "/lib", "/usr/lib"])), n3) {
      ne(`Found libssl.so file using "ldconfig" or other generic paths: ${n3}`);
      let o3 = Lo(n3);
      if (ne(`The parsed libssl version is: ${o3}`), o3)
        return { libssl: o3, strategy: "ldconfig" };
    }
    let i3 = await Gr("openssl version -v");
    if (i3) {
      ne(`Found openssl binary with version: ${i3}`);
      let o3 = $u(i3);
      if (ne(`The parsed openssl version is: ${o3}`), o3)
        return { libssl: o3, strategy: "openssl-binary" };
    }
    return ne("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function Fo(e) {
    for (let t3 of e) {
      let r = await ju(t3);
      if (r)
        return r;
    }
  }
  async function ju(e) {
    try {
      return (await Xn.default.readdir(e)).find((r) => r.startsWith("libssl.so.") && !r.startsWith("libssl.so.0"));
    } catch (t3) {
      if (t3.code === "ENOENT")
        return;
      throw t3;
    }
  }
  async function nt() {
    let { binaryTarget: e } = await jo();
    return e;
  }
  function Bu(e) {
    return e.binaryTarget !== undefined;
  }
  async function ei() {
    let { memoized: e, ...t3 } = await jo();
    return t3;
  }
  async function jo() {
    if (Bu(Ur))
      return Promise.resolve({ ...Ur, memoized: true });
    let e = await qo(), t3 = Uu(e);
    return Ur = { ...e, binaryTarget: t3 }, { ...Ur, memoized: false };
  }
  function Uu(e) {
    let { platform: t3, arch: r, archFromUname: n3, libssl: i3, targetDistro: o3, familyDistro: s3, originalDistro: a } = e;
    t3 === "linux" && !["x64", "arm64"].includes(r) && Br(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${r}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n3}".`);
    let l3 = "1.1.x";
    if (t3 === "linux" && i3 === undefined) {
      let c3 = dt({ familyDistro: s3 }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      Br(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l3}".
${c3}`);
    }
    let u3 = "debian";
    if (t3 === "linux" && o3 === undefined && ne(`Distro is "${a}". Falling back to Prisma engines built for "${u3}".`), t3 === "darwin" && r === "arm64")
      return "darwin-arm64";
    if (t3 === "darwin")
      return "darwin";
    if (t3 === "win32")
      return "windows";
    if (t3 === "freebsd")
      return o3;
    if (t3 === "openbsd")
      return "openbsd";
    if (t3 === "netbsd")
      return "netbsd";
    if (t3 === "linux" && o3 === "nixos")
      return "linux-nixos";
    if (t3 === "linux" && r === "arm64")
      return `${o3 === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i3 || l3}`;
    if (t3 === "linux" && r === "arm")
      return `linux-arm-openssl-${i3 || l3}`;
    if (t3 === "linux" && o3 === "musl") {
      let c3 = "linux-musl";
      return !i3 || Bo(i3) ? c3 : `${c3}-openssl-${i3}`;
    }
    return t3 === "linux" && o3 && i3 ? `${o3}-openssl-${i3}` : (t3 !== "linux" && Br(`Prisma detected unknown OS "${t3}" and may not work as expected. Defaulting to "linux".`), i3 ? `${u3}-openssl-${i3}` : o3 ? `${o3}-openssl-${l3}` : `${u3}-openssl-${l3}`);
  }
  async function Qu(e) {
    try {
      return await e();
    } catch {
      return;
    }
  }
  function Gr(e) {
    return Qu(async () => {
      let t3 = await Nu(e);
      return ne(`Command "${e}" successfully returned "${t3.stdout}"`), t3.stdout;
    });
  }
  async function Gu() {
    return typeof Qr.default.machine == "function" ? Qr.default.machine() : (await Gr("uname -m"))?.trim();
  }
  function Bo(e) {
    return e.startsWith("1.");
  }
  function ai(e) {
    return (0, es.default)(e, e, { fallback: X });
  }
  function ts() {
    return q.default.join(__dirname, "../");
  }
  function pi(e) {
    if (process.platform === "win32")
      return;
    let t3 = ci.default.statSync(e), r = t3.mode | 64 | 8 | 1;
    if (t3.mode === r) {
      rs(`Execution permissions of ${e} are fine`);
      return;
    }
    let n3 = r.toString(8).slice(-3);
    rs(`Have to call chmodPlusX on ${e}`), ci.default.chmodSync(e, n3);
  }
  function di(e) {
    let t3 = e.e, r = (a) => `Prisma cannot find the required \`${a}\` system library in your system`, n3 = t3.message.includes("cannot open shared object file"), i3 = `Please refer to the documentation about Prisma's system requirements: ${ai("https://pris.ly/d/system-requirements")}`, o3 = `Unable to require(\`${ke(e.id)}\`).`, s3 = dt({ message: t3.message, code: t3.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a }) => n3 && a.includes("libz"), () => `${r("libz")}. Please install it and try again.`).when(({ message: a }) => n3 && a.includes("libgcc_s"), () => `${r("libgcc_s")}. Please install it and try again.`).when(({ message: a }) => n3 && a.includes("libssl"), () => {
      let a = e.platformInfo.libssl ? `openssl-${e.platformInfo.libssl}` : "openssl";
      return `${r("libssl")}. Please install ${a} and try again.`;
    }).when(({ message: a }) => a.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i3}`).when(({ message: a }) => e.platformInfo.platform === "linux" && a.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i3}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i3}`);
    return `${o3}
${s3}

Details: ${t3.message}`;
  }
  function ls(e) {
    let t3 = e.ignoreProcessEnv ? {} : process.env, r = (n3) => n3.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o3, s3) {
      let a = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s3);
      if (!a)
        return o3;
      let l3 = a[1], u3, c3;
      if (l3 === "\\")
        c3 = a[0], u3 = c3.replace("\\$", "$");
      else {
        let p = a[2];
        c3 = a[0].substring(l3.length), u3 = Object.hasOwnProperty.call(t3, p) ? t3[p] : e.parsed[p] || "", u3 = r(u3);
      }
      return o3.replace(c3, u3);
    }, n3) ?? n3;
    for (let n3 in e.parsed) {
      let i3 = Object.hasOwnProperty.call(t3, n3) ? t3[n3] : e.parsed[n3];
      e.parsed[n3] = r(i3);
    }
    for (let n3 in e.parsed)
      t3[n3] = e.parsed[n3];
    return e;
  }
  function Kt({ rootEnvPath: e, schemaEnvPath: t3 }, r = { conflictCheck: "none" }) {
    let n3 = us(e);
    r.conflictCheck !== "none" && fc(n3, t3, r.conflictCheck);
    let i3 = null;
    return cs(n3?.path, t3) || (i3 = us(t3)), !n3 && !i3 && hi("No Environment variables loaded"), i3?.dotenvResult.error ? console.error(de(W("Schema Env Error: ")) + i3.dotenvResult.error) : { message: [n3?.message, i3?.message].filter(Boolean).join(`
`), parsed: { ...n3?.dotenvResult?.parsed, ...i3?.dotenvResult?.parsed } };
  }
  function fc(e, t3, r) {
    let n3 = e?.dotenvResult.parsed, i3 = !cs(e?.path, t3);
    if (n3 && t3 && i3 && Kr.default.existsSync(t3)) {
      let o3 = yi.default.parse(Kr.default.readFileSync(t3)), s3 = [];
      for (let a in o3)
        n3[a] === o3[a] && s3.push(a);
      if (s3.length > 0) {
        let a = gt.default.relative(process.cwd(), e.path), l3 = gt.default.relative(process.cwd(), t3);
        if (r === "error") {
          let u3 = `There is a conflict between env var${s3.length > 1 ? "s" : ""} in ${X(a)} and ${X(l3)}
Conflicting env vars:
${s3.map((c3) => `  ${W(c3)}`).join(`
`)}

We suggest to move the contents of ${X(l3)} to ${X(a)} to consolidate your env vars.
`;
          throw new Error(u3);
        } else if (r === "warn") {
          let u3 = `Conflict for env var${s3.length > 1 ? "s" : ""} ${s3.map((c3) => W(c3)).join(", ")} in ${X(a)} and ${X(l3)}
Env vars from ${X(l3)} overwrite the ones from ${X(a)}
      `;
          console.warn(`${De("warn(prisma)")} ${u3}`);
        }
      }
    }
  }
  function us(e) {
    if (gc(e)) {
      hi(`Environment variables loaded from ${e}`);
      let t3 = yi.default.config({ path: e, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined });
      return { dotenvResult: ls(t3), message: ke(`Environment variables loaded from ${gt.default.relative(process.cwd(), e)}`), path: e };
    } else
      hi(`Environment variables not found at ${e}`);
    return null;
  }
  function cs(e, t3) {
    return e && t3 && gt.default.resolve(e) === gt.default.resolve(t3);
  }
  function gc(e) {
    return !!(e && Kr.default.existsSync(e));
  }
  function Yt(e) {
    let t3 = hc();
    return t3 || (e?.config.engineType === "library" ? "library" : e?.config.engineType === "binary" ? "binary" : ps);
  }
  function hc() {
    let e = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e === "library" ? "library" : e === "binary" ? "binary" : undefined;
  }
  function Ei(e) {
    return Zt.default.sep === Zt.default.posix.sep ? e : e.split(Zt.default.sep).join(Zt.default.posix.sep);
  }
  function xi(e) {
    return String(new wi(e));
  }
  function Ec(e) {
    let t3;
    if (e.length > 0) {
      let r = e.find((n3) => n3.fromEnvVar !== null);
      r ? t3 = `env("${r.fromEnvVar}")` : t3 = e.map((n3) => n3.native ? "native" : n3.value);
    } else
      t3 = undefined;
    return t3;
  }
  function bc(e) {
    let t3 = Object.keys(e).reduce((r, n3) => Math.max(r, n3.length), 0);
    return Object.entries(e).map(([r, n3]) => `${r.padEnd(t3)} = ${wc(n3)}`).join(`
`);
  }
  function wc(e) {
    return JSON.parse(JSON.stringify(e, (t3, r) => Array.isArray(r) ? `[${r.map((n3) => JSON.stringify(n3)).join(", ")}]` : JSON.stringify(r)));
  }
  function xc(...e) {
    console.log(...e);
  }
  function vi(e, ...t3) {
    Es.warn() && console.warn(`${Xt.warn} ${e}`, ...t3);
  }
  function vc(e, ...t3) {
    console.info(`${Xt.info} ${e}`, ...t3);
  }
  function Pc(e, ...t3) {
    console.error(`${Xt.error} ${e}`, ...t3);
  }
  function Tc(e, ...t3) {
    console.log(`${Xt.query} ${e}`, ...t3);
  }
  function Yr(e, t3) {
    if (!e)
      throw new Error(`${t3}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`);
  }
  function Fe(e, t3) {
    throw new Error(t3);
  }
  function Ti(e, t3) {
    return Object.prototype.hasOwnProperty.call(e, t3);
  }
  function ht(e, t3) {
    let r = {};
    for (let n3 of Object.keys(e))
      r[n3] = t3(e[n3], n3);
    return r;
  }
  function Ci(e, t3) {
    if (e.length === 0)
      return;
    let r = e[0];
    for (let n3 = 1;n3 < e.length; n3++)
      t3(r, e[n3]) < 0 && (r = e[n3]);
    return r;
  }
  function w(e, t3) {
    Object.defineProperty(e, "name", { value: t3, configurable: true });
  }
  function K(e) {
    var t3, r, n3, i3 = e.length - 1, o3 = "", s3 = e[0];
    if (i3 > 0) {
      for (o3 += s3, t3 = 1;t3 < i3; t3++)
        n3 = e[t3] + "", r = E - n3.length, r && (o3 += He(r)), o3 += n3;
      s3 = e[t3], n3 = s3 + "", r = E - n3.length, r && (o3 += He(r));
    } else if (s3 === 0)
      return "0";
    for (;s3 % 10 === 0; )
      s3 /= 10;
    return o3 + s3;
  }
  function se(e, t3, r) {
    if (e !== ~~e || e < t3 || e > r)
      throw Error(Ke + e);
  }
  function rr(e, t3, r, n3) {
    var i3, o3, s3, a;
    for (o3 = e[0];o3 >= 10; o3 /= 10)
      --t3;
    return --t3 < 0 ? (t3 += E, i3 = 0) : (i3 = Math.ceil((t3 + 1) / E), t3 %= E), o3 = G(10, E - t3), a = e[i3] % o3 | 0, n3 == null ? t3 < 3 ? (t3 == 0 ? a = a / 100 | 0 : t3 == 1 && (a = a / 10 | 0), s3 = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 50000 || a == 0) : s3 = (r < 4 && a + 1 == o3 || r > 3 && a + 1 == o3 / 2) && (e[i3 + 1] / o3 / 100 | 0) == G(10, t3 - 2) - 1 || (a == o3 / 2 || a == 0) && (e[i3 + 1] / o3 / 100 | 0) == 0 : t3 < 4 ? (t3 == 0 ? a = a / 1000 | 0 : t3 == 1 ? a = a / 100 | 0 : t3 == 2 && (a = a / 10 | 0), s3 = (n3 || r < 4) && a == 9999 || !n3 && r > 3 && a == 4999) : s3 = ((n3 || r < 4) && a + 1 == o3 || !n3 && r > 3 && a + 1 == o3 / 2) && (e[i3 + 1] / o3 / 1000 | 0) == G(10, t3 - 3) - 1, s3;
  }
  function Xr(e, t3, r) {
    for (var n3, i3 = [0], o3, s3 = 0, a = e.length;s3 < a; ) {
      for (o3 = i3.length;o3--; )
        i3[o3] *= t3;
      for (i3[0] += Si.indexOf(e.charAt(s3++)), n3 = 0;n3 < i3.length; n3++)
        i3[n3] > r - 1 && (i3[n3 + 1] === undefined && (i3[n3 + 1] = 0), i3[n3 + 1] += i3[n3] / r | 0, i3[n3] %= r);
    }
    return i3.reverse();
  }
  function kc(e, t3) {
    var r, n3, i3;
    if (t3.isZero())
      return t3;
    n3 = t3.d.length, n3 < 32 ? (r = Math.ceil(n3 / 3), i3 = (1 / sn(4, r)).toString()) : (r = 16, i3 = "2.3283064365386962890625e-10"), e.precision += r, t3 = Et(e, 1, t3.times(i3), new e(1));
    for (var o3 = r;o3--; ) {
      var s3 = t3.times(t3);
      t3 = s3.times(s3).minus(s3).times(8).plus(1);
    }
    return e.precision -= r, t3;
  }
  function y3(e, t3, r, n3) {
    var i3, o3, s3, a, l3, u3, c3, p, d3, f3 = e.constructor;
    e:
      if (t3 != null) {
        if (p = e.d, !p)
          return e;
        for (i3 = 1, a = p[0];a >= 10; a /= 10)
          i3++;
        if (o3 = t3 - i3, o3 < 0)
          o3 += E, s3 = t3, c3 = p[d3 = 0], l3 = c3 / G(10, i3 - s3 - 1) % 10 | 0;
        else if (d3 = Math.ceil((o3 + 1) / E), a = p.length, d3 >= a)
          if (n3) {
            for (;a++ <= d3; )
              p.push(0);
            c3 = l3 = 0, i3 = 1, o3 %= E, s3 = o3 - E + 1;
          } else
            break e;
        else {
          for (c3 = a = p[d3], i3 = 1;a >= 10; a /= 10)
            i3++;
          o3 %= E, s3 = o3 - E + i3, l3 = s3 < 0 ? 0 : c3 / G(10, i3 - s3 - 1) % 10 | 0;
        }
        if (n3 = n3 || t3 < 0 || p[d3 + 1] !== undefined || (s3 < 0 ? c3 : c3 % G(10, i3 - s3 - 1)), u3 = r < 4 ? (l3 || n3) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : l3 > 5 || l3 == 5 && (r == 4 || n3 || r == 6 && (o3 > 0 ? s3 > 0 ? c3 / G(10, i3 - s3) : 0 : p[d3 - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t3 < 1 || !p[0])
          return p.length = 0, u3 ? (t3 -= e.e + 1, p[0] = G(10, (E - t3 % E) % E), e.e = -t3 || 0) : p[0] = e.e = 0, e;
        if (o3 == 0 ? (p.length = d3, a = 1, d3--) : (p.length = d3 + 1, a = G(10, E - o3), p[d3] = s3 > 0 ? (c3 / G(10, i3 - s3) % G(10, s3) | 0) * a : 0), u3)
          for (;; )
            if (d3 == 0) {
              for (o3 = 1, s3 = p[0];s3 >= 10; s3 /= 10)
                o3++;
              for (s3 = p[0] += a, a = 1;s3 >= 10; s3 /= 10)
                a++;
              o3 != a && (e.e++, p[0] == he && (p[0] = 1));
              break;
            } else {
              if (p[d3] += a, p[d3] != he)
                break;
              p[d3--] = 0, a = 1;
            }
        for (o3 = p.length;p[--o3] === 0; )
          p.pop();
      }
    return b && (e.e > f3.maxE ? (e.d = null, e.e = NaN) : e.e < f3.minE && (e.e = 0, e.d = [0])), e;
  }
  function xe(e, t3, r) {
    if (!e.isFinite())
      return Ls(e);
    var n3, i3 = e.e, o3 = K(e.d), s3 = o3.length;
    return t3 ? (r && (n3 = r - s3) > 0 ? o3 = o3.charAt(0) + "." + o3.slice(1) + He(n3) : s3 > 1 && (o3 = o3.charAt(0) + "." + o3.slice(1)), o3 = o3 + (e.e < 0 ? "e" : "e+") + e.e) : i3 < 0 ? (o3 = "0." + He(-i3 - 1) + o3, r && (n3 = r - s3) > 0 && (o3 += He(n3))) : i3 >= s3 ? (o3 += He(i3 + 1 - s3), r && (n3 = r - i3 - 1) > 0 && (o3 = o3 + "." + He(n3))) : ((n3 = i3 + 1) < s3 && (o3 = o3.slice(0, n3) + "." + o3.slice(n3)), r && (n3 = r - s3) > 0 && (i3 + 1 === s3 && (o3 += "."), o3 += He(n3))), o3;
  }
  function on(e, t3) {
    var r = e[0];
    for (t3 *= E;r >= 10; r /= 10)
      t3++;
    return t3;
  }
  function rn(e, t3, r) {
    if (t3 > Oc)
      throw b = true, r && (e.precision = r), Error(As);
    return y3(new e(en), t3, 1, true);
  }
  function ge(e, t3, r) {
    if (t3 > Ii)
      throw Error(As);
    return y3(new e(tn), t3, r, true);
  }
  function Ds(e) {
    var t3 = e.length - 1, r = t3 * E + 1;
    if (t3 = e[t3], t3) {
      for (;t3 % 10 == 0; t3 /= 10)
        r--;
      for (t3 = e[0];t3 >= 10; t3 /= 10)
        r++;
    }
    return r;
  }
  function He(e) {
    for (var t3 = "";e--; )
      t3 += "0";
    return t3;
  }
  function _s(e, t3, r, n3) {
    var i3, o3 = new e(1), s3 = Math.ceil(n3 / E + 4);
    for (b = false;; ) {
      if (r % 2 && (o3 = o3.times(t3), Rs(o3.d, s3) && (i3 = true)), r = re(r / 2), r === 0) {
        r = o3.d.length - 1, i3 && o3.d[r] === 0 && ++o3.d[r];
        break;
      }
      t3 = t3.times(t3), Rs(t3.d, s3);
    }
    return b = true, o3;
  }
  function Ts(e) {
    return e.d[e.d.length - 1] & 1;
  }
  function Ns(e, t3, r) {
    for (var n3, i3 = new e(t3[0]), o3 = 0;++o3 < t3.length; )
      if (n3 = new e(t3[o3]), n3.s)
        i3[r](n3) && (i3 = n3);
      else {
        i3 = n3;
        break;
      }
    return i3;
  }
  function Oi(e, t3) {
    var r, n3, i3, o3, s3, a, l3, u3 = 0, c3 = 0, p = 0, d3 = e.constructor, f3 = d3.rounding, g = d3.precision;
    if (!e.d || !e.d[0] || e.e > 17)
      return new d3(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
    for (t3 == null ? (b = false, l3 = g) : l3 = t3, a = new d3(0.03125);e.e > -2; )
      e = e.times(a), p += 5;
    for (n3 = Math.log(G(2, p)) / Math.LN10 * 2 + 5 | 0, l3 += n3, r = o3 = s3 = new d3(1), d3.precision = l3;; ) {
      if (o3 = y3(o3.times(e), l3, 1), r = r.times(++c3), a = s3.plus(M(o3, r, l3, 1)), K(a.d).slice(0, l3) === K(s3.d).slice(0, l3)) {
        for (i3 = p;i3--; )
          s3 = y3(s3.times(s3), l3, 1);
        if (t3 == null)
          if (u3 < 3 && rr(s3.d, l3 - n3, f3, u3))
            d3.precision = l3 += 10, r = o3 = a = new d3(1), c3 = 0, u3++;
          else
            return y3(s3, d3.precision = g, f3, b = true);
        else
          return d3.precision = g, s3;
      }
      s3 = a;
    }
  }
  function We(e, t3) {
    var r, n3, i3, o3, s3, a, l3, u3, c3, p, d3, f3 = 1, g = 10, h = e, O = h.d, P = h.constructor, C4 = P.rounding, R = P.precision;
    if (h.s < 0 || !O || !O[0] || !h.e && O[0] == 1 && O.length == 1)
      return new P(O && !O[0] ? -1 / 0 : h.s != 1 ? NaN : O ? 0 : h);
    if (t3 == null ? (b = false, c3 = R) : c3 = t3, P.precision = c3 += g, r = K(O), n3 = r.charAt(0), Math.abs(o3 = h.e) < 1500000000000000) {
      for (;n3 < 7 && n3 != 1 || n3 == 1 && r.charAt(1) > 3; )
        h = h.times(e), r = K(h.d), n3 = r.charAt(0), f3++;
      o3 = h.e, n3 > 1 ? (h = new P("0." + r), o3++) : h = new P(n3 + "." + r.slice(1));
    } else
      return u3 = rn(P, c3 + 2, R).times(o3 + ""), h = We(new P(n3 + "." + r.slice(1)), c3 - g).plus(u3), P.precision = R, t3 == null ? y3(h, R, C4, b = true) : h;
    for (p = h, l3 = s3 = h = M(h.minus(1), h.plus(1), c3, 1), d3 = y3(h.times(h), c3, 1), i3 = 3;; ) {
      if (s3 = y3(s3.times(d3), c3, 1), u3 = l3.plus(M(s3, new P(i3), c3, 1)), K(u3.d).slice(0, c3) === K(l3.d).slice(0, c3))
        if (l3 = l3.times(2), o3 !== 0 && (l3 = l3.plus(rn(P, c3 + 2, R).times(o3 + ""))), l3 = M(l3, new P(f3), c3, 1), t3 == null)
          if (rr(l3.d, c3 - g, C4, a))
            P.precision = c3 += g, u3 = s3 = h = M(p.minus(1), p.plus(1), c3, 1), d3 = y3(h.times(h), c3, 1), i3 = a = 1;
          else
            return y3(l3, P.precision = R, C4, b = true);
        else
          return P.precision = R, l3;
      l3 = u3, i3 += 2;
    }
  }
  function Ls(e) {
    return String(e.s * e.s / 0);
  }
  function ki(e, t3) {
    var r, n3, i3;
    for ((r = t3.indexOf(".")) > -1 && (t3 = t3.replace(".", "")), (n3 = t3.search(/e/i)) > 0 ? (r < 0 && (r = n3), r += +t3.slice(n3 + 1), t3 = t3.substring(0, n3)) : r < 0 && (r = t3.length), n3 = 0;t3.charCodeAt(n3) === 48; n3++)
      ;
    for (i3 = t3.length;t3.charCodeAt(i3 - 1) === 48; --i3)
      ;
    if (t3 = t3.slice(n3, i3), t3) {
      if (i3 -= n3, e.e = r = r - n3 - 1, e.d = [], n3 = (r + 1) % E, r < 0 && (n3 += E), n3 < i3) {
        for (n3 && e.d.push(+t3.slice(0, n3)), i3 -= E;n3 < i3; )
          e.d.push(+t3.slice(n3, n3 += E));
        t3 = t3.slice(n3), n3 = E - t3.length;
      } else
        n3 -= i3;
      for (;n3--; )
        t3 += "0";
      e.d.push(+t3), b && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
    } else
      e.e = 0, e.d = [0];
    return e;
  }
  function Dc(e, t3) {
    var r, n3, i3, o3, s3, a, l3, u3, c3;
    if (t3.indexOf("_") > -1) {
      if (t3 = t3.replace(/(\d)_(?=\d)/g, "$1"), ks.test(t3))
        return ki(e, t3);
    } else if (t3 === "Infinity" || t3 === "NaN")
      return +t3 || (e.s = NaN), e.e = NaN, e.d = null, e;
    if (Sc.test(t3))
      r = 16, t3 = t3.toLowerCase();
    else if (Cc.test(t3))
      r = 2;
    else if (Ac.test(t3))
      r = 8;
    else
      throw Error(Ke + t3);
    for (o3 = t3.search(/p/i), o3 > 0 ? (l3 = +t3.slice(o3 + 1), t3 = t3.substring(2, o3)) : t3 = t3.slice(2), o3 = t3.indexOf("."), s3 = o3 >= 0, n3 = e.constructor, s3 && (t3 = t3.replace(".", ""), a = t3.length, o3 = a - o3, i3 = _s(n3, new n3(r), o3, o3 * 2)), u3 = Xr(t3, r, he), c3 = u3.length - 1, o3 = c3;u3[o3] === 0; --o3)
      u3.pop();
    return o3 < 0 ? new n3(e.s * 0) : (e.e = on(u3, c3), e.d = u3, b = false, s3 && (e = M(e, i3, a * 4)), l3 && (e = e.times(Math.abs(l3) < 54 ? G(2, l3) : it.pow(2, l3))), b = true, e);
  }
  function _c(e, t3) {
    var r, n3 = t3.d.length;
    if (n3 < 3)
      return t3.isZero() ? t3 : Et(e, 2, t3, t3);
    r = 1.4 * Math.sqrt(n3), r = r > 16 ? 16 : r | 0, t3 = t3.times(1 / sn(5, r)), t3 = Et(e, 2, t3, t3);
    for (var i3, o3 = new e(5), s3 = new e(16), a = new e(20);r--; )
      i3 = t3.times(t3), t3 = t3.times(o3.plus(i3.times(s3.times(i3).minus(a))));
    return t3;
  }
  function Et(e, t3, r, n3, i3) {
    var o3, s3, a, l3, u3 = 1, c3 = e.precision, p = Math.ceil(c3 / E);
    for (b = false, l3 = r.times(r), a = new e(n3);; ) {
      if (s3 = M(a.times(l3), new e(t3++ * t3++), c3, 1), a = i3 ? n3.plus(s3) : n3.minus(s3), n3 = M(s3.times(l3), new e(t3++ * t3++), c3, 1), s3 = a.plus(n3), s3.d[p] !== undefined) {
        for (o3 = p;s3.d[o3] === a.d[o3] && o3--; )
          ;
        if (o3 == -1)
          break;
      }
      o3 = a, a = n3, n3 = s3, s3 = o3, u3++;
    }
    return b = true, s3.d.length = p + 1, s3;
  }
  function sn(e, t3) {
    for (var r = e;--t3; )
      r *= e;
    return r;
  }
  function Fs(e, t3) {
    var r, n3 = t3.s < 0, i3 = ge(e, e.precision, 1), o3 = i3.times(0.5);
    if (t3 = t3.abs(), t3.lte(o3))
      return Me = n3 ? 4 : 1, t3;
    if (r = t3.divToInt(i3), r.isZero())
      Me = n3 ? 3 : 2;
    else {
      if (t3 = t3.minus(r.times(i3)), t3.lte(o3))
        return Me = Ts(r) ? n3 ? 2 : 3 : n3 ? 4 : 1, t3;
      Me = Ts(r) ? n3 ? 1 : 4 : n3 ? 3 : 2;
    }
    return t3.minus(i3).abs();
  }
  function Di(e, t3, r, n3) {
    var i3, o3, s3, a, l3, u3, c3, p, d3, f3 = e.constructor, g = r !== undefined;
    if (g ? (se(r, 1, Ye), n3 === undefined ? n3 = f3.rounding : se(n3, 0, 8)) : (r = f3.precision, n3 = f3.rounding), !e.isFinite())
      c3 = Ls(e);
    else {
      for (c3 = xe(e), s3 = c3.indexOf("."), g ? (i3 = 2, t3 == 16 ? r = r * 4 - 3 : t3 == 8 && (r = r * 3 - 2)) : i3 = t3, s3 >= 0 && (c3 = c3.replace(".", ""), d3 = new f3(1), d3.e = c3.length - s3, d3.d = Xr(xe(d3), 10, i3), d3.e = d3.d.length), p = Xr(c3, 10, i3), o3 = l3 = p.length;p[--l3] == 0; )
        p.pop();
      if (!p[0])
        c3 = g ? "0p+0" : "0";
      else {
        if (s3 < 0 ? o3-- : (e = new f3(e), e.d = p, e.e = o3, e = M(e, d3, r, n3, 0, i3), p = e.d, o3 = e.e, u3 = Ss), s3 = p[r], a = i3 / 2, u3 = u3 || p[r + 1] !== undefined, u3 = n3 < 4 ? (s3 !== undefined || u3) && (n3 === 0 || n3 === (e.s < 0 ? 3 : 2)) : s3 > a || s3 === a && (n3 === 4 || u3 || n3 === 6 && p[r - 1] & 1 || n3 === (e.s < 0 ? 8 : 7)), p.length = r, u3)
          for (;++p[--r] > i3 - 1; )
            p[r] = 0, r || (++o3, p.unshift(1));
        for (l3 = p.length;!p[l3 - 1]; --l3)
          ;
        for (s3 = 0, c3 = "";s3 < l3; s3++)
          c3 += Si.charAt(p[s3]);
        if (g) {
          if (l3 > 1)
            if (t3 == 16 || t3 == 8) {
              for (s3 = t3 == 16 ? 4 : 3, --l3;l3 % s3; l3++)
                c3 += "0";
              for (p = Xr(c3, i3, t3), l3 = p.length;!p[l3 - 1]; --l3)
                ;
              for (s3 = 1, c3 = "1.";s3 < l3; s3++)
                c3 += Si.charAt(p[s3]);
            } else
              c3 = c3.charAt(0) + "." + c3.slice(1);
          c3 = c3 + (o3 < 0 ? "p" : "p+") + o3;
        } else if (o3 < 0) {
          for (;++o3; )
            c3 = "0" + c3;
          c3 = "0." + c3;
        } else if (++o3 > l3)
          for (o3 -= l3;o3--; )
            c3 += "0";
        else
          o3 < l3 && (c3 = c3.slice(0, o3) + "." + c3.slice(o3));
      }
      c3 = (t3 == 16 ? "0x" : t3 == 2 ? "0b" : t3 == 8 ? "0o" : "") + c3;
    }
    return e.s < 0 ? "-" + c3 : c3;
  }
  function Rs(e, t3) {
    if (e.length > t3)
      return e.length = t3, true;
  }
  function Nc(e) {
    return new this(e).abs();
  }
  function Lc(e) {
    return new this(e).acos();
  }
  function Fc(e) {
    return new this(e).acosh();
  }
  function Mc(e, t3) {
    return new this(e).plus(t3);
  }
  function $c(e) {
    return new this(e).asin();
  }
  function qc(e) {
    return new this(e).asinh();
  }
  function Vc(e) {
    return new this(e).atan();
  }
  function jc(e) {
    return new this(e).atanh();
  }
  function Bc(e, t3) {
    e = new this(e), t3 = new this(t3);
    var r, n3 = this.precision, i3 = this.rounding, o3 = n3 + 4;
    return !e.s || !t3.s ? r = new this(NaN) : !e.d && !t3.d ? (r = ge(this, o3, 1).times(t3.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t3.d || e.isZero() ? (r = t3.s < 0 ? ge(this, n3, i3) : new this(0), r.s = e.s) : !e.d || t3.isZero() ? (r = ge(this, o3, 1).times(0.5), r.s = e.s) : t3.s < 0 ? (this.precision = o3, this.rounding = 1, r = this.atan(M(e, t3, o3, 1)), t3 = ge(this, o3, 1), this.precision = n3, this.rounding = i3, r = e.s < 0 ? r.minus(t3) : r.plus(t3)) : r = this.atan(M(e, t3, o3, 1)), r;
  }
  function Uc(e) {
    return new this(e).cbrt();
  }
  function Qc(e) {
    return y3(e = new this(e), e.e + 1, 2);
  }
  function Gc(e, t3, r) {
    return new this(e).clamp(t3, r);
  }
  function Jc(e) {
    if (!e || typeof e != "object")
      throw Error(nn + "Object expected");
    var t3, r, n3, i3 = e.defaults === true, o3 = ["precision", 1, Ye, "rounding", 0, 8, "toExpNeg", -yt, 0, "toExpPos", 0, yt, "maxE", 0, yt, "minE", -yt, 0, "modulo", 0, 9];
    for (t3 = 0;t3 < o3.length; t3 += 3)
      if (r = o3[t3], i3 && (this[r] = Ai[r]), (n3 = e[r]) !== undefined)
        if (re(n3) === n3 && n3 >= o3[t3 + 1] && n3 <= o3[t3 + 2])
          this[r] = n3;
        else
          throw Error(Ke + r + ": " + n3);
    if (r = "crypto", i3 && (this[r] = Ai[r]), (n3 = e[r]) !== undefined)
      if (n3 === true || n3 === false || n3 === 0 || n3 === 1)
        if (n3)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[r] = true;
          else
            throw Error(Is);
        else
          this[r] = false;
      else
        throw Error(Ke + r + ": " + n3);
    return this;
  }
  function Hc(e) {
    return new this(e).cos();
  }
  function Wc(e) {
    return new this(e).cosh();
  }
  function Ms(e) {
    var t3, r, n3;
    function i3(o3) {
      var s3, a, l3, u3 = this;
      if (!(u3 instanceof i3))
        return new i3(o3);
      if (u3.constructor = i3, Cs(o3)) {
        u3.s = o3.s, b ? !o3.d || o3.e > i3.maxE ? (u3.e = NaN, u3.d = null) : o3.e < i3.minE ? (u3.e = 0, u3.d = [0]) : (u3.e = o3.e, u3.d = o3.d.slice()) : (u3.e = o3.e, u3.d = o3.d ? o3.d.slice() : o3.d);
        return;
      }
      if (l3 = typeof o3, l3 === "number") {
        if (o3 === 0) {
          u3.s = 1 / o3 < 0 ? -1 : 1, u3.e = 0, u3.d = [0];
          return;
        }
        if (o3 < 0 ? (o3 = -o3, u3.s = -1) : u3.s = 1, o3 === ~~o3 && o3 < 1e7) {
          for (s3 = 0, a = o3;a >= 10; a /= 10)
            s3++;
          b ? s3 > i3.maxE ? (u3.e = NaN, u3.d = null) : s3 < i3.minE ? (u3.e = 0, u3.d = [0]) : (u3.e = s3, u3.d = [o3]) : (u3.e = s3, u3.d = [o3]);
          return;
        } else if (o3 * 0 !== 0) {
          o3 || (u3.s = NaN), u3.e = NaN, u3.d = null;
          return;
        }
        return ki(u3, o3.toString());
      } else if (l3 !== "string")
        throw Error(Ke + o3);
      return (a = o3.charCodeAt(0)) === 45 ? (o3 = o3.slice(1), u3.s = -1) : (a === 43 && (o3 = o3.slice(1)), u3.s = 1), ks.test(o3) ? ki(u3, o3) : Dc(u3, o3);
    }
    if (i3.prototype = m3, i3.ROUND_UP = 0, i3.ROUND_DOWN = 1, i3.ROUND_CEIL = 2, i3.ROUND_FLOOR = 3, i3.ROUND_HALF_UP = 4, i3.ROUND_HALF_DOWN = 5, i3.ROUND_HALF_EVEN = 6, i3.ROUND_HALF_CEIL = 7, i3.ROUND_HALF_FLOOR = 8, i3.EUCLID = 9, i3.config = i3.set = Jc, i3.clone = Ms, i3.isDecimal = Cs, i3.abs = Nc, i3.acos = Lc, i3.acosh = Fc, i3.add = Mc, i3.asin = $c, i3.asinh = qc, i3.atan = Vc, i3.atanh = jc, i3.atan2 = Bc, i3.cbrt = Uc, i3.ceil = Qc, i3.clamp = Gc, i3.cos = Hc, i3.cosh = Wc, i3.div = Kc, i3.exp = Yc, i3.floor = zc, i3.hypot = Zc, i3.ln = Xc, i3.log = ep, i3.log10 = rp, i3.log2 = tp, i3.max = np, i3.min = ip, i3.mod = op, i3.mul = sp, i3.pow = ap, i3.random = lp, i3.round = up, i3.sign = cp, i3.sin = pp, i3.sinh = dp, i3.sqrt = mp, i3.sub = fp, i3.sum = gp, i3.tan = hp, i3.tanh = yp, i3.trunc = Ep, e === undefined && (e = {}), e && e.defaults !== true)
      for (n3 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t3 = 0;t3 < n3.length; )
        e.hasOwnProperty(r = n3[t3++]) || (e[r] = this[r]);
    return i3.config(e), i3;
  }
  function Kc(e, t3) {
    return new this(e).div(t3);
  }
  function Yc(e) {
    return new this(e).exp();
  }
  function zc(e) {
    return y3(e = new this(e), e.e + 1, 3);
  }
  function Zc() {
    var e, t3, r = new this(0);
    for (b = false, e = 0;e < arguments.length; )
      if (t3 = new this(arguments[e++]), t3.d)
        r.d && (r = r.plus(t3.times(t3)));
      else {
        if (t3.s)
          return b = true, new this(1 / 0);
        r = t3;
      }
    return b = true, r.sqrt();
  }
  function Cs(e) {
    return e instanceof it || e && e.toStringTag === Os || false;
  }
  function Xc(e) {
    return new this(e).ln();
  }
  function ep(e, t3) {
    return new this(e).log(t3);
  }
  function tp(e) {
    return new this(e).log(2);
  }
  function rp(e) {
    return new this(e).log(10);
  }
  function np() {
    return Ns(this, arguments, "lt");
  }
  function ip() {
    return Ns(this, arguments, "gt");
  }
  function op(e, t3) {
    return new this(e).mod(t3);
  }
  function sp(e, t3) {
    return new this(e).mul(t3);
  }
  function ap(e, t3) {
    return new this(e).pow(t3);
  }
  function lp(e) {
    var t3, r, n3, i3, o3 = 0, s3 = new this(1), a = [];
    if (e === undefined ? e = this.precision : se(e, 1, Ye), n3 = Math.ceil(e / E), this.crypto)
      if (crypto.getRandomValues)
        for (t3 = crypto.getRandomValues(new Uint32Array(n3));o3 < n3; )
          i3 = t3[o3], i3 >= 4290000000 ? t3[o3] = crypto.getRandomValues(new Uint32Array(1))[0] : a[o3++] = i3 % 1e7;
      else if (crypto.randomBytes) {
        for (t3 = crypto.randomBytes(n3 *= 4);o3 < n3; )
          i3 = t3[o3] + (t3[o3 + 1] << 8) + (t3[o3 + 2] << 16) + ((t3[o3 + 3] & 127) << 24), i3 >= 2140000000 ? crypto.randomBytes(4).copy(t3, o3) : (a.push(i3 % 1e7), o3 += 4);
        o3 = n3 / 4;
      } else
        throw Error(Is);
    else
      for (;o3 < n3; )
        a[o3++] = Math.random() * 1e7 | 0;
    for (n3 = a[--o3], e %= E, n3 && e && (i3 = G(10, E - e), a[o3] = (n3 / i3 | 0) * i3);a[o3] === 0; o3--)
      a.pop();
    if (o3 < 0)
      r = 0, a = [0];
    else {
      for (r = -1;a[0] === 0; r -= E)
        a.shift();
      for (n3 = 1, i3 = a[0];i3 >= 10; i3 /= 10)
        n3++;
      n3 < E && (r -= E - n3);
    }
    return s3.e = r, s3.d = a, s3;
  }
  function up(e) {
    return y3(e = new this(e), e.e + 1, this.rounding);
  }
  function cp(e) {
    return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
  }
  function pp(e) {
    return new this(e).sin();
  }
  function dp(e) {
    return new this(e).sinh();
  }
  function mp(e) {
    return new this(e).sqrt();
  }
  function fp(e, t3) {
    return new this(e).sub(t3);
  }
  function gp() {
    var e = 0, t3 = arguments, r = new this(t3[e]);
    for (b = false;r.s && ++e < t3.length; )
      r = r.plus(t3[e]);
    return b = true, y3(r, this.precision, this.rounding);
  }
  function hp(e) {
    return new this(e).tan();
  }
  function yp(e) {
    return new this(e).tanh();
  }
  function Ep(e) {
    return y3(e = new this(e), e.e + 1, 1);
  }
  function bt(e) {
    return e === null ? e : Array.isArray(e) ? e.map(bt) : typeof e == "object" ? bp(e) ? wp(e) : ht(e, bt) : e;
  }
  function bp(e) {
    return e !== null && typeof e == "object" && typeof e.$type == "string";
  }
  function wp({ $type: e, value: t3 }) {
    switch (e) {
      case "BigInt":
        return BigInt(t3);
      case "Bytes": {
        let { buffer: r, byteOffset: n3, byteLength: i3 } = Buffer.from(t3, "base64");
        return new Uint8Array(r, n3, i3);
      }
      case "DateTime":
        return new Date(t3);
      case "Decimal":
        return new ve(t3);
      case "Json":
        return JSON.parse(t3);
      default:
        Fe(t3, "Unknown tagged value");
    }
  }
  function wt(e) {
    return e.substring(0, 1).toLowerCase() + e.substring(1);
  }
  function xt(e) {
    return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
  }
  function an(e) {
    return e.toString() !== "Invalid Date";
  }
  function vt(e) {
    return it.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
  }
  function ye(e, t3, r, n3, i3) {
    this.type = e, this.content = t3, this.alias = r, this.length = (n3 || "").length | 0, this.greedy = !!i3;
  }
  function Pp(e) {
    return $s[e] || xp;
  }
  function qs(e) {
    return Tp(e, x3.languages.javascript);
  }
  function Tp(e, t3) {
    return x3.tokenize(e, t3).map((n3) => ye.stringify(n3)).join("");
  }
  function js(e) {
    return (0, Vs.default)(e);
  }
  function Sp({ message: e, originalMethod: t3, isPanic: r, callArguments: n3 }) {
    return { functionName: `prisma.${t3}()`, message: e, isPanic: r ?? false, callArguments: n3 };
  }
  function Ap({ callsite: e, message: t3, originalMethod: r, isPanic: n3, callArguments: i3 }, o3) {
    let s3 = Sp({ message: t3, originalMethod: r, isPanic: n3, callArguments: i3 });
    if (!e || typeof window < "u" || false)
      return s3;
    let a = e.getLocation();
    if (!a || !a.lineNumber || !a.columnNumber)
      return s3;
    let l3 = Math.max(1, a.lineNumber - 3), u3 = un.read(a.fileName)?.slice(l3, a.lineNumber), c3 = u3?.lineAt(a.lineNumber);
    if (u3 && c3) {
      let p = Op(c3), d3 = Ip(c3);
      if (!d3)
        return s3;
      s3.functionName = `${d3.code})`, s3.location = a, n3 || (u3 = u3.mapLineAt(a.lineNumber, (g) => g.slice(0, d3.openingBraceIndex))), u3 = o3.highlightSource(u3);
      let f3 = String(u3.lastLineNumber).length;
      if (s3.contextLines = u3.mapLines((g, h) => o3.gray(String(h).padStart(f3)) + " " + g).mapLines((g) => o3.dim(g)).prependSymbolAt(a.lineNumber, o3.bold(o3.red("\u2192"))), i3) {
        let g = p + f3 + 1;
        g += 2, s3.callArguments = (0, Us.default)(i3, g).slice(g);
      }
    }
    return s3;
  }
  function Ip(e) {
    let t3 = Object.keys(zt.ModelAction).join("|"), n3 = new RegExp(String.raw`\.(${t3})\(`).exec(e);
    if (n3) {
      let i3 = n3.index + n3[0].length, o3 = e.lastIndexOf(" ", n3.index) + 1;
      return { code: e.slice(o3, i3), openingBraceIndex: i3 };
    }
    return null;
  }
  function Op(e) {
    let t3 = 0;
    for (let r = 0;r < e.length; r++) {
      if (e.charAt(r) !== " ")
        return t3;
      t3++;
    }
    return t3;
  }
  function kp({ functionName: e, location: t3, message: r, isPanic: n3, contextLines: i3, callArguments: o3 }, s3) {
    let a = [""], l3 = t3 ? " in" : ":";
    if (n3 ? (a.push(s3.red(`Oops, an unknown error occurred! This is ${s3.bold("on us")}, you did nothing wrong.`)), a.push(s3.red(`It occurred in the ${s3.bold(`\`${e}\``)} invocation${l3}`))) : a.push(s3.red(`Invalid ${s3.bold(`\`${e}\``)} invocation${l3}`)), t3 && a.push(s3.underline(Dp(t3))), i3) {
      a.push("");
      let u3 = [i3.toString()];
      o3 && (u3.push(o3), u3.push(s3.dim(")"))), a.push(u3.join("")), o3 && a.push("");
    } else
      a.push(""), o3 && a.push(o3), a.push("");
    return a.push(r), a.join(`
`);
  }
  function Dp(e) {
    let t3 = [e.fileName];
    return e.lineNumber && t3.push(String(e.lineNumber)), e.columnNumber && t3.push(String(e.columnNumber)), t3.join(":");
  }
  function cn(e) {
    let t3 = e.showColors ? Rp : Cp, r;
    return r = Ap(e, t3), kp(r, t3);
  }
  function Hs(e, t3, r) {
    let n3 = Ws(e), i3 = _p(n3), o3 = Lp(i3);
    o3 ? pn(o3, t3, r) : t3.addErrorMessage(() => "Unknown error");
  }
  function Ws(e) {
    return e.errors.flatMap((t3) => t3.kind === "Union" ? Ws(t3) : [t3]);
  }
  function _p(e) {
    let t3 = new Map, r = [];
    for (let n3 of e) {
      if (n3.kind !== "InvalidArgumentType") {
        r.push(n3);
        continue;
      }
      let i3 = `${n3.selectionPath.join(".")}:${n3.argumentPath.join(".")}`, o3 = t3.get(i3);
      o3 ? t3.set(i3, { ...n3, argument: { ...n3.argument, typeNames: Np(o3.argument.typeNames, n3.argument.typeNames) } }) : t3.set(i3, n3);
    }
    return r.push(...t3.values()), r;
  }
  function Np(e, t3) {
    return [...new Set(e.concat(t3))];
  }
  function Lp(e) {
    return Ci(e, (t3, r) => {
      let n3 = Gs(t3), i3 = Gs(r);
      return n3 !== i3 ? n3 - i3 : Js(t3) - Js(r);
    });
  }
  function Gs(e) {
    let t3 = 0;
    return Array.isArray(e.selectionPath) && (t3 += e.selectionPath.length), Array.isArray(e.argumentPath) && (t3 += e.argumentPath.length), t3;
  }
  function Js(e) {
    switch (e.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  }
  function pn(e, t3, r) {
    switch (e.kind) {
      case "MutuallyExclusiveFields":
        Mp(e, t3);
        break;
      case "IncludeOnScalar":
        $p(e, t3);
        break;
      case "EmptySelection":
        qp(e, t3, r);
        break;
      case "UnknownSelectionField":
        Up(e, t3);
        break;
      case "InvalidSelectionValue":
        Qp(e, t3);
        break;
      case "UnknownArgument":
        Gp(e, t3);
        break;
      case "UnknownInputField":
        Jp(e, t3);
        break;
      case "RequiredArgumentMissing":
        Hp(e, t3);
        break;
      case "InvalidArgumentType":
        Wp(e, t3);
        break;
      case "InvalidArgumentValue":
        Kp(e, t3);
        break;
      case "ValueTooLarge":
        Yp(e, t3);
        break;
      case "SomeFieldsMissing":
        zp(e, t3);
        break;
      case "TooManyFieldsGiven":
        Zp(e, t3);
        break;
      case "Union":
        Hs(e, t3, r);
        break;
      default:
        throw new Error("not implemented: " + e.kind);
    }
  }
  function Mp(e, t3) {
    let r = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    r && (r.getField(e.firstField)?.markAsError(), r.getField(e.secondField)?.markAsError()), t3.addErrorMessage((n3) => `Please ${n3.bold("either")} use ${n3.green(`\`${e.firstField}\``)} or ${n3.green(`\`${e.secondField}\``)}, but ${n3.red("not both")} at the same time.`);
  }
  function $p(e, t3) {
    let [r, n3] = ir(e.selectionPath), i3 = e.outputType, o3 = t3.arguments.getDeepSelectionParent(r)?.value;
    if (o3 && (o3.getField(n3)?.markAsError(), i3))
      for (let s3 of i3.fields)
        s3.isRelation && o3.addSuggestion(new pe(s3.name, "true"));
    t3.addErrorMessage((s3) => {
      let a = `Invalid scalar field ${s3.red(`\`${n3}\``)} for ${s3.bold("include")} statement`;
      return i3 ? a += ` on model ${s3.bold(i3.name)}. ${or(s3)}` : a += ".", a += `
Note that ${s3.bold("include")} statements only accept relation fields.`, a;
    });
  }
  function qp(e, t3, r) {
    let n3 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (n3) {
      let i3 = n3.getField("omit")?.value.asObject();
      if (i3) {
        Vp(e, t3, i3);
        return;
      }
      if (n3.hasField("select")) {
        jp(e, t3);
        return;
      }
    }
    if (r?.[wt(e.outputType.name)]) {
      Bp(e, t3);
      return;
    }
    t3.addErrorMessage(() => `Unknown field at "${e.selectionPath.join(".")} selection"`);
  }
  function Vp(e, t3, r) {
    r.removeAllFields();
    for (let n3 of e.outputType.fields)
      r.addSuggestion(new pe(n3.name, "false"));
    t3.addErrorMessage((n3) => `The ${n3.red("omit")} statement includes every field of the model ${n3.bold(e.outputType.name)}. At least one field must be included in the result`);
  }
  function jp(e, t3) {
    let r = e.outputType, n3 = t3.arguments.getDeepSelectionParent(e.selectionPath)?.value, i3 = n3?.isEmpty() ?? false;
    n3 && (n3.removeAllFields(), Xs(n3, r)), t3.addErrorMessage((o3) => i3 ? `The ${o3.red("`select`")} statement for type ${o3.bold(r.name)} must not be empty. ${or(o3)}` : `The ${o3.red("`select`")} statement for type ${o3.bold(r.name)} needs ${o3.bold("at least one truthy value")}.`);
  }
  function Bp(e, t3) {
    let r = new nr;
    for (let i3 of e.outputType.fields)
      i3.isRelation || r.addField(i3.name, "false");
    let n3 = new pe("omit", r).makeRequired();
    if (e.selectionPath.length === 0)
      t3.arguments.addSuggestion(n3);
    else {
      let [i3, o3] = ir(e.selectionPath), a = t3.arguments.getDeepSelectionParent(i3)?.value.asObject()?.getField(o3);
      if (a) {
        let l3 = a?.value.asObject() ?? new Ct;
        l3.addSuggestion(n3), a.value = l3;
      }
    }
    t3.addErrorMessage((i3) => `The global ${i3.red("omit")} configuration excludes every field of the model ${i3.bold(e.outputType.name)}. At least one field must be included in the result`);
  }
  function Up(e, t3) {
    let r = ea(e.selectionPath, t3);
    if (r.parentKind !== "unknown") {
      r.field.markAsError();
      let n3 = r.parent;
      switch (r.parentKind) {
        case "select":
          Xs(n3, e.outputType);
          break;
        case "include":
          Xp(n3, e.outputType);
          break;
        case "omit":
          ed(n3, e.outputType);
          break;
      }
    }
    t3.addErrorMessage((n3) => {
      let i3 = [`Unknown field ${n3.red(`\`${r.fieldName}\``)}`];
      return r.parentKind !== "unknown" && i3.push(`for ${n3.bold(r.parentKind)} statement`), i3.push(`on model ${n3.bold(`\`${e.outputType.name}\``)}.`), i3.push(or(n3)), i3.join(" ");
    });
  }
  function Qp(e, t3) {
    let r = ea(e.selectionPath, t3);
    r.parentKind !== "unknown" && r.field.value.markAsError(), t3.addErrorMessage((n3) => `Invalid value for selection field \`${n3.red(r.fieldName)}\`: ${e.underlyingError}`);
  }
  function Gp(e, t3) {
    let r = e.argumentPath[0], n3 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    n3 && (n3.getField(r)?.markAsError(), td(n3, e.arguments)), t3.addErrorMessage((i3) => zs(i3, r, e.arguments.map((o3) => o3.name)));
  }
  function Jp(e, t3) {
    let [r, n3] = ir(e.argumentPath), i3 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (i3) {
      i3.getDeepField(e.argumentPath)?.markAsError();
      let o3 = i3.getDeepFieldValue(r)?.asObject();
      o3 && ta(o3, e.inputType);
    }
    t3.addErrorMessage((o3) => zs(o3, n3, e.inputType.fields.map((s3) => s3.name)));
  }
  function zs(e, t3, r) {
    let n3 = [`Unknown argument \`${e.red(t3)}\`.`], i3 = nd(t3, r);
    return i3 && n3.push(`Did you mean \`${e.green(i3)}\`?`), r.length > 0 && n3.push(or(e)), n3.join(" ");
  }
  function Hp(e, t3) {
    let r;
    t3.addErrorMessage((l3) => r?.value instanceof H && r.value.text === "null" ? `Argument \`${l3.green(o3)}\` must not be ${l3.red("null")}.` : `Argument \`${l3.green(o3)}\` is missing.`);
    let n3 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (!n3)
      return;
    let [i3, o3] = ir(e.argumentPath), s3 = new nr, a = n3.getDeepFieldValue(i3)?.asObject();
    if (a)
      if (r = a.getField(o3), r && a.removeField(o3), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
        for (let l3 of e.inputTypes[0].fields)
          s3.addField(l3.name, l3.typeNames.join(" | "));
        a.addSuggestion(new pe(o3, s3).makeRequired());
      } else {
        let l3 = e.inputTypes.map(Zs).join(" | ");
        a.addSuggestion(new pe(o3, l3).makeRequired());
      }
  }
  function Zs(e) {
    return e.kind === "list" ? `${Zs(e.elementType)}[]` : e.name;
  }
  function Wp(e, t3) {
    let r = e.argument.name, n3 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    n3 && n3.getDeepFieldValue(e.argumentPath)?.markAsError(), t3.addErrorMessage((i3) => {
      let o3 = gn("or", e.argument.typeNames.map((s3) => i3.green(s3)));
      return `Argument \`${i3.bold(r)}\`: Invalid value provided. Expected ${o3}, provided ${i3.red(e.inferredType)}.`;
    });
  }
  function Kp(e, t3) {
    let r = e.argument.name, n3 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    n3 && n3.getDeepFieldValue(e.argumentPath)?.markAsError(), t3.addErrorMessage((i3) => {
      let o3 = [`Invalid value for argument \`${i3.bold(r)}\``];
      if (e.underlyingError && o3.push(`: ${e.underlyingError}`), o3.push("."), e.argument.typeNames.length > 0) {
        let s3 = gn("or", e.argument.typeNames.map((a) => i3.green(a)));
        o3.push(` Expected ${s3}.`);
      }
      return o3.join("");
    });
  }
  function Yp(e, t3) {
    let r = e.argument.name, n3 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(), i3;
    if (n3) {
      let s3 = n3.getDeepField(e.argumentPath)?.value;
      s3?.markAsError(), s3 instanceof H && (i3 = s3.text);
    }
    t3.addErrorMessage((o3) => {
      let s3 = ["Unable to fit value"];
      return i3 && s3.push(o3.red(i3)), s3.push(`into a 64-bit signed integer for field \`${o3.bold(r)}\``), s3.join(" ");
    });
  }
  function zp(e, t3) {
    let r = e.argumentPath[e.argumentPath.length - 1], n3 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (n3) {
      let i3 = n3.getDeepFieldValue(e.argumentPath)?.asObject();
      i3 && ta(i3, e.inputType);
    }
    t3.addErrorMessage((i3) => {
      let o3 = [`Argument \`${i3.bold(r)}\` of type ${i3.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? o3.push(`${i3.green("at least one of")} ${gn("or", e.constraints.requiredFields.map((s3) => `\`${i3.bold(s3)}\``))} arguments.`) : o3.push(`${i3.green("at least one")} argument.`) : o3.push(`${i3.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), o3.push(or(i3)), o3.join(" ");
    });
  }
  function Zp(e, t3) {
    let r = e.argumentPath[e.argumentPath.length - 1], n3 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(), i3 = [];
    if (n3) {
      let o3 = n3.getDeepFieldValue(e.argumentPath)?.asObject();
      o3 && (o3.markAsError(), i3 = Object.keys(o3.getFields()));
    }
    t3.addErrorMessage((o3) => {
      let s3 = [`Argument \`${o3.bold(r)}\` of type ${o3.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s3.push(`${o3.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s3.push(`${o3.green("at most one")} argument,`) : s3.push(`${o3.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s3.push(`but you provided ${gn("and", i3.map((a) => o3.red(a)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s3.push("one.") : s3.push(`${e.constraints.maxFieldCount}.`), s3.join(" ");
    });
  }
  function Xs(e, t3) {
    for (let r of t3.fields)
      e.hasField(r.name) || e.addSuggestion(new pe(r.name, "true"));
  }
  function Xp(e, t3) {
    for (let r of t3.fields)
      r.isRelation && !e.hasField(r.name) && e.addSuggestion(new pe(r.name, "true"));
  }
  function ed(e, t3) {
    for (let r of t3.fields)
      !e.hasField(r.name) && !r.isRelation && e.addSuggestion(new pe(r.name, "true"));
  }
  function td(e, t3) {
    for (let r of t3)
      e.hasField(r.name) || e.addSuggestion(new pe(r.name, r.typeNames.join(" | ")));
  }
  function ea(e, t3) {
    let [r, n3] = ir(e), i3 = t3.arguments.getDeepSubSelectionValue(r)?.asObject();
    if (!i3)
      return { parentKind: "unknown", fieldName: n3 };
    let o3 = i3.getFieldValue("select")?.asObject(), s3 = i3.getFieldValue("include")?.asObject(), a = i3.getFieldValue("omit")?.asObject(), l3 = o3?.getField(n3);
    return o3 && l3 ? { parentKind: "select", parent: o3, field: l3, fieldName: n3 } : (l3 = s3?.getField(n3), s3 && l3 ? { parentKind: "include", field: l3, parent: s3, fieldName: n3 } : (l3 = a?.getField(n3), a && l3 ? { parentKind: "omit", field: l3, parent: a, fieldName: n3 } : { parentKind: "unknown", fieldName: n3 }));
  }
  function ta(e, t3) {
    if (t3.kind === "object")
      for (let r of t3.fields)
        e.hasField(r.name) || e.addSuggestion(new pe(r.name, r.typeNames.join(" | ")));
  }
  function ir(e) {
    let t3 = [...e], r = t3.pop();
    if (!r)
      throw new Error("unexpected empty path");
    return [t3, r];
  }
  function or({ green: e, enabled: t3 }) {
    return "Available options are " + (t3 ? `listed in ${e("green")}` : "marked with ?") + ".";
  }
  function gn(e, t3) {
    if (t3.length === 1)
      return t3[0];
    let r = [...t3], n3 = r.pop();
    return `${r.join(", ")} ${e} ${n3}`;
  }
  function nd(e, t3) {
    let r = 1 / 0, n3;
    for (let i3 of t3) {
      let o3 = (0, Ys.default)(e, i3);
      o3 > rd || o3 < r && (r = o3, n3 = i3);
    }
    return n3;
  }
  function ra(e) {
    return e.substring(0, 1).toLowerCase() + e.substring(1);
  }
  function St(e) {
    return e instanceof sr;
  }
  function Li(e, t3) {
    Object.defineProperty(e, "name", { value: t3, configurable: true });
  }
  function At(e) {
    return new Fi(ia(e));
  }
  function ia(e) {
    let t3 = new Ct;
    for (let [r, n3] of Object.entries(e)) {
      let i3 = new En(r, oa(n3));
      t3.addField(i3);
    }
    return t3;
  }
  function oa(e) {
    if (typeof e == "string")
      return new H(JSON.stringify(e));
    if (typeof e == "number" || typeof e == "boolean")
      return new H(String(e));
    if (typeof e == "bigint")
      return new H(`${e}n`);
    if (e === null)
      return new H("null");
    if (e === undefined)
      return new H("undefined");
    if (vt(e))
      return new H(`new Prisma.Decimal("${e.toFixed()}")`);
    if (e instanceof Uint8Array)
      return Buffer.isBuffer(e) ? new H(`Buffer.alloc(${e.byteLength})`) : new H(`new Uint8Array(${e.byteLength})`);
    if (e instanceof Date) {
      let t3 = an(e) ? e.toISOString() : "Invalid Date";
      return new H(`new Date("${t3}")`);
    }
    return e instanceof $e ? new H(`Prisma.${e._getName()}`) : St(e) ? new H(`prisma.${ra(e.modelName)}.\$fields.${e.name}`) : Array.isArray(e) ? id(e) : typeof e == "object" ? ia(e) : new H(Object.prototype.toString.call(e));
  }
  function id(e) {
    let t3 = new Rt;
    for (let r of e)
      t3.addItem(oa(r));
    return t3;
  }
  function bn(e, t3) {
    let r = t3 === "pretty" ? Ks : fn, n3 = e.renderAllMessages(r), i3 = new Pt(0, { colors: r }).write(e).toString();
    return { message: n3, args: i3 };
  }
  function wn({ args: e, errors: t3, errorFormat: r, callsite: n3, originalMethod: i3, clientVersion: o3, globalOmit: s3 }) {
    let a = At(e);
    for (let p of t3)
      pn(p, a, s3);
    let { message: l3, args: u3 } = bn(a, r), c3 = cn({ message: l3, callsite: n3, originalMethod: i3, showColors: r === "pretty", callArguments: u3 });
    throw new te(c3, { clientVersion: o3 });
  }
  function pr(e) {
    let t3;
    return { get() {
      return t3 || (t3 = { value: e() }), t3.value;
    } };
  }
  function Re(e) {
    return e.replace(/^./, (t3) => t3.toLowerCase());
  }
  function aa(e, t3, r) {
    let n3 = Re(r);
    return !t3.result || !(t3.result.$allModels || t3.result[n3]) ? e : od({ ...e, ...sa(t3.name, e, t3.result.$allModels), ...sa(t3.name, e, t3.result[n3]) });
  }
  function od(e) {
    let t3 = new Te, r = (n3, i3) => t3.getOrCreate(n3, () => i3.has(n3) ? [n3] : (i3.add(n3), e[n3] ? e[n3].needs.flatMap((o3) => r(o3, i3)) : [n3]));
    return ht(e, (n3) => ({ ...n3, needs: r(n3.name, new Set) }));
  }
  function sa(e, t3, r) {
    return r ? ht(r, ({ needs: n3, compute: i3 }, o3) => ({ name: o3, needs: n3 ? Object.keys(n3).filter((s3) => n3[s3]) : [], compute: sd(t3, o3, i3) })) : {};
  }
  function sd(e, t3, r) {
    let n3 = e?.[t3]?.compute;
    return n3 ? (i3) => r({ ...i3, [t3]: n3(i3) }) : r;
  }
  function la(e, t3) {
    if (!t3)
      return e;
    let r = { ...e };
    for (let n3 of Object.values(t3))
      if (e[n3.name])
        for (let i3 of n3.needs)
          r[i3] = true;
    return r;
  }
  function ua(e, t3) {
    if (!t3)
      return e;
    let r = { ...e };
    for (let n3 of Object.values(t3))
      if (!e[n3.name])
        for (let i3 of n3.needs)
          delete r[i3];
    return r;
  }
  function Ce(e) {
    return e instanceof dr;
  }
  function Pn({ modelName: e, action: t3, args: r, runtimeDataModel: n3, extensions: i3 = It.empty(), callsite: o3, clientMethod: s3, errorFormat: a, clientVersion: l3, previewFeatures: u3, globalOmit: c3 }) {
    let p = new Mi({ runtimeDataModel: n3, modelName: e, action: t3, rootArgs: r, callsite: o3, extensions: i3, selectionPath: [], argumentPath: [], originalMethod: s3, errorFormat: a, clientVersion: l3, previewFeatures: u3, globalOmit: c3 });
    return { modelName: e, action: ad[t3], query: mr(r, p) };
  }
  function mr({ select: e, include: t3, ...r } = {}, n3) {
    let i3 = r.omit;
    return delete r.omit, { arguments: ma(r, n3), selection: ld(e, t3, i3, n3) };
  }
  function ld(e, t3, r, n3) {
    return e ? (t3 ? n3.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "include", secondField: "select", selectionPath: n3.getSelectionPath() }) : r && n3.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "omit", secondField: "select", selectionPath: n3.getSelectionPath() }), dd(e, n3)) : ud(n3, t3, r);
  }
  function ud(e, t3, r) {
    let n3 = {};
    return e.modelOrType && !e.isRawAction() && (n3.$composites = true, n3.$scalars = true), t3 && cd(n3, t3, e), pd(n3, r, e), n3;
  }
  function cd(e, t3, r) {
    for (let [n3, i3] of Object.entries(t3)) {
      if (Ce(i3))
        continue;
      let o3 = r.nestSelection(n3);
      if ($i(i3, o3), i3 === false || i3 === undefined) {
        e[n3] = false;
        continue;
      }
      let s3 = r.findField(n3);
      if (s3 && s3.kind !== "object" && r.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r.getSelectionPath().concat(n3), outputType: r.getOutputTypeDescription() }), s3) {
        e[n3] = mr(i3 === true ? {} : i3, o3);
        continue;
      }
      if (i3 === true) {
        e[n3] = true;
        continue;
      }
      e[n3] = mr(i3, o3);
    }
  }
  function pd(e, t3, r) {
    let n3 = r.getComputedFields(), i3 = { ...r.getGlobalOmit(), ...t3 }, o3 = ua(i3, n3);
    for (let [s3, a] of Object.entries(o3)) {
      if (Ce(a))
        continue;
      $i(a, r.nestSelection(s3));
      let l3 = r.findField(s3);
      n3?.[s3] && !l3 || (e[s3] = !a);
    }
  }
  function dd(e, t3) {
    let r = {}, n3 = t3.getComputedFields(), i3 = la(e, n3);
    for (let [o3, s3] of Object.entries(i3)) {
      if (Ce(s3))
        continue;
      let a = t3.nestSelection(o3);
      $i(s3, a);
      let l3 = t3.findField(o3);
      if (!(n3?.[o3] && !l3)) {
        if (s3 === false || s3 === undefined || Ce(s3)) {
          r[o3] = false;
          continue;
        }
        if (s3 === true) {
          l3?.kind === "object" ? r[o3] = mr({}, a) : r[o3] = true;
          continue;
        }
        r[o3] = mr(s3, a);
      }
    }
    return r;
  }
  function da(e, t3) {
    if (e === null)
      return null;
    if (typeof e == "string" || typeof e == "number" || typeof e == "boolean")
      return e;
    if (typeof e == "bigint")
      return { $type: "BigInt", value: String(e) };
    if (xt(e)) {
      if (an(e))
        return { $type: "DateTime", value: e.toISOString() };
      t3.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t3.getSelectionPath(), argumentPath: t3.getArgumentPath(), argument: { name: t3.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (St(e))
      return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
    if (Array.isArray(e))
      return md(e, t3);
    if (ArrayBuffer.isView(e)) {
      let { buffer: r, byteOffset: n3, byteLength: i3 } = e;
      return { $type: "Bytes", value: Buffer.from(r, n3, i3).toString("base64") };
    }
    if (fd(e))
      return e.values;
    if (vt(e))
      return { $type: "Decimal", value: e.toFixed() };
    if (e instanceof $e) {
      if (e !== yn.instances[e._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e._getName() };
    }
    if (gd(e))
      return e.toJSON();
    if (typeof e == "object")
      return ma(e, t3);
    t3.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t3.getSelectionPath(), argumentPath: t3.getArgumentPath(), argument: { name: t3.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  }
  function ma(e, t3) {
    if (e.$type)
      return { $type: "Raw", value: e };
    let r = {};
    for (let n3 in e) {
      let i3 = e[n3], o3 = t3.nestArgument(n3);
      Ce(i3) || (i3 !== undefined ? r[n3] = da(i3, o3) : t3.isPreviewFeatureOn("strictUndefinedChecks") && t3.throwValidationError({ kind: "InvalidArgumentValue", argumentPath: o3.getArgumentPath(), selectionPath: t3.getSelectionPath(), argument: { name: t3.getArgumentName(), typeNames: [] }, underlyingError: pa }));
    }
    return r;
  }
  function md(e, t3) {
    let r = [];
    for (let n3 = 0;n3 < e.length; n3++) {
      let i3 = t3.nestArgument(String(n3)), o3 = e[n3];
      if (o3 === undefined || Ce(o3)) {
        let s3 = o3 === undefined ? "undefined" : "Prisma.skip";
        t3.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i3.getSelectionPath(), argumentPath: i3.getArgumentPath(), argument: { name: `${t3.getArgumentName()}[${n3}]`, typeNames: [] }, underlyingError: `Can not use \`${s3}\` value within array. Use \`null\` or filter out \`${s3}\` values` });
      }
      r.push(da(o3, i3));
    }
    return r;
  }
  function fd(e) {
    return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
  }
  function gd(e) {
    return typeof e == "object" && e !== null && typeof e.toJSON == "function";
  }
  function $i(e, t3) {
    e === undefined && t3.isPreviewFeatureOn("strictUndefinedChecks") && t3.throwValidationError({ kind: "InvalidSelectionValue", selectionPath: t3.getSelectionPath(), underlyingError: pa });
  }
  function fa(e) {
    return { models: qi(e.models), enums: qi(e.enums), types: qi(e.types) };
  }
  function qi(e) {
    let t3 = {};
    for (let { name: r, ...n3 } of e)
      t3[r] = n3;
    return t3;
  }
  function ga(e, t3) {
    let r = pr(() => hd(t3));
    Object.defineProperty(e, "dmmf", { get: () => r.get() });
  }
  function hd(e) {
    return { datamodel: { models: Vi(e.models), enums: Vi(e.enums), types: Vi(e.types) } };
  }
  function Vi(e) {
    return Object.entries(e).map(([t3, r]) => ({ name: t3, ...r }));
  }
  function ha(e) {
    return (...t3) => new Bi(e, t3);
  }
  function ya(e) {
    return e != null && e[Tn] === Tn;
  }
  function fr(e) {
    return { ok: false, error: e, map() {
      return fr(e);
    }, flatMap() {
      return fr(e);
    } };
  }
  function Se(e, t3) {
    return async (...r) => {
      try {
        return await t3(...r);
      } catch (n3) {
        let i3 = e.registerNewError(n3);
        return fr({ kind: "GenericJs", id: i3 });
      }
    };
  }
  function bd(e, t3) {
    return (...r) => {
      try {
        return t3(...r);
      } catch (n3) {
        let i3 = e.registerNewError(n3);
        return fr({ kind: "GenericJs", id: i3 });
      }
    };
  }
  function Ea(e, t3 = ",", r = "", n3 = "") {
    if (e.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new ae([r, ...Array(e.length - 1).fill(t3), n3], e);
  }
  function Gi(e) {
    return new ae([e], []);
  }
  function Ji(e, ...t3) {
    return new ae(e, t3);
  }
  function gr(e) {
    return { getKeys() {
      return Object.keys(e);
    }, getPropertyValue(t3) {
      return e[t3];
    } };
  }
  function ie(e, t3) {
    return { getKeys() {
      return [e];
    }, getPropertyValue() {
      return t3();
    } };
  }
  function ot(e) {
    let t3 = new Te;
    return { getKeys() {
      return e.getKeys();
    }, getPropertyValue(r) {
      return t3.getOrCreate(r, () => e.getPropertyValue(r));
    }, getPropertyDescriptor(r) {
      return e.getPropertyDescriptor?.(r);
    } };
  }
  function Cn(e) {
    let t3 = new Set(e);
    return { getPrototypeOf: () => Object.prototype, getOwnPropertyDescriptor: () => Rn, has: (r, n3) => t3.has(n3), set: (r, n3, i3) => t3.add(n3) && Reflect.set(r, n3, i3), ownKeys: () => [...t3] };
  }
  function Ae(e, t3) {
    let r = wd(t3), n3 = new Set, i3 = new Proxy(e, { get(o3, s3) {
      if (n3.has(s3))
        return o3[s3];
      let a = r.get(s3);
      return a ? a.getPropertyValue(s3) : o3[s3];
    }, has(o3, s3) {
      if (n3.has(s3))
        return true;
      let a = r.get(s3);
      return a ? a.has?.(s3) ?? true : Reflect.has(o3, s3);
    }, ownKeys(o3) {
      let s3 = xa(Reflect.ownKeys(o3), r), a = xa(Array.from(r.keys()), r);
      return [...new Set([...s3, ...a, ...n3])];
    }, set(o3, s3, a) {
      return r.get(s3)?.getPropertyDescriptor?.(s3)?.writable === false ? false : (n3.add(s3), Reflect.set(o3, s3, a));
    }, getOwnPropertyDescriptor(o3, s3) {
      let a = Reflect.getOwnPropertyDescriptor(o3, s3);
      if (a && !a.configurable)
        return a;
      let l3 = r.get(s3);
      return l3 ? l3.getPropertyDescriptor ? { ...Rn, ...l3?.getPropertyDescriptor(s3) } : Rn : a;
    }, defineProperty(o3, s3, a) {
      return n3.add(s3), Reflect.defineProperty(o3, s3, a);
    }, getPrototypeOf: () => Object.prototype });
    return i3[wa] = function() {
      let o3 = { ...this };
      return delete o3[wa], o3;
    }, i3;
  }
  function wd(e) {
    let t3 = new Map;
    for (let r of e) {
      let n3 = r.getKeys();
      for (let i3 of n3)
        t3.set(i3, r);
    }
    return t3;
  }
  function xa(e, t3) {
    return e.filter((r) => t3.get(r)?.has?.(r) ?? true);
  }
  function kt(e) {
    return { getKeys() {
      return e;
    }, has() {
      return false;
    }, getPropertyValue() {
    } };
  }
  function Dt(e, t3) {
    return { batch: e, transaction: t3?.kind === "batch" ? { isolationLevel: t3.options.isolationLevel } : undefined };
  }
  function va(e) {
    if (e === undefined)
      return "";
    let t3 = At(e);
    return new Pt(0, { colors: fn }).write(t3).toString();
  }
  function _t({ error: e, user_facing_error: t3 }, r, n3) {
    return t3.error_code ? new ee(vd(t3, n3), { code: t3.error_code, clientVersion: r, meta: t3.meta, batchRequestIdx: t3.batch_request_idx }) : new B(e, { clientVersion: r, batchRequestIdx: t3.batch_request_idx });
  }
  function vd(e, t3) {
    let r = e.message;
    return (t3 === "postgresql" || t3 === "postgres" || t3 === "mysql") && e.error_code === xd && (r += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), r;
  }
  function Pa(e) {
    var t3 = e.split(`
`);
    return t3.reduce(function(r, n3) {
      var i3 = Rd(n3) || Sd(n3) || Od(n3) || Nd(n3) || Dd(n3);
      return i3 && r.push(i3), r;
    }, []);
  }
  function Rd(e) {
    var t3 = Pd.exec(e);
    if (!t3)
      return null;
    var r = t3[2] && t3[2].indexOf("native") === 0, n3 = t3[2] && t3[2].indexOf("eval") === 0, i3 = Td.exec(t3[2]);
    return n3 && i3 != null && (t3[2] = i3[1], t3[3] = i3[2], t3[4] = i3[3]), { file: r ? null : t3[2], methodName: t3[1] || hr, arguments: r ? [t3[2]] : [], lineNumber: t3[3] ? +t3[3] : null, column: t3[4] ? +t3[4] : null };
  }
  function Sd(e) {
    var t3 = Cd.exec(e);
    return t3 ? { file: t3[2], methodName: t3[1] || hr, arguments: [], lineNumber: +t3[3], column: t3[4] ? +t3[4] : null } : null;
  }
  function Od(e) {
    var t3 = Ad.exec(e);
    if (!t3)
      return null;
    var r = t3[3] && t3[3].indexOf(" > eval") > -1, n3 = Id.exec(t3[3]);
    return r && n3 != null && (t3[3] = n3[1], t3[4] = n3[2], t3[5] = null), { file: t3[3], methodName: t3[1] || hr, arguments: t3[2] ? t3[2].split(",") : [], lineNumber: t3[4] ? +t3[4] : null, column: t3[5] ? +t3[5] : null };
  }
  function Dd(e) {
    var t3 = kd.exec(e);
    return t3 ? { file: t3[3], methodName: t3[1] || hr, arguments: [], lineNumber: +t3[4], column: t3[5] ? +t3[5] : null } : null;
  }
  function Nd(e) {
    var t3 = _d.exec(e);
    return t3 ? { file: t3[2], methodName: t3[1] || hr, arguments: [], lineNumber: +t3[3], column: t3[4] ? +t3[4] : null } : null;
  }
  function Ze(e) {
    return e === "minimal" ? typeof $EnabledCallSite == "function" && e !== "minimal" ? new $EnabledCallSite : new Hi : new Wi;
  }
  function Nt(e = {}) {
    let t3 = Fd(e);
    return Object.entries(t3).reduce((n3, [i3, o3]) => (Ta[i3] !== undefined ? n3.select[i3] = { select: o3 } : n3[i3] = o3, n3), { select: {} });
  }
  function Fd(e = {}) {
    return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
  }
  function Sn(e = {}) {
    return (t3) => (typeof e._count == "boolean" && (t3._count = t3._count._all), t3);
  }
  function Ra(e, t3) {
    let r = Sn(e);
    return t3({ action: "aggregate", unpacker: r, argsMapper: Nt })(e);
  }
  function Md(e = {}) {
    let { select: t3, ...r } = e;
    return typeof t3 == "object" ? Nt({ ...r, _count: t3 }) : Nt({ ...r, _count: { _all: true } });
  }
  function $d(e = {}) {
    return typeof e.select == "object" ? (t3) => Sn(e)(t3)._count : (t3) => Sn(e)(t3)._count._all;
  }
  function Ca(e, t3) {
    return t3({ action: "count", unpacker: $d(e), argsMapper: Md })(e);
  }
  function qd(e = {}) {
    let t3 = Nt(e);
    if (Array.isArray(t3.by))
      for (let r of t3.by)
        typeof r == "string" && (t3.select[r] = true);
    else
      typeof t3.by == "string" && (t3.select[t3.by] = true);
    return t3;
  }
  function Vd(e = {}) {
    return (t3) => (typeof e?._count == "boolean" && t3.forEach((r) => {
      r._count = r._count._all;
    }), t3);
  }
  function Sa(e, t3) {
    return t3({ action: "groupBy", unpacker: Vd(e), argsMapper: qd })(e);
  }
  function Aa(e, t3, r) {
    if (t3 === "aggregate")
      return (n3) => Ra(n3, r);
    if (t3 === "count")
      return (n3) => Ca(n3, r);
    if (t3 === "groupBy")
      return (n3) => Sa(n3, r);
  }
  function Ia(e, t3) {
    let r = t3.fields.filter((i3) => !i3.relationName), n3 = Ri(r, (i3) => i3.name);
    return new Proxy({}, { get(i3, o3) {
      if (o3 in i3 || typeof o3 == "symbol")
        return i3[o3];
      let s3 = n3[o3];
      if (s3)
        return new sr(e, o3, s3.type, s3.isList, s3.kind === "enum");
    }, ...Cn(Object.keys(n3)) });
  }
  function jd(e, t3) {
    return e === undefined || t3 === undefined ? [] : [...t3, "select", e];
  }
  function Bd(e, t3, r) {
    return t3 === undefined ? e ?? {} : ka(t3, r, e || true);
  }
  function Yi(e, t3, r, n3, i3, o3) {
    let a = e._runtimeDataModel.models[t3].fields.reduce((l3, u3) => ({ ...l3, [u3.name]: u3 }), {});
    return (l3) => {
      let u3 = Ze(e._errorFormat), c3 = jd(n3, i3), p = Bd(l3, o3, c3), d3 = r({ dataPath: c3, callsite: u3 })(p), f3 = Ud(e, t3);
      return new Proxy(d3, { get(g, h) {
        if (!f3.includes(h))
          return g[h];
        let P = [a[h].type, r, h], C4 = [c3, p];
        return Yi(e, ...P, ...C4);
      }, ...Cn([...f3, ...Object.getOwnPropertyNames(d3)]) });
    };
  }
  function Ud(e, t3) {
    return e._runtimeDataModel.models[t3].fields.filter((r) => r.kind === "object").map((r) => r.name);
  }
  function zi(e, t3) {
    let r = e._extensions.getAllModelExtensions(t3) ?? {}, n3 = [Jd(e, t3), Wd(e, t3), gr(r), ie("name", () => t3), ie("$name", () => t3), ie("$parent", () => e._appliedParent)];
    return Ae({}, n3);
  }
  function Jd(e, t3) {
    let r = Re(t3), n3 = Object.keys(zt.ModelAction).concat("count");
    return { getKeys() {
      return n3;
    }, getPropertyValue(i3) {
      let o3 = i3, s3 = (a) => (l3) => {
        let u3 = Ze(e._errorFormat);
        return e._createPrismaPromise((c3) => {
          let p = { args: l3, dataPath: [], action: o3, model: t3, clientMethod: `${r}.${i3}`, jsModelName: r, transaction: c3, callsite: u3 };
          return e._request({ ...p, ...a });
        });
      };
      return Qd.includes(o3) ? Yi(e, t3, s3) : Hd(i3) ? Aa(e, i3, s3) : s3({});
    } };
  }
  function Hd(e) {
    return Gd.includes(e);
  }
  function Wd(e, t3) {
    return ot(ie("fields", () => {
      let r = e._runtimeDataModel.models[t3];
      return Ia(t3, r);
    }));
  }
  function Da(e) {
    return e.replace(/^./, (t3) => t3.toUpperCase());
  }
  function yr(e) {
    let t3 = [Kd(e), ie(Zi, () => e), ie("$parent", () => e._appliedParent)], r = e._extensions.getAllClientExtensions();
    return r && t3.push(gr(r)), Ae(e, t3);
  }
  function Kd(e) {
    let t3 = Object.keys(e._runtimeDataModel.models), r = t3.map(Re), n3 = [...new Set(t3.concat(r))];
    return ot({ getKeys() {
      return n3;
    }, getPropertyValue(i3) {
      let o3 = Da(i3);
      if (e._runtimeDataModel.models[o3] !== undefined)
        return zi(e, o3);
      if (e._runtimeDataModel.models[i3] !== undefined)
        return zi(e, i3);
    }, getPropertyDescriptor(i3) {
      if (!r.includes(i3))
        return { enumerable: false };
    } });
  }
  function _a(e) {
    return e[Zi] ? e[Zi] : e;
  }
  function Na(e) {
    if (typeof e == "function")
      return e(this);
    if (e.client?.__AccelerateEngine) {
      let r = e.client.__AccelerateEngine;
      this._originalClient._engine = new r(this._originalClient._accelerateEngineConfig);
    }
    let t3 = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return yr(t3);
  }
  function La({ result: e, modelName: t3, select: r, omit: n3, extensions: i3 }) {
    let o3 = i3.getAllComputedFields(t3);
    if (!o3)
      return e;
    let s3 = [], a = [];
    for (let l3 of Object.values(o3)) {
      if (n3) {
        if (n3[l3.name])
          continue;
        let u3 = l3.needs.filter((c3) => n3[c3]);
        u3.length > 0 && a.push(kt(u3));
      } else if (r) {
        if (!r[l3.name])
          continue;
        let u3 = l3.needs.filter((c3) => !r[c3]);
        u3.length > 0 && a.push(kt(u3));
      }
      Yd(e, l3.needs) && s3.push(zd(l3, Ae(e, s3)));
    }
    return s3.length > 0 || a.length > 0 ? Ae(e, [...s3, ...a]) : e;
  }
  function Yd(e, t3) {
    return t3.every((r) => Ti(e, r));
  }
  function zd(e, t3) {
    return ot(ie(e.name, () => e.compute(t3)));
  }
  function An({ visitor: e, result: t3, args: r, runtimeDataModel: n3, modelName: i3 }) {
    if (Array.isArray(t3)) {
      for (let s3 = 0;s3 < t3.length; s3++)
        t3[s3] = An({ result: t3[s3], args: r, modelName: i3, runtimeDataModel: n3, visitor: e });
      return t3;
    }
    let o3 = e(t3, i3, r) ?? t3;
    return r.include && Fa({ includeOrSelect: r.include, result: o3, parentModelName: i3, runtimeDataModel: n3, visitor: e }), r.select && Fa({ includeOrSelect: r.select, result: o3, parentModelName: i3, runtimeDataModel: n3, visitor: e }), o3;
  }
  function Fa({ includeOrSelect: e, result: t3, parentModelName: r, runtimeDataModel: n3, visitor: i3 }) {
    for (let [o3, s3] of Object.entries(e)) {
      if (!s3 || t3[o3] == null || Ce(s3))
        continue;
      let l3 = n3.models[r].fields.find((c3) => c3.name === o3);
      if (!l3 || l3.kind !== "object" || !l3.relationName)
        continue;
      let u3 = typeof s3 == "object" ? s3 : {};
      t3[o3] = An({ visitor: i3, result: t3[o3], args: u3, modelName: l3.type, runtimeDataModel: n3 });
    }
  }
  function Ma({ result: e, modelName: t3, args: r, extensions: n3, runtimeDataModel: i3, globalOmit: o3 }) {
    return n3.isEmpty() || e == null || typeof e != "object" || !i3.models[t3] ? e : An({ result: e, args: r ?? {}, modelName: t3, runtimeDataModel: i3, visitor: (a, l3, u3) => {
      let c3 = Re(l3);
      return La({ result: a, modelName: c3, select: u3.select, omit: u3.select ? undefined : { ...o3?.[c3], ...u3.omit }, extensions: n3 });
    } });
  }
  function $a(e) {
    if (e instanceof ae)
      return Zd(e);
    if (Array.isArray(e)) {
      let r = [e[0]];
      for (let n3 = 1;n3 < e.length; n3++)
        r[n3] = Er(e[n3]);
      return r;
    }
    let t3 = {};
    for (let r in e)
      t3[r] = Er(e[r]);
    return t3;
  }
  function Zd(e) {
    return new ae(e.strings, e.values);
  }
  function Er(e) {
    if (typeof e != "object" || e == null || e instanceof $e || St(e))
      return e;
    if (vt(e))
      return new ve(e.toFixed());
    if (xt(e))
      return new Date(+e);
    if (ArrayBuffer.isView(e))
      return e.slice(0);
    if (Array.isArray(e)) {
      let t3 = e.length, r;
      for (r = Array(t3);t3--; )
        r[t3] = Er(e[t3]);
      return r;
    }
    if (typeof e == "object") {
      let t3 = {};
      for (let r in e)
        r === "__proto__" ? Object.defineProperty(t3, r, { value: Er(e[r]), configurable: true, enumerable: true, writable: true }) : t3[r] = Er(e[r]);
      return t3;
    }
    Fe(e, "Unknown value");
  }
  function Va(e, t3, r, n3 = 0) {
    return e._createPrismaPromise((i3) => {
      let o3 = t3.customDataProxyFetch;
      return "transaction" in t3 && i3 !== undefined && (t3.transaction?.kind === "batch" && t3.transaction.lock.then(), t3.transaction = i3), n3 === r.length ? e._executeRequest(t3) : r[n3]({ model: t3.model, operation: t3.model ? t3.action : t3.clientMethod, args: $a(t3.args ?? {}), __internalParams: t3, query: (s3, a = t3) => {
        let l3 = a.customDataProxyFetch;
        return a.customDataProxyFetch = Qa(o3, l3), a.args = s3, Va(e, a, r, n3 + 1);
      } });
    });
  }
  function ja(e, t3) {
    let { jsModelName: r, action: n3, clientMethod: i3 } = t3, o3 = r ? n3 : i3;
    if (e._extensions.isEmpty())
      return e._executeRequest(t3);
    let s3 = e._extensions.getAllQueryCallbacks(r ?? "$none", o3);
    return Va(e, t3, s3);
  }
  function Ba(e) {
    return (t3) => {
      let r = { requests: t3 }, n3 = t3[0].extensions.getAllBatchQueryCallbacks();
      return n3.length ? Ua(r, n3, 0, e) : e(r);
    };
  }
  function Ua(e, t3, r, n3) {
    if (r === t3.length)
      return n3(e);
    let i3 = e.customDataProxyFetch, o3 = e.requests[0].transaction;
    return t3[r]({ args: { queries: e.requests.map((s3) => ({ model: s3.modelName, operation: s3.action, args: s3.args })), transaction: o3 ? { isolationLevel: o3.kind === "batch" ? o3.isolationLevel : undefined } : undefined }, __internalParams: e, query(s3, a = e) {
      let l3 = a.customDataProxyFetch;
      return a.customDataProxyFetch = Qa(i3, l3), Ua(a, t3, r + 1, n3);
    } });
  }
  function Qa(e = qa, t3 = qa) {
    return (r) => e(t3(r));
  }
  function Ha({ postinstall: e, ciName: t3, clientVersion: r }) {
    if (Ga("checkPlatformCaching:postinstall", e), Ga("checkPlatformCaching:ciName", t3), e === true && t3 && t3 in Ja) {
      let n3 = `Prisma has detected that this project was built on ${t3}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${Ja[t3]}-build`;
      throw console.error(n3), new T3(n3, r);
    }
  }
  function Wa(e, t3) {
    return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [t3[0]]: { url: e.datasourceUrl } } : {} : {};
  }
  function Ka() {
    return typeof Netlify == "object" ? "netlify" : typeof EdgeRuntime == "string" ? "edge-light" : globalThis.navigator?.userAgent === Xd ? "workerd" : globalThis.Deno ? "deno" : globalThis.__lagon__ ? "lagon" : globalThis.process?.release?.name === em ? "node" : globalThis.Bun ? "bun" : globalThis.fastly ? "fastly" : "unknown";
  }
  function In() {
    let e = Ka();
    return { id: e, prettyName: tm[e] || e, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e) };
  }
  function On(e) {
    let { runtimeBinaryTarget: t3 } = e;
    return `Add "${t3}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${rm(e)}`;
  }
  function rm(e) {
    let { generator: t3, generatorBinaryTargets: r, runtimeBinaryTarget: n3 } = e, i3 = { fromEnvVar: null, value: n3 }, o3 = [...r, i3];
    return xi({ ...t3, binaryTargets: o3 });
  }
  function Xe(e) {
    let { runtimeBinaryTarget: t3 } = e;
    return `Prisma Client could not locate the Query Engine for runtime "${t3}".`;
  }
  function et(e) {
    let { searchedLocations: t3 } = e;
    return `The following locations have been searched:
${[...new Set(t3)].map((i3) => `  ${i3}`).join(`
`)}`;
  }
  function Ya(e) {
    let { runtimeBinaryTarget: t3 } = e;
    return `${Xe(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t3}".
${On(e)}

${et(e)}`;
  }
  function kn(e) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`;
  }
  function Dn(e) {
    let { errorStack: t3 } = e;
    return t3?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
  }
  function za(e) {
    let { queryEngineName: t3 } = e;
    return `${Xe(e)}${Dn(e)}

This is likely caused by a bundler that has not copied "${t3}" next to the resulting bundle.
Ensure that "${t3}" has been copied next to the bundle or in "${e.expectedLocation}".

${kn("engine-not-found-bundler-investigation")}

${et(e)}`;
  }
  function Za(e) {
    let { runtimeBinaryTarget: t3, generatorBinaryTargets: r } = e, n3 = r.find((i3) => i3.native);
    return `${Xe(e)}

This happened because Prisma Client was generated for "${n3?.value ?? "unknown"}", but the actual deployment required "${t3}".
${On(e)}

${et(e)}`;
  }
  function Xa(e) {
    let { queryEngineName: t3 } = e;
    return `${Xe(e)}${Dn(e)}

This is likely caused by tooling that has not copied "${t3}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${t3}" has been copied to "${e.expectedLocation}".

${kn("engine-not-found-tooling-investigation")}

${et(e)}`;
  }
  async function tl(e, t3) {
    let r = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e] ?? t3.prismaPath;
    if (r !== undefined)
      return r;
    let { enginePath: n3, searchedLocations: i3 } = await om(e, t3);
    if (nm("enginePath", n3), n3 !== undefined && e === "binary" && pi(n3), n3 !== undefined)
      return t3.prismaPath = n3;
    let o3 = await nt(), s3 = t3.generator?.binaryTargets ?? [], a = s3.some((d3) => d3.native), l3 = !s3.some((d3) => d3.value === o3), u3 = __filename.match(im()) === null, c3 = { searchedLocations: i3, generatorBinaryTargets: s3, generator: t3.generator, runtimeBinaryTarget: o3, queryEngineName: rl(e, o3), expectedLocation: br.default.relative(process.cwd(), t3.dirname), errorStack: new Error().stack }, p;
    throw a && l3 ? p = Za(c3) : l3 ? p = Ya(c3) : u3 ? p = za(c3) : p = Xa(c3), new T3(p, t3.clientVersion);
  }
  async function om(engineType, config) {
    let binaryTarget = await nt(), searchedLocations = [], dirname = eval("__dirname"), searchLocations = [config.dirname, br.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, br.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
    __filename.includes("resolveEnginePath") && searchLocations.push(ts());
    for (let e of searchLocations) {
      let t3 = rl(engineType, binaryTarget), r = br.default.join(e, t3);
      if (searchedLocations.push(e), el.default.existsSync(r))
        return { enginePath: r, searchedLocations };
    }
    return { enginePath: undefined, searchedLocations };
  }
  function rl(e, t3) {
    return e === "library" ? qr(t3, "fs") : `query-engine-${t3}${t3 === "windows" ? ".exe" : ""}`;
  }
  function nl(e) {
    return e ? e.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (t3) => `${t3[0]}5`) : "";
  }
  function il(e) {
    return e.split(`
`).map((t3) => t3.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  }
  function sl({ title: e, user: t3 = "prisma", repo: r = "prisma", template: n3 = "bug_report.yml", body: i3 }) {
    return (0, ol.default)({ user: t3, repo: r, template: n3, title: e, body: i3 });
  }
  function al({ version: e, binaryTarget: t3, title: r, description: n3, engineVersion: i3, database: o3, query: s3 }) {
    let a = ko(6000 - (s3?.length ?? 0)), l3 = il((0, Xi.default)(a)), u3 = n3 ? `# Description
\`\`\`
${n3}
\`\`\`` : "", c3 = (0, Xi.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${t3?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i3?.padEnd(19)}|
| Database        | ${o3?.padEnd(19)}|

${u3}

## Logs
\`\`\`
${l3}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s3 ? nl(s3) : ""}
\`\`\`
`), p = sl({ title: r, body: c3 });
    return `${r}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${X(p)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  }
  function Lt({ inlineDatasources: e, overrideDatasources: t3, env: r, clientVersion: n3 }) {
    let i3, o3 = Object.keys(e)[0], s3 = e[o3]?.url, a = t3[o3]?.url;
    if (o3 === undefined ? i3 = undefined : a ? i3 = a : s3?.value ? i3 = s3.value : s3?.fromEnvVar && (i3 = r[s3.fromEnvVar]), s3?.fromEnvVar !== undefined && i3 === undefined)
      throw new T3(`error: Environment variable not found: ${s3.fromEnvVar}.`, n3);
    if (i3 === undefined)
      throw new T3("error: Missing URL environment variable, value, or override.", n3);
    return i3;
  }
  function S(e, t3) {
    return { ...e, isRetryable: t3 };
  }
  async function lm(e) {
    let t3;
    try {
      t3 = await e.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let r = JSON.parse(t3);
      if (typeof r == "string")
        switch (r) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: r };
          default:
            return { type: "UnknownTextError", body: r };
        }
      if (typeof r == "object" && r !== null) {
        if ("is_panic" in r && "message" in r && "error_code" in r)
          return { type: "QueryEngineError", body: r };
        if ("EngineNotStarted" in r || "InteractiveTransactionMisrouted" in r || "InvalidRequestError" in r) {
          let n3 = Object.values(r)[0].reason;
          return typeof n3 == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n3) ? { type: "UnknownJsonError", body: r } : { type: "DataProxyError", body: r };
        }
      }
      return { type: "UnknownJsonError", body: r };
    } catch {
      return t3 === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t3 };
    }
  }
  async function Or2(e, t3) {
    if (e.ok)
      return;
    let r = { clientVersion: t3, response: e }, n3 = await lm(e);
    if (n3.type === "QueryEngineError")
      throw new ee(n3.body.message, { code: n3.body.error_code, clientVersion: t3 });
    if (n3.type === "DataProxyError") {
      if (n3.body === "InternalDataProxyError")
        throw new Mt(r, "Internal Data Proxy error");
      if ("EngineNotStarted" in n3.body) {
        if (n3.body.EngineNotStarted.reason === "SchemaMissing")
          return new lt(r);
        if (n3.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new Pr(r);
        if ("EngineStartupError" in n3.body.EngineNotStarted.reason) {
          let { msg: i3, logs: o3 } = n3.body.EngineNotStarted.reason.EngineStartupError;
          throw new vr(r, i3, o3);
        }
        if ("KnownEngineStartupError" in n3.body.EngineNotStarted.reason) {
          let { msg: i3, error_code: o3 } = n3.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new T3(i3, t3, o3);
        }
        if ("HealthcheckTimeout" in n3.body.EngineNotStarted.reason) {
          let { logs: i3 } = n3.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new xr(r, i3);
        }
      }
      if ("InteractiveTransactionMisrouted" in n3.body) {
        let i3 = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new Rr(r, i3[n3.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n3.body)
        throw new Cr(r, n3.body.InvalidRequestError.reason);
    }
    if (e.status === 401 || e.status === 403)
      throw new Ar(r, $t(io, n3));
    if (e.status === 404)
      return new Sr(r, $t(ro, n3));
    if (e.status === 429)
      throw new Ir(r, $t(oo, n3));
    if (e.status === 504)
      throw new Tr(r, $t(to, n3));
    if (e.status >= 500)
      throw new Mt(r, $t(no, n3));
    if (e.status >= 400)
      throw new wr(r, $t(eo, n3));
  }
  function $t(e, t3) {
    return t3.type === "EmptyError" ? e : `${e}: ${JSON.stringify(t3)}`;
  }
  function ll(e) {
    let t3 = Math.pow(2, e) * 50, r = Math.ceil(Math.random() * t3) - Math.ceil(t3 / 2), n3 = t3 + r;
    return new Promise((i3) => setTimeout(() => i3(n3), n3));
  }
  function ul(e) {
    let t3 = new TextEncoder().encode(e), r = "", n3 = t3.byteLength, i3 = n3 % 3, o3 = n3 - i3, s3, a, l3, u3, c3;
    for (let p = 0;p < o3; p = p + 3)
      c3 = t3[p] << 16 | t3[p + 1] << 8 | t3[p + 2], s3 = (c3 & 16515072) >> 18, a = (c3 & 258048) >> 12, l3 = (c3 & 4032) >> 6, u3 = c3 & 63, r += qe[s3] + qe[a] + qe[l3] + qe[u3];
    return i3 == 1 ? (c3 = t3[o3], s3 = (c3 & 252) >> 2, a = (c3 & 3) << 4, r += qe[s3] + qe[a] + "==") : i3 == 2 && (c3 = t3[o3] << 8 | t3[o3 + 1], s3 = (c3 & 64512) >> 10, a = (c3 & 1008) >> 4, l3 = (c3 & 15) << 2, r += qe[s3] + qe[a] + qe[l3] + "="), r;
  }
  function cl(e) {
    if (!!e.generator?.previewFeatures.some((r) => r.toLowerCase().includes("metrics")))
      throw new T3("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
  }
  function um(e) {
    return e[0] * 1000 + e[1] / 1e6;
  }
  function so(e) {
    return new Date(um(e));
  }
  async function ut(e, t3, r = (n3) => n3) {
    let { clientVersion: n3, ...i3 } = t3, o3 = r(fetch);
    try {
      return await o3(e, i3);
    } catch (s3) {
      let a = s3.message ?? "Unknown error";
      throw new kr(a, { clientVersion: n3, cause: s3 });
    }
  }
  async function dm(e, t3) {
    let r = pl["@prisma/engines-version"], n3 = t3.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e.includes("accelerate") && n3 !== "0.0.0" && n3 !== "in-memory")
      return n3;
    let [i3, o3] = n3?.split("-") ?? [];
    if (o3 === undefined && pm.test(i3))
      return i3;
    if (o3 !== undefined || n3 === "0.0.0" || n3 === "in-memory") {
      if (e.startsWith("localhost") || e.startsWith("127.0.0.1"))
        return "0.0.0";
      let [s3] = r.split("-") ?? [], [a, l3, u3] = s3.split("."), c3 = mm(`<=${a}.${l3}.${u3}`), p = await ut(c3, { clientVersion: n3 });
      if (!p.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
      let d3 = await p.text();
      dl("length of body fetched from unpkg.com", d3.length);
      let f3;
      try {
        f3 = JSON.parse(d3);
      } catch (g) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", d3), g;
      }
      return f3.version;
    }
    throw new at("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n3 });
  }
  async function ml(e, t3) {
    let r = await dm(e, t3);
    return dl("version", r), r;
  }
  function mm(e) {
    return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
  }
  function gl(e) {
    if (e?.kind === "itx")
      return e.options.id;
  }
  function fm() {
    let e = globalThis;
    return e[lo] === undefined && (e[lo] = {}), e[lo];
  }
  function gm(e) {
    let t3 = fm();
    if (t3[e] !== undefined)
      return t3[e];
    let r = hl.default.toNamespacedPath(e), n3 = { exports: {} }, i3 = 0;
    return process.platform !== "win32" && (i3 = uo.default.constants.dlopen.RTLD_LAZY | uo.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n3, r, i3), t3[e] = n3.exports, n3.exports;
  }
  function ym(e) {
    return e.item_type === "query" && "query" in e;
  }
  function Em(e) {
    return "level" in e ? e.level === "error" && e.message === "PANIC" : false;
  }
  function wm() {
    let e = po++;
    return po > bm && (po = 1n), e;
  }
  function xm(e) {
    return typeof e == "object" && e !== null && e.error_code !== undefined;
  }
  function mo(e, t3) {
    return al({ binaryTarget: e.binaryTarget, title: t3, version: e.config.clientVersion, engineVersion: e.versionInfo?.commit, database: e.config.activeProvider, query: e.lastQuery });
  }
  function wl({ copyEngine: e = true }, t3) {
    let r;
    try {
      r = Lt({ inlineDatasources: t3.inlineDatasources, overrideDatasources: t3.overrideDatasources, env: { ...t3.env, ...process.env }, clientVersion: t3.clientVersion });
    } catch {
    }
    let n3 = !!(r?.startsWith("prisma://") || r?.startsWith("prisma+postgres://"));
    e && n3 && tr("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
    let i3 = Yt(t3.generator), o3 = n3 || !e, s3 = !!t3.adapter, a = i3 === "library", l3 = i3 === "binary";
    if (o3 && s3 || s3 && false) {
      let u3;
      throw e ? r?.startsWith("prisma://") ? u3 = ["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.", "Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."] : u3 = ["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."] : u3 = ["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."], new te(u3.join(`
`), { clientVersion: t3.clientVersion });
    }
    if (o3)
      return new Dr(t3);
    if (a)
      return new _r(t3);
    throw new te("Invalid client engine type, please use `library` or `binary`", { clientVersion: t3.clientVersion });
  }
  function Ln({ generator: e }) {
    return e?.previewFeatures ?? [];
  }
  function qt(e) {
    try {
      return Pl(e, "fast");
    } catch {
      return Pl(e, "slow");
    }
  }
  function Pl(e, t3) {
    return JSON.stringify(e.map((r) => Rl(r, t3)));
  }
  function Rl(e, t3) {
    if (Array.isArray(e))
      return e.map((r) => Rl(r, t3));
    if (typeof e == "bigint")
      return { prisma__type: "bigint", prisma__value: e.toString() };
    if (xt(e))
      return { prisma__type: "date", prisma__value: e.toJSON() };
    if (ve.isDecimal(e))
      return { prisma__type: "decimal", prisma__value: e.toJSON() };
    if (Buffer.isBuffer(e))
      return { prisma__type: "bytes", prisma__value: e.toString("base64") };
    if (vm(e))
      return { prisma__type: "bytes", prisma__value: Buffer.from(e).toString("base64") };
    if (ArrayBuffer.isView(e)) {
      let { buffer: r, byteOffset: n3, byteLength: i3 } = e;
      return { prisma__type: "bytes", prisma__value: Buffer.from(r, n3, i3).toString("base64") };
    }
    return typeof e == "object" && t3 === "slow" ? Cl(e) : e;
  }
  function vm(e) {
    return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  }
  function Cl(e) {
    if (typeof e != "object" || e === null)
      return e;
    if (typeof e.toJSON == "function")
      return e.toJSON();
    if (Array.isArray(e))
      return e.map(Tl);
    let t3 = {};
    for (let r of Object.keys(e))
      t3[r] = Tl(e[r]);
    return t3;
  }
  function Tl(e) {
    return typeof e == "bigint" ? e.toString() : Cl(e);
  }
  function fo(e, t3, r, n3) {
    if (!(e !== "postgresql" && e !== "cockroachdb") && r.length > 0 && Tm.exec(t3))
      throw new Error(`Running ALTER using ${n3} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  }
  function ho(e) {
    return function(r) {
      let n3, i3 = (o3 = e) => {
        try {
          return o3 === undefined || o3?.kind === "itx" ? n3 ??= kl(r(o3)) : kl(r(o3));
        } catch (s3) {
          return Promise.reject(s3);
        }
      };
      return { then(o3, s3) {
        return i3().then(o3, s3);
      }, catch(o3) {
        return i3().catch(o3);
      }, finally(o3) {
        return i3().finally(o3);
      }, requestTransaction(o3) {
        let s3 = i3(o3);
        return s3.requestTransaction ? s3.requestTransaction(o3) : s3;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  }
  function kl(e) {
    return typeof e.then == "function" ? e : Promise.resolve(e);
  }
  function Dl() {
    return new yo;
  }
  function _l(e, t3 = () => {
  }) {
    let r, n3 = new Promise((i3) => r = i3);
    return { then(i3) {
      return --e === 0 && r(t3()), i3?.(n3);
    } };
  }
  function Nl(e) {
    return typeof e == "string" ? e : e.reduce((t3, r) => {
      let n3 = typeof r == "string" ? r : r.level;
      return n3 === "query" ? t3 : t3 && (r === "info" || t3 === "info") ? "info" : n3;
    }, undefined);
  }
  function Mn(e) {
    return typeof e.batchRequestIdx == "number";
  }
  function Ll(e) {
    if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow")
      return;
    let t3 = [];
    return e.modelName && t3.push(e.modelName), e.query.arguments && t3.push(Eo(e.query.arguments)), t3.push(Eo(e.query.selection)), t3.join("");
  }
  function Eo(e) {
    return `(${Object.keys(e).sort().map((r) => {
      let n3 = e[r];
      return typeof n3 == "object" && n3 !== null ? `(${r} ${Eo(n3)})` : r;
    }).join(" ")})`;
  }
  function bo(e) {
    return Cm[e];
  }
  function ct(e, t3) {
    if (t3 === null)
      return t3;
    switch (e) {
      case "bigint":
        return BigInt(t3);
      case "bytes": {
        let { buffer: r, byteOffset: n3, byteLength: i3 } = Buffer.from(t3, "base64");
        return new Uint8Array(r, n3, i3);
      }
      case "decimal":
        return new ve(t3);
      case "datetime":
      case "date":
        return new Date(t3);
      case "time":
        return new Date(`1970-01-01T${t3}Z`);
      case "bigint-array":
        return t3.map((r) => ct("bigint", r));
      case "bytes-array":
        return t3.map((r) => ct("bytes", r));
      case "decimal-array":
        return t3.map((r) => ct("decimal", r));
      case "datetime-array":
        return t3.map((r) => ct("datetime", r));
      case "date-array":
        return t3.map((r) => ct("date", r));
      case "time-array":
        return t3.map((r) => ct("time", r));
      default:
        return t3;
    }
  }
  function qn(e) {
    let t3 = [], r = Sm(e);
    for (let n3 = 0;n3 < e.rows.length; n3++) {
      let i3 = e.rows[n3], o3 = { ...r };
      for (let s3 = 0;s3 < i3.length; s3++)
        o3[e.columns[s3]] = ct(e.types[s3], i3[s3]);
      t3.push(o3);
    }
    return t3;
  }
  function Sm(e) {
    let t3 = {};
    for (let r = 0;r < e.columns.length; r++)
      t3[e.columns[r]] = null;
    return t3;
  }
  function Im(e) {
    if (e) {
      if (e.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
      if (e.kind === "itx")
        return { kind: "itx", options: Ml(e) };
      Fe(e, "Unknown transaction kind");
    }
  }
  function Ml(e) {
    return { id: e.id, payload: e.payload };
  }
  function Om(e, t3) {
    return Mn(e) && t3?.kind === "batch" && e.batchRequestIdx !== t3.index;
  }
  function km(e) {
    return e.code === "P2009" || e.code === "P2012";
  }
  function $l(e) {
    if (e.kind === "Union")
      return { kind: "Union", errors: e.errors.map($l) };
    if (Array.isArray(e.selectionPath)) {
      let [, ...t3] = e.selectionPath;
      return { ...e, selectionPath: t3 };
    }
    return e;
  }
  function Jl(e, t3) {
    for (let [r, n3] of Object.entries(e)) {
      if (!jl.includes(r)) {
        let i3 = Vt(r, jl);
        throw new L(`Unknown property ${r} provided to PrismaClient constructor.${i3}`);
      }
      _m[r](n3, t3);
    }
    if (e.datasourceUrl && e.datasources)
      throw new L('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  }
  function Vt(e, t3) {
    if (t3.length === 0 || typeof e != "string")
      return "";
    let r = Nm(e, t3);
    return r ? ` Did you mean "${r}"?` : "";
  }
  function Nm(e, t3) {
    if (t3.length === 0)
      return null;
    let r = t3.map((i3) => ({ value: i3, distance: (0, Gl.default)(e, i3) }));
    r.sort((i3, o3) => i3.distance < o3.distance ? -1 : 1);
    let n3 = r[0];
    return n3.distance < 3 ? n3.value : null;
  }
  function Lm(e, t3) {
    return Ql(t3.models, e) ?? Ql(t3.types, e);
  }
  function Ql(e, t3) {
    let r = Object.keys(e).find((n3) => wt(n3) === t3);
    if (r)
      return e[r];
  }
  function Fm(e, t3) {
    let r = At(e);
    for (let o3 of t3)
      switch (o3.kind) {
        case "UnknownModel":
          r.arguments.getField(o3.modelKey)?.markAsError(), r.addErrorMessage(() => `Unknown model name: ${o3.modelKey}.`);
          break;
        case "UnknownField":
          r.arguments.getDeepField([o3.modelKey, o3.fieldName])?.markAsError(), r.addErrorMessage(() => `Model "${o3.modelKey}" does not have a field named "${o3.fieldName}".`);
          break;
        case "RelationInOmit":
          r.arguments.getDeepField([o3.modelKey, o3.fieldName])?.markAsError(), r.addErrorMessage(() => 'Relations are already excluded by default and can not be specified in "omit".');
          break;
        case "InvalidFieldValue":
          r.arguments.getDeepFieldValue([o3.modelKey, o3.fieldName])?.markAsError(), r.addErrorMessage(() => "Omit field option value must be a boolean.");
          break;
      }
    let { message: n3, args: i3 } = bn(r, "colorless");
    return `Error validating "omit" option:

${i3}

${n3}`;
  }
  function Hl(e) {
    return e.length === 0 ? Promise.resolve([]) : new Promise((t3, r) => {
      let n3 = new Array(e.length), i3 = null, o3 = false, s3 = 0, a = () => {
        o3 || (s3++, s3 === e.length && (o3 = true, i3 ? r(i3) : t3(n3)));
      }, l3 = (u3) => {
        o3 || (o3 = true, r(u3));
      };
      for (let u3 = 0;u3 < e.length; u3++)
        e[u3].then((c3) => {
          n3[u3] = c3, a();
        }, (c3) => {
          if (!Mn(c3)) {
            l3(c3);
            return;
          }
          c3.batchRequestIdx === u3 ? l3(c3) : (i3 || (i3 = c3), a());
        });
    });
  }
  function Xl(e) {

    class t3 {
      constructor(n3) {
        this._originalClient = this;
        this._middlewares = new Fn;
        this._createPrismaPromise = ho();
        this.$extends = Na;
        e = n3?.__internal?.configOverride?.(e) ?? e, Ha(e), n3 && Jl(n3, e);
        let i3 = new zl.EventEmitter().on("error", () => {
        });
        this._extensions = It.empty(), this._previewFeatures = Ln(e), this._clientVersion = e.clientVersion ?? Vl, this._activeProvider = e.activeProvider, this._globalOmit = n3?.omit, this._tracingHelper = Dl();
        let o3 = { rootEnvPath: e.relativeEnvPaths.rootEnvPath && Nr.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && Nr.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, s3;
        if (n3?.adapter) {
          s3 = Qi(n3.adapter);
          let l3 = e.activeProvider === "postgresql" ? "postgres" : e.activeProvider;
          if (s3.provider !== l3)
            throw new T3(`The Driver Adapter \`${s3.adapterName}\`, based on \`${s3.provider}\`, is not compatible with the provider \`${l3}\` specified in the Prisma schema.`, this._clientVersion);
          if (n3.datasources || n3.datasourceUrl !== undefined)
            throw new T3("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.", this._clientVersion);
        }
        let a = !s3 && Kt(o3, { conflictCheck: "none" }) || e.injectableEdgeEnv?.();
        try {
          let l3 = n3 ?? {}, u3 = l3.__internal ?? {}, c3 = u3.debug === true;
          c3 && F.enable("prisma:client");
          let p = Nr.default.resolve(e.dirname, e.relativePath);
          Zl.default.existsSync(p) || (p = e.dirname), tt("dirname", e.dirname), tt("relativePath", e.relativePath), tt("cwd", p);
          let d3 = u3.engine || {};
          if (l3.errorFormat ? this._errorFormat = l3.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: p, dirname: e.dirname, enableDebugLogs: c3, allowTriggerPanic: d3.allowTriggerPanic, datamodelPath: Nr.default.join(e.dirname, e.filename ?? "schema.prisma"), prismaPath: d3.binaryPath ?? undefined, engineEndpoint: d3.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: l3.log && Nl(l3.log), logQueries: l3.log && !!(typeof l3.log == "string" ? l3.log === "query" : l3.log.find((f3) => typeof f3 == "string" ? f3 === "query" : f3.level === "query")), env: a?.parsed ?? {}, flags: [], engineWasm: e.engineWasm, clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: Wa(l3, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: l3.transactionOptions?.maxWait ?? 2000, timeout: l3.transactionOptions?.timeout ?? 5000, isolationLevel: l3.transactionOptions?.isolationLevel }, logEmitter: i3, isBundled: e.isBundled, adapter: s3 }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: Lt, getBatchRequestPayload: Dt, prismaGraphQLToJSError: _t, PrismaClientUnknownRequestError: B, PrismaClientInitializationError: T3, PrismaClientKnownRequestError: ee, debug: F("prisma:client:accelerateEngine"), engineVersion: Kl.version, clientVersion: e.clientVersion } }, tt("clientVersion", e.clientVersion), this._engine = wl(e, this._engineConfig), this._requestHandler = new Vn(this, i3), l3.log)
            for (let f3 of l3.log) {
              let g = typeof f3 == "string" ? f3 : f3.emit === "stdout" ? f3.level : null;
              g && this.$on(g, (h) => {
                er.log(`${er.tags[g] ?? ""}`, h.message || h.query);
              });
            }
          this._metrics = new Ot(this._engine);
        } catch (l3) {
          throw l3.clientVersion = this._clientVersion, l3;
        }
        return this._appliedParent = yr(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n3) {
        this._middlewares.use(n3);
      }
      $on(n3, i3) {
        n3 === "beforeExit" ? this._engine.onBeforeExit(i3) : n3 && this._engineConfig.logEmitter.on(n3, i3);
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n3) {
          throw n3.clientVersion = this._clientVersion, n3;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n3) {
          throw n3.clientVersion = this._clientVersion, n3;
        } finally {
          Do();
        }
      }
      $executeRawInternal(n3, i3, o3, s3) {
        let a = this._activeProvider;
        return this._request({ action: "executeRaw", args: o3, transaction: n3, clientMethod: i3, argsMapper: go({ clientMethod: i3, activeProvider: a }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s3 });
      }
      $executeRaw(n3, ...i3) {
        return this._createPrismaPromise((o3) => {
          if (n3.raw !== undefined || n3.sql !== undefined) {
            let [s3, a] = Wl(n3, i3);
            return fo(this._activeProvider, s3.text, s3.values, Array.isArray(n3) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o3, "$executeRaw", s3, a);
          }
          throw new te("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n3, ...i3) {
        return this._createPrismaPromise((o3) => (fo(this._activeProvider, n3, i3, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o3, "$executeRawUnsafe", [n3, ...i3])));
      }
      $runCommandRaw(n3) {
        if (e.activeProvider !== "mongodb")
          throw new te(`The ${e.activeProvider} provider does not support \$runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i3) => this._request({ args: n3, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: xl, callsite: Ze(this._errorFormat), transaction: i3 }));
      }
      async $queryRawInternal(n3, i3, o3, s3) {
        let a = this._activeProvider;
        return this._request({ action: "queryRaw", args: o3, transaction: n3, clientMethod: i3, argsMapper: go({ clientMethod: i3, activeProvider: a }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s3 });
      }
      $queryRaw(n3, ...i3) {
        return this._createPrismaPromise((o3) => {
          if (n3.raw !== undefined || n3.sql !== undefined)
            return this.$queryRawInternal(o3, "$queryRaw", ...Wl(n3, i3));
          throw new te("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawTyped(n3) {
        return this._createPrismaPromise((i3) => {
          if (!this._hasPreviewFlag("typedSql"))
            throw new te("`typedSql` preview feature must be enabled in order to access $queryRawTyped API", { clientVersion: this._clientVersion });
          return this.$queryRawInternal(i3, "$queryRawTyped", n3);
        });
      }
      $queryRawUnsafe(n3, ...i3) {
        return this._createPrismaPromise((o3) => this.$queryRawInternal(o3, "$queryRawUnsafe", [n3, ...i3]));
      }
      _transactionWithArray({ promises: n3, options: i3 }) {
        let o3 = qm.nextId(), s3 = _l(n3.length), a = n3.map((l3, u3) => {
          if (l3?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c3 = i3?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, p = { kind: "batch", id: o3, index: u3, isolationLevel: c3, lock: s3 };
          return l3.requestTransaction?.(p) ?? l3;
        });
        return Hl(a);
      }
      async _transactionWithCallback({ callback: n3, options: i3 }) {
        let o3 = { traceparent: this._tracingHelper.getTraceParent() }, s3 = { maxWait: i3?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: i3?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: i3?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, a = await this._engine.transaction("start", o3, s3), l3;
        try {
          let u3 = { kind: "itx", ...a };
          l3 = await n3(this._createItxClient(u3)), await this._engine.transaction("commit", o3, a);
        } catch (u3) {
          throw await this._engine.transaction("rollback", o3, a).catch(() => {
          }), u3;
        }
        return l3;
      }
      _createItxClient(n3) {
        return yr(Ae(_a(this), [ie("_appliedParent", () => this._appliedParent._createItxClient(n3)), ie("_createPrismaPromise", () => ho(n3)), ie($m, () => n3.id), kt(Sl)]));
      }
      $transaction(n3, i3) {
        let o3;
        typeof n3 == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? o3 = () => {
          throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
        } : o3 = () => this._transactionWithCallback({ callback: n3, options: i3 }) : o3 = () => this._transactionWithArray({ promises: n3, options: i3 });
        let s3 = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s3, o3);
      }
      _request(n3) {
        n3.otelParentCtx = this._tracingHelper.getActiveContext();
        let i3 = n3.middlewareArgsMapper ?? Mm, o3 = { args: i3.requestArgsToMiddlewareArgs(n3.args), dataPath: n3.dataPath, runInTransaction: !!n3.transaction, action: n3.action, model: n3.model }, s3 = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o3.action, model: o3.model, name: o3.model ? `${o3.model}.${o3.action}` : o3.action } } }, a = -1, l3 = async (u3) => {
          let c3 = this._middlewares.get(++a);
          if (c3)
            return this._tracingHelper.runInChildSpan(s3.middleware, (O) => c3(u3, (P) => (O?.end(), l3(P))));
          let { runInTransaction: p, args: d3, ...f3 } = u3, g = { ...n3, ...f3 };
          d3 && (g.args = i3.middlewareArgsToRequestArgs(d3)), n3.transaction !== undefined && p === false && delete g.transaction;
          let h = await ja(this, g);
          return g.model ? Ma({ result: h, modelName: g.model, args: g.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel, globalOmit: this._globalOmit }) : h;
        };
        return this._tracingHelper.runInChildSpan(s3.operation, () => new Yl.AsyncResource("prisma-client-request").runInAsyncScope(() => l3(o3)));
      }
      async _executeRequest({ args: n3, clientMethod: i3, dataPath: o3, callsite: s3, action: a, model: l3, argsMapper: u3, transaction: c3, unpacker: p, otelParentCtx: d3, customDataProxyFetch: f3 }) {
        try {
          n3 = u3 ? u3(n3) : n3;
          let g = { name: "serialize" }, h = this._tracingHelper.runInChildSpan(g, () => Pn({ modelName: l3, runtimeDataModel: this._runtimeDataModel, action: a, args: n3, clientMethod: i3, callsite: s3, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion, previewFeatures: this._previewFeatures, globalOmit: this._globalOmit }));
          return F.enabled("prisma:client") && (tt("Prisma Client call:"), tt(`prisma.${i3}(${va(n3)})`), tt("Generated request:"), tt(JSON.stringify(h, null, 2) + `
`)), c3?.kind === "batch" && await c3.lock, this._requestHandler.request({ protocolQuery: h, modelName: l3, action: a, clientMethod: i3, dataPath: o3, callsite: s3, args: n3, extensions: this._extensions, transaction: c3, unpacker: p, otelParentCtx: d3, otelChildCtx: this._tracingHelper.getActiveContext(), globalOmit: this._globalOmit, customDataProxyFetch: f3 });
        } catch (g) {
          throw g.clientVersion = this._clientVersion, g;
        }
      }
      get $metrics() {
        if (!this._hasPreviewFlag("metrics"))
          throw new te("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
        return this._metrics;
      }
      _hasPreviewFlag(n3) {
        return !!this._engineConfig.previewFeatures?.includes(n3);
      }
      $applyPendingMigrations() {
        return this._engine.applyPendingMigrations();
      }
    }
    return t3;
  }
  function Wl(e, t3) {
    return Vm(e) ? [new ae(e, t3), Il] : [e, Ol];
  }
  function Vm(e) {
    return Array.isArray(e) && Array.isArray(e.raw);
  }
  function eu(e) {
    return new Proxy(e, { get(t3, r) {
      if (r in t3)
        return t3[r];
      if (!jm.has(r))
        throw new TypeError(`Invalid enum value: ${String(r)}`);
    } });
  }
  function tu(e) {
    Kt(e, { conflictCheck: "warn" });
  }
  var __dirname = "/home/natee/workspace/portfolio-v3-api/node_modules/@prisma/client/runtime", __filename = "/home/natee/workspace/portfolio-v3-api/node_modules/@prisma/client/runtime/library.js";
  var ru = Object.create;
  var Fr = Object.defineProperty;
  var nu = Object.getOwnPropertyDescriptor;
  var iu = Object.getOwnPropertyNames;
  var ou = Object.getPrototypeOf;
  var su = Object.prototype.hasOwnProperty;
  var Z = (e, t3) => () => (t3 || e((t3 = { exports: {} }).exports, t3), t3.exports);
  var Bt = (e, t3) => {
    for (var r in t3)
      Fr(e, r, { get: t3[r], enumerable: true });
  };
  var wo = (e, t3, r, n3) => {
    if (t3 && typeof t3 == "object" || typeof t3 == "function")
      for (let i3 of iu(t3))
        !su.call(e, i3) && i3 !== r && Fr(e, i3, { get: () => t3[i3], enumerable: !(n3 = nu(t3, i3)) || n3.enumerable });
    return e;
  };
  var D = (e, t3, r) => (r = e != null ? ru(ou(e)) : {}, wo(t3 || !e || !e.__esModule ? Fr(r, "default", { value: e, enumerable: true }) : r, e));
  var au = (e) => wo(Fr({}, "__esModule", { value: true }), e);
  var Qo = Z((yf, ti) => {
    var v3 = ti.exports;
    ti.exports.default = v3;
    var _ = "\x1B[", Ht = "\x1B]", mt = "\x07", Jr = ";", Uo = false;
    v3.cursorTo = (e, t3) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      return typeof t3 != "number" ? _ + (e + 1) + "G" : _ + (t3 + 1) + ";" + (e + 1) + "H";
    };
    v3.cursorMove = (e, t3) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      let r = "";
      return e < 0 ? r += _ + -e + "D" : e > 0 && (r += _ + e + "C"), t3 < 0 ? r += _ + -t3 + "A" : t3 > 0 && (r += _ + t3 + "B"), r;
    };
    v3.cursorUp = (e = 1) => _ + e + "A";
    v3.cursorDown = (e = 1) => _ + e + "B";
    v3.cursorForward = (e = 1) => _ + e + "C";
    v3.cursorBackward = (e = 1) => _ + e + "D";
    v3.cursorLeft = _ + "G";
    v3.cursorSavePosition = Uo ? "\x1B7" : _ + "s";
    v3.cursorRestorePosition = Uo ? "\x1B8" : _ + "u";
    v3.cursorGetPosition = _ + "6n";
    v3.cursorNextLine = _ + "E";
    v3.cursorPrevLine = _ + "F";
    v3.cursorHide = _ + "?25l";
    v3.cursorShow = _ + "?25h";
    v3.eraseLines = (e) => {
      let t3 = "";
      for (let r = 0;r < e; r++)
        t3 += v3.eraseLine + (r < e - 1 ? v3.cursorUp() : "");
      return e && (t3 += v3.cursorLeft), t3;
    };
    v3.eraseEndLine = _ + "K";
    v3.eraseStartLine = _ + "1K";
    v3.eraseLine = _ + "2K";
    v3.eraseDown = _ + "J";
    v3.eraseUp = _ + "1J";
    v3.eraseScreen = _ + "2J";
    v3.scrollUp = _ + "S";
    v3.scrollDown = _ + "T";
    v3.clearScreen = "\x1Bc";
    v3.clearTerminal = process.platform === "win32" ? `${v3.eraseScreen}${_}0f` : `${v3.eraseScreen}${_}3J${_}H`;
    v3.beep = mt;
    v3.link = (e, t3) => [Ht, "8", Jr, Jr, t3, mt, e, Ht, "8", Jr, Jr, mt].join("");
    v3.image = (e, t3 = {}) => {
      let r = `${Ht}1337;File=inline=1`;
      return t3.width && (r += `;width=${t3.width}`), t3.height && (r += `;height=${t3.height}`), t3.preserveAspectRatio === false && (r += ";preserveAspectRatio=0"), r + ":" + e.toString("base64") + mt;
    };
    v3.iTerm = { setCwd: (e = process.cwd()) => `${Ht}50;CurrentDir=${e}${mt}`, annotation: (e, t3 = {}) => {
      let r = `${Ht}1337;`, n3 = typeof t3.x < "u", i3 = typeof t3.y < "u";
      if ((n3 || i3) && !(n3 && i3 && typeof t3.length < "u"))
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e = e.replace(/\|/g, ""), r += t3.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", t3.length > 0 ? r += (n3 ? [e, t3.length, t3.x, t3.y] : [t3.length, e]).join("|") : r += e, r + mt;
    } };
  });
  var ri = Z((Ef, Go) => {
    Go.exports = (e, t3 = process.argv) => {
      let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n3 = t3.indexOf(r + e), i3 = t3.indexOf("--");
      return n3 !== -1 && (i3 === -1 || n3 < i3);
    };
  });
  var Wo = Z((bf, Ho) => {
    var Ju = import.meta.require("os"), Jo = import.meta.require("tty"), fe = ri(), { env: J } = process, Je;
    fe("no-color") || fe("no-colors") || fe("color=false") || fe("color=never") ? Je = 0 : (fe("color") || fe("colors") || fe("color=true") || fe("color=always")) && (Je = 1);
    "FORCE_COLOR" in J && (J.FORCE_COLOR === "true" ? Je = 1 : J.FORCE_COLOR === "false" ? Je = 0 : Je = J.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(J.FORCE_COLOR, 10), 3));
    function ni(e) {
      return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
    }
    function ii(e, t3) {
      if (Je === 0)
        return 0;
      if (fe("color=16m") || fe("color=full") || fe("color=truecolor"))
        return 3;
      if (fe("color=256"))
        return 2;
      if (e && !t3 && Je === undefined)
        return 0;
      let r = Je || 0;
      if (J.TERM === "dumb")
        return r;
      if (process.platform === "win32") {
        let n3 = Ju.release().split(".");
        return Number(n3[0]) >= 10 && Number(n3[2]) >= 10586 ? Number(n3[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in J)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n3) => (n3 in J)) || J.CI_NAME === "codeship" ? 1 : r;
      if ("TEAMCITY_VERSION" in J)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(J.TEAMCITY_VERSION) ? 1 : 0;
      if (J.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in J) {
        let n3 = parseInt((J.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (J.TERM_PROGRAM) {
          case "iTerm.app":
            return n3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(J.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(J.TERM) || ("COLORTERM" in J) ? 1 : r;
    }
    function Hu(e) {
      let t3 = ii(e, e && e.isTTY);
      return ni(t3);
    }
    Ho.exports = { supportsColor: Hu, stdout: ni(ii(true, Jo.isatty(1))), stderr: ni(ii(true, Jo.isatty(2))) };
  });
  var zo = Z((wf, Yo) => {
    var Wu = Wo(), ft = ri();
    function Ko(e) {
      if (/^\d{3,4}$/.test(e)) {
        let r = /(\d{1,2})(\d{2})/.exec(e);
        return { major: 0, minor: parseInt(r[1], 10), patch: parseInt(r[2], 10) };
      }
      let t3 = (e || "").split(".").map((r) => parseInt(r, 10));
      return { major: t3[0], minor: t3[1], patch: t3[2] };
    }
    function oi(e) {
      let { env: t3 } = process;
      if ("FORCE_HYPERLINK" in t3)
        return !(t3.FORCE_HYPERLINK.length > 0 && parseInt(t3.FORCE_HYPERLINK, 10) === 0);
      if (ft("no-hyperlink") || ft("no-hyperlinks") || ft("hyperlink=false") || ft("hyperlink=never"))
        return false;
      if (ft("hyperlink=true") || ft("hyperlink=always") || "NETLIFY" in t3)
        return true;
      if (!Wu.supportsColor(e) || e && !e.isTTY || process.platform === "win32" || "CI" in t3 || "TEAMCITY_VERSION" in t3)
        return false;
      if ("TERM_PROGRAM" in t3) {
        let r = Ko(t3.TERM_PROGRAM_VERSION);
        switch (t3.TERM_PROGRAM) {
          case "iTerm.app":
            return r.major === 3 ? r.minor >= 1 : r.major > 3;
          case "WezTerm":
            return r.major >= 20200620;
          case "vscode":
            return r.major > 1 || r.major === 1 && r.minor >= 72;
        }
      }
      if ("VTE_VERSION" in t3) {
        if (t3.VTE_VERSION === "0.50.0")
          return false;
        let r = Ko(t3.VTE_VERSION);
        return r.major > 0 || r.minor >= 50;
      }
      return false;
    }
    Yo.exports = { supportsHyperlink: oi, stdout: oi(process.stdout), stderr: oi(process.stderr) };
  });
  var Xo = Z((xf, Wt) => {
    var Ku = Qo(), si = zo(), Zo = (e, t3, { target: r = "stdout", ...n3 } = {}) => si[r] ? Ku.link(e, t3) : n3.fallback === false ? e : typeof n3.fallback == "function" ? n3.fallback(e, t3) : `${e} (\u200B${t3}\u200B)`;
    Wt.exports = (e, t3, r = {}) => Zo(e, t3, r);
    Wt.exports.stderr = (e, t3, r = {}) => Zo(e, t3, { target: "stderr", ...r });
    Wt.exports.isSupported = si.stdout;
    Wt.exports.stderr.isSupported = si.stderr;
  });
  var li = Z((kf, Yu) => {
    Yu.exports = { name: "@prisma/engines-version", version: "6.2.0-14.4123509d24aa4dede1e864b46351bf2790323b69", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "4123509d24aa4dede1e864b46351bf2790323b69" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.68", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var ui = Z((Hr) => {
    Object.defineProperty(Hr, "__esModule", { value: true });
    Hr.enginesVersion = undefined;
    Hr.enginesVersion = li().prisma.enginesVersion;
  });
  var ns = Z((Yf, Xu) => {
    Xu.exports = { name: "dotenv", version: "16.4.7", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", pretest: "npm run lint && npm run dts-check", test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000", "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, funding: "https://dotenvx.com", keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^18.11.3", decache: "^4.6.2", sinon: "^14.0.1", standard: "^17.0.0", "standard-version": "^9.5.0", tap: "^19.2.0", typescript: "^4.8.4" }, engines: { node: ">=12" }, browser: { fs: false } };
  });
  var as = Z((zf, Le) => {
    var mi = import.meta.require("fs"), fi = import.meta.require("path"), ec = import.meta.require("os"), tc = import.meta.require("crypto"), rc = ns(), gi = rc.version, nc = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function ic(e) {
      let t3 = {}, r = e.toString();
      r = r.replace(/\r\n?/mg, `
`);
      let n3;
      for (;(n3 = nc.exec(r)) != null; ) {
        let i3 = n3[1], o3 = n3[2] || "";
        o3 = o3.trim();
        let s3 = o3[0];
        o3 = o3.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s3 === '"' && (o3 = o3.replace(/\\n/g, `
`), o3 = o3.replace(/\\r/g, "\r")), t3[i3] = o3;
      }
      return t3;
    }
    function oc(e) {
      let t3 = ss(e), r = Q.configDotenv({ path: t3 });
      if (!r.parsed) {
        let s3 = new Error(`MISSING_DATA: Cannot parse ${t3} for an unknown reason`);
        throw s3.code = "MISSING_DATA", s3;
      }
      let n3 = os2(e).split(","), i3 = n3.length, o3;
      for (let s3 = 0;s3 < i3; s3++)
        try {
          let a = n3[s3].trim(), l3 = lc(r, a);
          o3 = Q.decrypt(l3.ciphertext, l3.key);
          break;
        } catch (a) {
          if (s3 + 1 >= i3)
            throw a;
        }
      return Q.parse(o3);
    }
    function sc(e) {
      console.log(`[dotenv@${gi}][INFO] ${e}`);
    }
    function ac(e) {
      console.log(`[dotenv@${gi}][WARN] ${e}`);
    }
    function Wr(e) {
      console.log(`[dotenv@${gi}][DEBUG] ${e}`);
    }
    function os2(e) {
      return e && e.DOTENV_KEY && e.DOTENV_KEY.length > 0 ? e.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
    }
    function lc(e, t3) {
      let r;
      try {
        r = new URL(t3);
      } catch (a) {
        if (a.code === "ERR_INVALID_URL") {
          let l3 = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          throw l3.code = "INVALID_DOTENV_KEY", l3;
        }
        throw a;
      }
      let n3 = r.password;
      if (!n3) {
        let a = new Error("INVALID_DOTENV_KEY: Missing key part");
        throw a.code = "INVALID_DOTENV_KEY", a;
      }
      let i3 = r.searchParams.get("environment");
      if (!i3) {
        let a = new Error("INVALID_DOTENV_KEY: Missing environment part");
        throw a.code = "INVALID_DOTENV_KEY", a;
      }
      let o3 = `DOTENV_VAULT_${i3.toUpperCase()}`, s3 = e.parsed[o3];
      if (!s3) {
        let a = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o3} in your .env.vault file.`);
        throw a.code = "NOT_FOUND_DOTENV_ENVIRONMENT", a;
      }
      return { ciphertext: s3, key: n3 };
    }
    function ss(e) {
      let t3 = null;
      if (e && e.path && e.path.length > 0)
        if (Array.isArray(e.path))
          for (let r of e.path)
            mi.existsSync(r) && (t3 = r.endsWith(".vault") ? r : `${r}.vault`);
        else
          t3 = e.path.endsWith(".vault") ? e.path : `${e.path}.vault`;
      else
        t3 = fi.resolve(process.cwd(), ".env.vault");
      return mi.existsSync(t3) ? t3 : null;
    }
    function is(e) {
      return e[0] === "~" ? fi.join(ec.homedir(), e.slice(1)) : e;
    }
    function uc(e) {
      sc("Loading env from encrypted .env.vault");
      let t3 = Q._parseVault(e), r = process.env;
      return e && e.processEnv != null && (r = e.processEnv), Q.populate(r, t3, e), { parsed: t3 };
    }
    function cc(e) {
      let t3 = fi.resolve(process.cwd(), ".env"), r = "utf8", n3 = !!(e && e.debug);
      e && e.encoding ? r = e.encoding : n3 && Wr("No encoding is specified. UTF-8 is used by default");
      let i3 = [t3];
      if (e && e.path)
        if (!Array.isArray(e.path))
          i3 = [is(e.path)];
        else {
          i3 = [];
          for (let l3 of e.path)
            i3.push(is(l3));
        }
      let o3, s3 = {};
      for (let l3 of i3)
        try {
          let u3 = Q.parse(mi.readFileSync(l3, { encoding: r }));
          Q.populate(s3, u3, e);
        } catch (u3) {
          n3 && Wr(`Failed to load ${l3} ${u3.message}`), o3 = u3;
        }
      let a = process.env;
      return e && e.processEnv != null && (a = e.processEnv), Q.populate(a, s3, e), o3 ? { parsed: s3, error: o3 } : { parsed: s3 };
    }
    function pc(e) {
      if (os2(e).length === 0)
        return Q.configDotenv(e);
      let t3 = ss(e);
      return t3 ? Q._configVault(e) : (ac(`You set DOTENV_KEY but you are missing a .env.vault file at ${t3}. Did you forget to build it?`), Q.configDotenv(e));
    }
    function dc(e, t3) {
      let r = Buffer.from(t3.slice(-64), "hex"), n3 = Buffer.from(e, "base64"), i3 = n3.subarray(0, 12), o3 = n3.subarray(-16);
      n3 = n3.subarray(12, -16);
      try {
        let s3 = tc.createDecipheriv("aes-256-gcm", r, i3);
        return s3.setAuthTag(o3), `${s3.update(n3)}${s3.final()}`;
      } catch (s3) {
        let a = s3 instanceof RangeError, l3 = s3.message === "Invalid key length", u3 = s3.message === "Unsupported state or unable to authenticate data";
        if (a || l3) {
          let c3 = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          throw c3.code = "INVALID_DOTENV_KEY", c3;
        } else if (u3) {
          let c3 = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          throw c3.code = "DECRYPTION_FAILED", c3;
        } else
          throw s3;
      }
    }
    function mc(e, t3, r = {}) {
      let n3 = !!(r && r.debug), i3 = !!(r && r.override);
      if (typeof t3 != "object") {
        let o3 = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        throw o3.code = "OBJECT_REQUIRED", o3;
      }
      for (let o3 of Object.keys(t3))
        Object.prototype.hasOwnProperty.call(e, o3) ? (i3 === true && (e[o3] = t3[o3]), n3 && Wr(i3 === true ? `"${o3}" is already defined and WAS overwritten` : `"${o3}" is already defined and was NOT overwritten`)) : e[o3] = t3[o3];
    }
    var Q = { configDotenv: cc, _configVault: uc, _parseVault: oc, config: pc, decrypt: dc, parse: ic, populate: mc };
    Le.exports.configDotenv = Q.configDotenv;
    Le.exports._configVault = Q._configVault;
    Le.exports._parseVault = Q._parseVault;
    Le.exports.config = Q.config;
    Le.exports.decrypt = Q.decrypt;
    Le.exports.parse = Q.parse;
    Le.exports.populate = Q.populate;
    Le.exports = Q;
  });
  var ms = Z((ig, ds) => {
    ds.exports = (e) => {
      let t3 = e.match(/^[ \t]*(?=\S)/gm);
      return t3 ? t3.reduce((r, n3) => Math.min(r, n3.length), 1 / 0) : 0;
    };
  });
  var gs = Z((og, fs2) => {
    var yc = ms();
    fs2.exports = (e) => {
      let t3 = yc(e);
      if (t3 === 0)
        return e;
      let r = new RegExp(`^[ \\t]{${t3}}`, "gm");
      return e.replace(r, "");
    };
  });
  var bi = Z((pg, hs) => {
    hs.exports = (e, t3 = 1, r) => {
      if (r = { indent: " ", includeEmptyLines: false, ...r }, typeof e != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
      if (typeof t3 != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t3}\``);
      if (typeof r.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);
      if (t3 === 0)
        return e;
      let n3 = r.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e.replace(n3, r.indent.repeat(t3));
    };
  });
  var ws = Z((fg, bs) => {
    bs.exports = ({ onlyFirst: e = false } = {}) => {
      let t3 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(t3, e ? undefined : "g");
    };
  });
  var Pi = Z((gg, xs) => {
    var Rc = ws();
    xs.exports = (e) => typeof e == "string" ? e.replace(Rc(), "") : e;
  });
  var vs = Z((Eg, zr) => {
    zr.exports = (e = {}) => {
      let t3;
      if (e.repoUrl)
        t3 = e.repoUrl;
      else if (e.user && e.repo)
        t3 = `https://github.com/${e.user}/${e.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let r = new URL(`${t3}/issues/new`), n3 = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i3 of n3) {
        let o3 = e[i3];
        if (o3 !== undefined) {
          if (i3 === "labels" || i3 === "projects") {
            if (!Array.isArray(o3))
              throw new TypeError(`The \`${i3}\` option should be an array`);
            o3 = o3.join(",");
          }
          r.searchParams.set(i3, o3);
        }
      }
      return r.toString();
    };
    zr.exports.default = zr.exports;
  });
  var _i = Z((Sh, Qs) => {
    Qs.exports = function() {
      function e(t3, r, n3, i3, o3) {
        return t3 < r || n3 < r ? t3 > n3 ? n3 + 1 : t3 + 1 : i3 === o3 ? r : r + 1;
      }
      return function(t3, r) {
        if (t3 === r)
          return 0;
        if (t3.length > r.length) {
          var n3 = t3;
          t3 = r, r = n3;
        }
        for (var i3 = t3.length, o3 = r.length;i3 > 0 && t3.charCodeAt(i3 - 1) === r.charCodeAt(o3 - 1); )
          i3--, o3--;
        for (var s3 = 0;s3 < i3 && t3.charCodeAt(s3) === r.charCodeAt(s3); )
          s3++;
        if (i3 -= s3, o3 -= s3, i3 === 0 || o3 < 3)
          return o3;
        var a = 0, l3, u3, c3, p, d3, f3, g, h, O, P, C4, R, k = [];
        for (l3 = 0;l3 < i3; l3++)
          k.push(l3 + 1), k.push(t3.charCodeAt(s3 + l3));
        for (var A = k.length - 1;a < o3 - 3; )
          for (O = r.charCodeAt(s3 + (u3 = a)), P = r.charCodeAt(s3 + (c3 = a + 1)), C4 = r.charCodeAt(s3 + (p = a + 2)), R = r.charCodeAt(s3 + (d3 = a + 3)), f3 = a += 4, l3 = 0;l3 < A; l3 += 2)
            g = k[l3], h = k[l3 + 1], u3 = e(g, u3, c3, O, h), c3 = e(u3, c3, p, P, h), p = e(c3, p, d3, C4, h), f3 = e(p, d3, f3, R, h), k[l3] = f3, d3 = p, p = c3, c3 = u3, u3 = g;
        for (;a < o3; )
          for (O = r.charCodeAt(s3 + (u3 = a)), f3 = ++a, l3 = 0;l3 < A; l3 += 2)
            g = k[l3], k[l3] = f3 = e(g, u3, f3, O, k[l3 + 1]), u3 = g;
        return f3;
      };
    }();
  });
  var Bm = {};
  Bt(Bm, { Debug: () => Jn, Decimal: () => ve, Extensions: () => Bn, MetricsClient: () => Ot, PrismaClientInitializationError: () => T3, PrismaClientKnownRequestError: () => ee, PrismaClientRustPanicError: () => ce, PrismaClientUnknownRequestError: () => B, PrismaClientValidationError: () => te, Public: () => Un, Sql: () => ae, defineDmmfProperty: () => ga, deserializeJsonResponse: () => bt, deserializeRawResult: () => qn, dmmfToRuntimeDataModel: () => fa, empty: () => ba, getPrismaClient: () => Xl, getRuntime: () => In, join: () => Ea, makeStrictEnum: () => eu, makeTypedQueryFactory: () => ha, objectEnumValues: () => yn, raw: () => Gi, serializeJsonQuery: () => Pn, skip: () => vn, sqltag: () => Ji, warnEnvConflicts: () => tu, warnOnce: () => tr });
  module.exports = au(Bm);
  var Bn = {};
  Bt(Bn, { defineExtension: () => xo, getExtensionContext: () => vo });
  var Un = {};
  Bt(Un, { validator: () => Po });
  var Mr = {};
  Bt(Mr, { $: () => Ao, bgBlack: () => yu, bgBlue: () => xu, bgCyan: () => Pu, bgGreen: () => bu, bgMagenta: () => vu, bgRed: () => Eu, bgWhite: () => Tu, bgYellow: () => wu, black: () => mu, blue: () => rt, bold: () => W, cyan: () => _e, dim: () => ke, gray: () => Ut, green: () => Ve, grey: () => hu, hidden: () => pu, inverse: () => cu, italic: () => uu, magenta: () => fu, red: () => de, reset: () => lu, strikethrough: () => du, underline: () => X, white: () => gu, yellow: () => De });
  var Qn;
  var To;
  var Ro;
  var Co;
  var So = true;
  typeof process < "u" && ({ FORCE_COLOR: Qn, NODE_DISABLE_COLORS: To, NO_COLOR: Ro, TERM: Co } = process.env || {}, So = process.stdout && process.stdout.isTTY);
  var Ao = { enabled: !To && Ro == null && Co !== "dumb" && (Qn != null && Qn !== "0" || So) };
  var lu = $(0, 0);
  var W = $(1, 22);
  var ke = $(2, 22);
  var uu = $(3, 23);
  var X = $(4, 24);
  var cu = $(7, 27);
  var pu = $(8, 28);
  var du = $(9, 29);
  var mu = $(30, 39);
  var de = $(31, 39);
  var Ve = $(32, 39);
  var De = $(33, 39);
  var rt = $(34, 39);
  var fu = $(35, 39);
  var _e = $(36, 39);
  var gu = $(37, 39);
  var Ut = $(90, 39);
  var hu = $(90, 39);
  var yu = $(40, 49);
  var Eu = $(41, 49);
  var bu = $(42, 49);
  var wu = $(43, 49);
  var xu = $(44, 49);
  var vu = $(45, 49);
  var Pu = $(46, 49);
  var Tu = $(47, 49);
  var Ru = 100;
  var Io = ["green", "yellow", "blue", "magenta", "cyan", "red"];
  var Qt = [];
  var Oo = Date.now();
  var Cu = 0;
  var Gn = typeof process < "u" ? process.env : {};
  globalThis.DEBUG ??= Gn.DEBUG ?? "";
  globalThis.DEBUG_COLORS ??= Gn.DEBUG_COLORS ? Gn.DEBUG_COLORS === "true" : true;
  var Gt = { enable(e) {
    typeof e == "string" && (globalThis.DEBUG = e);
  }, disable() {
    let e = globalThis.DEBUG;
    return globalThis.DEBUG = "", e;
  }, enabled(e) {
    let t3 = globalThis.DEBUG.split(",").map((i3) => i3.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), r = t3.some((i3) => i3 === "" || i3[0] === "-" ? false : e.match(RegExp(i3.split("*").join(".*") + "$"))), n3 = t3.some((i3) => i3 === "" || i3[0] !== "-" ? false : e.match(RegExp(i3.slice(1).split("*").join(".*") + "$")));
    return r && !n3;
  }, log: (...e) => {
    let [t3, r, ...n3] = e;
    (console.warn ?? console.log)(`${t3} ${r}`, ...n3);
  }, formatters: {} };
  var Jn = new Proxy(Su, { get: (e, t3) => Gt[t3], set: (e, t3, r) => Gt[t3] = r });
  var F = Jn;
  var _o = D(import.meta.require("fs"));
  var Wn = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
  var $r = "libquery_engine";
  var Mo = D(import.meta.require("child_process"));
  var Xn = D(import.meta.require("fs/promises"));
  var Qr = D(import.meta.require("os"));
  var Ne = Symbol.for("@ts-pattern/matcher");
  var Iu = Symbol.for("@ts-pattern/isVariadic");
  var jr = "@ts-pattern/anonymous-select-key";
  var Kn = (e) => !!(e && typeof e == "object");
  var Vr = (e) => e && !!e[Ne];
  var we = (e, t3, r) => {
    if (Vr(e)) {
      let n3 = e[Ne](), { matched: i3, selections: o3 } = n3.match(t3);
      return i3 && o3 && Object.keys(o3).forEach((s3) => r(s3, o3[s3])), i3;
    }
    if (Kn(e)) {
      if (!Kn(t3))
        return false;
      if (Array.isArray(e)) {
        if (!Array.isArray(t3))
          return false;
        let n3 = [], i3 = [], o3 = [];
        for (let s3 of e.keys()) {
          let a = e[s3];
          Vr(a) && a[Iu] ? o3.push(a) : o3.length ? i3.push(a) : n3.push(a);
        }
        if (o3.length) {
          if (o3.length > 1)
            throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
          if (t3.length < n3.length + i3.length)
            return false;
          let s3 = t3.slice(0, n3.length), a = i3.length === 0 ? [] : t3.slice(-i3.length), l3 = t3.slice(n3.length, i3.length === 0 ? 1 / 0 : -i3.length);
          return n3.every((u3, c3) => we(u3, s3[c3], r)) && i3.every((u3, c3) => we(u3, a[c3], r)) && (o3.length === 0 || we(o3[0], l3, r));
        }
        return e.length === t3.length && e.every((s3, a) => we(s3, t3[a], r));
      }
      return Reflect.ownKeys(e).every((n3) => {
        let i3 = e[n3];
        return ((n3 in t3) || Vr(o3 = i3) && o3[Ne]().matcherType === "optional") && we(i3, t3[n3], r);
        var o3;
      });
    }
    return Object.is(t3, e);
  };
  var Ge = (e) => {
    var t3, r, n3;
    return Kn(e) ? Vr(e) ? (t3 = (r = (n3 = e[Ne]()).getSelectionKeys) == null ? undefined : r.call(n3)) != null ? t3 : [] : Array.isArray(e) ? Jt(e, Ge) : Jt(Object.values(e), Ge) : [];
  };
  var Jt = (e, t3) => e.reduce((r, n3) => r.concat(t3(n3)), []);
  var tf = me(I(function(e) {
    return true;
  }));
  var Ue = (e) => Object.assign(me(e), { startsWith: (t3) => {
    return Ue(j(e, (r = t3, I((n3) => je(n3) && n3.startsWith(r)))));
    var r;
  }, endsWith: (t3) => {
    return Ue(j(e, (r = t3, I((n3) => je(n3) && n3.endsWith(r)))));
    var r;
  }, minLength: (t3) => Ue(j(e, ((r) => I((n3) => je(n3) && n3.length >= r))(t3))), length: (t3) => Ue(j(e, ((r) => I((n3) => je(n3) && n3.length === r))(t3))), maxLength: (t3) => Ue(j(e, ((r) => I((n3) => je(n3) && n3.length <= r))(t3))), includes: (t3) => {
    return Ue(j(e, (r = t3, I((n3) => je(n3) && n3.includes(r)))));
    var r;
  }, regex: (t3) => {
    return Ue(j(e, (r = t3, I((n3) => je(n3) && !!n3.match(r)))));
    var r;
  } });
  var rf = Ue(I(je));
  var be = (e) => Object.assign(me(e), { between: (t3, r) => be(j(e, ((n3, i3) => I((o3) => Ee(o3) && n3 <= o3 && i3 >= o3))(t3, r))), lt: (t3) => be(j(e, ((r) => I((n3) => Ee(n3) && n3 < r))(t3))), gt: (t3) => be(j(e, ((r) => I((n3) => Ee(n3) && n3 > r))(t3))), lte: (t3) => be(j(e, ((r) => I((n3) => Ee(n3) && n3 <= r))(t3))), gte: (t3) => be(j(e, ((r) => I((n3) => Ee(n3) && n3 >= r))(t3))), int: () => be(j(e, I((t3) => Ee(t3) && Number.isInteger(t3)))), finite: () => be(j(e, I((t3) => Ee(t3) && Number.isFinite(t3)))), positive: () => be(j(e, I((t3) => Ee(t3) && t3 > 0))), negative: () => be(j(e, I((t3) => Ee(t3) && t3 < 0))) });
  var nf = be(I(Ee));
  var Qe = (e) => Object.assign(me(e), { between: (t3, r) => Qe(j(e, ((n3, i3) => I((o3) => Be(o3) && n3 <= o3 && i3 >= o3))(t3, r))), lt: (t3) => Qe(j(e, ((r) => I((n3) => Be(n3) && n3 < r))(t3))), gt: (t3) => Qe(j(e, ((r) => I((n3) => Be(n3) && n3 > r))(t3))), lte: (t3) => Qe(j(e, ((r) => I((n3) => Be(n3) && n3 <= r))(t3))), gte: (t3) => Qe(j(e, ((r) => I((n3) => Be(n3) && n3 >= r))(t3))), positive: () => Qe(j(e, I((t3) => Be(t3) && t3 > 0))), negative: () => Qe(j(e, I((t3) => Be(t3) && t3 < 0))) });
  var of = Qe(I(Be));
  var sf = me(I(function(e) {
    return typeof e == "boolean";
  }));
  var af = me(I(function(e) {
    return typeof e == "symbol";
  }));
  var lf = me(I(function(e) {
    return e == null;
  }));
  var uf = me(I(function(e) {
    return e != null;
  }));
  var Yn = class extends Error {
    constructor(t3) {
      let r;
      try {
        r = JSON.stringify(t3);
      } catch {
        r = t3;
      }
      super(`Pattern matching error: no pattern matches value ${r}`), this.input = undefined, this.input = t3;
    }
  };
  var zn = { matched: false, value: undefined };
  var Zn = class e {
    constructor(t3, r) {
      this.input = undefined, this.state = undefined, this.input = t3, this.state = r;
    }
    with(...t3) {
      if (this.state.matched)
        return this;
      let r = t3[t3.length - 1], n3 = [t3[0]], i3;
      t3.length === 3 && typeof t3[1] == "function" ? i3 = t3[1] : t3.length > 2 && n3.push(...t3.slice(1, t3.length - 1));
      let o3 = false, s3 = {}, a = (u3, c3) => {
        o3 = true, s3[u3] = c3;
      }, l3 = !n3.some((u3) => we(u3, this.input, a)) || i3 && !i3(this.input) ? zn : { matched: true, value: r(o3 ? jr in s3 ? s3[jr] : s3 : this.input, this.input) };
      return new e(this.input, l3);
    }
    when(t3, r) {
      if (this.state.matched)
        return this;
      let n3 = !!t3(this.input);
      return new e(this.input, n3 ? { matched: true, value: r(this.input, this.input) } : zn);
    }
    otherwise(t3) {
      return this.state.matched ? this.state.value : t3(this.input);
    }
    exhaustive() {
      if (this.state.matched)
        return this.state.value;
      throw new Yn(this.input);
    }
    run() {
      return this.exhaustive();
    }
    returnType() {
      return this;
    }
  };
  var $o = import.meta.require("util");
  var Du = { warn: De("prisma:warn") };
  var _u = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var Nu = (0, $o.promisify)(Mo.default.exec);
  var ne = F("prisma:get-platform");
  var Lu = ["1.0.x", "1.1.x", "3.0.x"];
  var Ur = {};
  var es = D(Xo());
  var zu = D(ui());
  var q = D(import.meta.require("path"));
  var Zu = D(ui());
  var jf = F("prisma:engines");
  var Bf = "libquery-engine";
  q.default.join(__dirname, "../query-engine-darwin");
  q.default.join(__dirname, "../query-engine-darwin-arm64");
  q.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  q.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  q.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
  q.default.join(__dirname, "../query-engine-linux-static-x64");
  q.default.join(__dirname, "../query-engine-linux-static-arm64");
  q.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  q.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  q.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
  q.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
  q.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
  q.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
  q.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
  q.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
  q.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  q.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  q.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  q.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
  q.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  q.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  q.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  q.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  q.default.join(__dirname, "../query_engine-windows.dll.node");
  var ci = D(import.meta.require("fs"));
  var rs = F("chmodPlusX");
  var yi = D(as());
  var Kr = D(import.meta.require("fs"));
  var gt = D(import.meta.require("path"));
  var hi = F("prisma:tryLoadEnv");
  var ps = "library";
  var zt;
  ((t3) => {
    let e;
    ((A) => (A.findUnique = "findUnique", A.findUniqueOrThrow = "findUniqueOrThrow", A.findFirst = "findFirst", A.findFirstOrThrow = "findFirstOrThrow", A.findMany = "findMany", A.create = "create", A.createMany = "createMany", A.createManyAndReturn = "createManyAndReturn", A.update = "update", A.updateMany = "updateMany", A.updateManyAndReturn = "updateManyAndReturn", A.upsert = "upsert", A.delete = "delete", A.deleteMany = "deleteMany", A.groupBy = "groupBy", A.count = "count", A.aggregate = "aggregate", A.findRaw = "findRaw", A.aggregateRaw = "aggregateRaw"))(e = t3.ModelAction ||= {});
  })(zt ||= {});
  var Zt = D(import.meta.require("path"));
  var ys = D(bi());
  var wi = class {
    constructor(t3) {
      this.config = t3;
    }
    toString() {
      let { config: t3 } = this, r = t3.provider.fromEnvVar ? `env("${t3.provider.fromEnvVar}")` : t3.provider.value, n3 = JSON.parse(JSON.stringify({ provider: r, binaryTargets: Ec(t3.binaryTargets) }));
      return `generator ${t3.name} {
${(0, ys.default)(bc(n3), 2)}
}`;
    }
  };
  var er = {};
  Bt(er, { error: () => Pc, info: () => vc, log: () => xc, query: () => Tc, should: () => Es, tags: () => Xt, warn: () => vi });
  var Xt = { error: de("prisma:error"), warn: De("prisma:warn"), info: _e("prisma:info"), query: rt("prisma:query") };
  var Es = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var Ri = (e, t3) => e.reduce((r, n3) => (r[t3(n3)] = n3, r), {});
  var Ps = new Set;
  var tr = (e, t3, ...r) => {
    Ps.has(e) || (Ps.add(e), vi(t3, ...r));
  };
  var T3 = class e extends Error {
    constructor(t3, r, n3) {
      super(t3), this.name = "PrismaClientInitializationError", this.clientVersion = r, this.errorCode = n3, Error.captureStackTrace(e);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  w(T3, "PrismaClientInitializationError");
  var ee = class extends Error {
    constructor(t3, { code: r, clientVersion: n3, meta: i3, batchRequestIdx: o3 }) {
      super(t3), this.name = "PrismaClientKnownRequestError", this.code = r, this.clientVersion = n3, this.meta = i3, Object.defineProperty(this, "batchRequestIdx", { value: o3, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  w(ee, "PrismaClientKnownRequestError");
  var ce = class extends Error {
    constructor(t3, r) {
      super(t3), this.name = "PrismaClientRustPanicError", this.clientVersion = r;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  w(ce, "PrismaClientRustPanicError");
  var B = class extends Error {
    constructor(t3, { clientVersion: r, batchRequestIdx: n3 }) {
      super(t3), this.name = "PrismaClientUnknownRequestError", this.clientVersion = r, Object.defineProperty(this, "batchRequestIdx", { value: n3, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  w(B, "PrismaClientUnknownRequestError");
  var te = class extends Error {
    constructor(r, { clientVersion: n3 }) {
      super(r);
      this.name = "PrismaClientValidationError";
      this.clientVersion = n3;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  w(te, "PrismaClientValidationError");
  var yt = 9000000000000000;
  var Ye = 1e9;
  var Si = "0123456789abcdef";
  var en = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var tn = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var Ai = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -yt, maxE: yt, crypto: false };
  var Ss;
  var Me;
  var b = true;
  var nn = "[DecimalError] ";
  var Ke = nn + "Invalid argument: ";
  var As = nn + "Precision limit exceeded";
  var Is = nn + "crypto unavailable";
  var Os = "[object Decimal]";
  var re = Math.floor;
  var G = Math.pow;
  var Cc = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var Sc = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var Ac = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var ks = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var he = 1e7;
  var E = 7;
  var Ic = 9007199254740991;
  var Oc = en.length - 1;
  var Ii = tn.length - 1;
  var m3 = { toStringTag: Os };
  m3.absoluteValue = m3.abs = function() {
    var e = new this.constructor(this);
    return e.s < 0 && (e.s = 1), y3(e);
  };
  m3.ceil = function() {
    return y3(new this.constructor(this), this.e + 1, 2);
  };
  m3.clampedTo = m3.clamp = function(e, t3) {
    var r, n3 = this, i3 = n3.constructor;
    if (e = new i3(e), t3 = new i3(t3), !e.s || !t3.s)
      return new i3(NaN);
    if (e.gt(t3))
      throw Error(Ke + t3);
    return r = n3.cmp(e), r < 0 ? e : n3.cmp(t3) > 0 ? t3 : new i3(n3);
  };
  m3.comparedTo = m3.cmp = function(e) {
    var t3, r, n3, i3, o3 = this, s3 = o3.d, a = (e = new o3.constructor(e)).d, l3 = o3.s, u3 = e.s;
    if (!s3 || !a)
      return !l3 || !u3 ? NaN : l3 !== u3 ? l3 : s3 === a ? 0 : !s3 ^ l3 < 0 ? 1 : -1;
    if (!s3[0] || !a[0])
      return s3[0] ? l3 : a[0] ? -u3 : 0;
    if (l3 !== u3)
      return l3;
    if (o3.e !== e.e)
      return o3.e > e.e ^ l3 < 0 ? 1 : -1;
    for (n3 = s3.length, i3 = a.length, t3 = 0, r = n3 < i3 ? n3 : i3;t3 < r; ++t3)
      if (s3[t3] !== a[t3])
        return s3[t3] > a[t3] ^ l3 < 0 ? 1 : -1;
    return n3 === i3 ? 0 : n3 > i3 ^ l3 < 0 ? 1 : -1;
  };
  m3.cosine = m3.cos = function() {
    var e, t3, r = this, n3 = r.constructor;
    return r.d ? r.d[0] ? (e = n3.precision, t3 = n3.rounding, n3.precision = e + Math.max(r.e, r.sd()) + E, n3.rounding = 1, r = kc(n3, Fs(n3, r)), n3.precision = e, n3.rounding = t3, y3(Me == 2 || Me == 3 ? r.neg() : r, e, t3, true)) : new n3(1) : new n3(NaN);
  };
  m3.cubeRoot = m3.cbrt = function() {
    var e, t3, r, n3, i3, o3, s3, a, l3, u3, c3 = this, p = c3.constructor;
    if (!c3.isFinite() || c3.isZero())
      return new p(c3);
    for (b = false, o3 = c3.s * G(c3.s * c3, 1 / 3), !o3 || Math.abs(o3) == 1 / 0 ? (r = K(c3.d), e = c3.e, (o3 = (e - r.length + 1) % 3) && (r += o3 == 1 || o3 == -2 ? "0" : "00"), o3 = G(r, 1 / 3), e = re((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o3 == 1 / 0 ? r = "5e" + e : (r = o3.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n3 = new p(r), n3.s = c3.s) : n3 = new p(o3.toString()), s3 = (e = p.precision) + 3;; )
      if (a = n3, l3 = a.times(a).times(a), u3 = l3.plus(c3), n3 = M(u3.plus(c3).times(a), u3.plus(l3), s3 + 2, 1), K(a.d).slice(0, s3) === (r = K(n3.d)).slice(0, s3))
        if (r = r.slice(s3 - 3, s3 + 1), r == "9999" || !i3 && r == "4999") {
          if (!i3 && (y3(a, e + 1, 0), a.times(a).times(a).eq(c3))) {
            n3 = a;
            break;
          }
          s3 += 4, i3 = 1;
        } else {
          (!+r || !+r.slice(1) && r.charAt(0) == "5") && (y3(n3, e + 1, 1), t3 = !n3.times(n3).times(n3).eq(c3));
          break;
        }
    return b = true, y3(n3, e, p.rounding, t3);
  };
  m3.decimalPlaces = m3.dp = function() {
    var e, t3 = this.d, r = NaN;
    if (t3) {
      if (e = t3.length - 1, r = (e - re(this.e / E)) * E, e = t3[e], e)
        for (;e % 10 == 0; e /= 10)
          r--;
      r < 0 && (r = 0);
    }
    return r;
  };
  m3.dividedBy = m3.div = function(e) {
    return M(this, new this.constructor(e));
  };
  m3.dividedToIntegerBy = m3.divToInt = function(e) {
    var t3 = this, r = t3.constructor;
    return y3(M(t3, new r(e), 0, 1, 1), r.precision, r.rounding);
  };
  m3.equals = m3.eq = function(e) {
    return this.cmp(e) === 0;
  };
  m3.floor = function() {
    return y3(new this.constructor(this), this.e + 1, 3);
  };
  m3.greaterThan = m3.gt = function(e) {
    return this.cmp(e) > 0;
  };
  m3.greaterThanOrEqualTo = m3.gte = function(e) {
    var t3 = this.cmp(e);
    return t3 == 1 || t3 === 0;
  };
  m3.hyperbolicCosine = m3.cosh = function() {
    var e, t3, r, n3, i3, o3 = this, s3 = o3.constructor, a = new s3(1);
    if (!o3.isFinite())
      return new s3(o3.s ? 1 / 0 : NaN);
    if (o3.isZero())
      return a;
    r = s3.precision, n3 = s3.rounding, s3.precision = r + Math.max(o3.e, o3.sd()) + 4, s3.rounding = 1, i3 = o3.d.length, i3 < 32 ? (e = Math.ceil(i3 / 3), t3 = (1 / sn(4, e)).toString()) : (e = 16, t3 = "2.3283064365386962890625e-10"), o3 = Et(s3, 1, o3.times(t3), new s3(1), true);
    for (var l3, u3 = e, c3 = new s3(8);u3--; )
      l3 = o3.times(o3), o3 = a.minus(l3.times(c3.minus(l3.times(c3))));
    return y3(o3, s3.precision = r, s3.rounding = n3, true);
  };
  m3.hyperbolicSine = m3.sinh = function() {
    var e, t3, r, n3, i3 = this, o3 = i3.constructor;
    if (!i3.isFinite() || i3.isZero())
      return new o3(i3);
    if (t3 = o3.precision, r = o3.rounding, o3.precision = t3 + Math.max(i3.e, i3.sd()) + 4, o3.rounding = 1, n3 = i3.d.length, n3 < 3)
      i3 = Et(o3, 2, i3, i3, true);
    else {
      e = 1.4 * Math.sqrt(n3), e = e > 16 ? 16 : e | 0, i3 = i3.times(1 / sn(5, e)), i3 = Et(o3, 2, i3, i3, true);
      for (var s3, a = new o3(5), l3 = new o3(16), u3 = new o3(20);e--; )
        s3 = i3.times(i3), i3 = i3.times(a.plus(s3.times(l3.times(s3).plus(u3))));
    }
    return o3.precision = t3, o3.rounding = r, y3(i3, t3, r, true);
  };
  m3.hyperbolicTangent = m3.tanh = function() {
    var e, t3, r = this, n3 = r.constructor;
    return r.isFinite() ? r.isZero() ? new n3(r) : (e = n3.precision, t3 = n3.rounding, n3.precision = e + 7, n3.rounding = 1, M(r.sinh(), r.cosh(), n3.precision = e, n3.rounding = t3)) : new n3(r.s);
  };
  m3.inverseCosine = m3.acos = function() {
    var e, t3 = this, r = t3.constructor, n3 = t3.abs().cmp(1), i3 = r.precision, o3 = r.rounding;
    return n3 !== -1 ? n3 === 0 ? t3.isNeg() ? ge(r, i3, o3) : new r(0) : new r(NaN) : t3.isZero() ? ge(r, i3 + 4, o3).times(0.5) : (r.precision = i3 + 6, r.rounding = 1, t3 = t3.asin(), e = ge(r, i3 + 4, o3).times(0.5), r.precision = i3, r.rounding = o3, e.minus(t3));
  };
  m3.inverseHyperbolicCosine = m3.acosh = function() {
    var e, t3, r = this, n3 = r.constructor;
    return r.lte(1) ? new n3(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n3.precision, t3 = n3.rounding, n3.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n3.rounding = 1, b = false, r = r.times(r).minus(1).sqrt().plus(r), b = true, n3.precision = e, n3.rounding = t3, r.ln()) : new n3(r);
  };
  m3.inverseHyperbolicSine = m3.asinh = function() {
    var e, t3, r = this, n3 = r.constructor;
    return !r.isFinite() || r.isZero() ? new n3(r) : (e = n3.precision, t3 = n3.rounding, n3.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n3.rounding = 1, b = false, r = r.times(r).plus(1).sqrt().plus(r), b = true, n3.precision = e, n3.rounding = t3, r.ln());
  };
  m3.inverseHyperbolicTangent = m3.atanh = function() {
    var e, t3, r, n3, i3 = this, o3 = i3.constructor;
    return i3.isFinite() ? i3.e >= 0 ? new o3(i3.abs().eq(1) ? i3.s / 0 : i3.isZero() ? i3 : NaN) : (e = o3.precision, t3 = o3.rounding, n3 = i3.sd(), Math.max(n3, e) < 2 * -i3.e - 1 ? y3(new o3(i3), e, t3, true) : (o3.precision = r = n3 - i3.e, i3 = M(i3.plus(1), new o3(1).minus(i3), r + e, 1), o3.precision = e + 4, o3.rounding = 1, i3 = i3.ln(), o3.precision = e, o3.rounding = t3, i3.times(0.5))) : new o3(NaN);
  };
  m3.inverseSine = m3.asin = function() {
    var e, t3, r, n3, i3 = this, o3 = i3.constructor;
    return i3.isZero() ? new o3(i3) : (t3 = i3.abs().cmp(1), r = o3.precision, n3 = o3.rounding, t3 !== -1 ? t3 === 0 ? (e = ge(o3, r + 4, n3).times(0.5), e.s = i3.s, e) : new o3(NaN) : (o3.precision = r + 6, o3.rounding = 1, i3 = i3.div(new o3(1).minus(i3.times(i3)).sqrt().plus(1)).atan(), o3.precision = r, o3.rounding = n3, i3.times(2)));
  };
  m3.inverseTangent = m3.atan = function() {
    var e, t3, r, n3, i3, o3, s3, a, l3, u3 = this, c3 = u3.constructor, p = c3.precision, d3 = c3.rounding;
    if (u3.isFinite()) {
      if (u3.isZero())
        return new c3(u3);
      if (u3.abs().eq(1) && p + 4 <= Ii)
        return s3 = ge(c3, p + 4, d3).times(0.25), s3.s = u3.s, s3;
    } else {
      if (!u3.s)
        return new c3(NaN);
      if (p + 4 <= Ii)
        return s3 = ge(c3, p + 4, d3).times(0.5), s3.s = u3.s, s3;
    }
    for (c3.precision = a = p + 10, c3.rounding = 1, r = Math.min(28, a / E + 2 | 0), e = r;e; --e)
      u3 = u3.div(u3.times(u3).plus(1).sqrt().plus(1));
    for (b = false, t3 = Math.ceil(a / E), n3 = 1, l3 = u3.times(u3), s3 = new c3(u3), i3 = u3;e !== -1; )
      if (i3 = i3.times(l3), o3 = s3.minus(i3.div(n3 += 2)), i3 = i3.times(l3), s3 = o3.plus(i3.div(n3 += 2)), s3.d[t3] !== undefined)
        for (e = t3;s3.d[e] === o3.d[e] && e--; )
          ;
    return r && (s3 = s3.times(2 << r - 1)), b = true, y3(s3, c3.precision = p, c3.rounding = d3, true);
  };
  m3.isFinite = function() {
    return !!this.d;
  };
  m3.isInteger = m3.isInt = function() {
    return !!this.d && re(this.e / E) > this.d.length - 2;
  };
  m3.isNaN = function() {
    return !this.s;
  };
  m3.isNegative = m3.isNeg = function() {
    return this.s < 0;
  };
  m3.isPositive = m3.isPos = function() {
    return this.s > 0;
  };
  m3.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  m3.lessThan = m3.lt = function(e) {
    return this.cmp(e) < 0;
  };
  m3.lessThanOrEqualTo = m3.lte = function(e) {
    return this.cmp(e) < 1;
  };
  m3.logarithm = m3.log = function(e) {
    var t3, r, n3, i3, o3, s3, a, l3, u3 = this, c3 = u3.constructor, p = c3.precision, d3 = c3.rounding, f3 = 5;
    if (e == null)
      e = new c3(10), t3 = true;
    else {
      if (e = new c3(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1))
        return new c3(NaN);
      t3 = e.eq(10);
    }
    if (r = u3.d, u3.s < 0 || !r || !r[0] || u3.eq(1))
      return new c3(r && !r[0] ? -1 / 0 : u3.s != 1 ? NaN : r ? 0 : 1 / 0);
    if (t3)
      if (r.length > 1)
        o3 = true;
      else {
        for (i3 = r[0];i3 % 10 === 0; )
          i3 /= 10;
        o3 = i3 !== 1;
      }
    if (b = false, a = p + f3, s3 = We(u3, a), n3 = t3 ? rn(c3, a + 10) : We(e, a), l3 = M(s3, n3, a, 1), rr(l3.d, i3 = p, d3))
      do
        if (a += 10, s3 = We(u3, a), n3 = t3 ? rn(c3, a + 10) : We(e, a), l3 = M(s3, n3, a, 1), !o3) {
          +K(l3.d).slice(i3 + 1, i3 + 15) + 1 == 100000000000000 && (l3 = y3(l3, p + 1, 0));
          break;
        }
      while (rr(l3.d, i3 += 10, d3));
    return b = true, y3(l3, p, d3);
  };
  m3.minus = m3.sub = function(e) {
    var t3, r, n3, i3, o3, s3, a, l3, u3, c3, p, d3, f3 = this, g = f3.constructor;
    if (e = new g(e), !f3.d || !e.d)
      return !f3.s || !e.s ? e = new g(NaN) : f3.d ? e.s = -e.s : e = new g(e.d || f3.s !== e.s ? f3 : NaN), e;
    if (f3.s != e.s)
      return e.s = -e.s, f3.plus(e);
    if (u3 = f3.d, d3 = e.d, a = g.precision, l3 = g.rounding, !u3[0] || !d3[0]) {
      if (d3[0])
        e.s = -e.s;
      else if (u3[0])
        e = new g(f3);
      else
        return new g(l3 === 3 ? -0 : 0);
      return b ? y3(e, a, l3) : e;
    }
    if (r = re(e.e / E), c3 = re(f3.e / E), u3 = u3.slice(), o3 = c3 - r, o3) {
      for (p = o3 < 0, p ? (t3 = u3, o3 = -o3, s3 = d3.length) : (t3 = d3, r = c3, s3 = u3.length), n3 = Math.max(Math.ceil(a / E), s3) + 2, o3 > n3 && (o3 = n3, t3.length = 1), t3.reverse(), n3 = o3;n3--; )
        t3.push(0);
      t3.reverse();
    } else {
      for (n3 = u3.length, s3 = d3.length, p = n3 < s3, p && (s3 = n3), n3 = 0;n3 < s3; n3++)
        if (u3[n3] != d3[n3]) {
          p = u3[n3] < d3[n3];
          break;
        }
      o3 = 0;
    }
    for (p && (t3 = u3, u3 = d3, d3 = t3, e.s = -e.s), s3 = u3.length, n3 = d3.length - s3;n3 > 0; --n3)
      u3[s3++] = 0;
    for (n3 = d3.length;n3 > o3; ) {
      if (u3[--n3] < d3[n3]) {
        for (i3 = n3;i3 && u3[--i3] === 0; )
          u3[i3] = he - 1;
        --u3[i3], u3[n3] += he;
      }
      u3[n3] -= d3[n3];
    }
    for (;u3[--s3] === 0; )
      u3.pop();
    for (;u3[0] === 0; u3.shift())
      --r;
    return u3[0] ? (e.d = u3, e.e = on(u3, r), b ? y3(e, a, l3) : e) : new g(l3 === 3 ? -0 : 0);
  };
  m3.modulo = m3.mod = function(e) {
    var t3, r = this, n3 = r.constructor;
    return e = new n3(e), !r.d || !e.s || e.d && !e.d[0] ? new n3(NaN) : !e.d || r.d && !r.d[0] ? y3(new n3(r), n3.precision, n3.rounding) : (b = false, n3.modulo == 9 ? (t3 = M(r, e.abs(), 0, 3, 1), t3.s *= e.s) : t3 = M(r, e, 0, n3.modulo, 1), t3 = t3.times(e), b = true, r.minus(t3));
  };
  m3.naturalExponential = m3.exp = function() {
    return Oi(this);
  };
  m3.naturalLogarithm = m3.ln = function() {
    return We(this);
  };
  m3.negated = m3.neg = function() {
    var e = new this.constructor(this);
    return e.s = -e.s, y3(e);
  };
  m3.plus = m3.add = function(e) {
    var t3, r, n3, i3, o3, s3, a, l3, u3, c3, p = this, d3 = p.constructor;
    if (e = new d3(e), !p.d || !e.d)
      return !p.s || !e.s ? e = new d3(NaN) : p.d || (e = new d3(e.d || p.s === e.s ? p : NaN)), e;
    if (p.s != e.s)
      return e.s = -e.s, p.minus(e);
    if (u3 = p.d, c3 = e.d, a = d3.precision, l3 = d3.rounding, !u3[0] || !c3[0])
      return c3[0] || (e = new d3(p)), b ? y3(e, a, l3) : e;
    if (o3 = re(p.e / E), n3 = re(e.e / E), u3 = u3.slice(), i3 = o3 - n3, i3) {
      for (i3 < 0 ? (r = u3, i3 = -i3, s3 = c3.length) : (r = c3, n3 = o3, s3 = u3.length), o3 = Math.ceil(a / E), s3 = o3 > s3 ? o3 + 1 : s3 + 1, i3 > s3 && (i3 = s3, r.length = 1), r.reverse();i3--; )
        r.push(0);
      r.reverse();
    }
    for (s3 = u3.length, i3 = c3.length, s3 - i3 < 0 && (i3 = s3, r = c3, c3 = u3, u3 = r), t3 = 0;i3; )
      t3 = (u3[--i3] = u3[i3] + c3[i3] + t3) / he | 0, u3[i3] %= he;
    for (t3 && (u3.unshift(t3), ++n3), s3 = u3.length;u3[--s3] == 0; )
      u3.pop();
    return e.d = u3, e.e = on(u3, n3), b ? y3(e, a, l3) : e;
  };
  m3.precision = m3.sd = function(e) {
    var t3, r = this;
    if (e !== undefined && e !== !!e && e !== 1 && e !== 0)
      throw Error(Ke + e);
    return r.d ? (t3 = Ds(r.d), e && r.e + 1 > t3 && (t3 = r.e + 1)) : t3 = NaN, t3;
  };
  m3.round = function() {
    var e = this, t3 = e.constructor;
    return y3(new t3(e), e.e + 1, t3.rounding);
  };
  m3.sine = m3.sin = function() {
    var e, t3, r = this, n3 = r.constructor;
    return r.isFinite() ? r.isZero() ? new n3(r) : (e = n3.precision, t3 = n3.rounding, n3.precision = e + Math.max(r.e, r.sd()) + E, n3.rounding = 1, r = _c(n3, Fs(n3, r)), n3.precision = e, n3.rounding = t3, y3(Me > 2 ? r.neg() : r, e, t3, true)) : new n3(NaN);
  };
  m3.squareRoot = m3.sqrt = function() {
    var e, t3, r, n3, i3, o3, s3 = this, a = s3.d, l3 = s3.e, u3 = s3.s, c3 = s3.constructor;
    if (u3 !== 1 || !a || !a[0])
      return new c3(!u3 || u3 < 0 && (!a || a[0]) ? NaN : a ? s3 : 1 / 0);
    for (b = false, u3 = Math.sqrt(+s3), u3 == 0 || u3 == 1 / 0 ? (t3 = K(a), (t3.length + l3) % 2 == 0 && (t3 += "0"), u3 = Math.sqrt(t3), l3 = re((l3 + 1) / 2) - (l3 < 0 || l3 % 2), u3 == 1 / 0 ? t3 = "5e" + l3 : (t3 = u3.toExponential(), t3 = t3.slice(0, t3.indexOf("e") + 1) + l3), n3 = new c3(t3)) : n3 = new c3(u3.toString()), r = (l3 = c3.precision) + 3;; )
      if (o3 = n3, n3 = o3.plus(M(s3, o3, r + 2, 1)).times(0.5), K(o3.d).slice(0, r) === (t3 = K(n3.d)).slice(0, r))
        if (t3 = t3.slice(r - 3, r + 1), t3 == "9999" || !i3 && t3 == "4999") {
          if (!i3 && (y3(o3, l3 + 1, 0), o3.times(o3).eq(s3))) {
            n3 = o3;
            break;
          }
          r += 4, i3 = 1;
        } else {
          (!+t3 || !+t3.slice(1) && t3.charAt(0) == "5") && (y3(n3, l3 + 1, 1), e = !n3.times(n3).eq(s3));
          break;
        }
    return b = true, y3(n3, l3, c3.rounding, e);
  };
  m3.tangent = m3.tan = function() {
    var e, t3, r = this, n3 = r.constructor;
    return r.isFinite() ? r.isZero() ? new n3(r) : (e = n3.precision, t3 = n3.rounding, n3.precision = e + 10, n3.rounding = 1, r = r.sin(), r.s = 1, r = M(r, new n3(1).minus(r.times(r)).sqrt(), e + 10, 0), n3.precision = e, n3.rounding = t3, y3(Me == 2 || Me == 4 ? r.neg() : r, e, t3, true)) : new n3(NaN);
  };
  m3.times = m3.mul = function(e) {
    var t3, r, n3, i3, o3, s3, a, l3, u3, c3 = this, p = c3.constructor, d3 = c3.d, f3 = (e = new p(e)).d;
    if (e.s *= c3.s, !d3 || !d3[0] || !f3 || !f3[0])
      return new p(!e.s || d3 && !d3[0] && !f3 || f3 && !f3[0] && !d3 ? NaN : !d3 || !f3 ? e.s / 0 : e.s * 0);
    for (r = re(c3.e / E) + re(e.e / E), l3 = d3.length, u3 = f3.length, l3 < u3 && (o3 = d3, d3 = f3, f3 = o3, s3 = l3, l3 = u3, u3 = s3), o3 = [], s3 = l3 + u3, n3 = s3;n3--; )
      o3.push(0);
    for (n3 = u3;--n3 >= 0; ) {
      for (t3 = 0, i3 = l3 + n3;i3 > n3; )
        a = o3[i3] + f3[n3] * d3[i3 - n3 - 1] + t3, o3[i3--] = a % he | 0, t3 = a / he | 0;
      o3[i3] = (o3[i3] + t3) % he | 0;
    }
    for (;!o3[--s3]; )
      o3.pop();
    return t3 ? ++r : o3.shift(), e.d = o3, e.e = on(o3, r), b ? y3(e, p.precision, p.rounding) : e;
  };
  m3.toBinary = function(e, t3) {
    return Di(this, 2, e, t3);
  };
  m3.toDecimalPlaces = m3.toDP = function(e, t3) {
    var r = this, n3 = r.constructor;
    return r = new n3(r), e === undefined ? r : (se(e, 0, Ye), t3 === undefined ? t3 = n3.rounding : se(t3, 0, 8), y3(r, e + r.e + 1, t3));
  };
  m3.toExponential = function(e, t3) {
    var r, n3 = this, i3 = n3.constructor;
    return e === undefined ? r = xe(n3, true) : (se(e, 0, Ye), t3 === undefined ? t3 = i3.rounding : se(t3, 0, 8), n3 = y3(new i3(n3), e + 1, t3), r = xe(n3, true, e + 1)), n3.isNeg() && !n3.isZero() ? "-" + r : r;
  };
  m3.toFixed = function(e, t3) {
    var r, n3, i3 = this, o3 = i3.constructor;
    return e === undefined ? r = xe(i3) : (se(e, 0, Ye), t3 === undefined ? t3 = o3.rounding : se(t3, 0, 8), n3 = y3(new o3(i3), e + i3.e + 1, t3), r = xe(n3, false, e + n3.e + 1)), i3.isNeg() && !i3.isZero() ? "-" + r : r;
  };
  m3.toFraction = function(e) {
    var t3, r, n3, i3, o3, s3, a, l3, u3, c3, p, d3, f3 = this, g = f3.d, h = f3.constructor;
    if (!g)
      return new h(f3);
    if (u3 = r = new h(1), n3 = l3 = new h(0), t3 = new h(n3), o3 = t3.e = Ds(g) - f3.e - 1, s3 = o3 % E, t3.d[0] = G(10, s3 < 0 ? E + s3 : s3), e == null)
      e = o3 > 0 ? t3 : u3;
    else {
      if (a = new h(e), !a.isInt() || a.lt(u3))
        throw Error(Ke + a);
      e = a.gt(t3) ? o3 > 0 ? t3 : u3 : a;
    }
    for (b = false, a = new h(K(g)), c3 = h.precision, h.precision = o3 = g.length * E * 2;p = M(a, t3, 0, 1, 1), i3 = r.plus(p.times(n3)), i3.cmp(e) != 1; )
      r = n3, n3 = i3, i3 = u3, u3 = l3.plus(p.times(i3)), l3 = i3, i3 = t3, t3 = a.minus(p.times(i3)), a = i3;
    return i3 = M(e.minus(r), n3, 0, 1, 1), l3 = l3.plus(i3.times(u3)), r = r.plus(i3.times(n3)), l3.s = u3.s = f3.s, d3 = M(u3, n3, o3, 1).minus(f3).abs().cmp(M(l3, r, o3, 1).minus(f3).abs()) < 1 ? [u3, n3] : [l3, r], h.precision = c3, b = true, d3;
  };
  m3.toHexadecimal = m3.toHex = function(e, t3) {
    return Di(this, 16, e, t3);
  };
  m3.toNearest = function(e, t3) {
    var r = this, n3 = r.constructor;
    if (r = new n3(r), e == null) {
      if (!r.d)
        return r;
      e = new n3(1), t3 = n3.rounding;
    } else {
      if (e = new n3(e), t3 === undefined ? t3 = n3.rounding : se(t3, 0, 8), !r.d)
        return e.s ? r : e;
      if (!e.d)
        return e.s && (e.s = r.s), e;
    }
    return e.d[0] ? (b = false, r = M(r, e, 0, t3, 1).times(e), b = true, y3(r)) : (e.s = r.s, r = e), r;
  };
  m3.toNumber = function() {
    return +this;
  };
  m3.toOctal = function(e, t3) {
    return Di(this, 8, e, t3);
  };
  m3.toPower = m3.pow = function(e) {
    var t3, r, n3, i3, o3, s3, a = this, l3 = a.constructor, u3 = +(e = new l3(e));
    if (!a.d || !e.d || !a.d[0] || !e.d[0])
      return new l3(G(+a, u3));
    if (a = new l3(a), a.eq(1))
      return a;
    if (n3 = l3.precision, o3 = l3.rounding, e.eq(1))
      return y3(a, n3, o3);
    if (t3 = re(e.e / E), t3 >= e.d.length - 1 && (r = u3 < 0 ? -u3 : u3) <= Ic)
      return i3 = _s(l3, a, r, n3), e.s < 0 ? new l3(1).div(i3) : y3(i3, n3, o3);
    if (s3 = a.s, s3 < 0) {
      if (t3 < e.d.length - 1)
        return new l3(NaN);
      if (e.d[t3] & 1 || (s3 = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
        return a.s = s3, a;
    }
    return r = G(+a, u3), t3 = r == 0 || !isFinite(r) ? re(u3 * (Math.log("0." + K(a.d)) / Math.LN10 + a.e + 1)) : new l3(r + "").e, t3 > l3.maxE + 1 || t3 < l3.minE - 1 ? new l3(t3 > 0 ? s3 / 0 : 0) : (b = false, l3.rounding = a.s = 1, r = Math.min(12, (t3 + "").length), i3 = Oi(e.times(We(a, n3 + r)), n3), i3.d && (i3 = y3(i3, n3 + 5, 1), rr(i3.d, n3, o3) && (t3 = n3 + 10, i3 = y3(Oi(e.times(We(a, t3 + r)), t3), t3 + 5, 1), +K(i3.d).slice(n3 + 1, n3 + 15) + 1 == 100000000000000 && (i3 = y3(i3, n3 + 1, 0)))), i3.s = s3, b = true, l3.rounding = o3, y3(i3, n3, o3));
  };
  m3.toPrecision = function(e, t3) {
    var r, n3 = this, i3 = n3.constructor;
    return e === undefined ? r = xe(n3, n3.e <= i3.toExpNeg || n3.e >= i3.toExpPos) : (se(e, 1, Ye), t3 === undefined ? t3 = i3.rounding : se(t3, 0, 8), n3 = y3(new i3(n3), e, t3), r = xe(n3, e <= n3.e || n3.e <= i3.toExpNeg, e)), n3.isNeg() && !n3.isZero() ? "-" + r : r;
  };
  m3.toSignificantDigits = m3.toSD = function(e, t3) {
    var r = this, n3 = r.constructor;
    return e === undefined ? (e = n3.precision, t3 = n3.rounding) : (se(e, 1, Ye), t3 === undefined ? t3 = n3.rounding : se(t3, 0, 8)), y3(new n3(r), e, t3);
  };
  m3.toString = function() {
    var e = this, t3 = e.constructor, r = xe(e, e.e <= t3.toExpNeg || e.e >= t3.toExpPos);
    return e.isNeg() && !e.isZero() ? "-" + r : r;
  };
  m3.truncated = m3.trunc = function() {
    return y3(new this.constructor(this), this.e + 1, 1);
  };
  m3.valueOf = m3.toJSON = function() {
    var e = this, t3 = e.constructor, r = xe(e, e.e <= t3.toExpNeg || e.e >= t3.toExpPos);
    return e.isNeg() ? "-" + r : r;
  };
  var M = function() {
    function e(n3, i3, o3) {
      var s3, a = 0, l3 = n3.length;
      for (n3 = n3.slice();l3--; )
        s3 = n3[l3] * i3 + a, n3[l3] = s3 % o3 | 0, a = s3 / o3 | 0;
      return a && n3.unshift(a), n3;
    }
    function t3(n3, i3, o3, s3) {
      var a, l3;
      if (o3 != s3)
        l3 = o3 > s3 ? 1 : -1;
      else
        for (a = l3 = 0;a < o3; a++)
          if (n3[a] != i3[a]) {
            l3 = n3[a] > i3[a] ? 1 : -1;
            break;
          }
      return l3;
    }
    function r(n3, i3, o3, s3) {
      for (var a = 0;o3--; )
        n3[o3] -= a, a = n3[o3] < i3[o3] ? 1 : 0, n3[o3] = a * s3 + n3[o3] - i3[o3];
      for (;!n3[0] && n3.length > 1; )
        n3.shift();
    }
    return function(n3, i3, o3, s3, a, l3) {
      var u3, c3, p, d3, f3, g, h, O, P, C4, R, k, A, ue, jt, U, oe, Oe, Y, pt, Lr = n3.constructor, jn = n3.s == i3.s ? 1 : -1, z4 = n3.d, N = i3.d;
      if (!z4 || !z4[0] || !N || !N[0])
        return new Lr(!n3.s || !i3.s || (z4 ? N && z4[0] == N[0] : !N) ? NaN : z4 && z4[0] == 0 || !N ? jn * 0 : jn / 0);
      for (l3 ? (f3 = 1, c3 = n3.e - i3.e) : (l3 = he, f3 = E, c3 = re(n3.e / f3) - re(i3.e / f3)), Y = N.length, oe = z4.length, P = new Lr(jn), C4 = P.d = [], p = 0;N[p] == (z4[p] || 0); p++)
        ;
      if (N[p] > (z4[p] || 0) && c3--, o3 == null ? (ue = o3 = Lr.precision, s3 = Lr.rounding) : a ? ue = o3 + (n3.e - i3.e) + 1 : ue = o3, ue < 0)
        C4.push(1), g = true;
      else {
        if (ue = ue / f3 + 2 | 0, p = 0, Y == 1) {
          for (d3 = 0, N = N[0], ue++;(p < oe || d3) && ue--; p++)
            jt = d3 * l3 + (z4[p] || 0), C4[p] = jt / N | 0, d3 = jt % N | 0;
          g = d3 || p < oe;
        } else {
          for (d3 = l3 / (N[0] + 1) | 0, d3 > 1 && (N = e(N, d3, l3), z4 = e(z4, d3, l3), Y = N.length, oe = z4.length), U = Y, R = z4.slice(0, Y), k = R.length;k < Y; )
            R[k++] = 0;
          pt = N.slice(), pt.unshift(0), Oe = N[0], N[1] >= l3 / 2 && ++Oe;
          do
            d3 = 0, u3 = t3(N, R, Y, k), u3 < 0 ? (A = R[0], Y != k && (A = A * l3 + (R[1] || 0)), d3 = A / Oe | 0, d3 > 1 ? (d3 >= l3 && (d3 = l3 - 1), h = e(N, d3, l3), O = h.length, k = R.length, u3 = t3(h, R, O, k), u3 == 1 && (d3--, r(h, Y < O ? pt : N, O, l3))) : (d3 == 0 && (u3 = d3 = 1), h = N.slice()), O = h.length, O < k && h.unshift(0), r(R, h, k, l3), u3 == -1 && (k = R.length, u3 = t3(N, R, Y, k), u3 < 1 && (d3++, r(R, Y < k ? pt : N, k, l3))), k = R.length) : u3 === 0 && (d3++, R = [0]), C4[p++] = d3, u3 && R[0] ? R[k++] = z4[U] || 0 : (R = [z4[U]], k = 1);
          while ((U++ < oe || R[0] !== undefined) && ue--);
          g = R[0] !== undefined;
        }
        C4[0] || C4.shift();
      }
      if (f3 == 1)
        P.e = c3, Ss = g;
      else {
        for (p = 1, d3 = C4[0];d3 >= 10; d3 /= 10)
          p++;
        P.e = p + c3 * f3 - 1, y3(P, a ? o3 + P.e + 1 : o3, s3, g);
      }
      return P;
    };
  }();
  m3[Symbol.for("nodejs.util.inspect.custom")] = m3.toString;
  m3[Symbol.toStringTag] = "Decimal";
  var it = m3.constructor = Ms(Ai);
  en = new it(en);
  tn = new it(tn);
  var ve = it;
  var Us = D(bi());
  var Bs = D(import.meta.require("fs"));
  var $s = { keyword: _e, entity: _e, value: (e) => W(rt(e)), punctuation: rt, directive: _e, function: _e, variable: (e) => W(rt(e)), string: (e) => W(Ve(e)), boolean: De, number: _e, comment: Ut };
  var xp = (e) => e;
  var ln = {};
  var vp = 0;
  var x3 = { manual: ln.Prism && ln.Prism.manual, disableWorkerMessageHandler: ln.Prism && ln.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
    if (e instanceof ye) {
      let t3 = e;
      return new ye(t3.type, x3.util.encode(t3.content), t3.alias);
    } else
      return Array.isArray(e) ? e.map(x3.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e) {
    return Object.prototype.toString.call(e).slice(8, -1);
  }, objId: function(e) {
    return e.__id || Object.defineProperty(e, "__id", { value: ++vp }), e.__id;
  }, clone: function e(t3, r) {
    let n3, i3, o3 = x3.util.type(t3);
    switch (r = r || {}, o3) {
      case "Object":
        if (i3 = x3.util.objId(t3), r[i3])
          return r[i3];
        n3 = {}, r[i3] = n3;
        for (let s3 in t3)
          t3.hasOwnProperty(s3) && (n3[s3] = e(t3[s3], r));
        return n3;
      case "Array":
        return i3 = x3.util.objId(t3), r[i3] ? r[i3] : (n3 = [], r[i3] = n3, t3.forEach(function(s3, a) {
          n3[a] = e(s3, r);
        }), n3);
      default:
        return t3;
    }
  } }, languages: { extend: function(e, t3) {
    let r = x3.util.clone(x3.languages[e]);
    for (let n3 in t3)
      r[n3] = t3[n3];
    return r;
  }, insertBefore: function(e, t3, r, n3) {
    n3 = n3 || x3.languages;
    let i3 = n3[e], o3 = {};
    for (let a in i3)
      if (i3.hasOwnProperty(a)) {
        if (a == t3)
          for (let l3 in r)
            r.hasOwnProperty(l3) && (o3[l3] = r[l3]);
        r.hasOwnProperty(a) || (o3[a] = i3[a]);
      }
    let s3 = n3[e];
    return n3[e] = o3, x3.languages.DFS(x3.languages, function(a, l3) {
      l3 === s3 && a != e && (this[a] = o3);
    }), o3;
  }, DFS: function e(t3, r, n3, i3) {
    i3 = i3 || {};
    let o3 = x3.util.objId;
    for (let s3 in t3)
      if (t3.hasOwnProperty(s3)) {
        r.call(t3, s3, t3[s3], n3 || s3);
        let a = t3[s3], l3 = x3.util.type(a);
        l3 === "Object" && !i3[o3(a)] ? (i3[o3(a)] = true, e(a, r, null, i3)) : l3 === "Array" && !i3[o3(a)] && (i3[o3(a)] = true, e(a, r, s3, i3));
      }
  } }, plugins: {}, highlight: function(e, t3, r) {
    let n3 = { code: e, grammar: t3, language: r };
    return x3.hooks.run("before-tokenize", n3), n3.tokens = x3.tokenize(n3.code, n3.grammar), x3.hooks.run("after-tokenize", n3), ye.stringify(x3.util.encode(n3.tokens), n3.language);
  }, matchGrammar: function(e, t3, r, n3, i3, o3, s3) {
    for (let h in r) {
      if (!r.hasOwnProperty(h) || !r[h])
        continue;
      if (h == s3)
        return;
      let O = r[h];
      O = x3.util.type(O) === "Array" ? O : [O];
      for (let P = 0;P < O.length; ++P) {
        let C4 = O[P], R = C4.inside, k = !!C4.lookbehind, A = !!C4.greedy, ue = 0, jt = C4.alias;
        if (A && !C4.pattern.global) {
          let U = C4.pattern.toString().match(/[imuy]*$/)[0];
          C4.pattern = RegExp(C4.pattern.source, U + "g");
        }
        C4 = C4.pattern || C4;
        for (let U = n3, oe = i3;U < t3.length; oe += t3[U].length, ++U) {
          let Oe = t3[U];
          if (t3.length > e.length)
            return;
          if (Oe instanceof ye)
            continue;
          if (A && U != t3.length - 1) {
            C4.lastIndex = oe;
            var p = C4.exec(e);
            if (!p)
              break;
            var c3 = p.index + (k ? p[1].length : 0), d3 = p.index + p[0].length, a = U, l3 = oe;
            for (let N = t3.length;a < N && (l3 < d3 || !t3[a].type && !t3[a - 1].greedy); ++a)
              l3 += t3[a].length, c3 >= l3 && (++U, oe = l3);
            if (t3[U] instanceof ye)
              continue;
            u3 = a - U, Oe = e.slice(oe, l3), p.index -= oe;
          } else {
            C4.lastIndex = 0;
            var p = C4.exec(Oe), u3 = 1;
          }
          if (!p) {
            if (o3)
              break;
            continue;
          }
          k && (ue = p[1] ? p[1].length : 0);
          var c3 = p.index + ue, p = p[0].slice(ue), d3 = c3 + p.length, f3 = Oe.slice(0, c3), g = Oe.slice(d3);
          let Y = [U, u3];
          f3 && (++U, oe += f3.length, Y.push(f3));
          let pt = new ye(h, R ? x3.tokenize(p, R) : p, jt, p, A);
          if (Y.push(pt), g && Y.push(g), Array.prototype.splice.apply(t3, Y), u3 != 1 && x3.matchGrammar(e, t3, r, U, oe, true, h), o3)
            break;
        }
      }
    }
  }, tokenize: function(e, t3) {
    let r = [e], n3 = t3.rest;
    if (n3) {
      for (let i3 in n3)
        t3[i3] = n3[i3];
      delete t3.rest;
    }
    return x3.matchGrammar(e, r, t3, 0, 0, false), r;
  }, hooks: { all: {}, add: function(e, t3) {
    let r = x3.hooks.all;
    r[e] = r[e] || [], r[e].push(t3);
  }, run: function(e, t3) {
    let r = x3.hooks.all[e];
    if (!(!r || !r.length))
      for (var n3 = 0, i3;i3 = r[n3++]; )
        i3(t3);
  } }, Token: ye };
  x3.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  x3.languages.javascript = x3.languages.extend("clike", { "class-name": [x3.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  x3.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  x3.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: x3.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: x3.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: x3.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: x3.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  x3.languages.markup && x3.languages.markup.tag.addInlined("script", "javascript");
  x3.languages.js = x3.languages.javascript;
  x3.languages.typescript = x3.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  x3.languages.ts = x3.languages.typescript;
  ye.stringify = function(e, t3) {
    return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(r) {
      return ye.stringify(r, t3);
    }).join("") : Pp(e.type)(e.content);
  };
  var Vs = D(gs());
  var un = class e {
    static read(t3) {
      let r;
      try {
        r = Bs.default.readFileSync(t3, "utf-8");
      } catch {
        return null;
      }
      return e.fromContent(r);
    }
    static fromContent(t3) {
      let r = t3.split(/\r?\n/);
      return new e(1, r);
    }
    constructor(t3, r) {
      this.firstLineNumber = t3, this.lines = r;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(t3, r) {
      if (t3 < this.firstLineNumber || t3 > this.lines.length + this.firstLineNumber)
        return this;
      let n3 = t3 - this.firstLineNumber, i3 = [...this.lines];
      return i3[n3] = r(i3[n3]), new e(this.firstLineNumber, i3);
    }
    mapLines(t3) {
      return new e(this.firstLineNumber, this.lines.map((r, n3) => t3(r, this.firstLineNumber + n3)));
    }
    lineAt(t3) {
      return this.lines[t3 - this.firstLineNumber];
    }
    prependSymbolAt(t3, r) {
      return this.mapLines((n3, i3) => i3 === t3 ? `${r} ${n3}` : `  ${n3}`);
    }
    slice(t3, r) {
      let n3 = this.lines.slice(t3 - 1, r).join(`
`);
      return new e(t3, js(n3).split(`
`));
    }
    highlight() {
      let t3 = qs(this.toString());
      return new e(this.firstLineNumber, t3.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var Rp = { red: de, gray: Ut, dim: ke, bold: W, underline: X, highlightSource: (e) => e.highlight() };
  var Cp = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
  var Ys = D(_i());
  var pe = class {
    constructor(t3, r) {
      this.name = t3;
      this.value = r;
      this.isRequired = false;
    }
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(t3) {
      let { colors: { green: r } } = t3.context;
      t3.addMarginSymbol(r(this.isRequired ? "+" : "?")), t3.write(r(this.name)), this.isRequired || t3.write(r("?")), t3.write(r(": ")), typeof this.value == "string" ? t3.write(r(this.value)) : t3.write(this.value);
    }
  };
  var Pt = class {
    constructor(t3 = 0, r) {
      this.context = r;
      this.lines = [];
      this.currentLine = "";
      this.currentIndent = 0;
      this.currentIndent = t3;
    }
    write(t3) {
      return typeof t3 == "string" ? this.currentLine += t3 : t3.write(this), this;
    }
    writeJoined(t3, r, n3 = (i3, o3) => o3.write(i3)) {
      let i3 = r.length - 1;
      for (let o3 = 0;o3 < r.length; o3++)
        n3(r[o3], this), o3 !== i3 && this.write(t3);
      return this;
    }
    writeLine(t3) {
      return this.write(t3).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let t3 = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, t3?.(), this;
    }
    withIndent(t3) {
      return this.indent(), t3(this), this.unindent(), this;
    }
    afterNextNewline(t3) {
      return this.afterNextNewLineCallback = t3, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(t3) {
      return this.marginSymbol = t3, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let t3 = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + t3.slice(1) : t3;
    }
  };
  var dn = class {
    constructor(t3) {
      this.value = t3;
    }
    write(t3) {
      t3.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var mn = (e) => e;
  var fn = { bold: mn, red: mn, green: mn, dim: mn, enabled: false };
  var Ks = { bold: W, red: de, green: Ve, dim: ke, enabled: true };
  var Tt = { write(e) {
    e.writeLine(",");
  } };
  var Pe = class {
    constructor(t3) {
      this.contents = t3;
      this.isUnderlined = false;
      this.color = (t4) => t4;
    }
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(t3) {
      return this.color = t3, this;
    }
    write(t3) {
      let r = t3.getCurrentLineLength();
      t3.write(this.color(this.contents)), this.isUnderlined && t3.afterNextNewline(() => {
        t3.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var ze = class {
    constructor() {
      this.hasError = false;
    }
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var Rt = class extends ze {
    constructor() {
      super(...arguments);
      this.items = [];
    }
    addItem(r) {
      return this.items.push(new dn(r)), this;
    }
    getField(r) {
      return this.items[r];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((n3) => n3.value.getPrintWidth())) + 2;
    }
    write(r) {
      if (this.items.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithItems(r);
    }
    writeEmpty(r) {
      let n3 = new Pe("[]");
      this.hasError && n3.setColor(r.context.colors.red).underline(), r.write(n3);
    }
    writeWithItems(r) {
      let { colors: n3 } = r.context;
      r.writeLine("[").withIndent(() => r.writeJoined(Tt, this.items).newLine()).write("]"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(n3.red("~".repeat(this.getPrintWidth())));
      });
    }
    asObject() {
    }
  };
  var Ct = class e extends ze {
    constructor() {
      super(...arguments);
      this.fields = {};
      this.suggestions = [];
    }
    addField(r) {
      this.fields[r.name] = r;
    }
    addSuggestion(r) {
      this.suggestions.push(r);
    }
    getField(r) {
      return this.fields[r];
    }
    getDeepField(r) {
      let [n3, ...i3] = r, o3 = this.getField(n3);
      if (!o3)
        return;
      let s3 = o3;
      for (let a of i3) {
        let l3;
        if (s3.value instanceof e ? l3 = s3.value.getField(a) : s3.value instanceof Rt && (l3 = s3.value.getField(Number(a))), !l3)
          return;
        s3 = l3;
      }
      return s3;
    }
    getDeepFieldValue(r) {
      return r.length === 0 ? this : this.getDeepField(r)?.value;
    }
    hasField(r) {
      return !!this.getField(r);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(r) {
      delete this.fields[r];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(r) {
      return this.getField(r)?.value;
    }
    getDeepSubSelectionValue(r) {
      let n3 = this;
      for (let i3 of r) {
        if (!(n3 instanceof e))
          return;
        let o3 = n3.getSubSelectionValue(i3);
        if (!o3)
          return;
        n3 = o3;
      }
      return n3;
    }
    getDeepSelectionParent(r) {
      let n3 = this.getSelectionParent();
      if (!n3)
        return;
      let i3 = n3;
      for (let o3 of r) {
        let s3 = i3.value.getFieldValue(o3);
        if (!s3 || !(s3 instanceof e))
          return;
        let a = s3.getSelectionParent();
        if (!a)
          return;
        i3 = a;
      }
      return i3;
    }
    getSelectionParent() {
      let r = this.getField("select")?.value.asObject();
      if (r)
        return { kind: "select", value: r };
      let n3 = this.getField("include")?.value.asObject();
      if (n3)
        return { kind: "include", value: n3 };
    }
    getSubSelectionValue(r) {
      return this.getSelectionParent()?.value.fields[r].value;
    }
    getPrintWidth() {
      let r = Object.values(this.fields);
      return r.length == 0 ? 2 : Math.max(...r.map((i3) => i3.getPrintWidth())) + 2;
    }
    write(r) {
      let n3 = Object.values(this.fields);
      if (n3.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithContents(r, n3);
    }
    asObject() {
      return this;
    }
    writeEmpty(r) {
      let n3 = new Pe("{}");
      this.hasError && n3.setColor(r.context.colors.red).underline(), r.write(n3);
    }
    writeWithContents(r, n3) {
      r.writeLine("{").withIndent(() => {
        r.writeJoined(Tt, [...n3, ...this.suggestions]).newLine();
      }), r.write("}"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var H = class extends ze {
    constructor(r) {
      super();
      this.text = r;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(r) {
      let n3 = new Pe(this.text);
      this.hasError && n3.underline().setColor(r.context.colors.red), r.write(n3);
    }
    asObject() {
    }
  };
  var nr = class {
    constructor() {
      this.fields = [];
    }
    addField(t3, r) {
      return this.fields.push({ write(n3) {
        let { green: i3, dim: o3 } = n3.context.colors;
        n3.write(i3(o3(`${t3}: ${r}`))).addMarginSymbol(i3(o3("+")));
      } }), this;
    }
    write(t3) {
      let { colors: { green: r } } = t3.context;
      t3.writeLine(r("{")).withIndent(() => {
        t3.writeJoined(Tt, this.fields).newLine();
      }).write(r("}")).addMarginSymbol(r("+"));
    }
  };
  var rd = 3;
  var sr = class {
    constructor(t3, r, n3, i3, o3) {
      this.modelName = t3, this.name = r, this.typeName = n3, this.isList = i3, this.isEnum = o3;
    }
    _toGraphQLInputType() {
      let t3 = this.isList ? "List" : "", r = this.isEnum ? "Enum" : "";
      return `${t3}${r}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  var hn = Symbol();
  var Ni = new WeakMap;
  var $e = class {
    constructor(t3) {
      t3 === hn ? Ni.set(this, `Prisma.${this._getName()}`) : Ni.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return Ni.get(this);
    }
  };
  var ar = class extends $e {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var lr = class extends ar {
  };
  Li(lr, "DbNull");
  var ur = class extends ar {
  };
  Li(ur, "JsonNull");
  var cr = class extends ar {
  };
  Li(cr, "AnyNull");
  var yn = { classes: { DbNull: lr, JsonNull: ur, AnyNull: cr }, instances: { DbNull: new lr(hn), JsonNull: new ur(hn), AnyNull: new cr(hn) } };
  var na = ": ";
  var En = class {
    constructor(t3, r) {
      this.name = t3;
      this.value = r;
      this.hasError = false;
    }
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + na.length;
    }
    write(t3) {
      let r = new Pe(this.name);
      this.hasError && r.underline().setColor(t3.context.colors.red), t3.write(r).write(na).write(this.value);
    }
  };
  var Fi = class {
    constructor(t3) {
      this.errorMessages = [];
      this.arguments = t3;
    }
    write(t3) {
      t3.write(this.arguments);
    }
    addErrorMessage(t3) {
      this.errorMessages.push(t3);
    }
    renderAllMessages(t3) {
      return this.errorMessages.map((r) => r(t3)).join(`
`);
    }
  };
  var Te = class {
    constructor() {
      this._map = new Map;
    }
    get(t3) {
      return this._map.get(t3)?.value;
    }
    set(t3, r) {
      this._map.set(t3, { value: r });
    }
    getOrCreate(t3, r) {
      let n3 = this._map.get(t3);
      if (n3)
        return n3.value;
      let i3 = r();
      return this.set(t3, i3), i3;
    }
  };
  var xn = class {
    constructor(t3, r) {
      this.extension = t3;
      this.previous = r;
      this.computedFieldsCache = new Te;
      this.modelExtensionsCache = new Te;
      this.queryCallbacksCache = new Te;
      this.clientExtensions = pr(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      this.batchCallbacks = pr(() => {
        let t4 = this.previous?.getAllBatchQueryCallbacks() ?? [], r3 = this.extension.query?.$__internalBatch;
        return r3 ? t4.concat(r3) : t4;
      });
    }
    getAllComputedFields(t3) {
      return this.computedFieldsCache.getOrCreate(t3, () => aa(this.previous?.getAllComputedFields(t3), this.extension, t3));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(t3) {
      return this.modelExtensionsCache.getOrCreate(t3, () => {
        let r = Re(t3);
        return !this.extension.model || !(this.extension.model[r] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t3) : { ...this.previous?.getAllModelExtensions(t3), ...this.extension.model.$allModels, ...this.extension.model[r] };
      });
    }
    getAllQueryCallbacks(t3, r) {
      return this.queryCallbacksCache.getOrCreate(`${t3}:${r}`, () => {
        let n3 = this.previous?.getAllQueryCallbacks(t3, r) ?? [], i3 = [], o3 = this.extension.query;
        return !o3 || !(o3[t3] || o3.$allModels || o3[r] || o3.$allOperations) ? n3 : (o3[t3] !== undefined && (o3[t3][r] !== undefined && i3.push(o3[t3][r]), o3[t3].$allOperations !== undefined && i3.push(o3[t3].$allOperations)), t3 !== "$none" && o3.$allModels !== undefined && (o3.$allModels[r] !== undefined && i3.push(o3.$allModels[r]), o3.$allModels.$allOperations !== undefined && i3.push(o3.$allModels.$allOperations)), o3[r] !== undefined && i3.push(o3[r]), o3.$allOperations !== undefined && i3.push(o3.$allOperations), n3.concat(i3));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var It = class e {
    constructor(t3) {
      this.head = t3;
    }
    static empty() {
      return new e;
    }
    static single(t3) {
      return new e(new xn(t3));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(t3) {
      return new e(new xn(t3, this.head));
    }
    getAllComputedFields(t3) {
      return this.head?.getAllComputedFields(t3);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(t3) {
      return this.head?.getAllModelExtensions(t3);
    }
    getAllQueryCallbacks(t3, r) {
      return this.head?.getAllQueryCallbacks(t3, r) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var ca = Symbol();
  var dr = class {
    constructor(t3) {
      if (t3 !== ca)
        throw new Error("Skip instance can not be constructed directly");
    }
    ifUndefined(t3) {
      return t3 === undefined ? vn : t3;
    }
  };
  var vn = new dr(ca);
  var ad = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", createManyAndReturn: "createManyAndReturn", update: "updateOne", updateMany: "updateMany", updateManyAndReturn: "updateManyAndReturn", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var pa = "explicitly `undefined` values are not allowed";
  var Mi = class e {
    constructor(t3) {
      this.params = t3;
      this.params.modelName && (this.modelOrType = this.params.runtimeDataModel.models[this.params.modelName] ?? this.params.runtimeDataModel.types[this.params.modelName]);
    }
    throwValidationError(t3) {
      wn({ errors: [t3], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion, globalOmit: this.params.globalOmit });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.modelOrType))
        return { name: this.params.modelName, fields: this.modelOrType.fields.map((t3) => ({ name: t3.name, typeName: "boolean", isRelation: t3.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    isPreviewFeatureOn(t3) {
      return this.params.previewFeatures.includes(t3);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(t3) {
      return this.modelOrType?.fields.find((r) => r.name === t3);
    }
    nestSelection(t3) {
      let r = this.findField(t3), n3 = r?.kind === "object" ? r.type : undefined;
      return new e({ ...this.params, modelName: n3, selectionPath: this.params.selectionPath.concat(t3) });
    }
    getGlobalOmit() {
      return this.params.modelName && this.shouldApplyGlobalOmit() ? this.params.globalOmit?.[wt(this.params.modelName)] ?? {} : {};
    }
    shouldApplyGlobalOmit() {
      switch (this.params.action) {
        case "findFirst":
        case "findFirstOrThrow":
        case "findUniqueOrThrow":
        case "findMany":
        case "upsert":
        case "findUnique":
        case "createManyAndReturn":
        case "create":
        case "update":
        case "updateManyAndReturn":
        case "delete":
          return true;
        case "executeRaw":
        case "aggregateRaw":
        case "runCommandRaw":
        case "findRaw":
        case "createMany":
        case "deleteMany":
        case "groupBy":
        case "updateMany":
        case "count":
        case "aggregate":
        case "queryRaw":
          return false;
        default:
          Fe(this.params.action, "Unknown action");
      }
    }
    nestArgument(t3) {
      return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(t3) });
    }
  };
  var Ot = class {
    constructor(t3) {
      this._engine = t3;
    }
    prometheus(t3) {
      return this._engine.metrics({ format: "prometheus", ...t3 });
    }
    json(t3) {
      return this._engine.metrics({ format: "json", ...t3 });
    }
  };
  var ji = new WeakMap;
  var Tn = "$$PrismaTypedSql";
  var Bi = class {
    constructor(t3, r) {
      ji.set(this, { sql: t3, values: r }), Object.defineProperty(this, Tn, { value: Tn });
    }
    get sql() {
      return ji.get(this).sql;
    }
    get values() {
      return ji.get(this).values;
    }
  };
  var Ui = class {
    constructor() {
      this.registeredErrors = [];
    }
    consumeError(t3) {
      return this.registeredErrors[t3];
    }
    registerNewError(t3) {
      let r = 0;
      for (;this.registeredErrors[r] !== undefined; )
        r++;
      return this.registeredErrors[r] = { error: t3 }, r;
    }
  };
  var Qi = (e) => {
    let t3 = new Ui, r = Se(t3, e.transactionContext.bind(e)), n3 = { adapterName: e.adapterName, errorRegistry: t3, queryRaw: Se(t3, e.queryRaw.bind(e)), executeRaw: Se(t3, e.executeRaw.bind(e)), provider: e.provider, transactionContext: async (...i3) => (await r(...i3)).map((s3) => yd(t3, s3)) };
    return e.getConnectionInfo && (n3.getConnectionInfo = bd(t3, e.getConnectionInfo.bind(e))), n3;
  };
  var yd = (e, t3) => {
    let r = Se(e, t3.startTransaction.bind(t3));
    return { adapterName: t3.adapterName, provider: t3.provider, queryRaw: Se(e, t3.queryRaw.bind(t3)), executeRaw: Se(e, t3.executeRaw.bind(t3)), startTransaction: async (...n3) => (await r(...n3)).map((o3) => Ed(e, o3)) };
  };
  var Ed = (e, t3) => ({ adapterName: t3.adapterName, provider: t3.provider, options: t3.options, queryRaw: Se(e, t3.queryRaw.bind(t3)), executeRaw: Se(e, t3.executeRaw.bind(t3)), commit: Se(e, t3.commit.bind(t3)), rollback: Se(e, t3.rollback.bind(t3)) });
  var Kl = D(li());
  var Yl = import.meta.require("async_hooks");
  var zl = import.meta.require("events");
  var Zl = D(import.meta.require("fs"));
  var Nr = D(import.meta.require("path"));
  var ae = class e {
    constructor(t3, r) {
      if (t3.length - 1 !== r.length)
        throw t3.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t3.length} strings to have ${t3.length - 1} values`);
      let n3 = r.reduce((s3, a) => s3 + (a instanceof e ? a.values.length : 1), 0);
      this.values = new Array(n3), this.strings = new Array(n3 + 1), this.strings[0] = t3[0];
      let i3 = 0, o3 = 0;
      for (;i3 < r.length; ) {
        let s3 = r[i3++], a = t3[i3];
        if (s3 instanceof e) {
          this.strings[o3] += s3.strings[0];
          let l3 = 0;
          for (;l3 < s3.values.length; )
            this.values[o3++] = s3.values[l3++], this.strings[o3] = s3.strings[l3];
          this.strings[o3] += a;
        } else
          this.values[o3++] = s3, this.strings[o3] = a;
      }
    }
    get sql() {
      let t3 = this.strings.length, r = 1, n3 = this.strings[0];
      for (;r < t3; )
        n3 += `?${this.strings[r++]}`;
      return n3;
    }
    get statement() {
      let t3 = this.strings.length, r = 1, n3 = this.strings[0];
      for (;r < t3; )
        n3 += `:${r}${this.strings[r++]}`;
      return n3;
    }
    get text() {
      let t3 = this.strings.length, r = 1, n3 = this.strings[0];
      for (;r < t3; )
        n3 += `\$${r}${this.strings[r++]}`;
      return n3;
    }
    inspect() {
      return { sql: this.sql, statement: this.statement, text: this.text, values: this.values };
    }
  };
  var ba = Gi("");
  var Rn = { enumerable: true, configurable: true, writable: true };
  var wa = Symbol.for("nodejs.util.inspect.custom");
  var xd = "P2037";
  var hr = "<unknown>";
  var Pd = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var Td = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var Cd = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var Ad = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var Id = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var kd = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  var _d = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var Hi = class {
    getLocation() {
      return null;
    }
  };
  var Wi = class {
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let t3 = this._error.stack;
      if (!t3)
        return null;
      let n3 = Pa(t3).find((i3) => {
        if (!i3.file)
          return false;
        let o3 = Ei(i3.file);
        return o3 !== "<anonymous>" && !o3.includes("@prisma") && !o3.includes("/packages/client/src/runtime/") && !o3.endsWith("/runtime/binary.js") && !o3.endsWith("/runtime/library.js") && !o3.endsWith("/runtime/edge.js") && !o3.endsWith("/runtime/edge-esm.js") && !o3.startsWith("internal/") && !i3.methodName.includes("new ") && !i3.methodName.includes("getCallSite") && !i3.methodName.includes("Proxy.") && i3.methodName.split(".").length < 4;
      });
      return !n3 || !n3.file ? null : { fileName: n3.file, lineNumber: n3.lineNumber, columnNumber: n3.column };
    }
  };
  var Ta = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  var Oa = (e) => Array.isArray(e) ? e : e.split(".");
  var Ki = (e, t3) => Oa(t3).reduce((r, n3) => r && r[n3], e);
  var ka = (e, t3, r) => Oa(t3).reduceRight((n3, i3, o3, s3) => Object.assign({}, Ki(e, s3.slice(0, o3)), { [i3]: n3 }), r);
  var Qd = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var Gd = ["aggregate", "count", "groupBy"];
  var Zi = Symbol();
  var qa = (e) => e;
  var Ga = F("prisma:client");
  var Ja = { Vercel: "vercel", "Netlify CI": "netlify" };
  var Xd = "Cloudflare-Workers";
  var em = "node";
  var tm = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)" };
  var el = D(import.meta.require("fs"));
  var br = D(import.meta.require("path"));
  var nm = F("prisma:client:engines:resolveEnginePath");
  var im = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  var Xi = D(Pi());
  var ol = D(vs());
  var _n = class extends Error {
    constructor(t3, r) {
      super(t3), this.clientVersion = r.clientVersion, this.cause = r.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var le = class extends _n {
    constructor(t3, r) {
      super(t3, r), this.isRetryable = r.isRetryable ?? true;
    }
  };
  var Ft = class extends le {
    constructor(r) {
      super("This request must be retried", S(r, true));
      this.name = "ForcedRetryError";
      this.code = "P5001";
    }
  };
  w(Ft, "ForcedRetryError");
  var st = class extends le {
    constructor(r, n3) {
      super(r, S(n3, false));
      this.name = "InvalidDatasourceError";
      this.code = "P6001";
    }
  };
  w(st, "InvalidDatasourceError");
  var at = class extends le {
    constructor(r, n3) {
      super(r, S(n3, false));
      this.name = "NotImplementedYetError";
      this.code = "P5004";
    }
  };
  w(at, "NotImplementedYetError");
  var V = class extends le {
    constructor(t3, r) {
      super(t3, r), this.response = r.response;
      let n3 = this.response.headers.get("prisma-request-id");
      if (n3) {
        let i3 = `(The request id was: ${n3})`;
        this.message = this.message + " " + i3;
      }
    }
  };
  var lt = class extends V {
    constructor(r) {
      super("Schema needs to be uploaded", S(r, true));
      this.name = "SchemaMissingError";
      this.code = "P5005";
    }
  };
  w(lt, "SchemaMissingError");
  var eo = "This request could not be understood by the server";
  var wr = class extends V {
    constructor(r, n3, i3) {
      super(n3 || eo, S(r, false));
      this.name = "BadRequestError";
      this.code = "P5000";
      i3 && (this.code = i3);
    }
  };
  w(wr, "BadRequestError");
  var xr = class extends V {
    constructor(r, n3) {
      super("Engine not started: healthcheck timeout", S(r, true));
      this.name = "HealthcheckTimeoutError";
      this.code = "P5013";
      this.logs = n3;
    }
  };
  w(xr, "HealthcheckTimeoutError");
  var vr = class extends V {
    constructor(r, n3, i3) {
      super(n3, S(r, true));
      this.name = "EngineStartupError";
      this.code = "P5014";
      this.logs = i3;
    }
  };
  w(vr, "EngineStartupError");
  var Pr = class extends V {
    constructor(r) {
      super("Engine version is not supported", S(r, false));
      this.name = "EngineVersionNotSupportedError";
      this.code = "P5012";
    }
  };
  w(Pr, "EngineVersionNotSupportedError");
  var to = "Request timed out";
  var Tr = class extends V {
    constructor(r, n3 = to) {
      super(n3, S(r, false));
      this.name = "GatewayTimeoutError";
      this.code = "P5009";
    }
  };
  w(Tr, "GatewayTimeoutError");
  var sm = "Interactive transaction error";
  var Rr = class extends V {
    constructor(r, n3 = sm) {
      super(n3, S(r, false));
      this.name = "InteractiveTransactionError";
      this.code = "P5015";
    }
  };
  w(Rr, "InteractiveTransactionError");
  var am = "Request parameters are invalid";
  var Cr = class extends V {
    constructor(r, n3 = am) {
      super(n3, S(r, false));
      this.name = "InvalidRequestError";
      this.code = "P5011";
    }
  };
  w(Cr, "InvalidRequestError");
  var ro = "Requested resource does not exist";
  var Sr = class extends V {
    constructor(r, n3 = ro) {
      super(n3, S(r, false));
      this.name = "NotFoundError";
      this.code = "P5003";
    }
  };
  w(Sr, "NotFoundError");
  var no = "Unknown server error";
  var Mt = class extends V {
    constructor(r, n3, i3) {
      super(n3 || no, S(r, true));
      this.name = "ServerError";
      this.code = "P5006";
      this.logs = i3;
    }
  };
  w(Mt, "ServerError");
  var io = "Unauthorized, check your connection string";
  var Ar = class extends V {
    constructor(r, n3 = io) {
      super(n3, S(r, false));
      this.name = "UnauthorizedError";
      this.code = "P5007";
    }
  };
  w(Ar, "UnauthorizedError");
  var oo = "Usage exceeded, retry again later";
  var Ir = class extends V {
    constructor(r, n3 = oo) {
      super(n3, S(r, true));
      this.name = "UsageExceededError";
      this.code = "P5008";
    }
  };
  w(Ir, "UsageExceededError");
  var qe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var pl = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "6.2.0-14.4123509d24aa4dede1e864b46351bf2790323b69", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
  var kr = class extends le {
    constructor(r, n3) {
      super(`Cannot fetch data from service:
${r}`, S(n3, true));
      this.name = "RequestError";
      this.code = "P5010";
    }
  };
  w(kr, "RequestError");
  var pm = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var dl = F("prisma:client:dataproxyEngine");
  var fl = 3;
  var Nn = F("prisma:client:dataproxyEngine");
  var ao = class {
    constructor({ apiKey: t3, tracingHelper: r, logLevel: n3, logQueries: i3, engineHash: o3 }) {
      this.apiKey = t3, this.tracingHelper = r, this.logLevel = n3, this.logQueries = i3, this.engineHash = o3;
    }
    build({ traceparent: t3, interactiveTransaction: r } = {}) {
      let n3 = { Authorization: `Bearer ${this.apiKey}`, "Prisma-Engine-Hash": this.engineHash };
      this.tracingHelper.isEnabled() && (n3.traceparent = t3 ?? this.tracingHelper.getTraceParent()), r && (n3["X-transaction-id"] = r.id);
      let i3 = this.buildCaptureSettings();
      return i3.length > 0 && (n3["X-capture-telemetry"] = i3.join(", ")), n3;
    }
    buildCaptureSettings() {
      let t3 = [];
      return this.tracingHelper.isEnabled() && t3.push("tracing"), this.logLevel && t3.push(this.logLevel), this.logQueries && t3.push("query"), t3;
    }
  };
  var Dr = class {
    constructor(t3) {
      this.name = "DataProxyEngine";
      cl(t3), this.config = t3, this.env = { ...t3.env, ...typeof process < "u" ? process.env : {} }, this.inlineSchema = ul(t3.inlineSchema), this.inlineDatasources = t3.inlineDatasources, this.inlineSchemaHash = t3.inlineSchemaHash, this.clientVersion = t3.clientVersion, this.engineHash = t3.engineVersion, this.logEmitter = t3.logEmitter, this.tracingHelper = t3.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return this.engineHash;
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let [t3, r] = this.extractHostAndApiKey();
        this.host = t3, this.headerBuilder = new ao({ apiKey: r, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await ml(t3, this.config), Nn("host", this.host);
      })(), await this.startPromise;
    }
    async stop() {
    }
    propagateResponseExtensions(t3) {
      t3?.logs?.length && t3.logs.forEach((r) => {
        switch (r.level) {
          case "debug":
          case "trace":
            Nn(r);
            break;
          case "error":
          case "warn":
          case "info": {
            this.logEmitter.emit(r.level, { timestamp: so(r.timestamp), message: r.attributes.message ?? "", target: r.target });
            break;
          }
          case "query": {
            this.logEmitter.emit("query", { query: r.attributes.query ?? "", timestamp: so(r.timestamp), duration: r.attributes.duration_ms ?? 0, params: r.attributes.params ?? "", target: r.target });
            break;
          }
          default:
            r.level;
        }
      }), t3?.traces?.length && this.tracingHelper.dispatchEngineSpans(t3.traces);
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the remote query engine');
    }
    async url(t3) {
      return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${t3}`;
    }
    async uploadSchema() {
      let t3 = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(t3, async () => {
        let r = await ut(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        r.ok || Nn("schema response status", r.status);
        let n3 = await Or2(r, this.clientVersion);
        if (n3)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n3.message}`, timestamp: new Date, target: "" }), n3;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: new Date, target: "" });
      });
    }
    request(t3, { traceparent: r, interactiveTransaction: n3, customDataProxyFetch: i3 }) {
      return this.requestInternal({ body: t3, traceparent: r, interactiveTransaction: n3, customDataProxyFetch: i3 });
    }
    async requestBatch(t3, { traceparent: r, transaction: n3, customDataProxyFetch: i3 }) {
      let o3 = n3?.kind === "itx" ? n3.options : undefined, s3 = Dt(t3, n3);
      return (await this.requestInternal({ body: s3, customDataProxyFetch: i3, interactiveTransaction: o3, traceparent: r })).map((l3) => (l3.extensions && this.propagateResponseExtensions(l3.extensions), ("errors" in l3) ? this.convertProtocolErrorsToClientError(l3.errors) : l3));
    }
    requestInternal({ body: t3, traceparent: r, customDataProxyFetch: n3, interactiveTransaction: i3 }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: o3 }) => {
        let s3 = i3 ? `${i3.payload.endpoint}/graphql` : await this.url("graphql");
        o3(s3);
        let a = await ut(s3, { method: "POST", headers: this.headerBuilder.build({ traceparent: r, interactiveTransaction: i3 }), body: JSON.stringify(t3), clientVersion: this.clientVersion }, n3);
        a.ok || Nn("graphql response status", a.status), await this.handleError(await Or2(a, this.clientVersion));
        let l3 = await a.json();
        if (l3.extensions && this.propagateResponseExtensions(l3.extensions), "errors" in l3)
          throw this.convertProtocolErrorsToClientError(l3.errors);
        return "batchResult" in l3 ? l3.batchResult : l3;
      } });
    }
    async transaction(t3, r, n3) {
      let i3 = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${i3[t3]} transaction`, callback: async ({ logHttpCall: o3 }) => {
        if (t3 === "start") {
          let s3 = JSON.stringify({ max_wait: n3.maxWait, timeout: n3.timeout, isolation_level: n3.isolationLevel }), a = await this.url("transaction/start");
          o3(a);
          let l3 = await ut(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: r.traceparent }), body: s3, clientVersion: this.clientVersion });
          await this.handleError(await Or2(l3, this.clientVersion));
          let u3 = await l3.json(), { extensions: c3 } = u3;
          c3 && this.propagateResponseExtensions(c3);
          let p = u3.id, d3 = u3["data-proxy"].endpoint;
          return { id: p, payload: { endpoint: d3 } };
        } else {
          let s3 = `${n3.payload.endpoint}/${t3}`;
          o3(s3);
          let a = await ut(s3, { method: "POST", headers: this.headerBuilder.build({ traceparent: r.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await Or2(a, this.clientVersion));
          let l3 = await a.json(), { extensions: u3 } = l3;
          u3 && this.propagateResponseExtensions(u3);
          return;
        }
      } });
    }
    extractHostAndApiKey() {
      let t3 = { clientVersion: this.clientVersion }, r = Object.keys(this.inlineDatasources)[0], n3 = Lt({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), i3;
      try {
        i3 = new URL(n3);
      } catch {
        throw new st(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``, t3);
      }
      let { protocol: o3, host: s3, searchParams: a } = i3;
      if (o3 !== "prisma:" && o3 !== "prisma+postgres:")
        throw new st(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``, t3);
      let l3 = a.get("api_key");
      if (l3 === null || l3.length < 1)
        throw new st(`Error validating datasource \`${r}\`: the URL must contain a valid API key`, t3);
      return [s3, l3];
    }
    metrics() {
      throw new at("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(t3) {
      for (let r = 0;; r++) {
        let n3 = (i3) => {
          this.logEmitter.emit("info", { message: `Calling ${i3} (n=${r})`, timestamp: new Date, target: "" });
        };
        try {
          return await t3.callback({ logHttpCall: n3 });
        } catch (i3) {
          if (!(i3 instanceof le) || !i3.isRetryable)
            throw i3;
          if (r >= fl)
            throw i3 instanceof Ft ? i3.cause : i3;
          this.logEmitter.emit("warn", { message: `Attempt ${r + 1}/${fl} failed for ${t3.actionGerund}: ${i3.message ?? "(unknown)"}`, timestamp: new Date, target: "" });
          let o3 = await ll(r);
          this.logEmitter.emit("warn", { message: `Retrying after ${o3}ms`, timestamp: new Date, target: "" });
        }
      }
    }
    async handleError(t3) {
      if (t3 instanceof lt)
        throw await this.uploadSchema(), new Ft({ clientVersion: this.clientVersion, cause: t3 });
      if (t3)
        throw t3;
    }
    convertProtocolErrorsToClientError(t3) {
      return t3.length === 1 ? _t(t3[0], this.config.clientVersion, this.config.activeProvider) : new B(JSON.stringify(t3), { clientVersion: this.config.clientVersion });
    }
    applyPendingMigrations() {
      throw new Error("Method not implemented.");
    }
  };
  var uo = D(import.meta.require("os"));
  var hl = D(import.meta.require("path"));
  var lo = Symbol("PrismaLibraryEngineCache");
  var yl = { async loadLibrary(e) {
    let t3 = await ei(), r = await tl("library", e);
    try {
      return e.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => gm(r));
    } catch (n3) {
      let i3 = di({ e: n3, platformInfo: t3, id: r });
      throw new T3(i3, e.clientVersion);
    }
  } };
  var co;
  var El = { async loadLibrary(e) {
    let { clientVersion: t3, adapter: r, engineWasm: n3 } = e;
    if (r === undefined)
      throw new T3(`The \`adapter\` option for \`PrismaClient\` is required in this context (${In().prettyName})`, t3);
    if (n3 === undefined)
      throw new T3("WASM engine was unexpectedly `undefined`", t3);
    co === undefined && (co = (async () => {
      let o3 = n3.getRuntime(), s3 = await n3.getQueryEngineWasmModule();
      if (s3 == null)
        throw new T3("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", t3);
      let a = { "./query_engine_bg.js": o3 }, l3 = new WebAssembly.Instance(s3, a);
      return o3.__wbg_set_wasm(l3.exports), o3.QueryEngine;
    })());
    let i3 = await co;
    return { debugPanic() {
      return Promise.reject("{}");
    }, dmmf() {
      return Promise.resolve("{}");
    }, version() {
      return { commit: "unknown", version: "unknown" };
    }, QueryEngine: i3 };
  } };
  var hm = "P2036";
  var Ie = F("prisma:client:libraryEngine");
  var bl = [...Wn, "native"];
  var bm = 0xffffffffffffffffn;
  var po = 1n;
  var _r = class {
    constructor(t3, r) {
      this.name = "LibraryEngine";
      this.libraryLoader = r ?? yl, t3.engineWasm !== undefined && (this.libraryLoader = r ?? El), this.config = t3, this.libraryStarted = false, this.logQueries = t3.logQueries ?? false, this.logLevel = t3.logLevel ?? "error", this.logEmitter = t3.logEmitter, this.datamodel = t3.inlineSchema, this.tracingHelper = t3.tracingHelper, t3.enableDebugLogs && (this.logLevel = "debug");
      let n3 = Object.keys(t3.overrideDatasources)[0], i3 = t3.overrideDatasources[n3]?.url;
      n3 !== undefined && i3 !== undefined && (this.datasourceOverrides = { [n3]: i3 }), this.libraryInstantiationPromise = this.instantiateLibrary();
    }
    wrapEngine(t3) {
      return { applyPendingMigrations: t3.applyPendingMigrations?.bind(t3), commitTransaction: this.withRequestId(t3.commitTransaction.bind(t3)), connect: this.withRequestId(t3.connect.bind(t3)), disconnect: this.withRequestId(t3.disconnect.bind(t3)), metrics: t3.metrics?.bind(t3), query: this.withRequestId(t3.query.bind(t3)), rollbackTransaction: this.withRequestId(t3.rollbackTransaction.bind(t3)), sdlSchema: t3.sdlSchema?.bind(t3), startTransaction: this.withRequestId(t3.startTransaction.bind(t3)), trace: t3.trace.bind(t3) };
    }
    withRequestId(t3) {
      return async (...r) => {
        let n3 = wm().toString();
        try {
          return await t3(...r, n3);
        } finally {
          if (this.tracingHelper.isEnabled()) {
            let i3 = await this.engine?.trace(n3);
            if (i3) {
              let o3 = JSON.parse(i3);
              this.tracingHelper.dispatchEngineSpans(o3.spans);
            }
          }
        }
      };
    }
    async applyPendingMigrations() {
      throw new Error("Cannot call this method from this type of engine instance");
    }
    async transaction(t3, r, n3) {
      await this.start();
      let i3 = JSON.stringify(r), o3;
      if (t3 === "start") {
        let a = JSON.stringify({ max_wait: n3.maxWait, timeout: n3.timeout, isolation_level: n3.isolationLevel });
        o3 = await this.engine?.startTransaction(a, i3);
      } else
        t3 === "commit" ? o3 = await this.engine?.commitTransaction(n3.id, i3) : t3 === "rollback" && (o3 = await this.engine?.rollbackTransaction(n3.id, i3));
      let s3 = this.parseEngineResponse(o3);
      if (xm(s3)) {
        let a = this.getExternalAdapterError(s3);
        throw a ? a.error : new ee(s3.message, { code: s3.error_code, clientVersion: this.config.clientVersion, meta: s3.meta });
      }
      return s3;
    }
    async instantiateLibrary() {
      if (Ie("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      Hn(), this.binaryTarget = await this.getCurrentBinaryTarget(), await this.tracingHelper.runInChildSpan("load_engine", () => this.loadEngine()), this.version();
    }
    async getCurrentBinaryTarget() {
      {
        if (this.binaryTarget)
          return this.binaryTarget;
        let t3 = await this.tracingHelper.runInChildSpan("detect_platform", () => nt());
        if (!bl.includes(t3))
          throw new T3(`Unknown ${de("PRISMA_QUERY_ENGINE_LIBRARY")} ${de(W(t3))}. Possible binaryTargets: ${Ve(bl.join(", "))} or a path to the query engine library.
You may have to run ${Ve("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
        return t3;
      }
    }
    parseEngineResponse(t3) {
      if (!t3)
        throw new B("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(t3);
      } catch {
        throw new B("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(this.config), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let t3 = new WeakRef(this), { adapter: r } = this.config;
          r && Ie("Using driver adapter: %O", r), this.engine = this.wrapEngine(new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json", enableTracing: this.tracingHelper.isEnabled() }, (n3) => {
            t3.deref()?.logger(n3);
          }, r));
        } catch (t3) {
          let r = t3, n3 = this.parseInitError(r.message);
          throw typeof n3 == "string" ? r : new T3(n3.message, this.config.clientVersion, n3.error_code);
        }
      }
    }
    logger(t3) {
      let r = this.parseEngineResponse(t3);
      r && (r.level = r?.level.toLowerCase() ?? "unknown", ym(r) ? this.logEmitter.emit("query", { timestamp: new Date, query: r.query, params: r.params, duration: Number(r.duration_ms), target: r.module_path }) : Em(r) ? this.loggerRustPanic = new ce(mo(this, `${r.message}: ${r.reason} in ${r.file}:${r.line}:${r.column}`), this.config.clientVersion) : this.logEmitter.emit(r.level, { timestamp: new Date, message: r.message, target: r.module_path }));
    }
    parseInitError(t3) {
      try {
        return JSON.parse(t3);
      } catch {
      }
      return t3;
    }
    parseRequestError(t3) {
      try {
        return JSON.parse(t3);
      } catch {
      }
      return t3;
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
    }
    async start() {
      if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return Ie(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let t3 = async () => {
        Ie("library starting");
        try {
          let r = { traceparent: this.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(r)), this.libraryStarted = true, Ie("library started");
        } catch (r) {
          let n3 = this.parseInitError(r.message);
          throw typeof n3 == "string" ? r : new T3(n3.message, this.config.clientVersion, n3.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.tracingHelper.runInChildSpan("connect", t3), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return Ie("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted)
        return;
      let t3 = async () => {
        await new Promise((n3) => setTimeout(n3, 5)), Ie("library stopping");
        let r = { traceparent: this.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(r)), this.libraryStarted = false, this.libraryStoppingPromise = undefined, Ie("library stopped");
      };
      return this.libraryStoppingPromise = this.tracingHelper.runInChildSpan("disconnect", t3), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(t3) {
      return this.library?.debugPanic(t3);
    }
    async request(t3, { traceparent: r, interactiveTransaction: n3 }) {
      Ie(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let i3 = JSON.stringify({ traceparent: r }), o3 = JSON.stringify(t3);
      try {
        await this.start(), this.executingQueryPromise = this.engine?.query(o3, i3, n3?.id), this.lastQuery = o3;
        let s3 = this.parseEngineResponse(await this.executingQueryPromise);
        if (s3.errors)
          throw s3.errors.length === 1 ? this.buildQueryError(s3.errors[0]) : new B(JSON.stringify(s3.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: s3 };
      } catch (s3) {
        if (s3 instanceof T3)
          throw s3;
        if (s3.code === "GenericFailure" && s3.message?.startsWith("PANIC:"))
          throw new ce(mo(this, s3.message), this.config.clientVersion);
        let a = this.parseRequestError(s3.message);
        throw typeof a == "string" ? s3 : new B(`${a.message}
${a.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(t3, { transaction: r, traceparent: n3 }) {
      Ie("requestBatch");
      let i3 = Dt(t3, r);
      await this.start(), this.lastQuery = JSON.stringify(i3), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: n3 }), gl(r));
      let o3 = await this.executingQueryPromise, s3 = this.parseEngineResponse(o3);
      if (s3.errors)
        throw s3.errors.length === 1 ? this.buildQueryError(s3.errors[0]) : new B(JSON.stringify(s3.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: a, errors: l3 } = s3;
      if (Array.isArray(a))
        return a.map((u3) => u3.errors && u3.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(u3.errors[0]) : { data: u3 });
      throw l3 && l3.length === 1 ? new Error(l3[0].error) : new Error(JSON.stringify(s3));
    }
    buildQueryError(t3) {
      if (t3.user_facing_error.is_panic)
        return new ce(mo(this, t3.user_facing_error.message), this.config.clientVersion);
      let r = this.getExternalAdapterError(t3.user_facing_error);
      return r ? r.error : _t(t3, this.config.clientVersion, this.config.activeProvider);
    }
    getExternalAdapterError(t3) {
      if (t3.error_code === hm && this.config.adapter) {
        let r = t3.meta?.id;
        Yr(typeof r == "number", "Malformed external JS error received from the engine");
        let n3 = this.config.adapter.errorRegistry.consumeError(r);
        return Yr(n3, "External error with reported id was not registered"), n3;
      }
    }
    async metrics(t3) {
      await this.start();
      let r = await this.engine.metrics(JSON.stringify(t3));
      return t3.format === "prometheus" ? r : this.parseEngineResponse(r);
    }
  };
  var xl = (e) => ({ command: e });
  var vl = (e) => e.strings.reduce((t3, r, n3) => `${t3}@P${n3}${r}`);
  var Pm = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var Sl = Pm;
  var Tm = /^(\s*alter\s)/i;
  var Al = F("prisma:client");
  var go = ({ clientMethod: e, activeProvider: t3 }) => (r) => {
    let n3 = "", i3;
    if (ya(r))
      n3 = r.sql, i3 = { values: qt(r.values), __prismaRawParameters__: true };
    else if (Array.isArray(r)) {
      let [o3, ...s3] = r;
      n3 = o3, i3 = { values: qt(s3 || []), __prismaRawParameters__: true };
    } else
      switch (t3) {
        case "sqlite":
        case "mysql": {
          n3 = r.sql, i3 = { values: qt(r.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n3 = r.text, i3 = { values: qt(r.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n3 = vl(r), i3 = { values: qt(r.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${t3} provider does not support ${e}`);
      }
    return i3?.values ? Al(`prisma.${e}(${n3}, ${i3.values})`) : Al(`prisma.${e}(${n3})`), { query: n3, parameters: i3 };
  };
  var Il = { requestArgsToMiddlewareArgs(e) {
    return [e.strings, ...e.values];
  }, middlewareArgsToRequestArgs(e) {
    let [t3, ...r] = e;
    return new ae(t3, r);
  } };
  var Ol = { requestArgsToMiddlewareArgs(e) {
    return [e];
  }, middlewareArgsToRequestArgs(e) {
    return e[0];
  } };
  var Rm = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, dispatchEngineSpans() {
  }, getActiveContext() {
  }, runInChildSpan(e, t3) {
    return t3();
  } };
  var yo = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(t3) {
      return this.getGlobalTracingHelper().getTraceParent(t3);
    }
    dispatchEngineSpans(t3) {
      return this.getGlobalTracingHelper().dispatchEngineSpans(t3);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(t3, r) {
      return this.getGlobalTracingHelper().runInChildSpan(t3, r);
    }
    getGlobalTracingHelper() {
      return globalThis.PRISMA_INSTRUMENTATION?.helper ?? Rm;
    }
  };
  var Fn = class {
    constructor() {
      this._middlewares = [];
    }
    use(t3) {
      this._middlewares.push(t3);
    }
    get(t3) {
      return this._middlewares[t3];
    }
    has(t3) {
      return !!this._middlewares[t3];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var Fl = D(Pi());
  var Cm = { aggregate: false, aggregateRaw: false, createMany: true, createManyAndReturn: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateManyAndReturn: true, updateOne: true, upsertOne: true };
  var $n = class {
    constructor(t3) {
      this.options = t3;
      this.tickActive = false;
      this.batches = {};
    }
    request(t3) {
      let r = this.options.batchBy(t3);
      return r ? (this.batches[r] || (this.batches[r] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n3, i3) => {
        this.batches[r].push({ request: t3, resolve: n3, reject: i3 });
      })) : this.options.singleLoader(t3);
    }
    dispatchBatches() {
      for (let t3 in this.batches) {
        let r = this.batches[t3];
        delete this.batches[t3], r.length === 1 ? this.options.singleLoader(r[0].request).then((n3) => {
          n3 instanceof Error ? r[0].reject(n3) : r[0].resolve(n3);
        }).catch((n3) => {
          r[0].reject(n3);
        }) : (r.sort((n3, i3) => this.options.batchOrder(n3.request, i3.request)), this.options.batchLoader(r.map((n3) => n3.request)).then((n3) => {
          if (n3 instanceof Error)
            for (let i3 = 0;i3 < r.length; i3++)
              r[i3].reject(n3);
          else
            for (let i3 = 0;i3 < r.length; i3++) {
              let o3 = n3[i3];
              o3 instanceof Error ? r[i3].reject(o3) : r[i3].resolve(o3);
            }
        }).catch((n3) => {
          for (let i3 = 0;i3 < r.length; i3++)
            r[i3].reject(n3);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  var Am = F("prisma:client:request_handler");
  var Vn = class {
    constructor(t3, r) {
      this.logEmitter = r, this.client = t3, this.dataloader = new $n({ batchLoader: Ba(async ({ requests: n3, customDataProxyFetch: i3 }) => {
        let { transaction: o3, otelParentCtx: s3 } = n3[0], a = n3.map((p) => p.protocolQuery), l3 = this.client._tracingHelper.getTraceParent(s3), u3 = n3.some((p) => bo(p.protocolQuery.action));
        return (await this.client._engine.requestBatch(a, { traceparent: l3, transaction: Im(o3), containsWrite: u3, customDataProxyFetch: i3 })).map((p, d3) => {
          if (p instanceof Error)
            return p;
          try {
            return this.mapQueryEngineResult(n3[d3], p);
          } catch (f3) {
            return f3;
          }
        });
      }), singleLoader: async (n3) => {
        let i3 = n3.transaction?.kind === "itx" ? Ml(n3.transaction) : undefined, o3 = await this.client._engine.request(n3.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i3, isWrite: bo(n3.protocolQuery.action), customDataProxyFetch: n3.customDataProxyFetch });
        return this.mapQueryEngineResult(n3, o3);
      }, batchBy: (n3) => n3.transaction?.id ? `transaction-${n3.transaction.id}` : Ll(n3.protocolQuery), batchOrder(n3, i3) {
        return n3.transaction?.kind === "batch" && i3.transaction?.kind === "batch" ? n3.transaction.index - i3.transaction.index : 0;
      } });
    }
    async request(t3) {
      try {
        return await this.dataloader.request(t3);
      } catch (r) {
        let { clientMethod: n3, callsite: i3, transaction: o3, args: s3, modelName: a } = t3;
        this.handleAndLogRequestError({ error: r, clientMethod: n3, callsite: i3, transaction: o3, args: s3, modelName: a, globalOmit: t3.globalOmit });
      }
    }
    mapQueryEngineResult({ dataPath: t3, unpacker: r }, n3) {
      let i3 = n3?.data, o3 = this.unpack(i3, t3, r);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: o3 } : o3;
    }
    handleAndLogRequestError(t3) {
      try {
        this.handleRequestError(t3);
      } catch (r) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: r.message, target: t3.clientMethod, timestamp: new Date }), r;
      }
    }
    handleRequestError({ error: t3, clientMethod: r, callsite: n3, transaction: i3, args: o3, modelName: s3, globalOmit: a }) {
      if (Am(t3), Om(t3, i3))
        throw t3;
      if (t3 instanceof ee && km(t3)) {
        let u3 = $l(t3.meta);
        wn({ args: o3, errors: [u3], callsite: n3, errorFormat: this.client._errorFormat, originalMethod: r, clientVersion: this.client._clientVersion, globalOmit: a });
      }
      let l3 = t3.message;
      if (n3 && (l3 = cn({ callsite: n3, originalMethod: r, isPanic: t3.isPanic, showColors: this.client._errorFormat === "pretty", message: l3 })), l3 = this.sanitizeMessage(l3), t3.code) {
        let u3 = s3 ? { modelName: s3, ...t3.meta } : t3.meta;
        throw new ee(l3, { code: t3.code, clientVersion: this.client._clientVersion, meta: u3, batchRequestIdx: t3.batchRequestIdx });
      } else {
        if (t3.isPanic)
          throw new ce(l3, this.client._clientVersion);
        if (t3 instanceof B)
          throw new B(l3, { clientVersion: this.client._clientVersion, batchRequestIdx: t3.batchRequestIdx });
        if (t3 instanceof T3)
          throw new T3(l3, this.client._clientVersion);
        if (t3 instanceof ce)
          throw new ce(l3, this.client._clientVersion);
      }
      throw t3.clientVersion = this.client._clientVersion, t3;
    }
    sanitizeMessage(t3) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, Fl.default)(t3) : t3;
    }
    unpack(t3, r, n3) {
      if (!t3 || (t3.data && (t3 = t3.data), !t3))
        return t3;
      let i3 = Object.keys(t3)[0], o3 = Object.values(t3)[0], s3 = r.filter((u3) => u3 !== "select" && u3 !== "include"), a = Ki(o3, s3), l3 = i3 === "queryRaw" ? qn(a) : bt(a);
      return n3 ? n3(l3) : l3;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  var ql = "6.2.1";
  var Vl = ql;
  var Gl = D(_i());
  var L = class extends Error {
    constructor(t3) {
      super(t3 + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  w(L, "PrismaClientConstructorValidationError");
  var jl = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "omit", "__internal"];
  var Bl = ["pretty", "colorless", "minimal"];
  var Ul = ["info", "query", "warn", "error"];
  var _m = { datasources: (e, { datasourceNames: t3 }) => {
    if (e) {
      if (typeof e != "object" || Array.isArray(e))
        throw new L(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
      for (let [r, n3] of Object.entries(e)) {
        if (!t3.includes(r)) {
          let i3 = Vt(r, t3) || ` Available datasources: ${t3.join(", ")}`;
          throw new L(`Unknown datasource ${r} provided to PrismaClient constructor.${i3}`);
        }
        if (typeof n3 != "object" || Array.isArray(n3))
          throw new L(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n3 && typeof n3 == "object")
          for (let [i3, o3] of Object.entries(n3)) {
            if (i3 !== "url")
              throw new L(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o3 != "string")
              throw new L(`Invalid value ${JSON.stringify(o3)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, adapter: (e, t3) => {
    if (e === null)
      return;
    if (e === undefined)
      throw new L('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
    if (!Ln(t3).includes("driverAdapters"))
      throw new L('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
    if (Yt() === "binary")
      throw new L('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
  }, datasourceUrl: (e) => {
    if (typeof e < "u" && typeof e != "string")
      throw new L(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e) => {
    if (e) {
      if (typeof e != "string")
        throw new L(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!Bl.includes(e)) {
        let t3 = Vt(e, Bl);
        throw new L(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t3}`);
      }
    }
  }, log: (e) => {
    if (!e)
      return;
    if (!Array.isArray(e))
      throw new L(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
    function t3(r) {
      if (typeof r == "string" && !Ul.includes(r)) {
        let n3 = Vt(r, Ul);
        throw new L(`Invalid log level "${r}" provided to PrismaClient constructor.${n3}`);
      }
    }
    for (let r of e) {
      t3(r);
      let n3 = { level: t3, emit: (i3) => {
        let o3 = ["stdout", "event"];
        if (!o3.includes(i3)) {
          let s3 = Vt(i3, o3);
          throw new L(`Invalid value ${JSON.stringify(i3)} for "emit" in logLevel provided to PrismaClient constructor.${s3}`);
        }
      } };
      if (r && typeof r == "object")
        for (let [i3, o3] of Object.entries(r))
          if (n3[i3])
            n3[i3](o3);
          else
            throw new L(`Invalid property ${i3} for "log" provided to PrismaClient constructor`);
    }
  }, transactionOptions: (e) => {
    if (!e)
      return;
    let t3 = e.maxWait;
    if (t3 != null && t3 <= 0)
      throw new L(`Invalid value ${t3} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
    let r = e.timeout;
    if (r != null && r <= 0)
      throw new L(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
  }, omit: (e, t3) => {
    if (typeof e != "object")
      throw new L('"omit" option is expected to be an object.');
    if (e === null)
      throw new L('"omit" option can not be `null`');
    let r = [];
    for (let [n3, i3] of Object.entries(e)) {
      let o3 = Lm(n3, t3.runtimeDataModel);
      if (!o3) {
        r.push({ kind: "UnknownModel", modelKey: n3 });
        continue;
      }
      for (let [s3, a] of Object.entries(i3)) {
        let l3 = o3.fields.find((u3) => u3.name === s3);
        if (!l3) {
          r.push({ kind: "UnknownField", modelKey: n3, fieldName: s3 });
          continue;
        }
        if (l3.relationName) {
          r.push({ kind: "RelationInOmit", modelKey: n3, fieldName: s3 });
          continue;
        }
        typeof a != "boolean" && r.push({ kind: "InvalidFieldValue", modelKey: n3, fieldName: s3 });
      }
    }
    if (r.length > 0)
      throw new L(Fm(e, r));
  }, __internal: (e) => {
    if (!e)
      return;
    let t3 = ["debug", "engine", "configOverride"];
    if (typeof e != "object")
      throw new L(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
    for (let [r] of Object.entries(e))
      if (!t3.includes(r)) {
        let n3 = Vt(r, t3);
        throw new L(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n3}`);
      }
  } };
  var tt = F("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var Mm = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
  var $m = Symbol.for("prisma.client.transaction.id");
  var qm = { id: 0, nextId() {
    return ++this.id;
  } };
  var jm = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// node_modules/.prisma/client/index.js
var require_client = __commonJS((exports) => {
  var __dirname = "/home/natee/workspace/portfolio-v3-api/node_modules/.prisma/client";
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join2,
    raw: raw2,
    skip: skip2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2,
    getRuntime: getRuntime2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "6.2.1",
    engine: "4123509d24aa4dede1e864b46351bf2790323b69"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join2;
  Prisma.raw = raw2;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path = import.meta.require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.ProjectScalarFieldEnum = {
    id: "id",
    image: "image",
    title: "title",
    description: "description",
    content: "content",
    projectLink: "projectLink",
    sourceCodeLink: "sourceCodeLink",
    isFeatured: "isFeatured",
    created_at: "created_at",
    updated_at: "updated_at"
  };
  exports.Prisma.EducationScalarFieldEnum = {
    id: "id",
    logo: "logo",
    instance: "instance",
    content: "content",
    address: "address",
    duration: "duration",
    created_at: "created_at",
    updated_at: "updated_at"
  };
  exports.Prisma.WorkScalarFieldEnum = {
    id: "id",
    logo: "logo",
    jobTitle: "jobTitle",
    content: "content",
    instance: "instance",
    instanceLink: "instanceLink",
    address: "address",
    duration: "duration",
    created_at: "created_at",
    updated_at: "updated_at"
  };
  exports.Prisma.OAuthAccountScalarFieldEnum = {
    provider: "provider",
    providerAccountId: "providerAccountId",
    userId: "userId"
  };
  exports.Prisma.UserScalarFieldEnum = {
    id: "id",
    email: "email",
    emailVerified: "emailVerified",
    role: "role",
    name: "name",
    headline: "headline",
    location: "location",
    about: "about",
    avatarUrl: "avatarUrl",
    avatarMinioKey: "avatarMinioKey",
    bannerUrl: "bannerUrl",
    bannerMinioKey: "bannerMinioKey",
    iconUrl: "iconUrl",
    hashedPassword: "hashedPassword",
    passwordSalt: "passwordSalt",
    created_at: "created_at",
    updated_at: "updated_at"
  };
  exports.Prisma.SessionScalarFieldEnum = {
    id: "id",
    userId: "userId",
    expiresAt: "expiresAt"
  };
  exports.Prisma.PasswordResetTokenScalarFieldEnum = {
    userId: "userId",
    hashedToken: "hashedToken",
    expiresAt: "expiresAt"
  };
  exports.Prisma.AIChatScalarFieldEnum = {
    id: "id",
    userId: "userId",
    chatTitle: "chatTitle",
    createdAt: "createdAt"
  };
  exports.Prisma.AIChatMessageScalarFieldEnum = {
    id: "id",
    msg: "msg",
    role: "role",
    createdAt: "createdAt",
    aIChatId: "aIChatId"
  };
  exports.Prisma.PublicChatMessageScalarFieldEnum = {
    id: "id",
    message: "message",
    userId: "userId",
    replyToId: "replyToId",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    deletedAt: "deletedAt"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.Prisma.NullsOrder = {
    first: "first",
    last: "last"
  };
  exports.UserRole = exports.$Enums.UserRole = {
    ADMIN: "ADMIN",
    USER: "USER",
    GUEST: "GUEST"
  };
  exports.Prisma.ModelName = {
    Project: "Project",
    Education: "Education",
    Work: "Work",
    OAuthAccount: "OAuthAccount",
    User: "User",
    Session: "Session",
    PasswordResetToken: "PasswordResetToken",
    AIChat: "AIChat",
    AIChatMessage: "AIChatMessage",
    PublicChatMessage: "PublicChatMessage"
  };
  var config2 = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "/home/natee/workspace/portfolio-v3-api/node_modules/@prisma/client",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "debian-openssl-3.0.x",
          native: true
        }
      ],
      previewFeatures: [],
      sourceFilePath: "/home/natee/workspace/portfolio-v3-api/prisma/schema.prisma"
    },
    relativeEnvPaths: {
      rootEnvPath: null,
      schemaEnvPath: "../../../.env"
    },
    relativePath: "../../../prisma",
    clientVersion: "6.2.1",
    engineVersion: "4123509d24aa4dede1e864b46351bf2790323b69",
    datasourceNames: [
      "db"
    ],
    activeProvider: "postgresql",
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "DATABASE_URL",
          value: null
        }
      }
    },
    inlineSchema: "generator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n  // Prisma v7 compatible - no warnings\n}\n\nmodel Project {\n  id             Int      @id @default(autoincrement())\n  image          String\n  title          String\n  description    String\n  content        String\n  projectLink    String\n  sourceCodeLink String?\n  isFeatured     Boolean  @default(false)\n  created_at     DateTime @default(now())\n  updated_at     DateTime @updatedAt\n}\n\nmodel Education {\n  id         Int      @id @default(autoincrement())\n  logo       String\n  instance   String\n  content    String\n  address    String\n  duration   String\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n}\n\nmodel Work {\n  id           Int      @id @default(autoincrement())\n  logo         String\n  jobTitle     String\n  content      String\n  instance     String\n  instanceLink String\n  address      String\n  duration     String\n  created_at   DateTime @default(now())\n  updated_at   DateTime @updatedAt\n}\n\nmodel OAuthAccount {\n  provider          String\n  providerAccountId String @map(\"provider_account_id\")\n  userId            String @map(\"user_id\")\n  user              User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([provider, providerAccountId])\n}\n\nenum UserRole {\n  ADMIN\n  USER\n  GUEST\n}\n\nmodel User {\n  id                 String              @id @default(cuid())\n  email              String              @unique\n  emailVerified      Boolean             @default(false) @map(\"email_verified\")\n  role               UserRole            @default(USER)\n  name               String\n  headline           String?\n  location           String?\n  about              String?\n  avatarUrl          String?             @map(\"avatar_url\")\n  avatarMinioKey     String?             @map(\"avatar_minio_key\")\n  bannerUrl          String?             @map(\"banner_url\")\n  bannerMinioKey     String?             @map(\"banner_minio_key\")\n  iconUrl            String?             @map(\"icon_url\")\n  hashedPassword     String?             @map(\"hashed_password\")\n  passwordSalt       String?             @map(\"password_salt\")\n  passwordResets     PasswordResetToken?\n  oauthAccounts      OAuthAccount[]\n  sessions           Session[]\n  aiChat             AIChat[]\n  publicChatMessages PublicChatMessage[]\n  created_at         DateTime            @default(now()) @map(\"created_at\")\n  updated_at         DateTime            @updatedAt @map(\"updated_at\")\n}\n\nmodel Session {\n  id        String   @id\n  userId    String   @map(\"user_id\")\n  expiresAt DateTime @map(\"expires_at\")\n  user      User     @relation(references: [id], fields: [userId], onDelete: Cascade)\n}\n\nmodel PasswordResetToken {\n  userId      String   @unique @map(\"user_id\")\n  hashedToken String   @unique @map(\"hashed_token\")\n  expiresAt   DateTime @map(\"expires_at\")\n  user        User     @relation(references: [id], fields: [userId], onDelete: Cascade)\n}\n\nmodel AIChat {\n  id        String          @id @default(cuid())\n  userId    String\n  chatTitle String\n  messages  AIChatMessage[]\n  createdAt DateTime        @default(now()) @map(\"created_at\")\n  user      User            @relation(fields: [userId], references: [id])\n}\n\nmodel AIChatMessage {\n  id        String   @id @default(cuid())\n  msg       String\n  role      String\n  createdAt DateTime @default(now()) @map(\"created_at\")\n  AIChat    AIChat?  @relation(fields: [aIChatId], references: [id])\n  aIChatId  String?\n}\n\nmodel PublicChatMessage {\n  id        String              @id @default(cuid())\n  message   String              @db.Text\n  userId    String              @map(\"user_id\")\n  user      User                @relation(fields: [userId], references: [id], onDelete: Cascade)\n  replyToId String?             @map(\"reply_to_id\")\n  replyTo   PublicChatMessage?  @relation(\"MessageReplies\", fields: [replyToId], references: [id], onDelete: SetNull)\n  replies   PublicChatMessage[] @relation(\"MessageReplies\")\n  createdAt DateTime            @default(now()) @map(\"created_at\")\n  updatedAt DateTime            @updatedAt @map(\"updated_at\")\n  deletedAt DateTime?           @map(\"deleted_at\")\n\n  @@index([userId, createdAt])\n  @@index([createdAt])\n  @@index([replyToId])\n}\n",
    inlineSchemaHash: "acfa7bd18007fdddacd7e100a8e3b96e5f499e8ddec034cbfafaf1aadc68b4ff",
    copyEngine: true
  };
  var fs2 = import.meta.require("fs");
  config2.dirname = __dirname;
  if (!fs2.existsSync(path.join(__dirname, "schema.prisma"))) {
    const alternativePaths = [
      "node_modules/.prisma/client",
      ".prisma/client"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs2.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config2.dirname = path.join(process.cwd(), alternativePath);
    config2.isBundled = true;
  }
  config2.runtimeDataModel = JSON.parse("{\"models\":{\"Project\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"image\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"description\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"content\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"projectLink\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"sourceCodeLink\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isFeatured\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Education\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"logo\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"instance\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"content\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"address\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"duration\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Work\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"logo\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"jobTitle\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"content\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"instance\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"instanceLink\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"address\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"duration\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"OAuthAccount\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"provider\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"providerAccountId\",\"dbName\":\"provider_account_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"dbName\":\"user_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"OAuthAccountToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"provider\",\"providerAccountId\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"provider\",\"providerAccountId\"]}],\"isGenerated\":false},\"User\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"cuid\",\"args\":[1]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"emailVerified\",\"dbName\":\"email_verified\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"role\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"UserRole\",\"nativeType\":null,\"default\":\"USER\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"headline\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"location\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"about\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"avatarUrl\",\"dbName\":\"avatar_url\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"avatarMinioKey\",\"dbName\":\"avatar_minio_key\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bannerUrl\",\"dbName\":\"banner_url\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"bannerMinioKey\",\"dbName\":\"banner_minio_key\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"iconUrl\",\"dbName\":\"icon_url\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"hashedPassword\",\"dbName\":\"hashed_password\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"passwordSalt\",\"dbName\":\"password_salt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"passwordResets\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"PasswordResetToken\",\"nativeType\":null,\"relationName\":\"PasswordResetTokenToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"oauthAccounts\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"OAuthAccount\",\"nativeType\":null,\"relationName\":\"OAuthAccountToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"sessions\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Session\",\"nativeType\":null,\"relationName\":\"SessionToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"aiChat\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"AIChat\",\"nativeType\":null,\"relationName\":\"AIChatToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"publicChatMessages\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"PublicChatMessage\",\"nativeType\":null,\"relationName\":\"PublicChatMessageToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"created_at\",\"dbName\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updated_at\",\"dbName\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Session\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"dbName\":\"user_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"expiresAt\",\"dbName\":\"expires_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"SessionToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"PasswordResetToken\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"userId\",\"dbName\":\"user_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"hashedToken\",\"dbName\":\"hashed_token\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"expiresAt\",\"dbName\":\"expires_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"PasswordResetTokenToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"AIChat\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"cuid\",\"args\":[1]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"chatTitle\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"messages\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"AIChatMessage\",\"nativeType\":null,\"relationName\":\"AIChatToAIChatMessage\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"dbName\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"AIChatToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"AIChatMessage\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"cuid\",\"args\":[1]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"msg\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"role\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"dbName\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"AIChat\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"AIChat\",\"nativeType\":null,\"relationName\":\"AIChatToAIChatMessage\",\"relationFromFields\":[\"aIChatId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"aIChatId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"PublicChatMessage\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"cuid\",\"args\":[1]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"message\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":[\"Text\",[]],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"dbName\":\"user_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"PublicChatMessageToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"Cascade\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"replyToId\",\"dbName\":\"reply_to_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"replyTo\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"PublicChatMessage\",\"nativeType\":null,\"relationName\":\"MessageReplies\",\"relationFromFields\":[\"replyToId\"],\"relationToFields\":[\"id\"],\"relationOnDelete\":\"SetNull\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"replies\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"PublicChatMessage\",\"nativeType\":null,\"relationName\":\"MessageReplies\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"dbName\":\"created_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"dbName\":\"updated_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true},{\"name\":\"deletedAt\",\"dbName\":\"deleted_at\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{\"UserRole\":{\"values\":[{\"name\":\"ADMIN\",\"dbName\":null},{\"name\":\"USER\",\"dbName\":null},{\"name\":\"GUEST\",\"dbName\":null}],\"dbName\":null}},\"types\":{}}");
  defineDmmfProperty2(exports.Prisma, config2.runtimeDataModel);
  config2.engineWasm = undefined;
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config2.relativeEnvPaths.rootEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config2);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path.join(__dirname, "libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(process.cwd(), "node_modules/.prisma/client/libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(__dirname, "schema.prisma");
  path.join(process.cwd(), "node_modules/.prisma/client/schema.prisma");
});

// node_modules/.prisma/client/default.js
var require_default = __commonJS((exports, module) => {
  module.exports = { ...require_client() };
});

// node_modules/@prisma/client/default.js
var require_default2 = __commonJS((exports, module) => {
  module.exports = {
    ...require_default()
  };
});

// node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS((exports, module) => {
  var isErrorLike = (err) => {
    return err && typeof err.message === "string";
  };
  var getErrorCause = (err) => {
    if (!err)
      return;
    const cause = err.cause;
    if (typeof cause === "function") {
      const causeResult = err.cause();
      return isErrorLike(causeResult) ? causeResult : undefined;
    } else {
      return isErrorLike(cause) ? cause : undefined;
    }
  };
  var _stackWithCauses = (err, seen) => {
    if (!isErrorLike(err))
      return "";
    const stack = err.stack || "";
    if (seen.has(err)) {
      return stack + "\ncauses have become circular...";
    }
    const cause = getErrorCause(err);
    if (cause) {
      seen.add(err);
      return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
    } else {
      return stack;
    }
  };
  var stackWithCauses = (err) => _stackWithCauses(err, new Set);
  var _messageWithCauses = (err, seen, skip2) => {
    if (!isErrorLike(err))
      return "";
    const message = skip2 ? "" : err.message || "";
    if (seen.has(err)) {
      return message + ": ...";
    }
    const cause = getErrorCause(err);
    if (cause) {
      seen.add(err);
      const skipIfVErrorStyleCause = typeof err.cause === "function";
      return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
      return message;
    }
  };
  var messageWithCauses = (err) => _messageWithCauses(err, new Set);
  module.exports = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
  };
});

// node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS((exports, module) => {
  var seen = Symbol("circular-ref-tag");
  var rawSymbol = Symbol("pino-raw-err-ref");
  var pinoErrProto = Object.create({}, {
    type: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    message: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    stack: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    aggregateErrors: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
  });
  module.exports = {
    pinoErrProto,
    pinoErrorSymbols: {
      seen,
      rawSymbol
    }
  };
});

// node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS((exports, module) => {
  function errSerializer(err) {
    if (!isErrorLike(err)) {
      return err;
    }
    err[seen] = undefined;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
    _err.message = messageWithCauses(err);
    _err.stack = stackWithCauses(err);
    if (Array.isArray(err.errors)) {
      _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
    }
    for (const key in err) {
      if (_err[key] === undefined) {
        const val = err[key];
        if (isErrorLike(val)) {
          if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err[seen];
    _err.raw = err;
    return _err;
  }
  module.exports = errSerializer;
  var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
  var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
  var { seen } = pinoErrorSymbols;
  var { toString } = Object.prototype;
});

// node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS((exports, module) => {
  function errWithCauseSerializer(err) {
    if (!isErrorLike(err)) {
      return err;
    }
    err[seen] = undefined;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
    _err.message = err.message;
    _err.stack = err.stack;
    if (Array.isArray(err.errors)) {
      _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
    }
    if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
      _err.cause = errWithCauseSerializer(err.cause);
    }
    for (const key in err) {
      if (_err[key] === undefined) {
        const val = err[key];
        if (isErrorLike(val)) {
          if (!Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errWithCauseSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err[seen];
    _err.raw = err;
    return _err;
  }
  module.exports = errWithCauseSerializer;
  var { isErrorLike } = require_err_helpers();
  var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
  var { seen } = pinoErrorSymbols;
  var { toString } = Object.prototype;
});

// node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS((exports, module) => {
  function reqSerializer(req) {
    const connection = req.info || req.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : undefined);
    _req.method = req.method;
    if (req.originalUrl) {
      _req.url = req.originalUrl;
    } else {
      const path = req.path;
      _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : undefined;
    }
    if (req.query) {
      _req.query = req.query;
    }
    if (req.params) {
      _req.params = req.params;
    }
    _req.headers = req.headers;
    _req.remoteAddress = connection && connection.remoteAddress;
    _req.remotePort = connection && connection.remotePort;
    _req.raw = req.raw || req;
    return _req;
  }
  function mapHttpRequest(req) {
    return {
      req: reqSerializer(req)
    };
  }
  module.exports = {
    mapHttpRequest,
    reqSerializer
  };
  var rawSymbol = Symbol("pino-raw-req-ref");
  var pinoReqProto = Object.create({}, {
    id: {
      enumerable: true,
      writable: true,
      value: ""
    },
    method: {
      enumerable: true,
      writable: true,
      value: ""
    },
    url: {
      enumerable: true,
      writable: true,
      value: ""
    },
    query: {
      enumerable: true,
      writable: true,
      value: ""
    },
    params: {
      enumerable: true,
      writable: true,
      value: ""
    },
    headers: {
      enumerable: true,
      writable: true,
      value: {}
    },
    remoteAddress: {
      enumerable: true,
      writable: true,
      value: ""
    },
    remotePort: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
  });
});

// node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS((exports, module) => {
  function resSerializer(res) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res.headersSent ? res.statusCode : null;
    _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
    _res.raw = res;
    return _res;
  }
  function mapHttpResponse(res) {
    return {
      res: resSerializer(res)
    };
  }
  module.exports = {
    mapHttpResponse,
    resSerializer
  };
  var rawSymbol = Symbol("pino-raw-res-ref");
  var pinoResProto = Object.create({}, {
    statusCode: {
      enumerable: true,
      writable: true,
      value: 0
    },
    headers: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
  });
});

// node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS((exports, module) => {
  var errSerializer = require_err();
  var errWithCauseSerializer = require_err_with_cause();
  var reqSerializers = require_req();
  var resSerializers = require_res();
  module.exports = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
      if (customSerializer === errSerializer)
        return customSerializer;
      return function wrapErrSerializer(err) {
        return customSerializer(errSerializer(err));
      };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
      if (customSerializer === reqSerializers.reqSerializer)
        return customSerializer;
      return function wrappedReqSerializer(req) {
        return customSerializer(reqSerializers.reqSerializer(req));
      };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
      if (customSerializer === resSerializers.resSerializer)
        return customSerializer;
      return function wrappedResSerializer(res) {
        return customSerializer(resSerializers.resSerializer(res));
      };
    }
  };
});

// node_modules/pino/lib/caller.js
var require_caller = __commonJS((exports, module) => {
  function noOpPrepareStackTrace(_, stack) {
    return stack;
  }
  module.exports = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
      return;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries) {
      if (!entry) {
        continue;
      }
      fileNames.push(entry.getFileName());
    }
    return fileNames;
  };
});

// node_modules/@pinojs/redact/index.js
var require_redact = __commonJS((exports, module) => {
  function deepClone(obj) {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof Array) {
      const cloned = [];
      for (let i3 = 0;i3 < obj.length; i3++) {
        cloned[i3] = deepClone(obj[i3]);
      }
      return cloned;
    }
    if (typeof obj === "object") {
      const cloned = Object.create(Object.getPrototypeOf(obj));
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          cloned[key] = deepClone(obj[key]);
        }
      }
      return cloned;
    }
    return obj;
  }
  function parsePath(path) {
    const parts = [];
    let current = "";
    let inBrackets = false;
    let inQuotes = false;
    let quoteChar = "";
    for (let i3 = 0;i3 < path.length; i3++) {
      const char = path[i3];
      if (!inBrackets && char === ".") {
        if (current) {
          parts.push(current);
          current = "";
        }
      } else if (char === "[") {
        if (current) {
          parts.push(current);
          current = "";
        }
        inBrackets = true;
      } else if (char === "]" && inBrackets) {
        parts.push(current);
        current = "";
        inBrackets = false;
        inQuotes = false;
      } else if ((char === '"' || char === "'") && inBrackets) {
        if (!inQuotes) {
          inQuotes = true;
          quoteChar = char;
        } else if (char === quoteChar) {
          inQuotes = false;
          quoteChar = "";
        } else {
          current += char;
        }
      } else {
        current += char;
      }
    }
    if (current) {
      parts.push(current);
    }
    return parts;
  }
  function setValue(obj, parts, value15) {
    let current = obj;
    for (let i3 = 0;i3 < parts.length - 1; i3++) {
      const key = parts[i3];
      if (typeof current !== "object" || current === null || !(key in current)) {
        return false;
      }
      if (typeof current[key] !== "object" || current[key] === null) {
        return false;
      }
      current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === "*") {
      if (Array.isArray(current)) {
        for (let i3 = 0;i3 < current.length; i3++) {
          current[i3] = value15;
        }
      } else if (typeof current === "object" && current !== null) {
        for (const key in current) {
          if (Object.prototype.hasOwnProperty.call(current, key)) {
            current[key] = value15;
          }
        }
      }
    } else {
      if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
        current[lastKey] = value15;
      }
    }
    return true;
  }
  function removeKey(obj, parts) {
    let current = obj;
    for (let i3 = 0;i3 < parts.length - 1; i3++) {
      const key = parts[i3];
      if (typeof current !== "object" || current === null || !(key in current)) {
        return false;
      }
      if (typeof current[key] !== "object" || current[key] === null) {
        return false;
      }
      current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === "*") {
      if (Array.isArray(current)) {
        for (let i3 = 0;i3 < current.length; i3++) {
          current[i3] = undefined;
        }
      } else if (typeof current === "object" && current !== null) {
        for (const key in current) {
          if (Object.prototype.hasOwnProperty.call(current, key)) {
            delete current[key];
          }
        }
      }
    } else {
      if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
        delete current[lastKey];
      }
    }
    return true;
  }
  function getValueIfExists(obj, parts) {
    let current = obj;
    for (const part of parts) {
      if (current === null || current === undefined) {
        return PATH_NOT_FOUND;
      }
      if (typeof current !== "object" || current === null) {
        return PATH_NOT_FOUND;
      }
      if (!(part in current)) {
        return PATH_NOT_FOUND;
      }
      current = current[part];
    }
    return current;
  }
  function getValue(obj, parts) {
    let current = obj;
    for (const part of parts) {
      if (current === null || current === undefined) {
        return;
      }
      if (typeof current !== "object" || current === null) {
        return;
      }
      current = current[part];
    }
    return current;
  }
  function redactPaths(obj, paths, censor, remove = false) {
    for (const path of paths) {
      const parts = parsePath(path);
      if (parts.includes("*")) {
        redactWildcardPath(obj, parts, censor, path, remove);
      } else {
        if (remove) {
          removeKey(obj, parts);
        } else {
          const value15 = getValueIfExists(obj, parts);
          if (value15 === PATH_NOT_FOUND) {
            continue;
          }
          const actualCensor = typeof censor === "function" ? censor(value15, parts) : censor;
          setValue(obj, parts, actualCensor);
        }
      }
    }
  }
  function redactWildcardPath(obj, parts, censor, originalPath, remove = false) {
    const wildcardIndex = parts.indexOf("*");
    if (wildcardIndex === parts.length - 1) {
      const parentParts = parts.slice(0, -1);
      let current = obj;
      for (const part of parentParts) {
        if (current === null || current === undefined)
          return;
        if (typeof current !== "object" || current === null)
          return;
        current = current[part];
      }
      if (Array.isArray(current)) {
        if (remove) {
          for (let i3 = 0;i3 < current.length; i3++) {
            current[i3] = undefined;
          }
        } else {
          for (let i3 = 0;i3 < current.length; i3++) {
            const indexPath = [...parentParts, i3.toString()];
            const actualCensor = typeof censor === "function" ? censor(current[i3], indexPath) : censor;
            current[i3] = actualCensor;
          }
        }
      } else if (typeof current === "object" && current !== null) {
        if (remove) {
          const keysToDelete = [];
          for (const key in current) {
            if (Object.prototype.hasOwnProperty.call(current, key)) {
              keysToDelete.push(key);
            }
          }
          for (const key of keysToDelete) {
            delete current[key];
          }
        } else {
          for (const key in current) {
            const keyPath = [...parentParts, key];
            const actualCensor = typeof censor === "function" ? censor(current[key], keyPath) : censor;
            current[key] = actualCensor;
          }
        }
      }
    } else {
      redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove);
    }
  }
  function redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove = false) {
    const beforeWildcard = parts.slice(0, wildcardIndex);
    const afterWildcard = parts.slice(wildcardIndex + 1);
    const pathArray = [];
    function traverse(current, pathLength) {
      if (pathLength === beforeWildcard.length) {
        if (Array.isArray(current)) {
          for (let i3 = 0;i3 < current.length; i3++) {
            pathArray[pathLength] = i3.toString();
            traverse(current[i3], pathLength + 1);
          }
        } else if (typeof current === "object" && current !== null) {
          for (const key in current) {
            pathArray[pathLength] = key;
            traverse(current[key], pathLength + 1);
          }
        }
      } else if (pathLength < beforeWildcard.length) {
        const nextKey = beforeWildcard[pathLength];
        if (current && typeof current === "object" && current !== null && nextKey in current) {
          pathArray[pathLength] = nextKey;
          traverse(current[nextKey], pathLength + 1);
        }
      } else {
        if (afterWildcard.includes("*")) {
          const wrappedCensor = typeof censor === "function" ? (value15, path) => {
            const fullPath = [...pathArray.slice(0, pathLength), ...path];
            return censor(value15, fullPath);
          } : censor;
          redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove);
        } else {
          if (remove) {
            removeKey(current, afterWildcard);
          } else {
            const actualCensor = typeof censor === "function" ? censor(getValue(current, afterWildcard), [...pathArray.slice(0, pathLength), ...afterWildcard]) : censor;
            setValue(current, afterWildcard, actualCensor);
          }
        }
      }
    }
    if (beforeWildcard.length === 0) {
      traverse(obj, 0);
    } else {
      let current = obj;
      for (let i3 = 0;i3 < beforeWildcard.length; i3++) {
        const part = beforeWildcard[i3];
        if (current === null || current === undefined)
          return;
        if (typeof current !== "object" || current === null)
          return;
        current = current[part];
        pathArray[i3] = part;
      }
      if (current !== null && current !== undefined) {
        traverse(current, beforeWildcard.length);
      }
    }
  }
  function buildPathStructure(pathsToClone) {
    if (pathsToClone.length === 0) {
      return null;
    }
    const pathStructure = new Map;
    for (const path of pathsToClone) {
      const parts = parsePath(path);
      let current = pathStructure;
      for (let i3 = 0;i3 < parts.length; i3++) {
        const part = parts[i3];
        if (!current.has(part)) {
          current.set(part, new Map);
        }
        current = current.get(part);
      }
    }
    return pathStructure;
  }
  function selectiveClone(obj, pathStructure) {
    if (!pathStructure) {
      return obj;
    }
    function cloneSelectively(source, pathMap, depth = 0) {
      if (!pathMap || pathMap.size === 0) {
        return source;
      }
      if (source === null || typeof source !== "object") {
        return source;
      }
      if (source instanceof Date) {
        return new Date(source.getTime());
      }
      if (Array.isArray(source)) {
        const cloned2 = [];
        for (let i3 = 0;i3 < source.length; i3++) {
          const indexStr = i3.toString();
          if (pathMap.has(indexStr) || pathMap.has("*")) {
            cloned2[i3] = cloneSelectively(source[i3], pathMap.get(indexStr) || pathMap.get("*"));
          } else {
            cloned2[i3] = source[i3];
          }
        }
        return cloned2;
      }
      const cloned = Object.create(Object.getPrototypeOf(source));
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          if (pathMap.has(key) || pathMap.has("*")) {
            cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get("*"));
          } else {
            cloned[key] = source[key];
          }
        }
      }
      return cloned;
    }
    return cloneSelectively(obj, pathStructure);
  }
  function validatePath(path) {
    if (typeof path !== "string") {
      throw new Error("Paths must be (non-empty) strings");
    }
    if (path === "") {
      throw new Error("Invalid redaction path ()");
    }
    if (path.includes("..")) {
      throw new Error(`Invalid redaction path (${path})`);
    }
    if (path.includes(",")) {
      throw new Error(`Invalid redaction path (${path})`);
    }
    let bracketCount = 0;
    let inQuotes = false;
    let quoteChar = "";
    for (let i3 = 0;i3 < path.length; i3++) {
      const char = path[i3];
      if ((char === '"' || char === "'") && bracketCount > 0) {
        if (!inQuotes) {
          inQuotes = true;
          quoteChar = char;
        } else if (char === quoteChar) {
          inQuotes = false;
          quoteChar = "";
        }
      } else if (char === "[" && !inQuotes) {
        bracketCount++;
      } else if (char === "]" && !inQuotes) {
        bracketCount--;
        if (bracketCount < 0) {
          throw new Error(`Invalid redaction path (${path})`);
        }
      }
    }
    if (bracketCount !== 0) {
      throw new Error(`Invalid redaction path (${path})`);
    }
  }
  function validatePaths(paths) {
    if (!Array.isArray(paths)) {
      throw new TypeError("paths must be an array");
    }
    for (const path of paths) {
      validatePath(path);
    }
  }
  function slowRedact(options = {}) {
    const {
      paths = [],
      censor = "[REDACTED]",
      serialize = JSON.stringify,
      strict: strict4 = true,
      remove = false
    } = options;
    validatePaths(paths);
    const pathStructure = buildPathStructure(paths);
    return function redact(obj) {
      if (strict4 && (obj === null || typeof obj !== "object")) {
        if (obj === null || obj === undefined) {
          return serialize ? serialize(obj) : obj;
        }
        if (typeof obj !== "object") {
          return serialize ? serialize(obj) : obj;
        }
      }
      const cloned = selectiveClone(obj, pathStructure);
      const original = obj;
      let actualCensor = censor;
      if (typeof censor === "function") {
        actualCensor = censor;
      }
      redactPaths(cloned, paths, actualCensor, remove);
      if (serialize === false) {
        cloned.restore = function() {
          return deepClone(original);
        };
        return cloned;
      }
      if (typeof serialize === "function") {
        return serialize(cloned);
      }
      return JSON.stringify(cloned);
    };
  }
  var PATH_NOT_FOUND = Symbol("PATH_NOT_FOUND");
  module.exports = slowRedact;
});

// node_modules/pino/lib/symbols.js
var require_symbols = __commonJS((exports, module) => {
  var setLevelSym = Symbol("pino.setLevel");
  var getLevelSym = Symbol("pino.getLevel");
  var levelValSym = Symbol("pino.levelVal");
  var levelCompSym = Symbol("pino.levelComp");
  var useLevelLabelsSym = Symbol("pino.useLevelLabels");
  var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
  var mixinSym = Symbol("pino.mixin");
  var lsCacheSym = Symbol("pino.lsCache");
  var chindingsSym = Symbol("pino.chindings");
  var asJsonSym = Symbol("pino.asJson");
  var writeSym = Symbol("pino.write");
  var redactFmtSym = Symbol("pino.redactFmt");
  var timeSym = Symbol("pino.time");
  var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
  var streamSym = Symbol("pino.stream");
  var stringifySym = Symbol("pino.stringify");
  var stringifySafeSym = Symbol("pino.stringifySafe");
  var stringifiersSym = Symbol("pino.stringifiers");
  var endSym = Symbol("pino.end");
  var formatOptsSym = Symbol("pino.formatOpts");
  var messageKeySym = Symbol("pino.messageKey");
  var errorKeySym = Symbol("pino.errorKey");
  var nestedKeySym = Symbol("pino.nestedKey");
  var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
  var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
  var msgPrefixSym = Symbol("pino.msgPrefix");
  var wildcardFirstSym = Symbol("pino.wildcardFirst");
  var serializersSym = Symbol.for("pino.serializers");
  var formattersSym = Symbol.for("pino.formatters");
  var hooksSym = Symbol.for("pino.hooks");
  var needsMetadataGsym = Symbol.for("pino.metadata");
  module.exports = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    levelCompSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  };
});

// node_modules/pino/lib/redaction.js
var require_redaction = __commonJS((exports, module) => {
  function redaction(opts, serialize) {
    const { paths, censor, remove } = handle(opts);
    const shape = paths.reduce((o3, str) => {
      rx.lastIndex = 0;
      const first = rx.exec(str);
      const next = rx.exec(str);
      let ns = first[1] !== undefined ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
      if (ns === "*") {
        ns = wildcardFirstSym;
      }
      if (next === null) {
        o3[ns] = null;
        return o3;
      }
      if (o3[ns] === null) {
        return o3;
      }
      const { index } = next;
      const nextPath = `${str.substr(index, str.length - 1)}`;
      o3[ns] = o3[ns] || [];
      if (ns !== wildcardFirstSym && o3[ns].length === 0) {
        o3[ns].push(...o3[wildcardFirstSym] || []);
      }
      if (ns === wildcardFirstSym) {
        Object.keys(o3).forEach(function(k) {
          if (o3[k]) {
            o3[k].push(nextPath);
          }
        });
      }
      o3[ns].push(nextPath);
      return o3;
    }, {});
    const result = {
      [redactFmtSym]: Redact({ paths, censor, serialize, strict: strict4, remove })
    };
    const topCensor = (...args) => {
      return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
    };
    return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o3, k) => {
      if (shape[k] === null) {
        o3[k] = (value15) => topCensor(value15, [k]);
      } else {
        const wrappedCensor = typeof censor === "function" ? (value15, path) => {
          return censor(value15, [k, ...path]);
        } : censor;
        o3[k] = Redact({
          paths: shape[k],
          censor: wrappedCensor,
          serialize,
          strict: strict4,
          remove
        });
      }
      return o3;
    }, result);
  }
  function handle(opts) {
    if (Array.isArray(opts)) {
      opts = { paths: opts, censor: CENSOR };
      return opts;
    }
    let { paths, censor = CENSOR, remove } = opts;
    if (Array.isArray(paths) === false) {
      throw Error("pino \u2013 redact must contain an array of strings");
    }
    if (remove === true)
      censor = undefined;
    return { paths, censor, remove };
  }
  var Redact = require_redact();
  var { redactFmtSym, wildcardFirstSym } = require_symbols();
  var rx = /[^.[\]]+|\[([^[\]]*?)\]/g;
  var CENSOR = "[Redacted]";
  var strict4 = false;
  module.exports = redaction;
});

// node_modules/pino/lib/time.js
var require_time = __commonJS((exports, module) => {
  var nullTime = () => "";
  var epochTime = () => `,"time":${Date.now()}`;
  var unixTime = () => `,"time":${Math.round(Date.now() / 1000)}`;
  var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
  var NS_PER_MS = 1000000n;
  var NS_PER_SEC = 1000000000n;
  var startWallTimeNs = BigInt(Date.now()) * NS_PER_MS;
  var startHrTime = process.hrtime.bigint();
  var isoTimeNano = () => {
    const elapsedNs = process.hrtime.bigint() - startHrTime;
    const currentTimeNs = startWallTimeNs + elapsedNs;
    const secondsSinceEpoch = currentTimeNs / NS_PER_SEC;
    const nanosWithinSecond = currentTimeNs % NS_PER_SEC;
    const msSinceEpoch = Number(secondsSinceEpoch * 1000n + nanosWithinSecond / 1000000n);
    const date5 = new Date(msSinceEpoch);
    const year = date5.getUTCFullYear();
    const month = (date5.getUTCMonth() + 1).toString().padStart(2, "0");
    const day = date5.getUTCDate().toString().padStart(2, "0");
    const hours = date5.getUTCHours().toString().padStart(2, "0");
    const minutes = date5.getUTCMinutes().toString().padStart(2, "0");
    const seconds = date5.getUTCSeconds().toString().padStart(2, "0");
    return `,"time":"${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${nanosWithinSecond.toString().padStart(9, "0")}Z"`;
  };
  module.exports = { nullTime, epochTime, unixTime, isoTime, isoTimeNano };
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS((exports, module) => {
  function tryStringify(o3) {
    try {
      return JSON.stringify(o3);
    } catch (e) {
      return '"[Circular]"';
    }
  }
  function format(f3, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f3 === "object" && f3 !== null) {
      var len = args.length + offset;
      if (len === 1)
        return f3;
      var objects = new Array(len);
      objects[0] = ss(f3);
      for (var index = 1;index < len; index++) {
        objects[index] = ss(args[index]);
      }
      return objects.join(" ");
    }
    if (typeof f3 !== "string") {
      return f3;
    }
    var argLen = args.length;
    if (argLen === 0)
      return f3;
    var str = "";
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f3 && f3.length || 0;
    for (var i3 = 0;i3 < flen; ) {
      if (f3.charCodeAt(i3) === 37 && i3 + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f3.charCodeAt(i3 + 1)) {
          case 100:
          case 102:
            if (a >= argLen)
              break;
            if (args[a] == null)
              break;
            if (lastPos < i3)
              str += f3.slice(lastPos, i3);
            str += Number(args[a]);
            lastPos = i3 + 2;
            i3++;
            break;
          case 105:
            if (a >= argLen)
              break;
            if (args[a] == null)
              break;
            if (lastPos < i3)
              str += f3.slice(lastPos, i3);
            str += Math.floor(Number(args[a]));
            lastPos = i3 + 2;
            i3++;
            break;
          case 79:
          case 111:
          case 106:
            if (a >= argLen)
              break;
            if (args[a] === undefined)
              break;
            if (lastPos < i3)
              str += f3.slice(lastPos, i3);
            var type47 = typeof args[a];
            if (type47 === "string") {
              str += "\'" + args[a] + "\'";
              lastPos = i3 + 2;
              i3++;
              break;
            }
            if (type47 === "function") {
              str += args[a].name || "<anonymous>";
              lastPos = i3 + 2;
              i3++;
              break;
            }
            str += ss(args[a]);
            lastPos = i3 + 2;
            i3++;
            break;
          case 115:
            if (a >= argLen)
              break;
            if (lastPos < i3)
              str += f3.slice(lastPos, i3);
            str += String(args[a]);
            lastPos = i3 + 2;
            i3++;
            break;
          case 37:
            if (lastPos < i3)
              str += f3.slice(lastPos, i3);
            str += "%";
            lastPos = i3 + 2;
            i3++;
            a--;
            break;
        }
        ++a;
      }
      ++i3;
    }
    if (lastPos === -1)
      return f3;
    else if (lastPos < flen) {
      str += f3.slice(lastPos);
    }
    return str;
  }
  module.exports = format;
});

// node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS((exports, module) => {
  if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      Atomics.wait(nil, 0, 0, Number(ms));
    };
    const nil = new Int32Array(new SharedArrayBuffer(4));
    module.exports = sleep;
  } else {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      const target = Date.now() + Number(ms);
      while (target > Date.now()) {
      }
    };
    module.exports = sleep;
  }
});

// node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS((exports, module) => {
  function openFile(file, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    function fileOpened(err, fd) {
      if (err) {
        sonic._reopening = false;
        sonic._writing = false;
        sonic._opening = false;
        if (sonic.sync) {
          process.nextTick(() => {
            if (sonic.listenerCount("error") > 0) {
              sonic.emit("error", err);
            }
          });
        } else {
          sonic.emit("error", err);
        }
        return;
      }
      const reopening = sonic._reopening;
      sonic.fd = fd;
      sonic.file = file;
      sonic._reopening = false;
      sonic._opening = false;
      sonic._writing = false;
      if (sonic.sync) {
        process.nextTick(() => sonic.emit("ready"));
      } else {
        sonic.emit("ready");
      }
      if (sonic.destroyed) {
        return;
      }
      if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
        sonic._actualWrite();
      } else if (reopening) {
        process.nextTick(() => sonic.emit("drain"));
      }
    }
    const flags = sonic.append ? "a" : "w";
    const mode = sonic.mode;
    if (sonic.sync) {
      try {
        if (sonic.mkdir)
          fs2.mkdirSync(path.dirname(file), { recursive: true });
        const fd = fs2.openSync(file, flags, mode);
        fileOpened(null, fd);
      } catch (err) {
        fileOpened(err);
        throw err;
      }
    } else if (sonic.mkdir) {
      fs2.mkdir(path.dirname(file), { recursive: true }, (err) => {
        if (err)
          return fileOpened(err);
        fs2.open(file, flags, mode, fileOpened);
      });
    } else {
      fs2.open(file, flags, mode, fileOpened);
    }
  }
  function SonicBoom(opts) {
    if (!(this instanceof SonicBoom)) {
      return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
    fd = fd || dest;
    this._len = 0;
    this.fd = -1;
    this._bufs = [];
    this._lens = [];
    this._writing = false;
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._flushPending = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this._periodicFlush = periodicFlush || 0;
    this._periodicFlushTimer = undefined;
    this.sync = sync || false;
    this.writable = true;
    this._fsync = fsync || false;
    this.append = append || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (() => true);
    this.mkdir = mkdir || false;
    let fsWriteSync;
    let fsWrite;
    if (contentMode === kContentModeBuffer) {
      this._writingBuf = kEmptyBuffer;
      this.write = writeBuffer;
      this.flush = flushBuffer;
      this.flushSync = flushBufferSync;
      this._actualWrite = actualWriteBuffer;
      fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf);
      fsWrite = () => fs2.write(this.fd, this._writingBuf, this.release);
    } else if (contentMode === undefined || contentMode === kContentModeUtf8) {
      this._writingBuf = "";
      this.write = write;
      this.flush = flush;
      this.flushSync = flushSync;
      this._actualWrite = actualWrite;
      fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf, "utf8");
      fsWrite = () => fs2.write(this.fd, this._writingBuf, "utf8", this.release);
    } else {
      throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
    }
    if (typeof fd === "number") {
      this.fd = fd;
      process.nextTick(() => this.emit("ready"));
    } else if (typeof fd === "string") {
      openFile(fd, this);
    } else {
      throw new Error("SonicBoom supports only file descriptors and files");
    }
    if (this.minLength >= this.maxWrite) {
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err, n3) => {
      if (err) {
        if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
          if (this.sync) {
            try {
              sleep(BUSY_WRITE_TIMEOUT);
              this.release(undefined, 0);
            } catch (err2) {
              this.release(err2);
            }
          } else {
            setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
          }
        } else {
          this._writing = false;
          this.emit("error", err);
        }
        return;
      }
      this.emit("write", n3);
      const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n3);
      this._len = releasedBufObj.len;
      this._writingBuf = releasedBufObj.writingBuf;
      if (this._writingBuf.length) {
        if (!this.sync) {
          fsWrite();
          return;
        }
        try {
          do {
            const n4 = fsWriteSync();
            const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n4);
            this._len = releasedBufObj2.len;
            this._writingBuf = releasedBufObj2.writingBuf;
          } while (this._writingBuf.length);
        } catch (err2) {
          this.release(err2);
          return;
        }
      }
      if (this._fsync) {
        fs2.fsyncSync(this.fd);
      }
      const len = this._len;
      if (this._reopening) {
        this._writing = false;
        this._reopening = false;
        this.reopen();
      } else if (len > this.minLength) {
        this._actualWrite();
      } else if (this._ending) {
        if (len > 0) {
          this._actualWrite();
        } else {
          this._writing = false;
          actualClose(this);
        }
      } else {
        this._writing = false;
        if (this.sync) {
          if (!this._asyncDrainScheduled) {
            this._asyncDrainScheduled = true;
            process.nextTick(emitDrain, this);
          }
        } else {
          this.emit("drain");
        }
      }
    };
    this.on("newListener", function(name) {
      if (name === "drain") {
        this._asyncDrainScheduled = false;
      }
    });
    if (this._periodicFlush !== 0) {
      this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
      this._periodicFlushTimer.unref();
    }
  }
  function releaseWritingBuf(writingBuf, len, n3) {
    if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n3) {
      n3 = Buffer.from(writingBuf).subarray(0, n3).toString().length;
    }
    len = Math.max(len - n3, 0);
    writingBuf = writingBuf.slice(n3);
    return { writingBuf, len };
  }
  function emitDrain(sonic) {
    const hasListeners = sonic.listenerCount("drain") > 0;
    if (!hasListeners)
      return;
    sonic._asyncDrainScheduled = false;
    sonic.emit("drain");
  }
  function mergeBuf(bufs, len) {
    if (bufs.length === 0) {
      return kEmptyBuffer;
    }
    if (bufs.length === 1) {
      return bufs[0];
    }
    return Buffer.concat(bufs, len);
  }
  function write(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
      bufs.push("" + data);
    } else {
      bufs[bufs.length - 1] += data;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function writeBuffer(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    const lens = this._lens;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
      bufs.push([data]);
      lens.push(data.length);
    } else {
      bufs[bufs.length - 1].push(data);
      lens[lens.length - 1] += data.length;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function callFlushCallbackOnDrain(cb) {
    this._flushPending = true;
    const onDrain = () => {
      if (!this._fsync) {
        try {
          fs2.fsync(this.fd, (err) => {
            this._flushPending = false;
            cb(err);
          });
        } catch (err) {
          cb(err);
        }
      } else {
        this._flushPending = false;
        cb();
      }
      this.off("error", onError);
    };
    const onError = (err) => {
      this._flushPending = false;
      cb(err);
      this.off("drain", onDrain);
    };
    this.once("drain", onDrain);
    this.once("error", onError);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error23 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error23);
        return;
      }
      throw error23;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push("");
    }
    this._actualWrite();
  }
  function flushBuffer(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error23 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error23);
        return;
      }
      throw error23;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push([]);
      this._lens.push(0);
    }
    this._actualWrite();
  }
  function flushSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift(this._writingBuf);
      this._writingBuf = "";
    }
    let buf = "";
    while (this._bufs.length || buf) {
      if (buf.length <= 0) {
        buf = this._bufs[0];
      }
      try {
        const n3 = fs2.writeSync(this.fd, buf, "utf8");
        const releasedBufObj = releaseWritingBuf(buf, this._len, n3);
        buf = releasedBufObj.writingBuf;
        this._len = releasedBufObj.len;
        if (buf.length <= 0) {
          this._bufs.shift();
        }
      } catch (err) {
        const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
          throw err;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
    try {
      fs2.fsyncSync(this.fd);
    } catch {
    }
  }
  function flushBufferSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift([this._writingBuf]);
      this._writingBuf = kEmptyBuffer;
    }
    let buf = kEmptyBuffer;
    while (this._bufs.length || buf.length) {
      if (buf.length <= 0) {
        buf = mergeBuf(this._bufs[0], this._lens[0]);
      }
      try {
        const n3 = fs2.writeSync(this.fd, buf);
        buf = buf.subarray(n3);
        this._len = Math.max(this._len - n3, 0);
        if (buf.length <= 0) {
          this._bufs.shift();
          this._lens.shift();
        }
      } catch (err) {
        const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
          throw err;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
  }
  function actualWrite() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf || this._bufs.shift() || "";
    if (this.sync) {
      try {
        const written = fs2.writeSync(this.fd, this._writingBuf, "utf8");
        release(null, written);
      } catch (err) {
        release(err);
      }
    } else {
      fs2.write(this.fd, this._writingBuf, "utf8", release);
    }
  }
  function actualWriteBuffer() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
    if (this.sync) {
      try {
        const written = fs2.writeSync(this.fd, this._writingBuf);
        release(null, written);
      } catch (err) {
        release(err);
      }
    } else {
      if (kCopyBuffer) {
        this._writingBuf = Buffer.from(this._writingBuf);
      }
      fs2.write(this.fd, this._writingBuf, release);
    }
  }
  function actualClose(sonic) {
    if (sonic.fd === -1) {
      sonic.once("ready", actualClose.bind(null, sonic));
      return;
    }
    if (sonic._periodicFlushTimer !== undefined) {
      clearInterval(sonic._periodicFlushTimer);
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    sonic._lens = [];
    assert(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
    try {
      fs2.fsync(sonic.fd, closeWrapped);
    } catch {
    }
    function closeWrapped() {
      if (sonic.fd !== 1 && sonic.fd !== 2) {
        fs2.close(sonic.fd, done);
      } else {
        done();
      }
    }
    function done(err) {
      if (err) {
        sonic.emit("error", err);
        return;
      }
      if (sonic._ending && !sonic._writing) {
        sonic.emit("finish");
      }
      sonic.emit("close");
    }
  }
  var fs2 = import.meta.require("fs");
  var EventEmitter = import.meta.require("events");
  var inherits = import.meta.require("util").inherits;
  var path = import.meta.require("path");
  var sleep = require_atomic_sleep();
  var assert = import.meta.require("assert");
  var BUSY_WRITE_TIMEOUT = 100;
  var kEmptyBuffer = Buffer.allocUnsafe(0);
  var MAX_WRITE = 16 * 1024;
  var kContentModeBuffer = "buffer";
  var kContentModeUtf8 = "utf8";
  var [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
  var kCopyBuffer = major >= 22 && minor >= 7;
  inherits(SonicBoom, EventEmitter);
  SonicBoom.prototype.reopen = function(file) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.reopen(file);
      });
      return;
    }
    if (this._ending) {
      return;
    }
    if (!this.file) {
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    }
    if (file) {
      this.file = file;
    }
    this._reopening = true;
    if (this._writing) {
      return;
    }
    const fd = this.fd;
    this.once("ready", () => {
      if (fd !== this.fd) {
        fs2.close(fd, (err) => {
          if (err) {
            return this.emit("error", err);
          }
        });
      }
    });
    openFile(this.file, this);
  };
  SonicBoom.prototype.end = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    if (this._ending) {
      return;
    }
    this._ending = true;
    if (this._writing) {
      return;
    }
    if (this._len > 0 && this.fd >= 0) {
      this._actualWrite();
    } else {
      actualClose(this);
    }
  };
  SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
      return;
    }
    actualClose(this);
  };
  SonicBoom.SonicBoom = SonicBoom;
  SonicBoom.default = SonicBoom;
  module.exports = SonicBoom;
});

// node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS((exports, module) => {
  function ensureRegistry() {
    if (registry7 === undefined) {
      registry7 = new FinalizationRegistry(clear);
    }
  }
  function install(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.on(event, functions[event]);
  }
  function uninstall(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.removeListener(event, functions[event]);
    if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
      registry7 = undefined;
    }
  }
  function onExit() {
    callRefs("exit");
  }
  function onBeforeExit() {
    callRefs("beforeExit");
  }
  function callRefs(event) {
    for (const ref4 of refs[event]) {
      const obj = ref4.deref();
      const fn = ref4.fn;
      if (obj !== undefined) {
        fn(obj, event);
      }
    }
    refs[event] = [];
  }
  function clear(ref4) {
    for (const event of ["exit", "beforeExit"]) {
      const index = refs[event].indexOf(ref4);
      refs[event].splice(index, index + 1);
      uninstall(event);
    }
  }
  function _register(event, obj, fn) {
    if (obj === undefined) {
      throw new Error("the object can\'t be undefined");
    }
    install(event);
    const ref4 = new WeakRef(obj);
    ref4.fn = fn;
    ensureRegistry();
    registry7.register(obj, ref4);
    refs[event].push(ref4);
  }
  function register(obj, fn) {
    _register("exit", obj, fn);
  }
  function registerBeforeExit(obj, fn) {
    _register("beforeExit", obj, fn);
  }
  function unregister(obj) {
    if (registry7 === undefined) {
      return;
    }
    registry7.unregister(obj);
    for (const event of ["exit", "beforeExit"]) {
      refs[event] = refs[event].filter((ref4) => {
        const _obj = ref4.deref();
        return _obj && _obj !== obj;
      });
      uninstall(event);
    }
  }
  var refs = {
    exit: [],
    beforeExit: []
  };
  var functions = {
    exit: onExit,
    beforeExit: onBeforeExit
  };
  var registry7;
  module.exports = {
    register,
    registerBeforeExit,
    unregister
  };
});

// node_modules/thread-stream/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "thread-stream",
    version: "3.1.0",
    description: "A streaming way to send data to a Node.js Worker Thread",
    main: "index.js",
    types: "index.d.ts",
    dependencies: {
      "real-require": "^0.2.0"
    },
    devDependencies: {
      "@types/node": "^20.1.0",
      "@types/tap": "^15.0.0",
      "@yao-pkg/pkg": "^5.11.5",
      desm: "^1.3.0",
      fastbench: "^1.0.1",
      husky: "^9.0.6",
      "pino-elasticsearch": "^8.0.0",
      "sonic-boom": "^4.0.1",
      standard: "^17.0.0",
      tap: "^16.2.0",
      "ts-node": "^10.8.0",
      typescript: "^5.3.2",
      "why-is-node-running": "^2.2.2"
    },
    scripts: {
      build: "tsc --noEmit",
      test: "standard && npm run build && npm run transpile && tap \"test/**/*.test.*js\" && tap --ts test/*.test.*ts",
      "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
      "test:ci:js": "tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \"test/**/*.test.*js\"",
      "test:ci:ts": "tap --ts --no-check-coverage --coverage-report=lcovonly \"test/**/*.test.*ts\"",
      "test:yarn": "npm run transpile && tap \"test/**/*.test.js\" --no-check-coverage",
      transpile: "sh ./test/ts/transpile.sh",
      prepare: "husky install"
    },
    standard: {
      ignore: [
        "test/ts/**/*",
        "test/syntax-error.mjs"
      ]
    },
    repository: {
      type: "git",
      url: "git+https://github.com/mcollina/thread-stream.git"
    },
    keywords: [
      "worker",
      "thread",
      "threads",
      "stream"
    ],
    author: "Matteo Collina <hello@matteocollina.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/mcollina/thread-stream/issues"
    },
    homepage: "https://github.com/mcollina/thread-stream#readme"
  };
});

// node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS((exports, module) => {
  function wait(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current === expected) {
      done(null, "ok");
      return;
    }
    let prior = current;
    const check11 = (backoff) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          prior = current;
          current = Atomics.load(state, index);
          if (current === prior) {
            check11(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          } else {
            if (current === expected)
              done(null, "ok");
            else
              done(null, "not-equal");
          }
        }, backoff);
      }
    };
    check11(1);
  }
  function waitDiff(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current !== expected) {
      done(null, "ok");
      return;
    }
    const check11 = (backoff) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          current = Atomics.load(state, index);
          if (current !== expected) {
            done(null, "ok");
          } else {
            check11(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          }
        }, backoff);
      }
    };
    check11(1);
  }
  var MAX_TIMEOUT = 1000;
  module.exports = { wait, waitDiff };
});

// node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS((exports, module) => {
  var WRITE_INDEX = 4;
  var READ_INDEX = 8;
  module.exports = {
    WRITE_INDEX,
    READ_INDEX
  };
});

// node_modules/thread-stream/index.js
var require_thread_stream = __commonJS((exports, module) => {
  function createWorker(stream, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides["thread-stream-worker"] || join2(__dirname, "lib", "worker.js");
    const worker = new Worker(toExecute, {
      ...opts.workerOpts,
      trackUnmanagedFds: false,
      workerData: {
        filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
        dataBuf: stream[kImpl].dataBuf,
        stateBuf: stream[kImpl].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: version
          },
          ...workerData
        }
      }
    });
    worker.stream = new FakeWeakRef(stream);
    worker.on("message", onWorkerMessage);
    worker.on("exit", onWorkerExit);
    registry7.register(stream, worker);
    return worker;
  }
  function drain(stream) {
    assert(!stream[kImpl].sync);
    if (stream[kImpl].needDrain) {
      stream[kImpl].needDrain = false;
      stream.emit("drain");
    }
  }
  function nextFlush(stream) {
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let leftover = stream[kImpl].data.length - writeIndex;
    if (leftover > 0) {
      if (stream[kImpl].buf.length === 0) {
        stream[kImpl].flushing = false;
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
        return;
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, nextFlush.bind(null, stream));
      } else {
        stream.flush(() => {
          if (stream.destroyed) {
            return;
          }
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].data.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        });
      }
    } else if (leftover === 0) {
      if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
        return;
      }
      stream.flush(() => {
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        nextFlush(stream);
      });
    } else {
      destroy(stream, new Error("overwritten"));
    }
  }
  function onWorkerMessage(msg) {
    const stream = this.stream.deref();
    if (stream === undefined) {
      this.exited = true;
      this.terminate();
      return;
    }
    switch (msg.code) {
      case "READY":
        this.stream = new WeakRef2(stream);
        stream.flush(() => {
          stream[kImpl].ready = true;
          stream.emit("ready");
        });
        break;
      case "ERROR":
        destroy(stream, msg.err);
        break;
      case "EVENT":
        if (Array.isArray(msg.args)) {
          stream.emit(msg.name, ...msg.args);
        } else {
          stream.emit(msg.name, msg.args);
        }
        break;
      case "WARNING":
        process.emitWarning(msg.err);
        break;
      default:
        destroy(stream, new Error("this should not happen: " + msg.code));
    }
  }
  function onWorkerExit(code) {
    const stream = this.stream.deref();
    if (stream === undefined) {
      return;
    }
    registry7.unregister(stream);
    stream.worker.exited = true;
    stream.worker.off("exit", onWorkerExit);
    destroy(stream, code !== 0 ? new Error("the worker thread exited") : null);
  }
  function error23(stream, err) {
    setImmediate(() => {
      stream.emit("error", err);
    });
  }
  function destroy(stream, err) {
    if (stream[kImpl].destroyed) {
      return;
    }
    stream[kImpl].destroyed = true;
    if (err) {
      stream[kImpl].errored = err;
      error23(stream, err);
    }
    if (!stream.worker.exited) {
      stream.worker.terminate().catch(() => {
      }).then(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    } else {
      setImmediate(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    }
  }
  function write(stream, data, cb) {
    const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data);
    stream[kImpl].data.write(data, current);
    Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
    Atomics.notify(stream[kImpl].state, WRITE_INDEX);
    cb();
    return true;
  }
  function end(stream) {
    if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
      return;
    }
    stream[kImpl].ended = true;
    try {
      stream.flushSync();
      let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (readIndex !== -1) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
        readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          destroy(stream, new Error("end() failed"));
          return;
        }
        if (++spins === 10) {
          destroy(stream, new Error("end() took too long (10s)"));
          return;
        }
      }
      process.nextTick(() => {
        stream[kImpl].finished = true;
        stream.emit("finish");
      });
    } catch (err) {
      destroy(stream, err);
    }
  }
  function writeSync(stream) {
    const cb = () => {
      if (stream[kImpl].ending) {
        end(stream);
      } else if (stream[kImpl].needDrain) {
        process.nextTick(drain, stream);
      }
    };
    stream[kImpl].flushing = false;
    while (stream[kImpl].buf.length !== 0) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover === 0) {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        continue;
      } else if (leftover < 0) {
        throw new Error("overwritten");
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      } else {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        while (toWriteBytes > stream[kImpl].buf.length) {
          leftover = leftover / 2;
          toWrite = stream[kImpl].buf.slice(0, leftover);
          toWriteBytes = Buffer.byteLength(toWrite);
        }
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      }
    }
  }
  function flushSync(stream) {
    if (stream[kImpl].flushing) {
      throw new Error("unable to flush while flushing");
    }
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let spins = 0;
    while (true) {
      const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      if (readIndex === -2) {
        throw Error("_flushSync failed");
      }
      if (readIndex !== writeIndex) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
      } else {
        break;
      }
      if (++spins === 10) {
        throw new Error("_flushSync took too long (10s)");
      }
    }
  }
  var __dirname = "/home/natee/workspace/portfolio-v3-api/node_modules/thread-stream";
  var { version } = require_package();
  var { EventEmitter } = import.meta.require("events");
  var { Worker } = import.meta.require("worker_threads");
  var { join: join2 } = import.meta.require("path");
  var { pathToFileURL } = import.meta.require("url");
  var { wait } = require_wait();
  var {
    WRITE_INDEX,
    READ_INDEX
  } = require_indexes();
  var buffer = import.meta.require("buffer");
  var assert = import.meta.require("assert");
  var kImpl = Symbol("kImpl");
  var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;

  class FakeWeakRef {
    constructor(value15) {
      this._value = value15;
    }
    deref() {
      return this._value;
    }
  }

  class FakeFinalizationRegistry {
    register() {
    }
    unregister() {
    }
  }
  var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
  var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
  var registry7 = new FinalizationRegistry2((worker) => {
    if (worker.exited) {
      return;
    }
    worker.terminate();
  });

  class ThreadStream extends EventEmitter {
    constructor(opts = {}) {
      super();
      if (opts.bufferSize < 4) {
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      }
      this[kImpl] = {};
      this[kImpl].stateBuf = new SharedArrayBuffer(128);
      this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
      this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
      this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
      this[kImpl].sync = opts.sync || false;
      this[kImpl].ending = false;
      this[kImpl].ended = false;
      this[kImpl].needDrain = false;
      this[kImpl].destroyed = false;
      this[kImpl].flushing = false;
      this[kImpl].ready = false;
      this[kImpl].finished = false;
      this[kImpl].errored = null;
      this[kImpl].closed = false;
      this[kImpl].buf = "";
      this.worker = createWorker(this, opts);
      this.on("message", (message, transferList) => {
        this.worker.postMessage(message, transferList);
      });
    }
    write(data) {
      if (this[kImpl].destroyed) {
        error23(this, new Error("the worker has exited"));
        return false;
      }
      if (this[kImpl].ending) {
        error23(this, new Error("the worker is ending"));
        return false;
      }
      if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
        try {
          writeSync(this);
          this[kImpl].flushing = true;
        } catch (err) {
          destroy(this, err);
          return false;
        }
      }
      this[kImpl].buf += data;
      if (this[kImpl].sync) {
        try {
          writeSync(this);
          return true;
        } catch (err) {
          destroy(this, err);
          return false;
        }
      }
      if (!this[kImpl].flushing) {
        this[kImpl].flushing = true;
        setImmediate(nextFlush, this);
      }
      this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
      return !this[kImpl].needDrain;
    }
    end() {
      if (this[kImpl].destroyed) {
        return;
      }
      this[kImpl].ending = true;
      end(this);
    }
    flush(cb) {
      if (this[kImpl].destroyed) {
        if (typeof cb === "function") {
          process.nextTick(cb, new Error("the worker has exited"));
        }
        return;
      }
      const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
      wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
        if (err) {
          destroy(this, err);
          process.nextTick(cb, err);
          return;
        }
        if (res === "not-equal") {
          this.flush(cb);
          return;
        }
        process.nextTick(cb);
      });
    }
    flushSync() {
      if (this[kImpl].destroyed) {
        return;
      }
      writeSync(this);
      flushSync(this);
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[kImpl].ready;
    }
    get destroyed() {
      return this[kImpl].destroyed;
    }
    get closed() {
      return this[kImpl].closed;
    }
    get writable() {
      return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
      return this[kImpl].ending;
    }
    get writableFinished() {
      return this[kImpl].finished;
    }
    get writableNeedDrain() {
      return this[kImpl].needDrain;
    }
    get writableObjectMode() {
      return false;
    }
    get writableErrored() {
      return this[kImpl].errored;
    }
  }
  module.exports = ThreadStream;
});

// node_modules/pino/lib/transport.js
var require_transport = __commonJS((exports, module) => {
  function setupOnExit(stream) {
    onExit.register(stream, autoEnd);
    onExit.registerBeforeExit(stream, flush);
    stream.on("close", function() {
      onExit.unregister(stream);
    });
  }
  function buildStream(filename, workerData, workerOpts, sync) {
    const stream = new ThreadStream({
      filename,
      workerData,
      workerOpts,
      sync
    });
    stream.on("ready", onReady);
    stream.on("close", function() {
      process.removeListener("exit", onExit2);
    });
    process.on("exit", onExit2);
    function onReady() {
      process.removeListener("exit", onExit2);
      stream.unref();
      if (workerOpts.autoEnd !== false) {
        setupOnExit(stream);
      }
    }
    function onExit2() {
      if (stream.closed) {
        return;
      }
      stream.flushSync();
      sleep(100);
      stream.end();
    }
    return stream;
  }
  function autoEnd(stream) {
    stream.ref();
    stream.flushSync();
    stream.end();
    stream.once("close", function() {
      stream.unref();
    });
  }
  function flush(stream) {
    stream.flushSync();
  }
  function transport(fullOptions) {
    const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;
    const options = {
      ...fullOptions.options
    };
    const callers = typeof caller === "string" ? [caller] : caller;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let target = fullOptions.target;
    if (target && targets) {
      throw new Error("only one of target or targets can be specified");
    }
    if (targets) {
      target = bundlerOverrides["pino-worker"] || join2(__dirname, "worker.js");
      options.targets = targets.filter((dest) => dest.target).map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
      options.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
        return dest.pipeline.map((t3) => {
          return {
            ...t3,
            level: dest.level,
            target: fixTarget(t3.target)
          };
        });
      });
    } else if (pipeline) {
      target = bundlerOverrides["pino-worker"] || join2(__dirname, "worker.js");
      options.pipelines = [pipeline.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      })];
    }
    if (levels) {
      options.levels = levels;
    }
    if (dedupe) {
      options.dedupe = dedupe;
    }
    options.pinoWillSendConfig = true;
    return buildStream(fixTarget(target), options, worker, sync);
    function fixTarget(origin) {
      origin = bundlerOverrides[origin] || origin;
      if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
        return origin;
      }
      if (origin === "pino/file") {
        return join2(__dirname, "..", "file.js");
      }
      let fixTarget2;
      for (const filePath of callers) {
        try {
          const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
          fixTarget2 = createRequire(context).resolve(origin);
          break;
        } catch (err) {
          continue;
        }
      }
      if (!fixTarget2) {
        throw new Error(`unable to determine transport target for "${origin}"`);
      }
      return fixTarget2;
    }
  }
  var __dirname = "/home/natee/workspace/portfolio-v3-api/node_modules/pino/lib";
  var { createRequire } = import.meta.require("module");
  var getCallers = require_caller();
  var { join: join2, isAbsolute, sep } = import.meta.require("path");
  var sleep = require_atomic_sleep();
  var onExit = require_on_exit_leak_free();
  var ThreadStream = require_thread_stream();
  module.exports = transport;
});

// node_modules/pino/lib/tools.js
var require_tools = __commonJS((exports, module) => {
  function noop() {
  }
  function genLog(level, hook) {
    if (!hook)
      return LOG;
    return function hookWrappedLog(...args) {
      hook.call(this, args, LOG, level);
    };
    function LOG(o3, ...n3) {
      if (typeof o3 === "object") {
        let msg = o3;
        if (o3 !== null) {
          if (o3.method && o3.headers && o3.socket) {
            o3 = mapHttpRequest(o3);
          } else if (typeof o3.setHeader === "function") {
            o3 = mapHttpResponse(o3);
          }
        }
        let formatParams;
        if (msg === null && n3.length === 0) {
          formatParams = [null];
        } else {
          msg = n3.shift();
          formatParams = n3;
        }
        if (typeof this[msgPrefixSym] === "string" && msg !== undefined && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](o3, format(msg, formatParams, this[formatOptsSym]), level);
      } else {
        let msg = o3 === undefined ? n3.shift() : o3;
        if (typeof this[msgPrefixSym] === "string" && msg !== undefined && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](null, format(msg, n3, this[formatOptsSym]), level);
      }
    }
  }
  function asString(str) {
    let result = "";
    let last = 0;
    let found = false;
    let point = 255;
    const l3 = str.length;
    if (l3 > 100) {
      return JSON.stringify(str);
    }
    for (var i3 = 0;i3 < l3 && point >= 32; i3++) {
      point = str.charCodeAt(i3);
      if (point === 34 || point === 92) {
        result += str.slice(last, i3) + "\\";
        last = i3;
        found = true;
      }
    }
    if (!found) {
      result = str;
    } else {
      result += str.slice(last);
    }
    return point < 32 ? JSON.stringify(str) : '"' + result + '"';
  }
  function asJson(obj, msg, num, time) {
    if (asJsonChan.hasSubscribers === false) {
      return _asJson.call(this, obj, msg, num, time);
    }
    const store = { instance: this, arguments };
    return asJsonChan.traceSync(_asJson, store, this, obj, msg, num, time);
  }
  function _asJson(obj, msg, num, time) {
    const stringify2 = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data = this[lsCacheSym][num] + time;
    data = data + chindings;
    let value15;
    if (formatters.log) {
      obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = "";
    for (const key in obj) {
      value15 = obj[key];
      if (Object.prototype.hasOwnProperty.call(obj, key) && value15 !== undefined) {
        if (serializers[key]) {
          value15 = serializers[key](value15);
        } else if (key === errorKey && serializers.err) {
          value15 = serializers.err(value15);
        }
        const stringifier = stringifiers[key] || wildcardStringifier;
        switch (typeof value15) {
          case "undefined":
          case "function":
            continue;
          case "number":
            if (Number.isFinite(value15) === false) {
              value15 = null;
            }
          case "boolean":
            if (stringifier)
              value15 = stringifier(value15);
            break;
          case "string":
            value15 = (stringifier || asString)(value15);
            break;
          default:
            value15 = (stringifier || stringify2)(value15, stringifySafe);
        }
        if (value15 === undefined)
          continue;
        const strKey = asString(key);
        propStr += "," + strKey + ":" + value15;
      }
    }
    let msgStr = "";
    if (msg !== undefined) {
      value15 = serializers[messageKey] ? serializers[messageKey](msg) : msg;
      const stringifier = stringifiers[messageKey] || wildcardStringifier;
      switch (typeof value15) {
        case "function":
          break;
        case "number":
          if (Number.isFinite(value15) === false) {
            value15 = null;
          }
        case "boolean":
          if (stringifier)
            value15 = stringifier(value15);
          msgStr = ',"' + messageKey + '":' + value15;
          break;
        case "string":
          value15 = (stringifier || asString)(value15);
          msgStr = ',"' + messageKey + '":' + value15;
          break;
        default:
          value15 = (stringifier || stringify2)(value15, stringifySafe);
          msgStr = ',"' + messageKey + '":' + value15;
      }
    }
    if (this[nestedKeySym] && propStr) {
      return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
    } else {
      return data + propStr + msgStr + end;
    }
  }
  function asChindings(instance, bindings) {
    let value15;
    let data = instance[chindingsSym];
    const stringify2 = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter = instance[formattersSym].bindings;
    bindings = formatter(bindings);
    for (const key in bindings) {
      value15 = bindings[key];
      const valid = (key.length < 5 || key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels") && bindings.hasOwnProperty(key) && value15 !== undefined;
      if (valid === true) {
        value15 = serializers[key] ? serializers[key](value15) : value15;
        value15 = (stringifiers[key] || wildcardStringifier || stringify2)(value15, stringifySafe);
        if (value15 === undefined)
          continue;
        data += ',"' + key + '":' + value15;
      }
    }
    return data;
  }
  function hasBeenTampered(stream) {
    return stream.write !== stream.constructor.prototype.write;
  }
  function buildSafeSonicBoom(opts) {
    const stream = new SonicBoom(opts);
    stream.on("error", filterBrokenPipe);
    if (!opts.sync && isMainThread) {
      onExit.register(stream, autoEnd);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    return stream;
    function filterBrokenPipe(err) {
      if (err.code === "EPIPE") {
        stream.write = noop;
        stream.end = noop;
        stream.flushSync = noop;
        stream.destroy = noop;
        return;
      }
      stream.removeListener("error", filterBrokenPipe);
      stream.emit("error", err);
    }
  }
  function autoEnd(stream, eventName) {
    if (stream.destroyed) {
      return;
    }
    if (eventName === "beforeExit") {
      stream.flush();
      stream.on("drain", function() {
        stream.end();
      });
    } else {
      stream.flushSync();
    }
  }
  function createArgsNormalizer(defaultOptions2) {
    return function normalizeArgs(instance, caller, opts = {}, stream) {
      if (typeof opts === "string") {
        stream = buildSafeSonicBoom({ dest: opts });
        opts = {};
      } else if (typeof stream === "string") {
        if (opts && opts.transport) {
          throw Error("only one of option.transport or stream can be specified");
        }
        stream = buildSafeSonicBoom({ dest: stream });
      } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
        stream = opts;
        opts = {};
      } else if (opts.transport) {
        if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        }
        if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
          throw Error("option.transport.targets do not allow custom level formatters");
        }
        let customLevels;
        if (opts.customLevels) {
          customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
        }
        stream = transport({ caller, ...opts.transport, levels: customLevels });
      }
      opts = Object.assign({}, defaultOptions2, opts);
      opts.serializers = Object.assign({}, defaultOptions2.serializers, opts.serializers);
      opts.formatters = Object.assign({}, defaultOptions2.formatters, opts.formatters);
      if (opts.prettyPrint) {
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      }
      const { enabled, onChild } = opts;
      if (enabled === false)
        opts.level = "silent";
      if (!onChild)
        opts.onChild = noop;
      if (!stream) {
        if (!hasBeenTampered(process.stdout)) {
          stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
        } else {
          stream = process.stdout;
        }
      }
      return { opts, stream };
    };
  }
  function stringify(obj, stringifySafeFn) {
    try {
      return JSON.stringify(obj);
    } catch (_) {
      try {
        const stringify2 = stringifySafeFn || this[stringifySafeSym];
        return stringify2(obj);
      } catch (_4) {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
  function buildFormatters(level, bindings, log) {
    return {
      level,
      bindings,
      log
    };
  }
  function normalizeDestFileDescriptor(destination) {
    const fd = Number(destination);
    if (typeof destination === "string" && Number.isFinite(fd)) {
      return fd;
    }
    if (destination === undefined) {
      return 1;
    }
    return destination;
  }
  var diagChan = import.meta.require("diagnostics_channel");
  var format = require_quick_format_unescaped();
  var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
  var SonicBoom = require_sonic_boom();
  var onExit = require_on_exit_leak_free();
  var {
    lsCacheSym,
    chindingsSym,
    writeSym,
    serializersSym,
    formatOptsSym,
    endSym,
    stringifiersSym,
    stringifySym,
    stringifySafeSym,
    wildcardFirstSym,
    nestedKeySym,
    formattersSym,
    messageKeySym,
    errorKeySym,
    nestedKeyStrSym,
    msgPrefixSym
  } = require_symbols();
  var { isMainThread } = import.meta.require("worker_threads");
  var transport = require_transport();
  var asJsonChan = diagChan.tracingChannel("pino_asJson");
  module.exports = {
    noop,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify,
    buildFormatters,
    normalizeDestFileDescriptor
  };
});

// node_modules/pino/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  var DEFAULT_LEVELS = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
  };
  var SORTING_ORDER = {
    ASC: "ASC",
    DESC: "DESC"
  };
  module.exports = {
    DEFAULT_LEVELS,
    SORTING_ORDER
  };
});

// node_modules/pino/lib/levels.js
var require_levels = __commonJS((exports, module) => {
  function genLsCache(instance) {
    const formatter = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache = {};
    for (const label in labels) {
      const level = formatter(labels[label], Number(label));
      cache[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache;
    return instance;
  }
  function isStandardLevel(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
      return false;
    }
    switch (level) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return true;
      default:
        return false;
    }
  }
  function setLevel(level) {
    const { labels, values } = this.levels;
    if (typeof level === "number") {
      if (labels[level] === undefined)
        throw Error("unknown level value" + level);
      level = labels[level];
    }
    if (values[level] === undefined)
      throw Error("unknown level " + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const levelComparison = this[levelCompSym];
    const hook = this[hooksSym].logMethod;
    for (const key in values) {
      if (levelComparison(values[key], levelVal) === false) {
        this[key] = noop;
        continue;
      }
      this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
    }
    this.emit("level-change", level, levelVal, labels[preLevelVal], preLevelVal, this);
  }
  function getLevel(level) {
    const { levels, levelVal } = this;
    return levels && levels.labels ? levels.labels[levelVal] : "";
  }
  function isLevelEnabled(logLevel) {
    const { values } = this.levels;
    const logLevelVal = values[logLevel];
    return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym]);
  }
  function compareLevel(direction, current, expected) {
    if (direction === SORTING_ORDER.DESC) {
      return current <= expected;
    }
    return current >= expected;
  }
  function genLevelComparison(levelComparison) {
    if (typeof levelComparison === "string") {
      return compareLevel.bind(null, levelComparison);
    }
    return levelComparison;
  }
  function mappings(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o3, k) => {
      o3[customLevels[k]] = k;
      return o3;
    }, {}) : null;
    const labels = Object.assign(Object.create(Object.prototype, { Infinity: { value: "silent" } }), useOnlyCustomLevels ? null : nums, customNums);
    const values = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    return { labels, values };
  }
  function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === "number") {
      const values = [].concat(Object.keys(customLevels || {}).map((key) => customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level), Infinity);
      if (!values.includes(defaultLevel)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
      return;
    }
    const labels = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    if (!(defaultLevel in labels)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
  }
  function assertNoLevelCollisions(levels, customLevels) {
    const { labels, values } = levels;
    for (const k in customLevels) {
      if (k in values) {
        throw Error("levels cannot be overridden");
      }
      if (customLevels[k] in labels) {
        throw Error("pre-existing level values cannot be used for new levels");
      }
    }
  }
  function assertLevelComparison(levelComparison) {
    if (typeof levelComparison === "function") {
      return;
    }
    if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
      return;
    }
    throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  var {
    lsCacheSym,
    levelValSym,
    useOnlyCustomLevelsSym,
    streamSym,
    formattersSym,
    hooksSym,
    levelCompSym
  } = require_symbols();
  var { noop, genLog } = require_tools();
  var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
  var levelMethods = {
    fatal: (hook) => {
      const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
      return function(...args) {
        const stream = this[streamSym];
        logFatal.call(this, ...args);
        if (typeof stream.flushSync === "function") {
          try {
            stream.flushSync();
          } catch (e) {
          }
        }
      };
    },
    error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
    warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
    info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
    debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
    trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
  };
  var nums = Object.keys(DEFAULT_LEVELS).reduce((o3, k) => {
    o3[DEFAULT_LEVELS[k]] = k;
    return o3;
  }, {});
  var initialLsCache = Object.keys(nums).reduce((o3, k) => {
    o3[k] = '{"level":' + Number(k);
    return o3;
  }, {});
  module.exports = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    assertNoLevelCollisions,
    assertDefaultLevelFound,
    genLevelComparison,
    assertLevelComparison
  };
});

// node_modules/pino/lib/meta.js
var require_meta = __commonJS((exports, module) => {
  module.exports = { version: "10.1.0" };
});

// node_modules/pino/lib/proto.js
var require_proto = __commonJS((exports, module) => {
  function child(bindings2, options) {
    if (!bindings2) {
      throw Error("missing bindings for child Pino");
    }
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    if (options == null) {
      if (instance[formattersSym].bindings !== resetChildingsFormatter) {
        instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      if (this.onChild !== noop) {
        this.onChild(instance);
      }
      return instance;
    }
    if (options.hasOwnProperty("serializers") === true) {
      instance[serializersSym] = Object.create(null);
      for (const k in serializers) {
        instance[serializersSym][k] = serializers[k];
      }
      const parentSymbols = Object.getOwnPropertySymbols(serializers);
      for (var i3 = 0;i3 < parentSymbols.length; i3++) {
        const ks = parentSymbols[i3];
        instance[serializersSym][ks] = serializers[ks];
      }
      for (const bk in options.serializers) {
        instance[serializersSym][bk] = options.serializers[bk];
      }
      const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
      for (var bi = 0;bi < bindingsSymbols.length; bi++) {
        const bks = bindingsSymbols[bi];
        instance[serializersSym][bks] = options.serializers[bks];
      }
    } else
      instance[serializersSym] = serializers;
    if (options.hasOwnProperty("formatters")) {
      const { level, bindings: chindings, log } = options.formatters;
      instance[formattersSym] = buildFormatters(level || formatters.level, chindings || resetChildingsFormatter, log || formatters.log);
    } else {
      instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
    }
    if (options.hasOwnProperty("customLevels") === true) {
      assertNoLevelCollisions(this.levels, options.customLevels);
      instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
      genLsCache(instance);
    }
    if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
      instance.redact = options.redact;
      const stringifiers = redaction(instance.redact, stringify);
      const formatOpts = { stringify: stringifiers[redactFmtSym] };
      instance[stringifySym] = stringify;
      instance[stringifiersSym] = stringifiers;
      instance[formatOptsSym] = formatOpts;
    }
    if (typeof options.msgPrefix === "string") {
      instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings2);
    if (options.level !== undefined && options.level !== this.level || options.hasOwnProperty("customLevels")) {
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
    }
    this.onChild(instance);
    return instance;
  }
  function bindings() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}`;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
  }
  function setBindings(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
  }
  function defaultMixinMergeStrategy(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
  }
  function write(_obj, msg, num) {
    const t3 = this[timeSym]();
    const mixin = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    const streamWriteHook = this[hooksSym].streamWrite;
    if (_obj === undefined || _obj === null) {
      obj = {};
    } else if (_obj instanceof Error) {
      obj = { [errorKey]: _obj };
      if (msg === undefined) {
        msg = _obj.message;
      }
    } else {
      obj = _obj;
      if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {
        msg = _obj[errorKey].message;
      }
    }
    if (mixin) {
      obj = mixinMergeStrategy(obj, mixin(obj, num, this));
    }
    const s3 = this[asJsonSym](obj, msg, num, t3);
    const stream = this[streamSym];
    if (stream[needsMetadataGsym] === true) {
      stream.lastLevel = num;
      stream.lastObj = obj;
      stream.lastMsg = msg;
      stream.lastTime = t3.slice(this[timeSliceIndexSym]);
      stream.lastLogger = this;
    }
    stream.write(streamWriteHook ? streamWriteHook(s3) : s3);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw Error("callback must be a function");
    }
    const stream = this[streamSym];
    if (typeof stream.flush === "function") {
      stream.flush(cb || noop);
    } else if (cb)
      cb();
  }
  var { EventEmitter } = import.meta.require("events");
  var {
    lsCacheSym,
    levelValSym,
    setLevelSym,
    getLevelSym,
    chindingsSym,
    mixinSym,
    asJsonSym,
    writeSym,
    mixinMergeStrategySym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    serializersSym,
    formattersSym,
    errorKeySym,
    messageKeySym,
    useOnlyCustomLevelsSym,
    needsMetadataGsym,
    redactFmtSym,
    stringifySym,
    formatOptsSym,
    stringifiersSym,
    msgPrefixSym,
    hooksSym
  } = require_symbols();
  var {
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    initialLsCache,
    genLsCache,
    assertNoLevelCollisions
  } = require_levels();
  var {
    asChindings,
    asJson,
    buildFormatters,
    stringify,
    noop
  } = require_tools();
  var {
    version
  } = require_meta();
  var redaction = require_redaction();
  var constructor5 = class Pino {
  };
  var prototype = {
    constructor: constructor5,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version,
    get level() {
      return this[getLevelSym]();
    },
    set level(lvl) {
      this[setLevelSym](lvl);
    },
    get levelVal() {
      return this[levelValSym];
    },
    set levelVal(n3) {
      throw Error("levelVal is read-only");
    },
    get msgPrefix() {
      return this[msgPrefixSym];
    },
    get [Symbol.toStringTag]() {
      return "Pino";
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
  };
  Object.setPrototypeOf(prototype, EventEmitter.prototype);
  module.exports = function() {
    return Object.create(prototype);
  };
  var resetChildingsFormatter = (bindings2) => bindings2;
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS((exports, module) => {
  function strEscape(str) {
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
      return `"${str}"`;
    }
    return JSON.stringify(str);
  }
  function sort(array5, comparator) {
    if (array5.length > 200 || comparator) {
      return array5.sort(comparator);
    }
    for (let i3 = 1;i3 < array5.length; i3++) {
      const currentValue = array5[i3];
      let position = i3;
      while (position !== 0 && array5[position - 1] > currentValue) {
        array5[position] = array5[position - 1];
        position--;
      }
      array5[position] = currentValue;
    }
    return array5;
  }
  function isTypedArrayWithEntries(value15) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value15) !== undefined && value15.length !== 0;
  }
  function stringifyTypedArray(array5, separator, maximumBreadth) {
    if (array5.length < maximumBreadth) {
      maximumBreadth = array5.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array5[0]}`;
    for (let i3 = 1;i3 < maximumBreadth; i3++) {
      res += `${separator}"${i3}":${whitespace}${array5[i3]}`;
    }
    return res;
  }
  function getCircularValueOption(options) {
    if (hasOwnProperty.call(options, "circularValue")) {
      const circularValue = options.circularValue;
      if (typeof circularValue === "string") {
        return `"${circularValue}"`;
      }
      if (circularValue == null) {
        return circularValue;
      }
      if (circularValue === Error || circularValue === TypeError) {
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      }
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  }
  function getDeterministicOption(options) {
    let value15;
    if (hasOwnProperty.call(options, "deterministic")) {
      value15 = options.deterministic;
      if (typeof value15 !== "boolean" && typeof value15 !== "function") {
        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
      }
    }
    return value15 === undefined ? true : value15;
  }
  function getBooleanOption(options, key) {
    let value15;
    if (hasOwnProperty.call(options, key)) {
      value15 = options[key];
      if (typeof value15 !== "boolean") {
        throw new TypeError(`The "${key}" argument must be of type boolean`);
      }
    }
    return value15 === undefined ? true : value15;
  }
  function getPositiveIntegerOption(options, key) {
    let value15;
    if (hasOwnProperty.call(options, key)) {
      value15 = options[key];
      if (typeof value15 !== "number") {
        throw new TypeError(`The "${key}" argument must be of type number`);
      }
      if (!Number.isInteger(value15)) {
        throw new TypeError(`The "${key}" argument must be an integer`);
      }
      if (value15 < 1) {
        throw new RangeError(`The "${key}" argument must be >= 1`);
      }
    }
    return value15 === undefined ? Infinity : value15;
  }
  function getItemCount(number7) {
    if (number7 === 1) {
      return "1 item";
    }
    return `${number7} items`;
  }
  function getUniqueReplacerSet(replacerArray) {
    const replacerSet = new Set;
    for (const value15 of replacerArray) {
      if (typeof value15 === "string" || typeof value15 === "number") {
        replacerSet.add(String(value15));
      }
    }
    return replacerSet;
  }
  function getStrictOption(options) {
    if (hasOwnProperty.call(options, "strict")) {
      const value15 = options.strict;
      if (typeof value15 !== "boolean") {
        throw new TypeError('The "strict" argument must be of type boolean');
      }
      if (value15) {
        return (value16) => {
          let message = `Object can not safely be stringified. Received type ${typeof value16}`;
          if (typeof value16 !== "function")
            message += ` (${value16.toString()})`;
          throw new Error(message);
        };
      }
    }
  }
  function configure(options) {
    options = { ...options };
    const fail = getStrictOption(options);
    if (fail) {
      if (options.bigint === undefined) {
        options.bigint = false;
      }
      if (!("circularValue" in options)) {
        options.circularValue = Error;
      }
    }
    const circularValue = getCircularValueOption(options);
    const bigint6 = getBooleanOption(options, "bigint");
    const deterministic = getDeterministicOption(options);
    const comparator = typeof deterministic === "function" ? deterministic : undefined;
    const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
      let value15 = parent[key];
      if (typeof value15 === "object" && value15 !== null && typeof value15.toJSON === "function") {
        value15 = value15.toJSON(key);
      }
      value15 = replacer.call(parent, key, value15);
      switch (typeof value15) {
        case "string":
          return strEscape(value15);
        case "object": {
          if (value15 === null) {
            return "null";
          }
          if (stack.indexOf(value15) !== -1) {
            return circularValue;
          }
          let res = "";
          let join2 = ",";
          const originalIndentation = indentation;
          if (Array.isArray(value15)) {
            if (value15.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value15);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join2 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value15.length, maximumBreadth);
            let i3 = 0;
            for (;i3 < maximumValuesToStringify - 1; i3++) {
              const tmp2 = stringifyFnReplacer(String(i3), value15, stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join2;
            }
            const tmp = stringifyFnReplacer(String(i3), value15, stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value15.length - 1 > maximumBreadth) {
              const removedKeys = value15.length - maximumBreadth - 1;
              res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value15);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let whitespace = "";
          let separator = "";
          if (spacer !== "") {
            indentation += spacer;
            join2 = `,\n${indentation}`;
            whitespace = " ";
          }
          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (deterministic && !isTypedArrayWithEntries(value15)) {
            keys = sort(keys, comparator);
          }
          stack.push(value15);
          for (let i3 = 0;i3 < maximumPropertiesToStringify; i3++) {
            const key2 = keys[i3];
            const tmp = stringifyFnReplacer(key2, value15, stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join2;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
            separator = join2;
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value15) ? String(value15) : fail ? fail(value15) : "null";
        case "boolean":
          return value15 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value15);
          }
        default:
          return fail ? fail(value15) : undefined;
      }
    }
    function stringifyArrayReplacer(key, value15, stack, replacer, spacer, indentation) {
      if (typeof value15 === "object" && value15 !== null && typeof value15.toJSON === "function") {
        value15 = value15.toJSON(key);
      }
      switch (typeof value15) {
        case "string":
          return strEscape(value15);
        case "object": {
          if (value15 === null) {
            return "null";
          }
          if (stack.indexOf(value15) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          let res = "";
          let join2 = ",";
          if (Array.isArray(value15)) {
            if (value15.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value15);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join2 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value15.length, maximumBreadth);
            let i3 = 0;
            for (;i3 < maximumValuesToStringify - 1; i3++) {
              const tmp2 = stringifyArrayReplacer(String(i3), value15[i3], stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join2;
            }
            const tmp = stringifyArrayReplacer(String(i3), value15[i3], stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value15.length - 1 > maximumBreadth) {
              const removedKeys = value15.length - maximumBreadth - 1;
              res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          stack.push(value15);
          let whitespace = "";
          if (spacer !== "") {
            indentation += spacer;
            join2 = `,\n${indentation}`;
            whitespace = " ";
          }
          let separator = "";
          for (const key2 of replacer) {
            const tmp = stringifyArrayReplacer(key2, value15[key2], stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join2;
            }
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value15) ? String(value15) : fail ? fail(value15) : "null";
        case "boolean":
          return value15 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value15);
          }
        default:
          return fail ? fail(value15) : undefined;
      }
    }
    function stringifyIndent(key, value15, stack, spacer, indentation) {
      switch (typeof value15) {
        case "string":
          return strEscape(value15);
        case "object": {
          if (value15 === null) {
            return "null";
          }
          if (typeof value15.toJSON === "function") {
            value15 = value15.toJSON(key);
            if (typeof value15 !== "object") {
              return stringifyIndent(key, value15, stack, spacer, indentation);
            }
            if (value15 === null) {
              return "null";
            }
          }
          if (stack.indexOf(value15) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          if (Array.isArray(value15)) {
            if (value15.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value15);
            indentation += spacer;
            let res2 = `\n${indentation}`;
            const join3 = `,\n${indentation}`;
            const maximumValuesToStringify = Math.min(value15.length, maximumBreadth);
            let i3 = 0;
            for (;i3 < maximumValuesToStringify - 1; i3++) {
              const tmp2 = stringifyIndent(String(i3), value15[i3], stack, spacer, indentation);
              res2 += tmp2 !== undefined ? tmp2 : "null";
              res2 += join3;
            }
            const tmp = stringifyIndent(String(i3), value15[i3], stack, spacer, indentation);
            res2 += tmp !== undefined ? tmp : "null";
            if (value15.length - 1 > maximumBreadth) {
              const removedKeys = value15.length - maximumBreadth - 1;
              res2 += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            res2 += `\n${originalIndentation}`;
            stack.pop();
            return `[${res2}]`;
          }
          let keys = Object.keys(value15);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          indentation += spacer;
          const join2 = `,\n${indentation}`;
          let res = "";
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value15)) {
            res += stringifyTypedArray(value15, join2, maximumBreadth);
            keys = keys.slice(value15.length);
            maximumPropertiesToStringify -= value15.length;
            separator = join2;
          }
          if (deterministic) {
            keys = sort(keys, comparator);
          }
          stack.push(value15);
          for (let i3 = 0;i3 < maximumPropertiesToStringify; i3++) {
            const key2 = keys[i3];
            const tmp = stringifyIndent(key2, value15[key2], stack, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}: ${tmp}`;
              separator = join2;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
            separator = join2;
          }
          if (separator !== "") {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value15) ? String(value15) : fail ? fail(value15) : "null";
        case "boolean":
          return value15 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value15);
          }
        default:
          return fail ? fail(value15) : undefined;
      }
    }
    function stringifySimple(key, value15, stack) {
      switch (typeof value15) {
        case "string":
          return strEscape(value15);
        case "object": {
          if (value15 === null) {
            return "null";
          }
          if (typeof value15.toJSON === "function") {
            value15 = value15.toJSON(key);
            if (typeof value15 !== "object") {
              return stringifySimple(key, value15, stack);
            }
            if (value15 === null) {
              return "null";
            }
          }
          if (stack.indexOf(value15) !== -1) {
            return circularValue;
          }
          let res = "";
          const hasLength = value15.length !== undefined;
          if (hasLength && Array.isArray(value15)) {
            if (value15.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value15);
            const maximumValuesToStringify = Math.min(value15.length, maximumBreadth);
            let i3 = 0;
            for (;i3 < maximumValuesToStringify - 1; i3++) {
              const tmp2 = stringifySimple(String(i3), value15[i3], stack);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(String(i3), value15[i3], stack);
            res += tmp !== undefined ? tmp : "null";
            if (value15.length - 1 > maximumBreadth) {
              const removedKeys = value15.length - maximumBreadth - 1;
              res += `,"... ${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value15);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (hasLength && isTypedArrayWithEntries(value15)) {
            res += stringifyTypedArray(value15, ",", maximumBreadth);
            keys = keys.slice(value15.length);
            maximumPropertiesToStringify -= value15.length;
            separator = ",";
          }
          if (deterministic) {
            keys = sort(keys, comparator);
          }
          stack.push(value15);
          for (let i3 = 0;i3 < maximumPropertiesToStringify; i3++) {
            const key2 = keys[i3];
            const tmp = stringifySimple(key2, value15[key2], stack);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${tmp}`;
              separator = ",";
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value15) ? String(value15) : fail ? fail(value15) : "null";
        case "boolean":
          return value15 === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value15);
          }
        default:
          return fail ? fail(value15) : undefined;
      }
    }
    function stringify2(value15, replacer, space) {
      if (arguments.length > 1) {
        let spacer = "";
        if (typeof space === "number") {
          spacer = " ".repeat(Math.min(space, 10));
        } else if (typeof space === "string") {
          spacer = space.slice(0, 10);
        }
        if (replacer != null) {
          if (typeof replacer === "function") {
            return stringifyFnReplacer("", { "": value15 }, [], replacer, spacer, "");
          }
          if (Array.isArray(replacer)) {
            return stringifyArrayReplacer("", value15, [], getUniqueReplacerSet(replacer), spacer, "");
          }
        }
        if (spacer.length !== 0) {
          return stringifyIndent("", value15, [], spacer, "");
        }
      }
      return stringifySimple("", value15, []);
    }
    return stringify2;
  }
  var { hasOwnProperty } = Object.prototype;
  var stringify = configure();
  stringify.configure = configure;
  stringify.stringify = stringify;
  stringify.default = stringify;
  exports.stringify = stringify;
  exports.configure = configure;
  module.exports = stringify;
  var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
  var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
});

// node_modules/pino/lib/multistream.js
var require_multistream = __commonJS((exports, module) => {
  function multistream(streamsArray, opts) {
    streamsArray = streamsArray || [];
    opts = opts || { dedupe: false };
    const streamLevels = Object.create(DEFAULT_LEVELS);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === "object") {
      Object.keys(opts.levels).forEach((i3) => {
        streamLevels[i3] = opts.levels[i3];
      });
    }
    const res = {
      write,
      add,
      remove,
      emit,
      flushSync,
      end,
      minLevel: 0,
      lastId: 0,
      streams: [],
      clone: clone13,
      [metadata]: true,
      streamLevels
    };
    if (Array.isArray(streamsArray)) {
      streamsArray.forEach(add, res);
    } else {
      add.call(res, streamsArray);
    }
    streamsArray = null;
    return res;
    function write(data) {
      let dest;
      const level = this.lastLevel;
      const { streams } = this;
      let recordedLevel = 0;
      let stream;
      for (let i3 = initLoopVar(streams.length, opts.dedupe);checkLoopVar(i3, streams.length, opts.dedupe); i3 = adjustLoopVar(i3, opts.dedupe)) {
        dest = streams[i3];
        if (dest.level <= level) {
          if (recordedLevel !== 0 && recordedLevel !== dest.level) {
            break;
          }
          stream = dest.stream;
          if (stream[metadata]) {
            const { lastTime, lastMsg, lastObj, lastLogger } = this;
            stream.lastLevel = level;
            stream.lastTime = lastTime;
            stream.lastMsg = lastMsg;
            stream.lastObj = lastObj;
            stream.lastLogger = lastLogger;
          }
          stream.write(data);
          if (opts.dedupe) {
            recordedLevel = dest.level;
          }
        } else if (!opts.dedupe) {
          break;
        }
      }
    }
    function emit(...args) {
      for (const { stream } of this.streams) {
        if (typeof stream.emit === "function") {
          stream.emit(...args);
        }
      }
    }
    function flushSync() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
      }
    }
    function add(dest) {
      if (!dest) {
        return res;
      }
      const isStream = typeof dest.write === "function" || dest.stream;
      const stream_ = dest.write ? dest : dest.stream;
      if (!isStream) {
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      }
      const { streams, streamLevels: streamLevels2 } = this;
      let level;
      if (typeof dest.levelVal === "number") {
        level = dest.levelVal;
      } else if (typeof dest.level === "string") {
        level = streamLevels2[dest.level];
      } else if (typeof dest.level === "number") {
        level = dest.level;
      } else {
        level = DEFAULT_INFO_LEVEL;
      }
      const dest_ = {
        stream: stream_,
        level,
        levelVal: undefined,
        id: ++res.lastId
      };
      streams.unshift(dest_);
      streams.sort(compareByLevel);
      this.minLevel = streams[0].level;
      return res;
    }
    function remove(id) {
      const { streams } = this;
      const index = streams.findIndex((s3) => s3.id === id);
      if (index >= 0) {
        streams.splice(index, 1);
        streams.sort(compareByLevel);
        this.minLevel = streams.length > 0 ? streams[0].level : -1;
      }
      return res;
    }
    function end() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
        stream.end();
      }
    }
    function clone13(level) {
      const streams = new Array(this.streams.length);
      for (let i3 = 0;i3 < streams.length; i3++) {
        streams[i3] = {
          level,
          stream: this.streams[i3].stream
        };
      }
      return {
        write,
        add,
        remove,
        minLevel: level,
        streams,
        clone: clone13,
        emit,
        flushSync,
        [metadata]: true
      };
    }
  }
  function compareByLevel(a, b) {
    return a.level - b.level;
  }
  function initLoopVar(length, dedupe) {
    return dedupe ? length - 1 : 0;
  }
  function adjustLoopVar(i3, dedupe) {
    return dedupe ? i3 - 1 : i3 + 1;
  }
  function checkLoopVar(i3, length, dedupe) {
    return dedupe ? i3 >= 0 : i3 < length;
  }
  var metadata = Symbol.for("pino.metadata");
  var { DEFAULT_LEVELS } = require_constants();
  var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
  module.exports = multistream;
});

// node_modules/pino/pino.js
var require_pino = __commonJS((exports, module) => {
  function pino(...args) {
    const instance = {};
    const { opts, stream } = normalize(instance, caller(), ...args);
    if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined)
      opts.level = opts.level.toLowerCase();
    const {
      redact,
      crlf,
      serializers: serializers2,
      timestamp,
      messageKey,
      errorKey,
      nestedKey,
      base,
      name,
      level,
      customLevels,
      levelComparison,
      mixin,
      mixinMergeStrategy,
      useOnlyCustomLevels,
      formatters,
      hooks,
      depthLimit,
      edgeLimit,
      onChild,
      msgPrefix
    } = opts;
    const stringifySafe = configure({
      maximumDepth: depthLimit,
      maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);
    const stringifyFn = stringify.bind({
      [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact ? redaction(redact, stringifyFn) : {};
    const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
    const end = "}" + (crlf ? "\r\n" : "\n");
    const coreChindings = asChindings.bind(null, {
      [chindingsSym]: "",
      [serializersSym]: serializers2,
      [stringifiersSym]: stringifiers,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [formattersSym]: allFormatters
    });
    let chindings = "";
    if (base !== null) {
      if (name === undefined) {
        chindings = coreChindings(base);
      } else {
        chindings = coreChindings(Object.assign({}, base, { name }));
      }
    }
    const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
    const timeSliceIndex = time2().indexOf(":") + 1;
    if (useOnlyCustomLevels && !customLevels)
      throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (mixin && typeof mixin !== "function")
      throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== "string")
      throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels = mappings(customLevels, useOnlyCustomLevels);
    if (typeof stream.emit === "function") {
      stream.emit("message", { code: "PINO_CONFIG", config: { levels, messageKey, errorKey } });
    }
    assertLevelComparison(levelComparison);
    const levelCompFunc = genLevelComparison(levelComparison);
    Object.assign(instance, {
      levels,
      [levelCompSym]: levelCompFunc,
      [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
      [streamSym]: stream,
      [timeSym]: time2,
      [timeSliceIndexSym]: timeSliceIndex,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [stringifiersSym]: stringifiers,
      [endSym]: end,
      [formatOptsSym]: formatOpts,
      [messageKeySym]: messageKey,
      [errorKeySym]: errorKey,
      [nestedKeySym]: nestedKey,
      [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
      [serializersSym]: serializers2,
      [mixinSym]: mixin,
      [mixinMergeStrategySym]: mixinMergeStrategy,
      [chindingsSym]: chindings,
      [formattersSym]: allFormatters,
      [hooksSym]: hooks,
      silent: noop,
      onChild,
      [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto2());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
  }
  var os2 = import.meta.require("os");
  var stdSerializers = require_pino_std_serializers();
  var caller = require_caller();
  var redaction = require_redaction();
  var time = require_time();
  var proto2 = require_proto();
  var symbols70 = require_symbols();
  var { configure } = require_safe_stable_stringify();
  var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
  var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
  var {
    createArgsNormalizer,
    asChindings,
    buildSafeSonicBoom,
    buildFormatters,
    stringify,
    normalizeDestFileDescriptor,
    noop
  } = require_tools();
  var { version } = require_meta();
  var {
    chindingsSym,
    redactFmtSym,
    serializersSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    setLevelSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    mixinSym,
    levelCompSym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  } = symbols70;
  var { epochTime, nullTime } = time;
  var { pid } = process;
  var hostname = os2.hostname();
  var defaultErrorSerializer = stdSerializers.err;
  var defaultOptions2 = {
    level: "info",
    levelComparison: SORTING_ORDER.ASC,
    levels: DEFAULT_LEVELS,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: true,
    base: { pid, hostname },
    serializers: Object.assign(Object.create(null), {
      err: defaultErrorSerializer
    }),
    formatters: Object.assign(Object.create(null), {
      bindings(bindings) {
        return bindings;
      },
      level(label, number7) {
        return { level: number7 };
      }
    }),
    hooks: {
      logMethod: undefined,
      streamWrite: undefined
    },
    timestamp: epochTime,
    name: undefined,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
  };
  var normalize = createArgsNormalizer(defaultOptions2);
  var serializers = Object.assign(Object.create(null), stdSerializers);
  module.exports = pino;
  module.exports.destination = (dest = process.stdout.fd) => {
    if (typeof dest === "object") {
      dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
      return buildSafeSonicBoom(dest);
    } else {
      return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
    }
  };
  module.exports.transport = require_transport();
  module.exports.multistream = require_multistream();
  module.exports.levels = mappings();
  module.exports.stdSerializers = serializers;
  module.exports.stdTimeFunctions = Object.assign({}, time);
  module.exports.symbols = symbols70;
  module.exports.version = version;
  module.exports.default = pino;
  module.exports.pino = pino;
});

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS((exports) => {
  (function() {
    exports.defaults = {
      "0.1": {
        explicitCharkey: false,
        trim: true,
        normalize: true,
        normalizeTags: false,
        attrkey: "@",
        charkey: "#",
        explicitArray: false,
        ignoreAttrs: false,
        mergeAttrs: false,
        explicitRoot: false,
        validator: null,
        xmlns: false,
        explicitChildren: false,
        childkey: "@@",
        charsAsChildren: false,
        includeWhiteChars: false,
        async: false,
        strict: true,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        emptyTag: ""
      },
      "0.2": {
        explicitCharkey: false,
        trim: false,
        normalize: false,
        normalizeTags: false,
        attrkey: "$",
        charkey: "_",
        explicitArray: true,
        ignoreAttrs: false,
        mergeAttrs: false,
        explicitRoot: true,
        validator: null,
        xmlns: false,
        explicitChildren: false,
        preserveChildrenOrder: false,
        childkey: "$$",
        charsAsChildren: false,
        includeWhiteChars: false,
        async: false,
        strict: true,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        rootName: "root",
        xmldec: {
          version: "1.0",
          encoding: "UTF-8",
          standalone: true
        },
        doctype: null,
        renderOpts: {
          pretty: true,
          indent: "  ",
          newline: "\n"
        },
        headless: false,
        chunkSize: 1e4,
        emptyTag: "",
        cdata: false
      }
    };
  }).call(exports);
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS((exports, module) => {
  (function() {
    var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
    assign = function() {
      var i3, key, len, source, sources, target;
      target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (isFunction(Object.assign)) {
        Object.assign.apply(null, arguments);
      } else {
        for (i3 = 0, len = sources.length;i3 < len; i3++) {
          source = sources[i3];
          if (source != null) {
            for (key in source) {
              if (!hasProp.call(source, key))
                continue;
              target[key] = source[key];
            }
          }
        }
      }
      return target;
    };
    isFunction = function(val) {
      return !!val && Object.prototype.toString.call(val) === "[object Function]";
    };
    isObject = function(val) {
      var ref4;
      return !!val && ((ref4 = typeof val) === "function" || ref4 === "object");
    };
    isArray = function(val) {
      if (isFunction(Array.isArray)) {
        return Array.isArray(val);
      } else {
        return Object.prototype.toString.call(val) === "[object Array]";
      }
    };
    isEmpty = function(val) {
      var key;
      if (isArray(val)) {
        return !val.length;
      } else {
        for (key in val) {
          if (!hasProp.call(val, key))
            continue;
          return false;
        }
        return true;
      }
    };
    isPlainObject = function(val) {
      var ctor, proto2;
      return isObject(val) && (proto2 = Object.getPrototypeOf(val)) && (ctor = proto2.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    };
    getValue = function(obj) {
      if (isFunction(obj.valueOf)) {
        return obj.valueOf();
      } else {
        return obj;
      }
    };
    exports.assign = assign;
    exports.isFunction = isFunction;
    exports.isObject = isObject;
    exports.isArray = isArray;
    exports.isEmpty = isEmpty;
    exports.isPlainObject = isPlainObject;
    exports.getValue = getValue;
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS((exports, module) => {
  (function() {
    var XMLDOMImplementation;
    module.exports = XMLDOMImplementation = function() {
      function XMLDOMImplementation2() {
      }
      XMLDOMImplementation2.prototype.hasFeature = function(feature, version) {
        return true;
      };
      XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLDOMImplementation2.prototype.getFeature = function(feature, version) {
        throw new Error("This DOM method is not implemented.");
      };
      return XMLDOMImplementation2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS((exports, module) => {
  (function() {
    var XMLDOMErrorHandler;
    module.exports = XMLDOMErrorHandler = function() {
      function XMLDOMErrorHandler2() {
      }
      XMLDOMErrorHandler2.prototype.handleError = function(error23) {
        throw new Error(error23);
      };
      return XMLDOMErrorHandler2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS((exports, module) => {
  (function() {
    var XMLDOMStringList;
    module.exports = XMLDOMStringList = function() {
      function XMLDOMStringList2(arr) {
        this.arr = arr || [];
      }
      Object.defineProperty(XMLDOMStringList2.prototype, "length", {
        get: function() {
          return this.arr.length;
        }
      });
      XMLDOMStringList2.prototype.item = function(index) {
        return this.arr[index] || null;
      };
      XMLDOMStringList2.prototype.contains = function(str) {
        return this.arr.indexOf(str) !== -1;
      };
      return XMLDOMStringList2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS((exports, module) => {
  (function() {
    var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
    XMLDOMErrorHandler = require_XMLDOMErrorHandler();
    XMLDOMStringList = require_XMLDOMStringList();
    module.exports = XMLDOMConfiguration = function() {
      function XMLDOMConfiguration2() {
        var clonedSelf;
        this.defaultParams = {
          "canonical-form": false,
          "cdata-sections": false,
          comments: false,
          "datatype-normalization": false,
          "element-content-whitespace": true,
          entities: true,
          "error-handler": new XMLDOMErrorHandler,
          infoset: true,
          "validate-if-schema": false,
          namespaces: true,
          "namespace-declarations": true,
          "normalize-characters": false,
          "schema-location": "",
          "schema-type": "",
          "split-cdata-sections": true,
          validate: false,
          "well-formed": true
        };
        this.params = clonedSelf = Object.create(this.defaultParams);
      }
      Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
        get: function() {
          return new XMLDOMStringList(Object.keys(this.defaultParams));
        }
      });
      XMLDOMConfiguration2.prototype.getParameter = function(name) {
        if (this.params.hasOwnProperty(name)) {
          return this.params[name];
        } else {
          return null;
        }
      };
      XMLDOMConfiguration2.prototype.canSetParameter = function(name, value15) {
        return true;
      };
      XMLDOMConfiguration2.prototype.setParameter = function(name, value15) {
        if (value15 != null) {
          return this.params[name] = value15;
        } else {
          return delete this.params[name];
        }
      };
      return XMLDOMConfiguration2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS((exports, module) => {
  (function() {
    module.exports = {
      Element: 1,
      Attribute: 2,
      Text: 3,
      CData: 4,
      EntityReference: 5,
      EntityDeclaration: 6,
      ProcessingInstruction: 7,
      Comment: 8,
      Document: 9,
      DocType: 10,
      DocumentFragment: 11,
      NotationDeclaration: 12,
      Declaration: 201,
      Raw: 202,
      AttributeDeclaration: 203,
      ElementDeclaration: 204,
      Dummy: 205
    };
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLAttribute, XMLNode;
    NodeType = require_NodeType();
    XMLNode = require_XMLNode();
    module.exports = XMLAttribute = function() {
      function XMLAttribute2(parent, name, value15) {
        this.parent = parent;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo(name));
        }
        this.name = this.stringify.name(name);
        this.value = this.stringify.attValue(value15);
        this.type = NodeType.Attribute;
        this.isId = false;
        this.schemaTypeInfo = null;
      }
      Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
        get: function() {
          return this.parent;
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(value15) {
          return this.value = value15 || "";
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "prefix", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "localName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLAttribute2.prototype, "specified", {
        get: function() {
          return true;
        }
      });
      XMLAttribute2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLAttribute2.prototype.toString = function(options) {
        return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
      };
      XMLAttribute2.prototype.debugInfo = function(name) {
        name = name || this.name;
        if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else {
          return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
        }
      };
      XMLAttribute2.prototype.isEqualNode = function(node) {
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }
        if (node.prefix !== this.prefix) {
          return false;
        }
        if (node.localName !== this.localName) {
          return false;
        }
        if (node.value !== this.value) {
          return false;
        }
        return true;
      };
      return XMLAttribute2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS((exports, module) => {
  (function() {
    var XMLNamedNodeMap;
    module.exports = XMLNamedNodeMap = function() {
      function XMLNamedNodeMap2(nodes) {
        this.nodes = nodes;
      }
      Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
        get: function() {
          return Object.keys(this.nodes).length || 0;
        }
      });
      XMLNamedNodeMap2.prototype.clone = function() {
        return this.nodes = null;
      };
      XMLNamedNodeMap2.prototype.getNamedItem = function(name) {
        return this.nodes[name];
      };
      XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
        var oldNode;
        oldNode = this.nodes[node.nodeName];
        this.nodes[node.nodeName] = node;
        return oldNode || null;
      };
      XMLNamedNodeMap2.prototype.removeNamedItem = function(name) {
        var oldNode;
        oldNode = this.nodes[name];
        delete this.nodes[name];
        return oldNode || null;
      };
      XMLNamedNodeMap2.prototype.item = function(index) {
        return this.nodes[Object.keys(this.nodes)[index]] || null;
      };
      XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
        throw new Error("This DOM method is not implemented.");
      };
      XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      };
      return XMLNamedNodeMap2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref4, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    ref4 = require_Utility(), isObject = ref4.isObject, isFunction = ref4.isFunction, getValue = ref4.getValue;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLAttribute = require_XMLAttribute();
    XMLNamedNodeMap = require_XMLNamedNodeMap();
    module.exports = XMLElement = function(superClass) {
      extend(XMLElement2, superClass);
      function XMLElement2(parent, name, attributes) {
        var child, j, len, ref1;
        XMLElement2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing element name. " + this.debugInfo());
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.Element;
        this.attribs = {};
        this.schemaTypeInfo = null;
        if (attributes != null) {
          this.attribute(attributes);
        }
        if (parent.type === NodeType.Document) {
          this.isRoot = true;
          this.documentObject = parent;
          parent.rootObject = this;
          if (parent.children) {
            ref1 = parent.children;
            for (j = 0, len = ref1.length;j < len; j++) {
              child = ref1[j];
              if (child.type === NodeType.DocType) {
                child.name = this.name;
                break;
              }
            }
          }
        }
      }
      Object.defineProperty(XMLElement2.prototype, "tagName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLElement2.prototype, "prefix", {
        get: function() {
          return "";
        }
      });
      Object.defineProperty(XMLElement2.prototype, "localName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLElement2.prototype, "id", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement2.prototype, "className", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement2.prototype, "classList", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLElement2.prototype, "attributes", {
        get: function() {
          if (!this.attributeMap || !this.attributeMap.nodes) {
            this.attributeMap = new XMLNamedNodeMap(this.attribs);
          }
          return this.attributeMap;
        }
      });
      XMLElement2.prototype.clone = function() {
        var att, attName, clonedSelf, ref1;
        clonedSelf = Object.create(this);
        if (clonedSelf.isRoot) {
          clonedSelf.documentObject = null;
        }
        clonedSelf.attribs = {};
        ref1 = this.attribs;
        for (attName in ref1) {
          if (!hasProp.call(ref1, attName))
            continue;
          att = ref1[attName];
          clonedSelf.attribs[attName] = att.clone();
        }
        clonedSelf.children = [];
        this.children.forEach(function(child) {
          var clonedChild;
          clonedChild = child.clone();
          clonedChild.parent = clonedSelf;
          return clonedSelf.children.push(clonedChild);
        });
        return clonedSelf;
      };
      XMLElement2.prototype.attribute = function(name, value15) {
        var attName, attValue;
        if (name != null) {
          name = getValue(name);
        }
        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName))
              continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value15)) {
            value15 = value15.apply();
          }
          if (this.options.keepNullAttributes && value15 == null) {
            this.attribs[name] = new XMLAttribute(this, name, "");
          } else if (value15 != null) {
            this.attribs[name] = new XMLAttribute(this, name, value15);
          }
        }
        return this;
      };
      XMLElement2.prototype.removeAttribute = function(name) {
        var attName, j, len;
        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo());
        }
        name = getValue(name);
        if (Array.isArray(name)) {
          for (j = 0, len = name.length;j < len; j++) {
            attName = name[j];
            delete this.attribs[attName];
          }
        } else {
          delete this.attribs[name];
        }
        return this;
      };
      XMLElement2.prototype.toString = function(options) {
        return this.options.writer.element(this, this.options.writer.filterOptions(options));
      };
      XMLElement2.prototype.att = function(name, value15) {
        return this.attribute(name, value15);
      };
      XMLElement2.prototype.a = function(name, value15) {
        return this.attribute(name, value15);
      };
      XMLElement2.prototype.getAttribute = function(name) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name].value;
        } else {
          return null;
        }
      };
      XMLElement2.prototype.setAttribute = function(name, value15) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getAttributeNode = function(name) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name];
        } else {
          return null;
        }
      };
      XMLElement2.prototype.setAttributeNode = function(newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagName = function(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value15) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.hasAttribute = function(name) {
        return this.attribs.hasOwnProperty(name);
      };
      XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setIdAttribute = function(name, isId) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name].isId;
        } else {
          return isId;
        }
      };
      XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagName = function(tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.getElementsByClassName = function(classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLElement2.prototype.isEqualNode = function(node) {
        var i3, j, ref1;
        if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }
        if (node.prefix !== this.prefix) {
          return false;
        }
        if (node.localName !== this.localName) {
          return false;
        }
        if (node.attribs.length !== this.attribs.length) {
          return false;
        }
        for (i3 = j = 0, ref1 = this.attribs.length - 1;0 <= ref1 ? j <= ref1 : j >= ref1; i3 = 0 <= ref1 ? ++j : --j) {
          if (!this.attribs[i3].isEqualNode(node.attribs[i3])) {
            return false;
          }
        }
        return true;
      };
      return XMLElement2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS((exports, module) => {
  (function() {
    var XMLCharacterData, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    module.exports = XMLCharacterData = function(superClass) {
      extend(XMLCharacterData2, superClass);
      function XMLCharacterData2(parent) {
        XMLCharacterData2.__super__.constructor.call(this, parent);
        this.value = "";
      }
      Object.defineProperty(XMLCharacterData2.prototype, "data", {
        get: function() {
          return this.value;
        },
        set: function(value15) {
          return this.value = value15 || "";
        }
      });
      Object.defineProperty(XMLCharacterData2.prototype, "length", {
        get: function() {
          return this.value.length;
        }
      });
      Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(value15) {
          return this.value = value15 || "";
        }
      });
      XMLCharacterData2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLCharacterData2.prototype.substringData = function(offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.appendData = function(arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.insertData = function(offset, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.deleteData = function(offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLCharacterData2.prototype.isEqualNode = function(node) {
        if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.data !== this.data) {
          return false;
        }
        return true;
      };
      return XMLCharacterData2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLCData, XMLCharacterData, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module.exports = XMLCData = function(superClass) {
      extend(XMLCData2, superClass);
      function XMLCData2(parent, text) {
        XMLCData2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing CDATA text. " + this.debugInfo());
        }
        this.name = "#cdata-section";
        this.type = NodeType.CData;
        this.value = this.stringify.cdata(text);
      }
      XMLCData2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLCData2.prototype.toString = function(options) {
        return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
      };
      return XMLCData2;
    }(XMLCharacterData);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLCharacterData, XMLComment, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module.exports = XMLComment = function(superClass) {
      extend(XMLComment2, superClass);
      function XMLComment2(parent, text) {
        XMLComment2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing comment text. " + this.debugInfo());
        }
        this.name = "#comment";
        this.type = NodeType.Comment;
        this.value = this.stringify.comment(text);
      }
      XMLComment2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLComment2.prototype.toString = function(options) {
        return this.options.writer.comment(this, this.options.writer.filterOptions(options));
      };
      return XMLComment2;
    }(XMLCharacterData);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDeclaration, XMLNode, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDeclaration = function(superClass) {
      extend(XMLDeclaration2, superClass);
      function XMLDeclaration2(parent, version, encoding5, standalone) {
        var ref4;
        XMLDeclaration2.__super__.constructor.call(this, parent);
        if (isObject(version)) {
          ref4 = version, version = ref4.version, encoding5 = ref4.encoding, standalone = ref4.standalone;
        }
        if (!version) {
          version = "1.0";
        }
        this.type = NodeType.Declaration;
        this.version = this.stringify.xmlVersion(version);
        if (encoding5 != null) {
          this.encoding = this.stringify.xmlEncoding(encoding5);
        }
        if (standalone != null) {
          this.standalone = this.stringify.xmlStandalone(standalone);
        }
      }
      XMLDeclaration2.prototype.toString = function(options) {
        return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
      };
      return XMLDeclaration2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDTDAttList, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDTDAttList = function(superClass) {
      extend(XMLDTDAttList2, superClass);
      function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        XMLDTDAttList2.__super__.constructor.call(this, parent);
        if (elementName == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }
        if (attributeName == null) {
          throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
        }
        if (!attributeType) {
          throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
        }
        if (!defaultValueType) {
          throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
        }
        if (defaultValueType.indexOf("#") !== 0) {
          defaultValueType = "#" + defaultValueType;
        }
        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }
        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }
        this.elementName = this.stringify.name(elementName);
        this.type = NodeType.AttributeDeclaration;
        this.attributeName = this.stringify.name(attributeName);
        this.attributeType = this.stringify.dtdAttType(attributeType);
        if (defaultValue) {
          this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
        }
        this.defaultValueType = defaultValueType;
      }
      XMLDTDAttList2.prototype.toString = function(options) {
        return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDAttList2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDTDEntity, XMLNode, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDTDEntity = function(superClass) {
      extend(XMLDTDEntity2, superClass);
      function XMLDTDEntity2(parent, pe, name, value15) {
        XMLDTDEntity2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD entity name. " + this.debugInfo(name));
        }
        if (value15 == null) {
          throw new Error("Missing DTD entity value. " + this.debugInfo(name));
        }
        this.pe = !!pe;
        this.name = this.stringify.name(name);
        this.type = NodeType.EntityDeclaration;
        if (!isObject(value15)) {
          this.value = this.stringify.dtdEntityValue(value15);
          this.internal = true;
        } else {
          if (!value15.pubID && !value15.sysID) {
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          if (value15.pubID && !value15.sysID) {
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
          }
          this.internal = false;
          if (value15.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value15.pubID);
          }
          if (value15.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value15.sysID);
          }
          if (value15.nData != null) {
            this.nData = this.stringify.dtdNData(value15.nData);
          }
          if (this.pe && this.nData) {
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
          }
        }
      }
      Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
        get: function() {
          return this.nData || null;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
        get: function() {
          return null;
        }
      });
      XMLDTDEntity2.prototype.toString = function(options) {
        return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDEntity2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDTDElement, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDTDElement = function(superClass) {
      extend(XMLDTDElement2, superClass);
      function XMLDTDElement2(parent, name, value15) {
        XMLDTDElement2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }
        if (!value15) {
          value15 = "(#PCDATA)";
        }
        if (Array.isArray(value15)) {
          value15 = "(" + value15.join(",") + ")";
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.ElementDeclaration;
        this.value = this.stringify.dtdElementValue(value15);
      }
      XMLDTDElement2.prototype.toString = function(options) {
        return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDElement2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDTDNotation, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDTDNotation = function(superClass) {
      extend(XMLDTDNotation2, superClass);
      function XMLDTDNotation2(parent, name, value15) {
        XMLDTDNotation2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD notation name. " + this.debugInfo(name));
        }
        if (!value15.pubID && !value15.sysID) {
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.NotationDeclaration;
        if (value15.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value15.pubID);
        }
        if (value15.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value15.sysID);
        }
      }
      Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      });
      XMLDTDNotation2.prototype.toString = function(options) {
        return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
      };
      return XMLDTDNotation2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDNotation = require_XMLDTDNotation();
    XMLNamedNodeMap = require_XMLNamedNodeMap();
    module.exports = XMLDocType = function(superClass) {
      extend(XMLDocType2, superClass);
      function XMLDocType2(parent, pubID, sysID) {
        var child, i3, len, ref4, ref1, ref22;
        XMLDocType2.__super__.constructor.call(this, parent);
        this.type = NodeType.DocType;
        if (parent.children) {
          ref4 = parent.children;
          for (i3 = 0, len = ref4.length;i3 < len; i3++) {
            child = ref4[i3];
            if (child.type === NodeType.Element) {
              this.name = child.name;
              break;
            }
          }
        }
        this.documentObject = parent;
        if (isObject(pubID)) {
          ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
        }
        if (sysID == null) {
          ref22 = [pubID, sysID], sysID = ref22[0], pubID = ref22[1];
        }
        if (pubID != null) {
          this.pubID = this.stringify.dtdPubID(pubID);
        }
        if (sysID != null) {
          this.sysID = this.stringify.dtdSysID(sysID);
        }
      }
      Object.defineProperty(XMLDocType2.prototype, "entities", {
        get: function() {
          var child, i3, len, nodes, ref4;
          nodes = {};
          ref4 = this.children;
          for (i3 = 0, len = ref4.length;i3 < len; i3++) {
            child = ref4[i3];
            if (child.type === NodeType.EntityDeclaration && !child.pe) {
              nodes[child.name] = child;
            }
          }
          return new XMLNamedNodeMap(nodes);
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "notations", {
        get: function() {
          var child, i3, len, nodes, ref4;
          nodes = {};
          ref4 = this.children;
          for (i3 = 0, len = ref4.length;i3 < len; i3++) {
            child = ref4[i3];
            if (child.type === NodeType.NotationDeclaration) {
              nodes[child.name] = child;
            }
          }
          return new XMLNamedNodeMap(nodes);
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      });
      Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      XMLDocType2.prototype.element = function(name, value15) {
        var child;
        child = new XMLDTDElement(this, name, value15);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var child;
        child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.entity = function(name, value15) {
        var child;
        child = new XMLDTDEntity(this, false, name, value15);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.pEntity = function(name, value15) {
        var child;
        child = new XMLDTDEntity(this, true, name, value15);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.notation = function(name, value15) {
        var child;
        child = new XMLDTDNotation(this, name, value15);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.toString = function(options) {
        return this.options.writer.docType(this, this.options.writer.filterOptions(options));
      };
      XMLDocType2.prototype.ele = function(name, value15) {
        return this.element(name, value15);
      };
      XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
      };
      XMLDocType2.prototype.ent = function(name, value15) {
        return this.entity(name, value15);
      };
      XMLDocType2.prototype.pent = function(name, value15) {
        return this.pEntity(name, value15);
      };
      XMLDocType2.prototype.not = function(name, value15) {
        return this.notation(name, value15);
      };
      XMLDocType2.prototype.up = function() {
        return this.root() || this.documentObject;
      };
      XMLDocType2.prototype.isEqualNode = function(node) {
        if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.name !== this.name) {
          return false;
        }
        if (node.publicId !== this.publicId) {
          return false;
        }
        if (node.systemId !== this.systemId) {
          return false;
        }
        return true;
      };
      return XMLDocType2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLNode, XMLRaw, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLNode = require_XMLNode();
    module.exports = XMLRaw = function(superClass) {
      extend(XMLRaw2, superClass);
      function XMLRaw2(parent, text) {
        XMLRaw2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing raw text. " + this.debugInfo());
        }
        this.type = NodeType.Raw;
        this.value = this.stringify.raw(text);
      }
      XMLRaw2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLRaw2.prototype.toString = function(options) {
        return this.options.writer.raw(this, this.options.writer.filterOptions(options));
      };
      return XMLRaw2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLCharacterData, XMLText, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module.exports = XMLText = function(superClass) {
      extend(XMLText2, superClass);
      function XMLText2(parent, text) {
        XMLText2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing element text. " + this.debugInfo());
        }
        this.name = "#text";
        this.type = NodeType.Text;
        this.value = this.stringify.text(text);
      }
      Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      Object.defineProperty(XMLText2.prototype, "wholeText", {
        get: function() {
          var next, prev, str;
          str = "";
          prev = this.previousSibling;
          while (prev) {
            str = prev.data + str;
            prev = prev.previousSibling;
          }
          str += this.data;
          next = this.nextSibling;
          while (next) {
            str = str + next.data;
            next = next.nextSibling;
          }
          return str;
        }
      });
      XMLText2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLText2.prototype.toString = function(options) {
        return this.options.writer.text(this, this.options.writer.filterOptions(options));
      };
      XMLText2.prototype.splitText = function(offset) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLText2.prototype.replaceWholeText = function(content) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      return XMLText2;
    }(XMLCharacterData);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module.exports = XMLProcessingInstruction = function(superClass) {
      extend(XMLProcessingInstruction2, superClass);
      function XMLProcessingInstruction2(parent, target, value15) {
        XMLProcessingInstruction2.__super__.constructor.call(this, parent);
        if (target == null) {
          throw new Error("Missing instruction target. " + this.debugInfo());
        }
        this.type = NodeType.ProcessingInstruction;
        this.target = this.stringify.insTarget(target);
        this.name = this.target;
        if (value15) {
          this.value = this.stringify.insValue(value15);
        }
      }
      XMLProcessingInstruction2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLProcessingInstruction2.prototype.toString = function(options) {
        return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
      };
      XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
        if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
          return false;
        }
        if (node.target !== this.target) {
          return false;
        }
        return true;
      };
      return XMLProcessingInstruction2;
    }(XMLCharacterData);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDummy, XMLNode, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module.exports = XMLDummy = function(superClass) {
      extend(XMLDummy2, superClass);
      function XMLDummy2(parent) {
        XMLDummy2.__super__.constructor.call(this, parent);
        this.type = NodeType.Dummy;
      }
      XMLDummy2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLDummy2.prototype.toString = function(options) {
        return "";
      };
      return XMLDummy2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS((exports, module) => {
  (function() {
    var XMLNodeList;
    module.exports = XMLNodeList = function() {
      function XMLNodeList2(nodes) {
        this.nodes = nodes;
      }
      Object.defineProperty(XMLNodeList2.prototype, "length", {
        get: function() {
          return this.nodes.length || 0;
        }
      });
      XMLNodeList2.prototype.clone = function() {
        return this.nodes = null;
      };
      XMLNodeList2.prototype.item = function(index) {
        return this.nodes[index] || null;
      };
      return XMLNodeList2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS((exports, module) => {
  (function() {
    module.exports = {
      Disconnected: 1,
      Preceding: 2,
      Following: 4,
      Contains: 8,
      ContainedBy: 16,
      ImplementationSpecific: 32
    };
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS((exports, module) => {
  (function() {
    var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
    ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
    XMLElement = null;
    XMLCData = null;
    XMLComment = null;
    XMLDeclaration = null;
    XMLDocType = null;
    XMLRaw = null;
    XMLText = null;
    XMLProcessingInstruction = null;
    XMLDummy = null;
    NodeType = null;
    XMLNodeList = null;
    XMLNamedNodeMap = null;
    DocumentPosition = null;
    module.exports = XMLNode = function() {
      function XMLNode2(parent1) {
        this.parent = parent1;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        this.value = null;
        this.children = [];
        this.baseURI = null;
        if (!XMLElement) {
          XMLElement = require_XMLElement();
          XMLCData = require_XMLCData();
          XMLComment = require_XMLComment();
          XMLDeclaration = require_XMLDeclaration();
          XMLDocType = require_XMLDocType();
          XMLRaw = require_XMLRaw();
          XMLText = require_XMLText();
          XMLProcessingInstruction = require_XMLProcessingInstruction();
          XMLDummy = require_XMLDummy();
          NodeType = require_NodeType();
          XMLNodeList = require_XMLNodeList();
          XMLNamedNodeMap = require_XMLNamedNodeMap();
          DocumentPosition = require_DocumentPosition();
        }
      }
      Object.defineProperty(XMLNode2.prototype, "nodeName", {
        get: function() {
          return this.name;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "nodeValue", {
        get: function() {
          return this.value;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "parentNode", {
        get: function() {
          return this.parent;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "childNodes", {
        get: function() {
          if (!this.childNodeList || !this.childNodeList.nodes) {
            this.childNodeList = new XMLNodeList(this.children);
          }
          return this.childNodeList;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "firstChild", {
        get: function() {
          return this.children[0] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "lastChild", {
        get: function() {
          return this.children[this.children.length - 1] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "previousSibling", {
        get: function() {
          var i3;
          i3 = this.parent.children.indexOf(this);
          return this.parent.children[i3 - 1] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "nextSibling", {
        get: function() {
          var i3;
          i3 = this.parent.children.indexOf(this);
          return this.parent.children[i3 + 1] || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
        get: function() {
          return this.document() || null;
        }
      });
      Object.defineProperty(XMLNode2.prototype, "textContent", {
        get: function() {
          var child, j, len, ref22, str;
          if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
            str = "";
            ref22 = this.children;
            for (j = 0, len = ref22.length;j < len; j++) {
              child = ref22[j];
              if (child.textContent) {
                str += child.textContent;
              }
            }
            return str;
          } else {
            return null;
          }
        },
        set: function(value15) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      });
      XMLNode2.prototype.setParent = function(parent) {
        var child, j, len, ref22, results;
        this.parent = parent;
        if (parent) {
          this.options = parent.options;
          this.stringify = parent.stringify;
        }
        ref22 = this.children;
        results = [];
        for (j = 0, len = ref22.length;j < len; j++) {
          child = ref22[j];
          results.push(child.setParent(this));
        }
        return results;
      };
      XMLNode2.prototype.element = function(name, attributes, text) {
        var childNode, item, j, k, key, lastChild, len, len1, ref22, ref32, val;
        lastChild = null;
        if (attributes === null && text == null) {
          ref22 = [{}, null], attributes = ref22[0], text = ref22[1];
        }
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref32 = [attributes, text], text = ref32[0], attributes = ref32[1];
        }
        if (name != null) {
          name = getValue(name);
        }
        if (Array.isArray(name)) {
          for (j = 0, len = name.length;j < len; j++) {
            item = name[j];
            lastChild = this.element(item);
          }
        } else if (isFunction(name)) {
          lastChild = this.element(name.apply());
        } else if (isObject(name)) {
          for (key in name) {
            if (!hasProp.call(name, key))
              continue;
            val = name[key];
            if (isFunction(val)) {
              val = val.apply();
            }
            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
              lastChild = this.dummy();
            } else if (isObject(val) && isEmpty(val)) {
              lastChild = this.element(key);
            } else if (!this.options.keepNullNodes && val == null) {
              lastChild = this.dummy();
            } else if (!this.options.separateArrayItems && Array.isArray(val)) {
              for (k = 0, len1 = val.length;k < len1; k++) {
                item = val[k];
                childNode = {};
                childNode[key] = item;
                lastChild = this.element(childNode);
              }
            } else if (isObject(val)) {
              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                lastChild = this.element(val);
              } else {
                lastChild = this.element(key);
                lastChild.element(val);
              }
            } else {
              lastChild = this.element(key, val);
            }
          }
        } else if (!this.options.keepNullNodes && text === null) {
          lastChild = this.dummy();
        } else {
          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
            lastChild = this.text(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
            lastChild = this.cdata(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
            lastChild = this.comment(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
            lastChild = this.raw(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
          } else {
            lastChild = this.node(name, attributes, text);
          }
        }
        if (lastChild == null) {
          throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
        }
        return lastChild;
      };
      XMLNode2.prototype.insertBefore = function(name, attributes, text) {
        var child, i3, newChild, refChild, removed;
        if (name != null ? name.type : undefined) {
          newChild = name;
          refChild = attributes;
          newChild.setParent(this);
          if (refChild) {
            i3 = children.indexOf(refChild);
            removed = children.splice(i3);
            children.push(newChild);
            Array.prototype.push.apply(children, removed);
          } else {
            children.push(newChild);
          }
          return newChild;
        } else {
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          i3 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i3);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        }
      };
      XMLNode2.prototype.insertAfter = function(name, attributes, text) {
        var child, i3, removed;
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        }
        i3 = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i3 + 1);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };
      XMLNode2.prototype.remove = function() {
        var i3, ref22;
        if (this.isRoot) {
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        }
        i3 = this.parent.children.indexOf(this);
        [].splice.apply(this.parent.children, [i3, i3 - i3 + 1].concat(ref22 = []));
        return this.parent;
      };
      XMLNode2.prototype.node = function(name, attributes, text) {
        var child, ref22;
        if (name != null) {
          name = getValue(name);
        }
        attributes || (attributes = {});
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref22 = [attributes, text], text = ref22[0], attributes = ref22[1];
        }
        child = new XMLElement(this, name, attributes);
        if (text != null) {
          child.text(text);
        }
        this.children.push(child);
        return child;
      };
      XMLNode2.prototype.text = function(value15) {
        var child;
        if (isObject(value15)) {
          this.element(value15);
        }
        child = new XMLText(this, value15);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.cdata = function(value15) {
        var child;
        child = new XMLCData(this, value15);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.comment = function(value15) {
        var child;
        child = new XMLComment(this, value15);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.commentBefore = function(value15) {
        var child, i3, removed;
        i3 = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i3);
        child = this.parent.comment(value15);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.commentAfter = function(value15) {
        var child, i3, removed;
        i3 = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i3 + 1);
        child = this.parent.comment(value15);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.raw = function(value15) {
        var child;
        child = new XMLRaw(this, value15);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.dummy = function() {
        var child;
        child = new XMLDummy(this);
        return child;
      };
      XMLNode2.prototype.instruction = function(target, value15) {
        var insTarget, insValue, instruction, j, len;
        if (target != null) {
          target = getValue(target);
        }
        if (value15 != null) {
          value15 = getValue(value15);
        }
        if (Array.isArray(target)) {
          for (j = 0, len = target.length;j < len; j++) {
            insTarget = target[j];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget))
              continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value15)) {
            value15 = value15.apply();
          }
          instruction = new XMLProcessingInstruction(this, target, value15);
          this.children.push(instruction);
        }
        return this;
      };
      XMLNode2.prototype.instructionBefore = function(target, value15) {
        var child, i3, removed;
        i3 = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i3);
        child = this.parent.instruction(target, value15);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.instructionAfter = function(target, value15) {
        var child, i3, removed;
        i3 = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i3 + 1);
        child = this.parent.instruction(target, value15);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.declaration = function(version, encoding5, standalone) {
        var doc, xmldec;
        doc = this.document();
        xmldec = new XMLDeclaration(doc, version, encoding5, standalone);
        if (doc.children.length === 0) {
          doc.children.unshift(xmldec);
        } else if (doc.children[0].type === NodeType.Declaration) {
          doc.children[0] = xmldec;
        } else {
          doc.children.unshift(xmldec);
        }
        return doc.root() || doc;
      };
      XMLNode2.prototype.dtd = function(pubID, sysID) {
        var child, doc, doctype, i3, j, k, len, len1, ref22, ref32;
        doc = this.document();
        doctype = new XMLDocType(doc, pubID, sysID);
        ref22 = doc.children;
        for (i3 = j = 0, len = ref22.length;j < len; i3 = ++j) {
          child = ref22[i3];
          if (child.type === NodeType.DocType) {
            doc.children[i3] = doctype;
            return doctype;
          }
        }
        ref32 = doc.children;
        for (i3 = k = 0, len1 = ref32.length;k < len1; i3 = ++k) {
          child = ref32[i3];
          if (child.isRoot) {
            doc.children.splice(i3, 0, doctype);
            return doctype;
          }
        }
        doc.children.push(doctype);
        return doctype;
      };
      XMLNode2.prototype.up = function() {
        if (this.isRoot) {
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        }
        return this.parent;
      };
      XMLNode2.prototype.root = function() {
        var node;
        node = this;
        while (node) {
          if (node.type === NodeType.Document) {
            return node.rootObject;
          } else if (node.isRoot) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };
      XMLNode2.prototype.document = function() {
        var node;
        node = this;
        while (node) {
          if (node.type === NodeType.Document) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };
      XMLNode2.prototype.end = function(options) {
        return this.document().end(options);
      };
      XMLNode2.prototype.prev = function() {
        var i3;
        i3 = this.parent.children.indexOf(this);
        if (i3 < 1) {
          throw new Error("Already at the first node. " + this.debugInfo());
        }
        return this.parent.children[i3 - 1];
      };
      XMLNode2.prototype.next = function() {
        var i3;
        i3 = this.parent.children.indexOf(this);
        if (i3 === -1 || i3 === this.parent.children.length - 1) {
          throw new Error("Already at the last node. " + this.debugInfo());
        }
        return this.parent.children[i3 + 1];
      };
      XMLNode2.prototype.importDocument = function(doc) {
        var clonedRoot;
        clonedRoot = doc.root().clone();
        clonedRoot.parent = this;
        clonedRoot.isRoot = false;
        this.children.push(clonedRoot);
        return this;
      };
      XMLNode2.prototype.debugInfo = function(name) {
        var ref22, ref32;
        name = name || this.name;
        if (name == null && !((ref22 = this.parent) != null ? ref22.name : undefined)) {
          return "";
        } else if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else if (!((ref32 = this.parent) != null ? ref32.name : undefined)) {
          return "node: <" + name + ">";
        } else {
          return "node: <" + name + ">, parent: <" + this.parent.name + ">";
        }
      };
      XMLNode2.prototype.ele = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode2.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode2.prototype.txt = function(value15) {
        return this.text(value15);
      };
      XMLNode2.prototype.dat = function(value15) {
        return this.cdata(value15);
      };
      XMLNode2.prototype.com = function(value15) {
        return this.comment(value15);
      };
      XMLNode2.prototype.ins = function(target, value15) {
        return this.instruction(target, value15);
      };
      XMLNode2.prototype.doc = function() {
        return this.document();
      };
      XMLNode2.prototype.dec = function(version, encoding5, standalone) {
        return this.declaration(version, encoding5, standalone);
      };
      XMLNode2.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode2.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode2.prototype.t = function(value15) {
        return this.text(value15);
      };
      XMLNode2.prototype.d = function(value15) {
        return this.cdata(value15);
      };
      XMLNode2.prototype.c = function(value15) {
        return this.comment(value15);
      };
      XMLNode2.prototype.r = function(value15) {
        return this.raw(value15);
      };
      XMLNode2.prototype.i = function(target, value15) {
        return this.instruction(target, value15);
      };
      XMLNode2.prototype.u = function() {
        return this.up();
      };
      XMLNode2.prototype.importXMLBuilder = function(doc) {
        return this.importDocument(doc);
      };
      XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.removeChild = function(oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.appendChild = function(newChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.hasChildNodes = function() {
        return this.children.length !== 0;
      };
      XMLNode2.prototype.cloneNode = function(deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.normalize = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.isSupported = function(feature, version) {
        return true;
      };
      XMLNode2.prototype.hasAttributes = function() {
        return this.attribs.length !== 0;
      };
      XMLNode2.prototype.compareDocumentPosition = function(other) {
        var ref4, res;
        ref4 = this;
        if (ref4 === other) {
          return 0;
        } else if (this.document() !== other.document()) {
          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
          if (Math.random() < 0.5) {
            res |= DocumentPosition.Preceding;
          } else {
            res |= DocumentPosition.Following;
          }
          return res;
        } else if (ref4.isAncestor(other)) {
          return DocumentPosition.Contains | DocumentPosition.Preceding;
        } else if (ref4.isDescendant(other)) {
          return DocumentPosition.Contains | DocumentPosition.Following;
        } else if (ref4.isPreceding(other)) {
          return DocumentPosition.Preceding;
        } else {
          return DocumentPosition.Following;
        }
      };
      XMLNode2.prototype.isSameNode = function(other) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.isEqualNode = function(node) {
        var i3, j, ref22;
        if (node.nodeType !== this.nodeType) {
          return false;
        }
        if (node.children.length !== this.children.length) {
          return false;
        }
        for (i3 = j = 0, ref22 = this.children.length - 1;0 <= ref22 ? j <= ref22 : j >= ref22; i3 = 0 <= ref22 ? ++j : --j) {
          if (!this.children[i3].isEqualNode(node.children[i3])) {
            return false;
          }
        }
        return true;
      };
      XMLNode2.prototype.getFeature = function(feature, version) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.setUserData = function(key, data, handler) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.getUserData = function(key) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLNode2.prototype.contains = function(other) {
        if (!other) {
          return false;
        }
        return other === this || this.isDescendant(other);
      };
      XMLNode2.prototype.isDescendant = function(node) {
        var child, isDescendantChild, j, len, ref22;
        ref22 = this.children;
        for (j = 0, len = ref22.length;j < len; j++) {
          child = ref22[j];
          if (node === child) {
            return true;
          }
          isDescendantChild = child.isDescendant(node);
          if (isDescendantChild) {
            return true;
          }
        }
        return false;
      };
      XMLNode2.prototype.isAncestor = function(node) {
        return node.isDescendant(this);
      };
      XMLNode2.prototype.isPreceding = function(node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);
        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos < thisPos;
        }
      };
      XMLNode2.prototype.isFollowing = function(node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);
        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos > thisPos;
        }
      };
      XMLNode2.prototype.treePosition = function(node) {
        var found, pos;
        pos = 0;
        found = false;
        this.foreachTreeNode(this.document(), function(childNode) {
          pos++;
          if (!found && childNode === node) {
            return found = true;
          }
        });
        if (found) {
          return pos;
        } else {
          return -1;
        }
      };
      XMLNode2.prototype.foreachTreeNode = function(node, func) {
        var child, j, len, ref22, res;
        node || (node = this.document());
        ref22 = node.children;
        for (j = 0, len = ref22.length;j < len; j++) {
          child = ref22[j];
          if (res = func(child)) {
            return res;
          } else {
            res = this.foreachTreeNode(child, func);
            if (res) {
              return res;
            }
          }
        }
      };
      return XMLNode2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS((exports, module) => {
  (function() {
    var XMLStringifier, bind = function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    }, hasProp = {}.hasOwnProperty;
    module.exports = XMLStringifier = function() {
      function XMLStringifier2(options) {
        this.assertLegalName = bind(this.assertLegalName, this);
        this.assertLegalChar = bind(this.assertLegalChar, this);
        var key, ref4, value15;
        options || (options = {});
        this.options = options;
        if (!this.options.version) {
          this.options.version = "1.0";
        }
        ref4 = options.stringify || {};
        for (key in ref4) {
          if (!hasProp.call(ref4, key))
            continue;
          value15 = ref4[key];
          this[key] = value15;
        }
      }
      XMLStringifier2.prototype.name = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalName("" + val || "");
      };
      XMLStringifier2.prototype.text = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar(this.textEscape("" + val || ""));
      };
      XMLStringifier2.prototype.cdata = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        val = val.replace("]]>", "]]]]><![CDATA[>");
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.comment = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (val.match(/--/)) {
          throw new Error("Comment text cannot contain double-hypen: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.raw = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return "" + val || "";
      };
      XMLStringifier2.prototype.attValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar(this.attEscape(val = "" + val || ""));
      };
      XMLStringifier2.prototype.insTarget = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.insValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (val.match(/\?>/)) {
          throw new Error("Invalid processing instruction value: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.xmlVersion = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (!val.match(/1\.[0-9]+/)) {
          throw new Error("Invalid version number: " + val);
        }
        return val;
      };
      XMLStringifier2.prototype.xmlEncoding = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = "" + val || "";
        if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
          throw new Error("Invalid encoding: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.xmlStandalone = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        if (val) {
          return "yes";
        } else {
          return "no";
        }
      };
      XMLStringifier2.prototype.dtdPubID = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdSysID = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdElementValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdAttType = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdAttDefault = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdEntityValue = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.dtdNData = function(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar("" + val || "");
      };
      XMLStringifier2.prototype.convertAttKey = "@";
      XMLStringifier2.prototype.convertPIKey = "?";
      XMLStringifier2.prototype.convertTextKey = "#text";
      XMLStringifier2.prototype.convertCDataKey = "#cdata";
      XMLStringifier2.prototype.convertCommentKey = "#comment";
      XMLStringifier2.prototype.convertRawKey = "#raw";
      XMLStringifier2.prototype.assertLegalChar = function(str) {
        var regex, res;
        if (this.options.noValidation) {
          return str;
        }
        regex = "";
        if (this.options.version === "1.0") {
          regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          if (res = str.match(regex)) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
        } else if (this.options.version === "1.1") {
          regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          if (res = str.match(regex)) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
        }
        return str;
      };
      XMLStringifier2.prototype.assertLegalName = function(str) {
        var regex;
        if (this.options.noValidation) {
          return str;
        }
        this.assertLegalChar(str);
        regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
        if (!str.match(regex)) {
          throw new Error("Invalid character in name");
        }
        return str;
      };
      XMLStringifier2.prototype.textEscape = function(str) {
        var ampregex;
        if (this.options.noValidation) {
          return str;
        }
        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      };
      XMLStringifier2.prototype.attEscape = function(str) {
        var ampregex;
        if (this.options.noValidation) {
          return str;
        }
        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      };
      return XMLStringifier2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS((exports, module) => {
  (function() {
    module.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3
    };
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS((exports, module) => {
  (function() {
    var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
    assign = require_Utility().assign;
    NodeType = require_NodeType();
    XMLDeclaration = require_XMLDeclaration();
    XMLDocType = require_XMLDocType();
    XMLCData = require_XMLCData();
    XMLComment = require_XMLComment();
    XMLElement = require_XMLElement();
    XMLRaw = require_XMLRaw();
    XMLText = require_XMLText();
    XMLProcessingInstruction = require_XMLProcessingInstruction();
    XMLDummy = require_XMLDummy();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDNotation = require_XMLDTDNotation();
    WriterState = require_WriterState();
    module.exports = XMLWriterBase = function() {
      function XMLWriterBase2(options) {
        var key, ref4, value15;
        options || (options = {});
        this.options = options;
        ref4 = options.writer || {};
        for (key in ref4) {
          if (!hasProp.call(ref4, key))
            continue;
          value15 = ref4[key];
          this["_" + key] = this[key];
          this[key] = value15;
        }
      }
      XMLWriterBase2.prototype.filterOptions = function(options) {
        var filteredOptions, ref4, ref1, ref22, ref32, ref42, ref5, ref6;
        options || (options = {});
        options = assign({}, this.options, options);
        filteredOptions = {
          writer: this
        };
        filteredOptions.pretty = options.pretty || false;
        filteredOptions.allowEmpty = options.allowEmpty || false;
        filteredOptions.indent = (ref4 = options.indent) != null ? ref4 : "  ";
        filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
        filteredOptions.offset = (ref22 = options.offset) != null ? ref22 : 0;
        filteredOptions.dontPrettyTextNodes = (ref32 = (ref42 = options.dontPrettyTextNodes) != null ? ref42 : options.dontprettytextnodes) != null ? ref32 : 0;
        filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
        if (filteredOptions.spaceBeforeSlash === true) {
          filteredOptions.spaceBeforeSlash = " ";
        }
        filteredOptions.suppressPrettyCount = 0;
        filteredOptions.user = {};
        filteredOptions.state = WriterState.None;
        return filteredOptions;
      };
      XMLWriterBase2.prototype.indent = function(node, options, level) {
        var indentLevel;
        if (!options.pretty || options.suppressPrettyCount) {
          return "";
        } else if (options.pretty) {
          indentLevel = (level || 0) + options.offset + 1;
          if (indentLevel > 0) {
            return new Array(indentLevel).join(options.indent);
          }
        }
        return "";
      };
      XMLWriterBase2.prototype.endline = function(node, options, level) {
        if (!options.pretty || options.suppressPrettyCount) {
          return "";
        } else {
          return options.newline;
        }
      };
      XMLWriterBase2.prototype.attribute = function(att, options, level) {
        var r;
        this.openAttribute(att, options, level);
        r = " " + att.name + '="' + att.value + '"';
        this.closeAttribute(att, options, level);
        return r;
      };
      XMLWriterBase2.prototype.cdata = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<![CDATA[";
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += "]]>" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.comment = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!-- ";
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += " -->" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.declaration = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<?xml";
        options.state = WriterState.InsideTag;
        r += ' version="' + node.version + '"';
        if (node.encoding != null) {
          r += ' encoding="' + node.encoding + '"';
        }
        if (node.standalone != null) {
          r += ' standalone="' + node.standalone + '"';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + "?>";
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.docType = function(node, options, level) {
        var child, i3, len, r, ref4;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        r += "<!DOCTYPE " + node.root().name;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.children.length > 0) {
          r += " [";
          r += this.endline(node, options, level);
          options.state = WriterState.InsideTag;
          ref4 = node.children;
          for (i3 = 0, len = ref4.length;i3 < len; i3++) {
            child = ref4[i3];
            r += this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          r += "]";
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">";
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.element = function(node, options, level) {
        var att, child, childNodeCount, firstChildNode, i3, j, len, len1, name, prettySuppressed, r, ref4, ref1, ref22;
        level || (level = 0);
        prettySuppressed = false;
        r = "";
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r += this.indent(node, options, level) + "<" + node.name;
        ref4 = node.attribs;
        for (name in ref4) {
          if (!hasProp.call(ref4, name))
            continue;
          att = ref4[name];
          r += this.attribute(att, options, level);
        }
        childNodeCount = node.children.length;
        firstChildNode = childNodeCount === 0 ? null : node.children[0];
        if (childNodeCount === 0 || node.children.every(function(e) {
          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
        })) {
          if (options.allowEmpty) {
            r += ">";
            options.state = WriterState.CloseTag;
            r += "</" + node.name + ">" + this.endline(node, options, level);
          } else {
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
          }
        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
          r += ">";
          options.state = WriterState.InsideTag;
          options.suppressPrettyCount++;
          prettySuppressed = true;
          r += this.writeChildNode(firstChildNode, options, level + 1);
          options.suppressPrettyCount--;
          prettySuppressed = false;
          options.state = WriterState.CloseTag;
          r += "</" + node.name + ">" + this.endline(node, options, level);
        } else {
          if (options.dontPrettyTextNodes) {
            ref1 = node.children;
            for (i3 = 0, len = ref1.length;i3 < len; i3++) {
              child = ref1[i3];
              if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                options.suppressPrettyCount++;
                prettySuppressed = true;
                break;
              }
            }
          }
          r += ">" + this.endline(node, options, level);
          options.state = WriterState.InsideTag;
          ref22 = node.children;
          for (j = 0, len1 = ref22.length;j < len1; j++) {
            child = ref22[j];
            r += this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          r += this.indent(node, options, level) + "</" + node.name + ">";
          if (prettySuppressed) {
            options.suppressPrettyCount--;
          }
          r += this.endline(node, options, level);
          options.state = WriterState.None;
        }
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
        switch (node.type) {
          case NodeType.CData:
            return this.cdata(node, options, level);
          case NodeType.Comment:
            return this.comment(node, options, level);
          case NodeType.Element:
            return this.element(node, options, level);
          case NodeType.Raw:
            return this.raw(node, options, level);
          case NodeType.Text:
            return this.text(node, options, level);
          case NodeType.ProcessingInstruction:
            return this.processingInstruction(node, options, level);
          case NodeType.Dummy:
            return "";
          case NodeType.Declaration:
            return this.declaration(node, options, level);
          case NodeType.DocType:
            return this.docType(node, options, level);
          case NodeType.AttributeDeclaration:
            return this.dtdAttList(node, options, level);
          case NodeType.ElementDeclaration:
            return this.dtdElement(node, options, level);
          case NodeType.EntityDeclaration:
            return this.dtdEntity(node, options, level);
          case NodeType.NotationDeclaration:
            return this.dtdNotation(node, options, level);
          default:
            throw new Error("Unknown XML node type: " + node.constructor.name);
        }
      };
      XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<?";
        options.state = WriterState.InsideTag;
        r += node.target;
        if (node.value) {
          r += " " + node.value;
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + "?>";
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.raw = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.text = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!ATTLIST";
        options.state = WriterState.InsideTag;
        r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
        if (node.defaultValueType !== "#DEFAULT") {
          r += " " + node.defaultValueType;
        }
        if (node.defaultValue) {
          r += ' "' + node.defaultValue + '"';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!ELEMENT";
        options.state = WriterState.InsideTag;
        r += " " + node.name + " " + node.value;
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!ENTITY";
        options.state = WriterState.InsideTag;
        if (node.pe) {
          r += " %";
        }
        r += " " + node.name;
        if (node.value) {
          r += ' "' + node.value + '"';
        } else {
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.nData) {
            r += " NDATA " + node.nData;
          }
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + "<!NOTATION";
        options.state = WriterState.InsideTag;
        r += " " + node.name;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.pubID) {
          r += ' PUBLIC "' + node.pubID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.openNode = function(node, options, level) {
      };
      XMLWriterBase2.prototype.closeNode = function(node, options, level) {
      };
      XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
      };
      XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
      };
      return XMLWriterBase2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS((exports, module) => {
  (function() {
    var XMLStringWriter, XMLWriterBase, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLWriterBase = require_XMLWriterBase();
    module.exports = XMLStringWriter = function(superClass) {
      extend(XMLStringWriter2, superClass);
      function XMLStringWriter2(options) {
        XMLStringWriter2.__super__.constructor.call(this, options);
      }
      XMLStringWriter2.prototype.document = function(doc, options) {
        var child, i3, len, r, ref4;
        options = this.filterOptions(options);
        r = "";
        ref4 = doc.children;
        for (i3 = 0, len = ref4.length;i3 < len; i3++) {
          child = ref4[i3];
          r += this.writeChildNode(child, options, 0);
        }
        if (options.pretty && r.slice(-options.newline.length) === options.newline) {
          r = r.slice(0, -options.newline.length);
        }
        return r;
      };
      return XMLStringWriter2;
    }(XMLWriterBase);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS((exports, module) => {
  (function() {
    var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isPlainObject = require_Utility().isPlainObject;
    XMLDOMImplementation = require_XMLDOMImplementation();
    XMLDOMConfiguration = require_XMLDOMConfiguration();
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLStringifier = require_XMLStringifier();
    XMLStringWriter = require_XMLStringWriter();
    module.exports = XMLDocument = function(superClass) {
      extend(XMLDocument2, superClass);
      function XMLDocument2(options) {
        XMLDocument2.__super__.constructor.call(this, null);
        this.name = "#document";
        this.type = NodeType.Document;
        this.documentURI = null;
        this.domConfig = new XMLDOMConfiguration;
        options || (options = {});
        if (!options.writer) {
          options.writer = new XMLStringWriter;
        }
        this.options = options;
        this.stringify = new XMLStringifier(options);
      }
      Object.defineProperty(XMLDocument2.prototype, "implementation", {
        value: new XMLDOMImplementation
      });
      Object.defineProperty(XMLDocument2.prototype, "doctype", {
        get: function() {
          var child, i3, len, ref4;
          ref4 = this.children;
          for (i3 = 0, len = ref4.length;i3 < len; i3++) {
            child = ref4[i3];
            if (child.type === NodeType.DocType) {
              return child;
            }
          }
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "documentElement", {
        get: function() {
          return this.rootObject || null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
        get: function() {
          return false;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
            return this.children[0].encoding;
          } else {
            return null;
          }
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
            return this.children[0].standalone === "yes";
          } else {
            return false;
          }
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
            return this.children[0].version;
          } else {
            return "1.0";
          }
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "URL", {
        get: function() {
          return this.documentURI;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "origin", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "compatMode", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "characterSet", {
        get: function() {
          return null;
        }
      });
      Object.defineProperty(XMLDocument2.prototype, "contentType", {
        get: function() {
          return null;
        }
      });
      XMLDocument2.prototype.end = function(writer) {
        var writerOptions;
        writerOptions = {};
        if (!writer) {
          writer = this.options.writer;
        } else if (isPlainObject(writer)) {
          writerOptions = writer;
          writer = this.options.writer;
        }
        return writer.document(this, writer.filterOptions(writerOptions));
      };
      XMLDocument2.prototype.toString = function(options) {
        return this.options.writer.document(this, this.options.writer.filterOptions(options));
      };
      XMLDocument2.prototype.createElement = function(tagName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createDocumentFragment = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createTextNode = function(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createComment = function(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createCDATASection = function(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createProcessingInstruction = function(target, data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createAttribute = function(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createEntityReference = function(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementsByTagName = function(tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.importNode = function(importedNode, deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementById = function(elementId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.adoptNode = function(source) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.normalizeDocument = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.getElementsByClassName = function(classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createEvent = function(eventInterface) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createRange = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createNodeIterator = function(root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      XMLDocument2.prototype.createTreeWalker = function(root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      };
      return XMLDocument2;
    }(XMLNode);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS((exports, module) => {
  (function() {
    var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref4, hasProp = {}.hasOwnProperty;
    ref4 = require_Utility(), isObject = ref4.isObject, isFunction = ref4.isFunction, isPlainObject = ref4.isPlainObject, getValue = ref4.getValue;
    NodeType = require_NodeType();
    XMLDocument = require_XMLDocument();
    XMLElement = require_XMLElement();
    XMLCData = require_XMLCData();
    XMLComment = require_XMLComment();
    XMLRaw = require_XMLRaw();
    XMLText = require_XMLText();
    XMLProcessingInstruction = require_XMLProcessingInstruction();
    XMLDeclaration = require_XMLDeclaration();
    XMLDocType = require_XMLDocType();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDNotation = require_XMLDTDNotation();
    XMLAttribute = require_XMLAttribute();
    XMLStringifier = require_XMLStringifier();
    XMLStringWriter = require_XMLStringWriter();
    WriterState = require_WriterState();
    module.exports = XMLDocumentCB = function() {
      function XMLDocumentCB2(options, onData, onEnd) {
        var writerOptions;
        this.name = "?xml";
        this.type = NodeType.Document;
        options || (options = {});
        writerOptions = {};
        if (!options.writer) {
          options.writer = new XMLStringWriter;
        } else if (isPlainObject(options.writer)) {
          writerOptions = options.writer;
          options.writer = new XMLStringWriter;
        }
        this.options = options;
        this.writer = options.writer;
        this.writerOptions = this.writer.filterOptions(writerOptions);
        this.stringify = new XMLStringifier(options);
        this.onDataCallback = onData || function() {
        };
        this.onEndCallback = onEnd || function() {
        };
        this.currentNode = null;
        this.currentLevel = -1;
        this.openTags = {};
        this.documentStarted = false;
        this.documentCompleted = false;
        this.root = null;
      }
      XMLDocumentCB2.prototype.createChildNode = function(node) {
        var att, attName, attributes, child, i3, len, ref1, ref22;
        switch (node.type) {
          case NodeType.CData:
            this.cdata(node.value);
            break;
          case NodeType.Comment:
            this.comment(node.value);
            break;
          case NodeType.Element:
            attributes = {};
            ref1 = node.attribs;
            for (attName in ref1) {
              if (!hasProp.call(ref1, attName))
                continue;
              att = ref1[attName];
              attributes[attName] = att.value;
            }
            this.node(node.name, attributes);
            break;
          case NodeType.Dummy:
            this.dummy();
            break;
          case NodeType.Raw:
            this.raw(node.value);
            break;
          case NodeType.Text:
            this.text(node.value);
            break;
          case NodeType.ProcessingInstruction:
            this.instruction(node.target, node.value);
            break;
          default:
            throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
        }
        ref22 = node.children;
        for (i3 = 0, len = ref22.length;i3 < len; i3++) {
          child = ref22[i3];
          this.createChildNode(child);
          if (child.type === NodeType.Element) {
            this.up();
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.dummy = function() {
        return this;
      };
      XMLDocumentCB2.prototype.node = function(name, attributes, text) {
        var ref1;
        if (name == null) {
          throw new Error("Missing node name.");
        }
        if (this.root && this.currentLevel === -1) {
          throw new Error("Document can only have one root node. " + this.debugInfo(name));
        }
        this.openCurrent();
        name = getValue(name);
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
        }
        this.currentNode = new XMLElement(this, name, attributes);
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        if (text != null) {
          this.text(text);
        }
        return this;
      };
      XMLDocumentCB2.prototype.element = function(name, attributes, text) {
        var child, i3, len, oldValidationFlag, ref1, root;
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          this.dtdElement.apply(this, arguments);
        } else {
          if (Array.isArray(name) || isObject(name) || isFunction(name)) {
            oldValidationFlag = this.options.noValidation;
            this.options.noValidation = true;
            root = new XMLDocument(this.options).element("TEMP_ROOT");
            root.element(name);
            this.options.noValidation = oldValidationFlag;
            ref1 = root.children;
            for (i3 = 0, len = ref1.length;i3 < len; i3++) {
              child = ref1[i3];
              this.createChildNode(child);
              if (child.type === NodeType.Element) {
                this.up();
              }
            }
          } else {
            this.node(name, attributes, text);
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.attribute = function(name, value15) {
        var attName, attValue;
        if (!this.currentNode || this.currentNode.children) {
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
        }
        if (name != null) {
          name = getValue(name);
        }
        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName))
              continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value15)) {
            value15 = value15.apply();
          }
          if (this.options.keepNullAttributes && value15 == null) {
            this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
          } else if (value15 != null) {
            this.currentNode.attribs[name] = new XMLAttribute(this, name, value15);
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.text = function(value15) {
        var node;
        this.openCurrent();
        node = new XMLText(this, value15);
        this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.cdata = function(value15) {
        var node;
        this.openCurrent();
        node = new XMLCData(this, value15);
        this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.comment = function(value15) {
        var node;
        this.openCurrent();
        node = new XMLComment(this, value15);
        this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.raw = function(value15) {
        var node;
        this.openCurrent();
        node = new XMLRaw(this, value15);
        this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.instruction = function(target, value15) {
        var i3, insTarget, insValue, len, node;
        this.openCurrent();
        if (target != null) {
          target = getValue(target);
        }
        if (value15 != null) {
          value15 = getValue(value15);
        }
        if (Array.isArray(target)) {
          for (i3 = 0, len = target.length;i3 < len; i3++) {
            insTarget = target[i3];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget))
              continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value15)) {
            value15 = value15.apply();
          }
          node = new XMLProcessingInstruction(this, target, value15);
          this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        }
        return this;
      };
      XMLDocumentCB2.prototype.declaration = function(version, encoding5, standalone) {
        var node;
        this.openCurrent();
        if (this.documentStarted) {
          throw new Error("declaration() must be the first node.");
        }
        node = new XMLDeclaration(this, version, encoding5, standalone);
        this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
        this.openCurrent();
        if (root == null) {
          throw new Error("Missing root node name.");
        }
        if (this.root) {
          throw new Error("dtd() must come before the root node.");
        }
        this.currentNode = new XMLDocType(this, pubID, sysID);
        this.currentNode.rootNodeName = root;
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        return this;
      };
      XMLDocumentCB2.prototype.dtdElement = function(name, value15) {
        var node;
        this.openCurrent();
        node = new XMLDTDElement(this, name, value15);
        this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var node;
        this.openCurrent();
        node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.entity = function(name, value15) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity(this, false, name, value15);
        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.pEntity = function(name, value15) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity(this, true, name, value15);
        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.notation = function(name, value15) {
        var node;
        this.openCurrent();
        node = new XMLDTDNotation(this, name, value15);
        this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.up = function() {
        if (this.currentLevel < 0) {
          throw new Error("The document node has no parent.");
        }
        if (this.currentNode) {
          if (this.currentNode.children) {
            this.closeNode(this.currentNode);
          } else {
            this.openNode(this.currentNode);
          }
          this.currentNode = null;
        } else {
          this.closeNode(this.openTags[this.currentLevel]);
        }
        delete this.openTags[this.currentLevel];
        this.currentLevel--;
        return this;
      };
      XMLDocumentCB2.prototype.end = function() {
        while (this.currentLevel >= 0) {
          this.up();
        }
        return this.onEnd();
      };
      XMLDocumentCB2.prototype.openCurrent = function() {
        if (this.currentNode) {
          this.currentNode.children = true;
          return this.openNode(this.currentNode);
        }
      };
      XMLDocumentCB2.prototype.openNode = function(node) {
        var att, chunk, name, ref1;
        if (!node.isOpen) {
          if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
            this.root = node;
          }
          chunk = "";
          if (node.type === NodeType.Element) {
            this.writerOptions.state = WriterState.OpenTag;
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
            ref1 = node.attribs;
            for (name in ref1) {
              if (!hasProp.call(ref1, name))
                continue;
              att = ref1[name];
              chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
            }
            chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
            this.writerOptions.state = WriterState.InsideTag;
          } else {
            this.writerOptions.state = WriterState.OpenTag;
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
            if (node.pubID && node.sysID) {
              chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              chunk += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.children) {
              chunk += " [";
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.CloseTag;
              chunk += ">";
            }
            chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
          }
          this.onData(chunk, this.currentLevel);
          return node.isOpen = true;
        }
      };
      XMLDocumentCB2.prototype.closeNode = function(node) {
        var chunk;
        if (!node.isClosed) {
          chunk = "";
          this.writerOptions.state = WriterState.CloseTag;
          if (node.type === NodeType.Element) {
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
          } else {
            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
          }
          this.writerOptions.state = WriterState.None;
          this.onData(chunk, this.currentLevel);
          return node.isClosed = true;
        }
      };
      XMLDocumentCB2.prototype.onData = function(chunk, level) {
        this.documentStarted = true;
        return this.onDataCallback(chunk, level + 1);
      };
      XMLDocumentCB2.prototype.onEnd = function() {
        this.documentCompleted = true;
        return this.onEndCallback();
      };
      XMLDocumentCB2.prototype.debugInfo = function(name) {
        if (name == null) {
          return "";
        } else {
          return "node: <" + name + ">";
        }
      };
      XMLDocumentCB2.prototype.ele = function() {
        return this.element.apply(this, arguments);
      };
      XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLDocumentCB2.prototype.txt = function(value15) {
        return this.text(value15);
      };
      XMLDocumentCB2.prototype.dat = function(value15) {
        return this.cdata(value15);
      };
      XMLDocumentCB2.prototype.com = function(value15) {
        return this.comment(value15);
      };
      XMLDocumentCB2.prototype.ins = function(target, value15) {
        return this.instruction(target, value15);
      };
      XMLDocumentCB2.prototype.dec = function(version, encoding5, standalone) {
        return this.declaration(version, encoding5, standalone);
      };
      XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
        return this.doctype(root, pubID, sysID);
      };
      XMLDocumentCB2.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLDocumentCB2.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLDocumentCB2.prototype.t = function(value15) {
        return this.text(value15);
      };
      XMLDocumentCB2.prototype.d = function(value15) {
        return this.cdata(value15);
      };
      XMLDocumentCB2.prototype.c = function(value15) {
        return this.comment(value15);
      };
      XMLDocumentCB2.prototype.r = function(value15) {
        return this.raw(value15);
      };
      XMLDocumentCB2.prototype.i = function(target, value15) {
        return this.instruction(target, value15);
      };
      XMLDocumentCB2.prototype.att = function() {
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.a = function() {
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.ent = function(name, value15) {
        return this.entity(name, value15);
      };
      XMLDocumentCB2.prototype.pent = function(name, value15) {
        return this.pEntity(name, value15);
      };
      XMLDocumentCB2.prototype.not = function(name, value15) {
        return this.notation(name, value15);
      };
      return XMLDocumentCB2;
    }();
  }).call(exports);
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS((exports, module) => {
  (function() {
    var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLWriterBase = require_XMLWriterBase();
    WriterState = require_WriterState();
    module.exports = XMLStreamWriter = function(superClass) {
      extend(XMLStreamWriter2, superClass);
      function XMLStreamWriter2(stream, options) {
        this.stream = stream;
        XMLStreamWriter2.__super__.constructor.call(this, options);
      }
      XMLStreamWriter2.prototype.endline = function(node, options, level) {
        if (node.isLastRootNode && options.state === WriterState.CloseTag) {
          return "";
        } else {
          return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
        }
      };
      XMLStreamWriter2.prototype.document = function(doc, options) {
        var child, i3, j, k, len, len1, ref4, ref1, results;
        ref4 = doc.children;
        for (i3 = j = 0, len = ref4.length;j < len; i3 = ++j) {
          child = ref4[i3];
          child.isLastRootNode = i3 === doc.children.length - 1;
        }
        options = this.filterOptions(options);
        ref1 = doc.children;
        results = [];
        for (k = 0, len1 = ref1.length;k < len1; k++) {
          child = ref1[k];
          results.push(this.writeChildNode(child, options, 0));
        }
        return results;
      };
      XMLStreamWriter2.prototype.attribute = function(att, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
      };
      XMLStreamWriter2.prototype.cdata = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.comment = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.declaration = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.docType = function(node, options, level) {
        var child, j, len, ref4;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        this.stream.write(this.indent(node, options, level));
        this.stream.write("<!DOCTYPE " + node.root().name);
        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        if (node.children.length > 0) {
          this.stream.write(" [");
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.InsideTag;
          ref4 = node.children;
          for (j = 0, len = ref4.length;j < len; j++) {
            child = ref4[j];
            this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          this.stream.write("]");
        }
        options.state = WriterState.CloseTag;
        this.stream.write(options.spaceBeforeSlash + ">");
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.None;
        return this.closeNode(node, options, level);
      };
      XMLStreamWriter2.prototype.element = function(node, options, level) {
        var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref4, ref1;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        this.stream.write(this.indent(node, options, level) + "<" + node.name);
        ref4 = node.attribs;
        for (name in ref4) {
          if (!hasProp.call(ref4, name))
            continue;
          att = ref4[name];
          this.attribute(att, options, level);
        }
        childNodeCount = node.children.length;
        firstChildNode = childNodeCount === 0 ? null : node.children[0];
        if (childNodeCount === 0 || node.children.every(function(e) {
          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
        })) {
          if (options.allowEmpty) {
            this.stream.write(">");
            options.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            options.state = WriterState.CloseTag;
            this.stream.write(options.spaceBeforeSlash + "/>");
          }
        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
          this.stream.write(">");
          options.state = WriterState.InsideTag;
          options.suppressPrettyCount++;
          prettySuppressed = true;
          this.writeChildNode(firstChildNode, options, level + 1);
          options.suppressPrettyCount--;
          prettySuppressed = false;
          options.state = WriterState.CloseTag;
          this.stream.write("</" + node.name + ">");
        } else {
          this.stream.write(">" + this.endline(node, options, level));
          options.state = WriterState.InsideTag;
          ref1 = node.children;
          for (j = 0, len = ref1.length;j < len; j++) {
            child = ref1[j];
            this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
        }
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.None;
        return this.closeNode(node, options, level);
      };
      XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.raw = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.text = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
      };
      XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
        return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
      };
      return XMLStreamWriter2;
    }(XMLWriterBase);
  }).call(exports);
});

// node_modules/xmlbuilder/lib/index.js
var require_lib = __commonJS((exports, module) => {
  (function() {
    var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref4;
    ref4 = require_Utility(), assign = ref4.assign, isFunction = ref4.isFunction;
    XMLDOMImplementation = require_XMLDOMImplementation();
    XMLDocument = require_XMLDocument();
    XMLDocumentCB = require_XMLDocumentCB();
    XMLStringWriter = require_XMLStringWriter();
    XMLStreamWriter = require_XMLStreamWriter();
    NodeType = require_NodeType();
    WriterState = require_WriterState();
    exports.create = function(name, xmldec, doctype, options) {
      var doc, root;
      if (name == null) {
        throw new Error("Root element needs a name.");
      }
      options = assign({}, xmldec, doctype, options);
      doc = new XMLDocument(options);
      root = doc.element(name);
      if (!options.headless) {
        doc.declaration(options);
        if (options.pubID != null || options.sysID != null) {
          doc.dtd(options);
        }
      }
      return root;
    };
    exports.begin = function(options, onData, onEnd) {
      var ref1;
      if (isFunction(options)) {
        ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
        options = {};
      }
      if (onData) {
        return new XMLDocumentCB(options, onData, onEnd);
      } else {
        return new XMLDocument(options);
      }
    };
    exports.stringWriter = function(options) {
      return new XMLStringWriter(options);
    };
    exports.streamWriter = function(stream, options) {
      return new XMLStreamWriter(stream, options);
    };
    exports.implementation = new XMLDOMImplementation;
    exports.nodeType = NodeType;
    exports.writerState = WriterState;
  }).call(exports);
});

// node_modules/xml2js/lib/builder.js
var require_builder = __commonJS((exports) => {
  (function() {
    var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
    builder = require_lib();
    defaults = require_defaults().defaults;
    requiresCDATA = function(entry) {
      return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
    };
    wrapCDATA = function(entry) {
      return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    };
    escapeCDATA = function(entry) {
      return entry.replace("]]>", "]]]]><![CDATA[>");
    };
    exports.Builder = function() {
      function Builder(opts) {
        var key, ref4, value15;
        this.options = {};
        ref4 = defaults["0.2"];
        for (key in ref4) {
          if (!hasProp.call(ref4, key))
            continue;
          value15 = ref4[key];
          this.options[key] = value15;
        }
        for (key in opts) {
          if (!hasProp.call(opts, key))
            continue;
          value15 = opts[key];
          this.options[key] = value15;
        }
      }
      Builder.prototype.buildObject = function(rootObj) {
        var attrkey, charkey, render, rootElement, rootName;
        attrkey = this.options.attrkey;
        charkey = this.options.charkey;
        if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
          rootName = Object.keys(rootObj)[0];
          rootObj = rootObj[rootName];
        } else {
          rootName = this.options.rootName;
        }
        render = function(_this) {
          return function(element, obj) {
            var attr, child, entry, index, key, value15;
            if (typeof obj !== "object") {
              if (_this.options.cdata && requiresCDATA(obj)) {
                element.raw(wrapCDATA(obj));
              } else {
                element.txt(obj);
              }
            } else if (Array.isArray(obj)) {
              for (index in obj) {
                if (!hasProp.call(obj, index))
                  continue;
                child = obj[index];
                for (key in child) {
                  entry = child[key];
                  element = render(element.ele(key), entry).up();
                }
              }
            } else {
              for (key in obj) {
                if (!hasProp.call(obj, key))
                  continue;
                child = obj[key];
                if (key === attrkey) {
                  if (typeof child === "object") {
                    for (attr in child) {
                      value15 = child[attr];
                      element = element.att(attr, value15);
                    }
                  }
                } else if (key === charkey) {
                  if (_this.options.cdata && requiresCDATA(child)) {
                    element = element.raw(wrapCDATA(child));
                  } else {
                    element = element.txt(child);
                  }
                } else if (Array.isArray(child)) {
                  for (index in child) {
                    if (!hasProp.call(child, index))
                      continue;
                    entry = child[index];
                    if (typeof entry === "string") {
                      if (_this.options.cdata && requiresCDATA(entry)) {
                        element = element.ele(key).raw(wrapCDATA(entry)).up();
                      } else {
                        element = element.ele(key, entry).up();
                      }
                    } else {
                      element = render(element.ele(key), entry).up();
                    }
                  }
                } else if (typeof child === "object") {
                  element = render(element.ele(key), child).up();
                } else {
                  if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                    element = element.ele(key).raw(wrapCDATA(child)).up();
                  } else {
                    if (child == null) {
                      child = "";
                    }
                    element = element.ele(key, child.toString()).up();
                  }
                }
              }
            }
            return element;
          };
        }(this);
        rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
          headless: this.options.headless,
          allowSurrogateChars: this.options.allowSurrogateChars
        });
        return render(rootElement, rootObj).end(this.options.renderOpts);
      };
      return Builder;
    }();
  }).call(exports);
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS((exports) => {
  (function(sax) {
    sax.parser = function(strict4, opt) {
      return new SAXParser(strict4, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict4, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict4, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict4;
      parser.noscript = !!(strict4 || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      if (parser.opt.unquotedAttributeValues === undefined) {
        parser.opt.unquotedAttributeValues = !strict4;
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o3) {
        function F() {
        }
        F.prototype = o3;
        var newf = new F;
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o3) {
        var a = [];
        for (var i3 in o3)
          if (o3.hasOwnProperty(i3))
            a.push(i3);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i3 = 0, l3 = buffers.length;i3 < l3; i3++) {
        var len = parser[buffers[i3]].length;
        if (len > maxAllowed) {
          switch (buffers[i3]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error23(parser, "Max buffer length exceeded: " + buffers[i3]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m3 = sax.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m3 + parser.position;
    }
    function clearBuffers(parser) {
      for (var i3 = 0, l3 = buffers.length;i3 < l3; i3++) {
        parser[buffers[i3]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream;
    try {
      Stream = import.meta.require("stream").Stream;
    } catch (ex) {
      Stream = function() {
      };
    }
    if (!Stream)
      Stream = function() {
      };
    var streamWraps = sax.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict4, opt) {
      return new SAXStream(strict4, opt);
    }
    function SAXStream(strict4, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict4, opt);
      }
      Stream.apply(this);
      this._parser = new SAXParser(strict4, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h;
              return h;
            }
            me.on(ev, h);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = import.meta.require("string_decoder").StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c3) {
      return c3 === " " || c3 === "\n" || c3 === "\r" || c3 === "\t";
    }
    function isQuote(c3) {
      return c3 === '"' || c3 === "\'";
    }
    function isAttribEnd(c3) {
      return c3 === ">" || isWhitespace(c3);
    }
    function isMatch(regex, c3) {
      return regex.test(c3);
    }
    function notMatch(regex, c3) {
      return !isMatch(regex, c3);
    }
    var S = 0;
    sax.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    };
    sax.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    };
    sax.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
      var e = sax.ENTITIES[key];
      var s4 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax.ENTITIES[key] = s4;
    });
    for (var s3 in sax.STATE) {
      sax.STATE[sax.STATE[s3]] = s3;
    }
    S = sax.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode)
        closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error23(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error23(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error23(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i3 = name.indexOf(":");
      var qualName = i3 < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\n" + "Actual: " + parser.attribValue);
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n" + "Actual: " + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i3 = 0, l3 = parser.attribList.length;i3 < l3; i3++) {
          var nv = parser.attribList[i3];
          var name = nv[0];
          var value15 = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value: value15,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t3 = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t3--) {
        var close = parser.tags[t3];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t3 < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s4 = parser.tags.length;
      while (s4-- > t3) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x3 = {};
        for (var i3 in tag.ns) {
          x3[i3] = tag.ns[i3];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n3 = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n3 });
          });
        }
      }
      if (t3 === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c3) {
      if (c3 === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c3)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c3;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i3) {
      var result = "";
      if (i3 < chunk.length) {
        result = chunk.charAt(i3);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error23(parser, "Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i3 = 0;
      var c3 = "";
      while (true) {
        c3 = charAt(chunk, i3++);
        parser.c = c3;
        if (!c3) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c3 === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c3 === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c3);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c3);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i3 - 1;
              while (c3 && c3 !== "<" && c3 !== "&") {
                c3 = charAt(chunk, i3++);
                if (c3 && parser.trackPosition) {
                  parser.position++;
                  if (c3 === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i3 - 1);
            }
            if (c3 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c3) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c3 === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c3;
              }
            }
            continue;
          case S.SCRIPT:
            if (c3 === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c3;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c3 === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c3;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c3 === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace(c3)) {
            } else if (isMatch(nameStart, c3)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c3;
            } else if (c3 === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c3 === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c3 = new Array(pad).join(" ") + c3;
              }
              parser.textNode += "<" + c3;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if (parser.sgmlDecl + c3 === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
              continue;
            }
            if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
              parser.state = S.DOCTYPE_DTD;
              parser.doctype += "<!" + parser.sgmlDecl + c3;
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c3).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if ((parser.sgmlDecl + c3).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, "Inappropriately located doctype declaration");
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c3 === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c3)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c3;
            } else {
              parser.sgmlDecl += c3;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c3 === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c3;
            continue;
          case S.DOCTYPE:
            if (c3 === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c3;
              if (c3 === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c3)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c3;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c3;
            if (c3 === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            if (c3 === "]") {
              parser.doctype += c3;
              parser.state = S.DOCTYPE;
            } else if (c3 === "<") {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else if (isQuote(c3)) {
              parser.doctype += c3;
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c3;
            } else {
              parser.doctype += c3;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c3;
            if (c3 === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c3 === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c3;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c3 === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c3;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c3 !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c3;
              parser.state = S.COMMENT;
            } else if (parser.doctype && parser.doctype !== true) {
              parser.state = S.DOCTYPE_DTD;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c3 === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c3;
            }
            continue;
          case S.CDATA_ENDING:
            if (c3 === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c3;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c3 === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c3 === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c3;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c3 === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c3)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c3;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c3)) {
              continue;
            } else if (c3 === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c3;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c3 === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c3;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c3)) {
              parser.tagName += c3;
            } else {
              newTag(parser);
              if (c3 === ">") {
                openTag(parser);
              } else if (c3 === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c3)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c3 === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace(c3)) {
              continue;
            } else if (c3 === ">") {
              openTag(parser);
            } else if (c3 === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c3)) {
              parser.attribName = c3;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c3 === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c3 === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c3)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c3)) {
              parser.attribName += c3;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c3 === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c3)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c3 === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c3)) {
                parser.attribName = c3;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace(c3)) {
              continue;
            } else if (isQuote(c3)) {
              parser.q = c3;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              if (!parser.opt.unquotedAttributeValues) {
                error23(parser, "Unquoted attribute value");
              }
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c3;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c3 !== parser.q) {
              if (c3 === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c3;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c3)) {
              parser.state = S.ATTRIB;
            } else if (c3 === ">") {
              openTag(parser);
            } else if (c3 === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c3)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c3;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c3)) {
              if (c3 === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c3;
              }
              continue;
            }
            attrib(parser);
            if (c3 === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c3)) {
                continue;
              } else if (notMatch(nameStart, c3)) {
                if (parser.script) {
                  parser.script += "</" + c3;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c3;
              }
            } else if (c3 === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c3)) {
              parser.tagName += c3;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c3)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c3)) {
              continue;
            }
            if (c3 === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c3 === ";") {
              var parsedEntity = parseEntity(parser);
              if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                parser.entity = "";
                parser.state = returnState;
                parser.write(parsedEntity);
              } else {
                parser[buffer] += parsedEntity;
                parser.entity = "";
                parser.state = returnState;
              }
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c3)) {
              parser.entity += c3;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c3;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default: {
            throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(typeof exports === "undefined" ? exports.sax = {} : exports);
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS((exports) => {
  (function() {
    exports.stripBOM = function(str) {
      if (str[0] === "\uFEFF") {
        return str.substring(1);
      } else {
        return str;
      }
    };
  }).call(exports);
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS((exports) => {
  (function() {
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports.normalize = function(str) {
      return str.toLowerCase();
    };
    exports.firstCharLowerCase = function(str) {
      return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports.stripPrefix = function(str) {
      return str.replace(prefixMatch, "");
    };
    exports.parseNumbers = function(str) {
      if (!isNaN(str)) {
        str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
      }
      return str;
    };
    exports.parseBooleans = function(str) {
      if (/^(?:true|false)$/i.test(str)) {
        str = str.toLowerCase() === "true";
      }
      return str;
    };
  }).call(exports);
});

// node_modules/xml2js/lib/parser.js
var require_parser = __commonJS((exports) => {
  (function() {
    var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate2, bind = function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    }, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    sax = require_sax();
    events = import.meta.require("events");
    bom = require_bom();
    processors = require_processors();
    setImmediate2 = import.meta.require("timers").setImmediate;
    defaults = require_defaults().defaults;
    isEmpty = function(thing) {
      return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
    };
    processItem = function(processors2, item, key) {
      var i3, len, process3;
      for (i3 = 0, len = processors2.length;i3 < len; i3++) {
        process3 = processors2[i3];
        item = process3(item, key);
      }
      return item;
    };
    defineProperty = function(obj, key, value15) {
      var descriptor;
      descriptor = Object.create(null);
      descriptor.value = value15;
      descriptor.writable = true;
      descriptor.enumerable = true;
      descriptor.configurable = true;
      return Object.defineProperty(obj, key, descriptor);
    };
    exports.Parser = function(superClass) {
      extend(Parser, superClass);
      function Parser(opts) {
        this.parseStringPromise = bind(this.parseStringPromise, this);
        this.parseString = bind(this.parseString, this);
        this.reset = bind(this.reset, this);
        this.assignOrPush = bind(this.assignOrPush, this);
        this.processAsync = bind(this.processAsync, this);
        var key, ref4, value15;
        if (!(this instanceof exports.Parser)) {
          return new exports.Parser(opts);
        }
        this.options = {};
        ref4 = defaults["0.2"];
        for (key in ref4) {
          if (!hasProp.call(ref4, key))
            continue;
          value15 = ref4[key];
          this.options[key] = value15;
        }
        for (key in opts) {
          if (!hasProp.call(opts, key))
            continue;
          value15 = opts[key];
          this.options[key] = value15;
        }
        if (this.options.xmlns) {
          this.options.xmlnskey = this.options.attrkey + "ns";
        }
        if (this.options.normalizeTags) {
          if (!this.options.tagNameProcessors) {
            this.options.tagNameProcessors = [];
          }
          this.options.tagNameProcessors.unshift(processors.normalize);
        }
        this.reset();
      }
      Parser.prototype.processAsync = function() {
        var chunk, err;
        try {
          if (this.remaining.length <= this.options.chunkSize) {
            chunk = this.remaining;
            this.remaining = "";
            this.saxParser = this.saxParser.write(chunk);
            return this.saxParser.close();
          } else {
            chunk = this.remaining.substr(0, this.options.chunkSize);
            this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
            this.saxParser = this.saxParser.write(chunk);
            return setImmediate2(this.processAsync);
          }
        } catch (error1) {
          err = error1;
          if (!this.saxParser.errThrown) {
            this.saxParser.errThrown = true;
            return this.emit(err);
          }
        }
      };
      Parser.prototype.assignOrPush = function(obj, key, newValue) {
        if (!(key in obj)) {
          if (!this.options.explicitArray) {
            return defineProperty(obj, key, newValue);
          } else {
            return defineProperty(obj, key, [newValue]);
          }
        } else {
          if (!(obj[key] instanceof Array)) {
            defineProperty(obj, key, [obj[key]]);
          }
          return obj[key].push(newValue);
        }
      };
      Parser.prototype.reset = function() {
        var attrkey, charkey, ontext, stack;
        this.removeAllListeners();
        this.saxParser = sax.parser(this.options.strict, {
          trim: false,
          normalize: false,
          xmlns: this.options.xmlns
        });
        this.saxParser.errThrown = false;
        this.saxParser.onerror = function(_this) {
          return function(error23) {
            _this.saxParser.resume();
            if (!_this.saxParser.errThrown) {
              _this.saxParser.errThrown = true;
              return _this.emit("error", error23);
            }
          };
        }(this);
        this.saxParser.onend = function(_this) {
          return function() {
            if (!_this.saxParser.ended) {
              _this.saxParser.ended = true;
              return _this.emit("end", _this.resultObject);
            }
          };
        }(this);
        this.saxParser.ended = false;
        this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
        this.resultObject = null;
        stack = [];
        attrkey = this.options.attrkey;
        charkey = this.options.charkey;
        this.saxParser.onopentag = function(_this) {
          return function(node) {
            var key, newValue, obj, processedKey, ref4;
            obj = {};
            obj[charkey] = "";
            if (!_this.options.ignoreAttrs) {
              ref4 = node.attributes;
              for (key in ref4) {
                if (!hasProp.call(ref4, key))
                  continue;
                if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                  obj[attrkey] = {};
                }
                newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                if (_this.options.mergeAttrs) {
                  _this.assignOrPush(obj, processedKey, newValue);
                } else {
                  defineProperty(obj[attrkey], processedKey, newValue);
                }
              }
            }
            obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
            if (_this.options.xmlns) {
              obj[_this.options.xmlnskey] = {
                uri: node.uri,
                local: node.local
              };
            }
            return stack.push(obj);
          };
        }(this);
        this.saxParser.onclosetag = function(_this) {
          return function() {
            var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s3, xpath;
            obj = stack.pop();
            nodeName = obj["#name"];
            if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
              delete obj["#name"];
            }
            if (obj.cdata === true) {
              cdata = obj.cdata;
              delete obj.cdata;
            }
            s3 = stack[stack.length - 1];
            if (obj[charkey].match(/^\s*$/) && !cdata) {
              emptyStr = obj[charkey];
              delete obj[charkey];
            } else {
              if (_this.options.trim) {
                obj[charkey] = obj[charkey].trim();
              }
              if (_this.options.normalize) {
                obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
              }
              obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
            if (isEmpty(obj)) {
              if (typeof _this.options.emptyTag === "function") {
                obj = _this.options.emptyTag();
              } else {
                obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
              }
            }
            if (_this.options.validator != null) {
              xpath = "/" + function() {
                var i3, len, results;
                results = [];
                for (i3 = 0, len = stack.length;i3 < len; i3++) {
                  node = stack[i3];
                  results.push(node["#name"]);
                }
                return results;
              }().concat(nodeName).join("/");
              (function() {
                var err;
                try {
                  return obj = _this.options.validator(xpath, s3 && s3[nodeName], obj);
                } catch (error1) {
                  err = error1;
                  return _this.emit("error", err);
                }
              })();
            }
            if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
              if (!_this.options.preserveChildrenOrder) {
                node = {};
                if (_this.options.attrkey in obj) {
                  node[_this.options.attrkey] = obj[_this.options.attrkey];
                  delete obj[_this.options.attrkey];
                }
                if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                  node[_this.options.charkey] = obj[_this.options.charkey];
                  delete obj[_this.options.charkey];
                }
                if (Object.getOwnPropertyNames(obj).length > 0) {
                  node[_this.options.childkey] = obj;
                }
                obj = node;
              } else if (s3) {
                s3[_this.options.childkey] = s3[_this.options.childkey] || [];
                objClone = {};
                for (key in obj) {
                  if (!hasProp.call(obj, key))
                    continue;
                  defineProperty(objClone, key, obj[key]);
                }
                s3[_this.options.childkey].push(objClone);
                delete obj["#name"];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
            }
            if (stack.length > 0) {
              return _this.assignOrPush(s3, nodeName, obj);
            } else {
              if (_this.options.explicitRoot) {
                old = obj;
                obj = {};
                defineProperty(obj, nodeName, old);
              }
              _this.resultObject = obj;
              _this.saxParser.ended = true;
              return _this.emit("end", _this.resultObject);
            }
          };
        }(this);
        ontext = function(_this) {
          return function(text) {
            var charChild, s3;
            s3 = stack[stack.length - 1];
            if (s3) {
              s3[charkey] += text;
              if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                s3[_this.options.childkey] = s3[_this.options.childkey] || [];
                charChild = {
                  "#name": "__text__"
                };
                charChild[charkey] = text;
                if (_this.options.normalize) {
                  charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                }
                s3[_this.options.childkey].push(charChild);
              }
              return s3;
            }
          };
        }(this);
        this.saxParser.ontext = ontext;
        return this.saxParser.oncdata = function(_this) {
          return function(text) {
            var s3;
            s3 = ontext(text);
            if (s3) {
              return s3.cdata = true;
            }
          };
        }(this);
      };
      Parser.prototype.parseString = function(str, cb) {
        var err;
        if (cb != null && typeof cb === "function") {
          this.on("end", function(result) {
            this.reset();
            return cb(null, result);
          });
          this.on("error", function(err2) {
            this.reset();
            return cb(err2);
          });
        }
        try {
          str = str.toString();
          if (str.trim() === "") {
            this.emit("end", null);
            return true;
          }
          str = bom.stripBOM(str);
          if (this.options.async) {
            this.remaining = str;
            setImmediate2(this.processAsync);
            return this.saxParser;
          }
          return this.saxParser.write(str).close();
        } catch (error1) {
          err = error1;
          if (!(this.saxParser.errThrown || this.saxParser.ended)) {
            this.emit("error", err);
            return this.saxParser.errThrown = true;
          } else if (this.saxParser.ended) {
            throw err;
          }
        }
      };
      Parser.prototype.parseStringPromise = function(str) {
        return new Promise(function(_this) {
          return function(resolve, reject) {
            return _this.parseString(str, function(err, value15) {
              if (err) {
                return reject(err);
              } else {
                return resolve(value15);
              }
            });
          };
        }(this));
      };
      return Parser;
    }(events);
    exports.parseString = function(str, a, b) {
      var cb, options, parser;
      if (b != null) {
        if (typeof b === "function") {
          cb = b;
        }
        if (typeof a === "object") {
          options = a;
        }
      } else {
        if (typeof a === "function") {
          cb = a;
        }
        options = {};
      }
      parser = new exports.Parser(options);
      return parser.parseString(str, cb);
    };
    exports.parseStringPromise = function(str, a) {
      var options, parser;
      if (typeof a === "object") {
        options = a;
      }
      parser = new exports.Parser(options);
      return parser.parseStringPromise(str);
    };
  }).call(exports);
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS((exports) => {
  (function() {
    var builder, defaults, parser, processors, extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    defaults = require_defaults();
    builder = require_builder();
    parser = require_parser();
    processors = require_processors();
    exports.defaults = defaults.defaults;
    exports.processors = processors;
    exports.ValidationError = function(superClass) {
      extend(ValidationError, superClass);
      function ValidationError(message) {
        this.message = message;
      }
      return ValidationError;
    }(Error);
    exports.Builder = builder.Builder;
    exports.Parser = parser.Parser;
    exports.parseString = parser.parseString;
    exports.parseStringPromise = parser.parseStringPromise;
  }).call(exports);
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS((exports, module) => {
  module.exports = import.meta.require("util").deprecate;
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/errors.js
var require_errors = __commonJS((exports, module) => {
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }

    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i3) => String(i3));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  var codes = {};
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value15) {
    return 'The value "' + value15 + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type47 = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type47} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports.codes = codes;
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports, module) => {
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
  module.exports = {
    getHighWaterMark
  };
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util2 = import.meta.require("util");
    if (typeof util2.inherits !== "function")
      throw "";
    module.exports = util2.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util2;
});

// node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END;
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES;
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  function decodeChunk(state, chunk, encoding5) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding5);
    }
    return chunk;
  }
  function writeOrBuffer(stream, state, isBuf, chunk, encoding5, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding5);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding5 = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding: encoding5,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding5, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding5, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding5, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l3 = state.bufferedRequestCount;
      var buffer = new Array(l3);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding5 = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding5, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  module.exports = Writable;
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_node()
  };
  var Stream = import.meta.require("stream");
  var Buffer2 = import.meta.require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits()(Writable, Stream);
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object13) {
        if (realHasInstance.call(this, object13))
          return true;
        if (this !== Writable)
          return false;
        return object13 && object13._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object13) {
      return object13 instanceof this;
    };
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  Writable.prototype.write = function(chunk, encoding5, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding5 === "function") {
      cb = encoding5;
      encoding5 = null;
    }
    if (isBuf)
      encoding5 = "buffer";
    else if (!encoding5)
      encoding5 = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding5, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding5) {
    if (typeof encoding5 === "string")
      encoding5 = encoding5.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding5 + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding5);
    this._writableState.defaultEncoding = encoding5;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Writable.prototype._write = function(chunk, encoding5, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding5, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding5 = null;
    } else if (typeof encoding5 === "function") {
      cb = encoding5;
      encoding5 = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding5);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value15) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value15;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj)
      keys2.push(key);
    return keys2;
  };
  module.exports = Duplex;
  var Readable = require__stream_readable();
  var Writable = require__stream_writable();
  require_inherits()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v3 = 0;v3 < keys.length; v3++) {
      method = keys[v3];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v3;
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value15) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value15;
      this._writableState.destroyed = value15;
    }
  });
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = import.meta.require("buffer");
  var Buffer2 = buffer.Buffer;
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding5) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding5 === "string") {
        buf.fill(fill, encoding5);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports) => {
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  function StringDecoder(encoding5) {
    this.encoding = normalizeEncoding(encoding5);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i3) {
    var j = buf.length - 1;
    if (j < i3)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i3 || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i3 || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "\uFFFD";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "\uFFFD";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "\uFFFD";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i3) {
    var total = utf8CheckIncomplete(this, buf, i3);
    if (!this.lastNeed)
      return buf.toString("utf8", i3);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i3, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "\uFFFD";
    return r;
  }
  function utf16Text(buf, i3) {
    if ((buf.length - i3) % 2 === 0) {
      var r = buf.toString("utf16le", i3);
      if (r) {
        var c3 = r.charCodeAt(r.length - 1);
        if (c3 >= 55296 && c3 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i3, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i3) {
    var n3 = (buf.length - i3) % 3;
    if (n3 === 0)
      return buf.toString("base64", i3);
    this.lastNeed = 3 - n3;
    this.lastTotal = 3;
    if (n3 === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i3, buf.length - n3);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding5) {
    encoding5 = "" + encoding5;
    switch (encoding5 && encoding5.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  exports.StringDecoder = StringDecoder;
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i3;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i3 = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i3 = 0;
    }
    if (i3 < buf.length)
      return r ? r + this.text(buf, i3) : this.text(buf, i3);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  function ownKeys(object13, enumerableOnly) {
    var keys = Object.keys(object13);
    if (Object.getOwnPropertySymbols) {
      var symbols70 = Object.getOwnPropertySymbols(object13);
      enumerableOnly && (symbols70 = symbols70.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object13, sym).enumerable;
      })), keys.push.apply(keys, symbols70);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i3 = 1;i3 < arguments.length; i3++) {
      var source = arguments[i3] != null ? arguments[i3] : {};
      i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value15) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value15, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value15;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor2) {
    if (!(instance instanceof Constructor2)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i3 = 0;i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor2, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor2.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor2, staticProps);
    Object.defineProperty(Constructor2, "prototype", { writable: false });
    return Constructor2;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  var _require = import.meta.require("buffer");
  var Buffer2 = _require.Buffer;
  var _require2 = import.meta.require("util");
  var inspect = _require2.inspect;
  var custom2 = inspect && inspect.custom || "inspect";
  module.exports = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v3) {
        var entry = {
          data: v3,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v3) {
        var entry = {
          data: v3,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s3) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next)
          ret += s3 + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n3) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n3 >>> 0);
        var p = this.head;
        var i3 = 0;
        while (p) {
          copyBuffer(p.data, ret, i3);
          i3 += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n3, hasStrings) {
        var ret;
        if (n3 < this.head.data.length) {
          ret = this.head.data.slice(0, n3);
          this.head.data = this.head.data.slice(n3);
        } else if (n3 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n3) : this._getBuffer(n3);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n3) {
        var p = this.head;
        var c3 = 1;
        var ret = p.data;
        n3 -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n3 > str.length ? str.length : n3;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n3);
          n3 -= nb;
          if (n3 === 0) {
            if (nb === str.length) {
              ++c3;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c3;
        }
        this.length -= c3;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n3) {
        var ret = Buffer2.allocUnsafe(n3);
        var p = this.head;
        var c3 = 1;
        p.data.copy(ret);
        n3 -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n3 > buf.length ? buf.length : n3;
          buf.copy(ret, ret.length - n3, 0, nb);
          n3 -= nb;
          if (n3 === 0) {
            if (nb === buf.length) {
              ++c3;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c3;
        }
        this.length -= c3;
        return ret;
      }
    }, {
      key: custom2,
      value: function value(_, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  function once2(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once2(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
  module.exports = eos;
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports, module) => {
  function _defineProperty(obj, key, value15) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value15, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value15;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function createIterResult(value15, done) {
    return {
      value: value15,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject2) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }
        iter[kHandlePromise](resolve, reject2);
      }, reject2);
    };
  }
  var _Object$setPrototypeO;
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error23 = this[kError];
      if (error23 !== null) {
        return Promise.reject(error23);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject2) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject2(_this[kError]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise5;
      if (lastPromise) {
        promise5 = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise5 = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise5;
      return promise5;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject2) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject2(err);
          return;
        }
        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator5 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject2) {
        var data = iterator5[kStream].read();
        if (data) {
          iterator5[kLastPromise] = null;
          iterator5[kLastResolve] = null;
          iterator5[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator5[kLastResolve] = resolve;
          iterator5[kLastReject] = reject2;
        }
      },
      writable: true
    }), _Object$create));
    iterator5[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject2 = iterator5[kLastReject];
        if (reject2 !== null) {
          iterator5[kLastPromise] = null;
          iterator5[kLastResolve] = null;
          iterator5[kLastReject] = null;
          reject2(err);
        }
        iterator5[kError] = err;
        return;
      }
      var resolve = iterator5[kLastResolve];
      if (resolve !== null) {
        iterator5[kLastPromise] = null;
        iterator5[kLastResolve] = null;
        iterator5[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }
      iterator5[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator5));
    return iterator5;
  };
  module.exports = createReadableStreamAsyncIterator;
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  function asyncGeneratorStep(gen, resolve, reject2, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value15 = info.value;
    } catch (error23) {
      reject2(error23);
      return;
    }
    if (info.done) {
      resolve(value15);
    } else {
      Promise.resolve(value15).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject2) {
        var gen = fn.apply(self2, args);
        function _next(value15) {
          asyncGeneratorStep(gen, resolve, reject2, _next, _throw, "next", value15);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject2, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function ownKeys(object13, enumerableOnly) {
    var keys = Object.keys(object13);
    if (Object.getOwnPropertySymbols) {
      var symbols70 = Object.getOwnPropertySymbols(object13);
      enumerableOnly && (symbols70 = symbols70.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object13, sym).enumerable;
      })), keys.push.apply(keys, symbols70);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i3 = 1;i3 < arguments.length; i3++) {
      var source = arguments[i3] != null ? arguments[i3] : {};
      i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value15) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value15, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value15;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function from(Readable, iterable, opts) {
    var iterator5;
    if (iterable && typeof iterable.next === "function") {
      iterator5 = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator])
      iterator5 = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator])
      iterator5 = iterable[Symbol.iterator]();
    else
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable = new Readable(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator5.next(), value15 = _yield$iterator$next.value, done = _yield$iterator$next.done;
          if (done) {
            readable.push(null);
          } else if (readable.push(yield value15)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable;
  }
  var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
  module.exports = from;
});

// node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  function readableAddChunk(stream, chunk, encoding5, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding5) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  function computeNewHighWaterMark(n3) {
    if (n3 >= MAX_HWM) {
      n3 = MAX_HWM;
    } else {
      n3--;
      n3 |= n3 >>> 1;
      n3 |= n3 >>> 2;
      n3 |= n3 >>> 4;
      n3 |= n3 >>> 8;
      n3 |= n3 >>> 16;
      n3++;
    }
    return n3;
  }
  function howMuchToRead(n3, state) {
    if (n3 <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n3 !== n3) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n3 > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n3);
    if (n3 <= state.length)
      return n3;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  function fromList(n3, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n3 || n3 >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n3, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  function indexOf(xs, x3) {
    for (var i3 = 0, l3 = xs.length;i3 < l3; i3++) {
      if (xs[i3] === x3)
        return i3;
    }
    return -1;
  }
  module.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = import.meta.require("events").EventEmitter;
  var EElistenerCount = function EElistenerCount(emitter, type47) {
    return emitter.listeners(type47).length;
  };
  var Stream = import.meta.require("stream");
  var Buffer2 = import.meta.require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  var debugUtil = import.meta.require("util");
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug() {
    };
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value15) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value15;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding5) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding5 = encoding5 || state.defaultEncoding;
        if (encoding5 !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding5);
          encoding5 = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding5, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  Readable.prototype.read = function(n3) {
    debug("read", n3);
    n3 = parseInt(n3, 10);
    var state = this._readableState;
    var nOrig = n3;
    if (n3 !== 0)
      state.emittedReadable = false;
    if (n3 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n3 = howMuchToRead(n3, state);
    if (n3 === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n3 < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n3 = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n3 > 0)
      ret = fromList(n3, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n3 = 0;
    } else {
      state.length -= n3;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n3 && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  Readable.prototype._read = function(n3) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i3 = 0;i3 < len; i3++)
        dests[i3].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i3 in stream) {
      if (this[i3] === undefined && typeof stream[i3] === "function") {
        this[i3] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i3);
      }
    }
    for (var n3 = 0;n3 < kProxyEvents.length; n3++) {
      stream.on(kProxyEvents[n3], this.emit.bind(this, kProxyEvents[n3]));
    }
    this._read = function(n4) {
      debug("wrapped _read", n4);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === undefined) {
        from = require_from();
      }
      return from(Readable, iterable, opts);
    };
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK);
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2))
      return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0;
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
    return stream.push(null);
  }
  module.exports = Transform2;
  var _require$codes = require_errors().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require__stream_duplex();
  require_inherits()(Transform2, Duplex);
  Transform2.prototype.push = function(chunk, encoding5) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding5);
  };
  Transform2.prototype._transform = function(chunk, encoding5, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform2.prototype._write = function(chunk, encoding5, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding5;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n3) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform2.call(this, options);
  }
  module.exports = PassThrough;
  var Transform2 = require__stream_transform();
  require_inherits()(PassThrough, Transform2);
  PassThrough.prototype._transform = function(chunk, encoding5, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  function once2(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(undefined, arguments);
    };
  }
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once2(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === undefined)
      eos = require_end_of_stream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0;_key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error23;
    var destroys = streams.map(function(stream, i3) {
      var reading = i3 < streams.length - 1;
      var writing = i3 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error23)
          error23 = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error23);
      });
    });
    return streams.reduce(pipe);
  }
  var eos;
  var _require$codes = require_errors().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  module.exports = pipeline;
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports, module) => {
  var Stream = import.meta.require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable();
    exports.Duplex = require__stream_duplex();
    exports.Transform = require__stream_transform();
    exports.PassThrough = require__stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/block-stream2/index.js
var require_block_stream2 = __commonJS((exports, module) => {
  var { Transform: Transform2 } = require_readable();

  class Block extends Transform2 {
    constructor(size, opts = {}) {
      super(opts);
      if (typeof size === "object") {
        opts = size;
        size = opts.size;
      }
      this.size = size || 512;
      const { nopad, zeroPadding = true } = opts;
      if (nopad)
        this._zeroPadding = false;
      else
        this._zeroPadding = !!zeroPadding;
      this._buffered = [];
      this._bufferedBytes = 0;
    }
    _transform(buf, enc, next) {
      this._bufferedBytes += buf.length;
      this._buffered.push(buf);
      while (this._bufferedBytes >= this.size) {
        this._bufferedBytes -= this.size;
        const blockBufs = [];
        let blockBufsBytes = 0;
        while (blockBufsBytes < this.size) {
          const b = this._buffered.shift();
          if (blockBufsBytes + b.length <= this.size) {
            blockBufs.push(b);
            blockBufsBytes += b.length;
          } else {
            const neededSize = this.size - blockBufsBytes;
            blockBufs.push(b.slice(0, neededSize));
            blockBufsBytes += neededSize;
            this._buffered.unshift(b.slice(neededSize));
          }
        }
        this.push(Buffer.concat(blockBufs, this.size));
      }
      next();
    }
    _flush() {
      if (this._bufferedBytes && this._zeroPadding) {
        const zeroes = Buffer.alloc(this.size - this._bufferedBytes);
        this._buffered.push(zeroes);
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
      } else if (this._bufferedBytes) {
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
      }
      this.push(null);
    }
  }
  module.exports = Block;
});

// node_modules/browser-or-node/lib/index.js
var require_lib2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
  var isWebWorker = (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
  var isJsDom = typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
  var isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
  exports.isBrowser = isBrowser;
  exports.isWebWorker = isWebWorker;
  exports.isNode = isNode;
  exports.isJsDom = isJsDom;
  exports.isDeno = isDeno;
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports, module) => {
  (function() {
    var undefined6;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array5, setter, iteratee, accumulator) {
      var index = -1, length = array5 == null ? 0 : array5.length;
      while (++index < length) {
        var value15 = array5[index];
        setter(accumulator, value15, iteratee(value15), array5);
      }
      return accumulator;
    }
    function arrayEach(array5, iteratee) {
      var index = -1, length = array5 == null ? 0 : array5.length;
      while (++index < length) {
        if (iteratee(array5[index], index, array5) === false) {
          break;
        }
      }
      return array5;
    }
    function arrayEachRight(array5, iteratee) {
      var length = array5 == null ? 0 : array5.length;
      while (length--) {
        if (iteratee(array5[length], length, array5) === false) {
          break;
        }
      }
      return array5;
    }
    function arrayEvery(array5, predicate) {
      var index = -1, length = array5 == null ? 0 : array5.length;
      while (++index < length) {
        if (!predicate(array5[index], index, array5)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array5, predicate) {
      var index = -1, length = array5 == null ? 0 : array5.length, resIndex = 0, result = [];
      while (++index < length) {
        var value15 = array5[index];
        if (predicate(value15, index, array5)) {
          result[resIndex++] = value15;
        }
      }
      return result;
    }
    function arrayIncludes(array5, value15) {
      var length = array5 == null ? 0 : array5.length;
      return !!length && baseIndexOf(array5, value15, 0) > -1;
    }
    function arrayIncludesWith(array5, value15, comparator) {
      var index = -1, length = array5 == null ? 0 : array5.length;
      while (++index < length) {
        if (comparator(value15, array5[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array5, iteratee) {
      var index = -1, length = array5 == null ? 0 : array5.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array5[index], index, array5);
      }
      return result;
    }
    function arrayPush(array5, values) {
      var index = -1, length = values.length, offset = array5.length;
      while (++index < length) {
        array5[offset + index] = values[index];
      }
      return array5;
    }
    function arrayReduce(array5, iteratee, accumulator, initAccum) {
      var index = -1, length = array5 == null ? 0 : array5.length;
      if (initAccum && length) {
        accumulator = array5[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array5[index], index, array5);
      }
      return accumulator;
    }
    function arrayReduceRight(array5, iteratee, accumulator, initAccum) {
      var length = array5 == null ? 0 : array5.length;
      if (initAccum && length) {
        accumulator = array5[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array5[length], length, array5);
      }
      return accumulator;
    }
    function arraySome(array5, predicate) {
      var index = -1, length = array5 == null ? 0 : array5.length;
      while (++index < length) {
        if (predicate(array5[index], index, array5)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string7) {
      return string7.split("");
    }
    function asciiWords(string7) {
      return string7.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value15, key, collection2) {
        if (predicate(value15, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array5, predicate, fromIndex, fromRight) {
      var length = array5.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array5[index], index, array5)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array5, value15, fromIndex) {
      return value15 === value15 ? strictIndexOf(array5, value15, fromIndex) : baseFindIndex(array5, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array5, value15, fromIndex, comparator) {
      var index = fromIndex - 1, length = array5.length;
      while (++index < length) {
        if (comparator(array5[index], value15)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value15) {
      return value15 !== value15;
    }
    function baseMean(array5, iteratee) {
      var length = array5 == null ? 0 : array5.length;
      return length ? baseSum(array5, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object13) {
        return object13 == null ? undefined6 : object13[key];
      };
    }
    function basePropertyOf(object13) {
      return function(key) {
        return object13 == null ? undefined6 : object13[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value15, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value15) : iteratee(accumulator, value15, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array5, comparer) {
      var length = array5.length;
      array5.sort(comparer);
      while (length--) {
        array5[length] = array5[length].value;
      }
      return array5;
    }
    function baseSum(array5, iteratee) {
      var result, index = -1, length = array5.length;
      while (++index < length) {
        var current = iteratee(array5[index]);
        if (current !== undefined6) {
          result = result === undefined6 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object13, props) {
      return arrayMap(props, function(key) {
        return [key, object13[key]];
      });
    }
    function baseTrim(string7) {
      return string7 ? string7.slice(0, trimmedEndIndex(string7) + 1).replace(reTrimStart, "") : string7;
    }
    function baseUnary(func) {
      return function(value15) {
        return func(value15);
      };
    }
    function baseValues(object13, props) {
      return arrayMap(props, function(key) {
        return object13[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array5, placeholder) {
      var length = array5.length, result = 0;
      while (length--) {
        if (array5[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object13, key) {
      return object13 == null ? undefined6 : object13[key];
    }
    function hasUnicode(string7) {
      return reHasUnicode.test(string7);
    }
    function hasUnicodeWord(string7) {
      return reHasUnicodeWord.test(string7);
    }
    function iteratorToArray(iterator5) {
      var data, result = [];
      while (!(data = iterator5.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map4) {
      var index = -1, result = Array(map4.size);
      map4.forEach(function(value15, key) {
        result[++index] = [key, value15];
      });
      return result;
    }
    function overArg(func, transform7) {
      return function(arg) {
        return func(transform7(arg));
      };
    }
    function replaceHolders(array5, placeholder) {
      var index = -1, length = array5.length, resIndex = 0, result = [];
      while (++index < length) {
        var value15 = array5[index];
        if (value15 === placeholder || value15 === PLACEHOLDER) {
          array5[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value15) {
        result[++index] = value15;
      });
      return result;
    }
    function setToPairs(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value15) {
        result[++index] = [value15, value15];
      });
      return result;
    }
    function strictIndexOf(array5, value15, fromIndex) {
      var index = fromIndex - 1, length = array5.length;
      while (++index < length) {
        if (array5[index] === value15) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array5, value15, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array5[index] === value15) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string7) {
      return hasUnicode(string7) ? unicodeSize(string7) : asciiSize(string7);
    }
    function stringToArray(string7) {
      return hasUnicode(string7) ? unicodeToArray(string7) : asciiToArray(string7);
    }
    function trimmedEndIndex(string7) {
      var index = string7.length;
      while (index-- && reWhitespace.test(string7.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string7) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string7)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string7) {
      return string7.match(reUnicode) || [];
    }
    function unicodeWords(string7) {
      return string7.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var { Array: Array3, Date: Date3, Error: Error2, Function: Function3, Math: Math2, Object: Object3, RegExp: RegExp3, String: String3, TypeError: TypeError2 } = context;
      var arrayProto = Array3.prototype, funcProto = Function3.prototype, objectProto = Object3.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object3);
      var oldDash = root._;
      var reIsNative = RegExp3("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined6, Symbol3 = context.Symbol, Uint8Array3 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined6, getPrototype = overArg(Object3.getPrototypeOf, Object3), objectCreate = Object3.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : undefined6, symIterator = Symbol3 ? Symbol3.iterator : undefined6, symToStringTag = Symbol3 ? Symbol3.toStringTag : undefined6;
      var defineProperty = function() {
        try {
          var func = getNative(Object3, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date3 && Date3.now !== root.Date.now && Date3.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var { ceil: nativeCeil, floor: nativeFloor } = Math2, nativeGetSymbols = Object3.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined6, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object3.keys, Object3), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date3.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise3 = getNative(context, "Promise"), Set5 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object3, "create");
      var metaMap = WeakMap2 && new WeakMap2;
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise3), setCtorString = toSource(Set5), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol3 ? Symbol3.prototype : undefined6, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined6, symbolToString = symbolProto ? symbolProto.toString : undefined6;
      function lodash(value15) {
        if (isObjectLike(value15) && !isArray(value15) && !(value15 instanceof LazyWrapper)) {
          if (value15 instanceof LodashWrapper) {
            return value15;
          }
          if (hasOwnProperty.call(value15, "__wrapped__")) {
            return wrapperClone(value15);
          }
        }
        return new LodashWrapper(value15);
      }
      var baseCreate = function() {
        function object13() {
        }
        return function(proto2) {
          if (!isObject(proto2)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto2);
          }
          object13.prototype = proto2;
          var result2 = new object13;
          object13.prototype = undefined6;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value15, chainAll) {
        this.__wrapped__ = value15;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined6;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value15) {
        this.__wrapped__ = value15;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array5 = this.__wrapped__.value(), dir2 = this.__dir__, isArr = isArray(array5), isRight = dir2 < 0, arrLength = isArr ? array5.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array5, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir2;
            var iterIndex = -1, value15 = array5[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type47 = data.type, computed = iteratee2(value15);
              if (type47 == LAZY_MAP_FLAG) {
                value15 = computed;
              } else if (!computed) {
                if (type47 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value15;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash3(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined6 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined6;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined6 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value15) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value15 === undefined6 ? HASH_UNDEFINED : value15;
        return this;
      }
      Hash3.prototype.clear = hashClear;
      Hash3.prototype["delete"] = hashDelete;
      Hash3.prototype.get = hashGet;
      Hash3.prototype.has = hashHas;
      Hash3.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined6 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value15) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value15]);
        } else {
          data[index][1] = value15;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash3,
          map: new (Map2 || ListCache),
          string: new Hash3
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value15) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value15);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value15) {
        this.__data__.set(value15, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value15) {
        return this.__data__.has(value15);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value15) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value15]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value15);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value15, inherited) {
        var isArr = isArray(value15), isArg = !isArr && isArguments(value15), isBuff = !isArr && !isArg && isBuffer(value15), isType = !isArr && !isArg && !isBuff && isTypedArray(value15), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value15.length, String3) : [], length = result2.length;
        for (var key in value15) {
          if ((inherited || hasOwnProperty.call(value15, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array5) {
        var length = array5.length;
        return length ? array5[baseRandom(0, length - 1)] : undefined6;
      }
      function arraySampleSize(array5, n3) {
        return shuffleSelf(copyArray(array5), baseClamp(n3, 0, array5.length));
      }
      function arrayShuffle(array5) {
        return shuffleSelf(copyArray(array5));
      }
      function assignMergeValue(object13, key, value15) {
        if (value15 !== undefined6 && !eq(object13[key], value15) || value15 === undefined6 && !(key in object13)) {
          baseAssignValue(object13, key, value15);
        }
      }
      function assignValue(object13, key, value15) {
        var objValue = object13[key];
        if (!(hasOwnProperty.call(object13, key) && eq(objValue, value15)) || value15 === undefined6 && !(key in object13)) {
          baseAssignValue(object13, key, value15);
        }
      }
      function assocIndexOf(array5, key) {
        var length = array5.length;
        while (length--) {
          if (eq(array5[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value15, key, collection2) {
          setter(accumulator, value15, iteratee2(value15), collection2);
        });
        return accumulator;
      }
      function baseAssign(object13, source) {
        return object13 && copyObject(source, keys(source), object13);
      }
      function baseAssignIn(object13, source) {
        return object13 && copyObject(source, keysIn(source), object13);
      }
      function baseAssignValue(object13, key, value15) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object13, key, {
            configurable: true,
            enumerable: true,
            value: value15,
            writable: true
          });
        } else {
          object13[key] = value15;
        }
      }
      function baseAt(object13, paths) {
        var index = -1, length = paths.length, result2 = Array3(length), skip2 = object13 == null;
        while (++index < length) {
          result2[index] = skip2 ? undefined6 : get(object13, paths[index]);
        }
        return result2;
      }
      function baseClamp(number7, lower, upper) {
        if (number7 === number7) {
          if (upper !== undefined6) {
            number7 = number7 <= upper ? number7 : upper;
          }
          if (lower !== undefined6) {
            number7 = number7 >= lower ? number7 : lower;
          }
        }
        return number7;
      }
      function baseClone(value15, bitmask, customizer, key, object13, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object13 ? customizer(value15, key, object13, stack) : customizer(value15);
        }
        if (result2 !== undefined6) {
          return result2;
        }
        if (!isObject(value15)) {
          return value15;
        }
        var isArr = isArray(value15);
        if (isArr) {
          result2 = initCloneArray(value15);
          if (!isDeep) {
            return copyArray(value15, result2);
          }
        } else {
          var tag = getTag(value15), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value15)) {
            return cloneBuffer(value15, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object13) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value15);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value15, baseAssignIn(result2, value15)) : copySymbols(value15, baseAssign(result2, value15));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object13 ? value15 : {};
            }
            result2 = initCloneByTag(value15, tag, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value15);
        if (stacked) {
          return stacked;
        }
        stack.set(value15, result2);
        if (isSet(value15)) {
          value15.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value15, stack));
          });
        } else if (isMap(value15)) {
          value15.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value15, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined6 : keysFunc(value15);
        arrayEach(props || value15, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value15[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value15, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object13) {
          return baseConformsTo(object13, source, props);
        };
      }
      function baseConformsTo(object13, source, props) {
        var length = props.length;
        if (object13 == null) {
          return !length;
        }
        object13 = Object3(object13);
        while (length--) {
          var key = props[length], predicate = source[key], value15 = object13[key];
          if (value15 === undefined6 && !(key in object13) || !predicate(value15)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined6, args);
        }, wait);
      }
      function baseDifference(array5, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array5.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value15 = array5[index], computed = iteratee2 == null ? value15 : iteratee2(value15);
            value15 = comparator || value15 !== 0 ? value15 : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value15);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value15);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value15, index, collection2) {
          result2 = !!predicate(value15, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array5, iteratee2, comparator) {
        var index = -1, length = array5.length;
        while (++index < length) {
          var value15 = array5[index], current = iteratee2(value15);
          if (current != null && (computed === undefined6 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value15;
          }
        }
        return result2;
      }
      function baseFill(array5, value15, start, end) {
        var length = array5.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined6 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array5[start++] = value15;
        }
        return array5;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value15, index, collection2) {
          if (predicate(value15, index, collection2)) {
            result2.push(value15);
          }
        });
        return result2;
      }
      function baseFlatten(array5, depth, predicate, isStrict, result2) {
        var index = -1, length = array5.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value15 = array5[index];
          if (depth > 0 && predicate(value15)) {
            if (depth > 1) {
              baseFlatten(value15, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value15);
            }
          } else if (!isStrict) {
            result2[result2.length] = value15;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object13, iteratee2) {
        return object13 && baseFor(object13, iteratee2, keys);
      }
      function baseForOwnRight(object13, iteratee2) {
        return object13 && baseForRight(object13, iteratee2, keys);
      }
      function baseFunctions(object13, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object13[key]);
        });
      }
      function baseGet(object13, path) {
        path = castPath(path, object13);
        var index = 0, length = path.length;
        while (object13 != null && index < length) {
          object13 = object13[toKey(path[index++])];
        }
        return index && index == length ? object13 : undefined6;
      }
      function baseGetAllKeys(object13, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object13);
        return isArray(object13) ? result2 : arrayPush(result2, symbolsFunc(object13));
      }
      function baseGetTag(value15) {
        if (value15 == null) {
          return value15 === undefined6 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object3(value15) ? getRawTag(value15) : objectToString(value15);
      }
      function baseGt(value15, other) {
        return value15 > other;
      }
      function baseHas(object13, key) {
        return object13 != null && hasOwnProperty.call(object13, key);
      }
      function baseHasIn(object13, key) {
        return object13 != null && key in Object3(object13);
      }
      function baseInRange(number7, start, end) {
        return number7 >= nativeMin(start, end) && number7 < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array3(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array5 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array5 = arrayMap(array5, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array5.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array5.length >= 120) ? new SetCache(othIndex && array5) : undefined6;
        }
        array5 = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value15 = array5[index], computed = iteratee2 ? iteratee2(value15) : value15;
            value15 = comparator || value15 !== 0 ? value15 : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value15);
            }
          }
        return result2;
      }
      function baseInverter(object13, setter, iteratee2, accumulator) {
        baseForOwn(object13, function(value15, key, object14) {
          setter(accumulator, iteratee2(value15), key, object14);
        });
        return accumulator;
      }
      function baseInvoke(object13, path, args) {
        path = castPath(path, object13);
        object13 = parent(object13, path);
        var func = object13 == null ? object13 : object13[toKey(last(path))];
        return func == null ? undefined6 : apply(func, object13, args);
      }
      function baseIsArguments(value15) {
        return isObjectLike(value15) && baseGetTag(value15) == argsTag;
      }
      function baseIsArrayBuffer(value15) {
        return isObjectLike(value15) && baseGetTag(value15) == arrayBufferTag;
      }
      function baseIsDate(value15) {
        return isObjectLike(value15) && baseGetTag(value15) == dateTag;
      }
      function baseIsEqual(value15, other, bitmask, customizer, stack) {
        if (value15 === other) {
          return true;
        }
        if (value15 == null || other == null || !isObjectLike(value15) && !isObjectLike(other)) {
          return value15 !== value15 && other !== other;
        }
        return baseIsEqualDeep(value15, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object13, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object13), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object13), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object13)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return objIsArr || isTypedArray(object13) ? equalArrays(object13, other, bitmask, customizer, equalFunc, stack) : equalByTag(object13, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object13, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object13.value() : object13, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object13, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value15) {
        return isObjectLike(value15) && getTag(value15) == mapTag;
      }
      function baseIsMatch(object13, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object13 == null) {
          return !length;
        }
        object13 = Object3(object13);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object13[data[0]] : !(data[0] in object13)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object13[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined6 && !(key in object13)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object13, source, stack);
            }
            if (!(result2 === undefined6 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value15) {
        if (!isObject(value15) || isMasked(value15)) {
          return false;
        }
        var pattern3 = isFunction(value15) ? reIsNative : reIsHostCtor;
        return pattern3.test(toSource(value15));
      }
      function baseIsRegExp(value15) {
        return isObjectLike(value15) && baseGetTag(value15) == regexpTag;
      }
      function baseIsSet(value15) {
        return isObjectLike(value15) && getTag(value15) == setTag;
      }
      function baseIsTypedArray(value15) {
        return isObjectLike(value15) && isLength(value15.length) && !!typedArrayTags[baseGetTag(value15)];
      }
      function baseIteratee(value15) {
        if (typeof value15 == "function") {
          return value15;
        }
        if (value15 == null) {
          return identity;
        }
        if (typeof value15 == "object") {
          return isArray(value15) ? baseMatchesProperty(value15[0], value15[1]) : baseMatches(value15);
        }
        return property(value15);
      }
      function baseKeys(object13) {
        if (!isPrototype(object13)) {
          return nativeKeys(object13);
        }
        var result2 = [];
        for (var key in Object3(object13)) {
          if (hasOwnProperty.call(object13, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object13) {
        if (!isObject(object13)) {
          return nativeKeysIn(object13);
        }
        var isProto = isPrototype(object13), result2 = [];
        for (var key in object13) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object13, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value15, other) {
        return value15 < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike2(collection) ? Array3(collection.length) : [];
        baseEach(collection, function(value15, key, collection2) {
          result2[++index] = iteratee2(value15, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object13) {
          return object13 === source || baseIsMatch(object13, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object13) {
          var objValue = get(object13, path);
          return objValue === undefined6 && objValue === srcValue ? hasIn(object13, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object13, source, srcIndex, customizer, stack) {
        if (object13 === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack);
          if (isObject(srcValue)) {
            baseMergeDeep(object13, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object13, key), srcValue, key + "", object13, source, stack) : undefined6;
            if (newValue === undefined6) {
              newValue = srcValue;
            }
            assignMergeValue(object13, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object13, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object13, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object13, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object13, source, stack) : undefined6;
        var isCommon = newValue === undefined6;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object13, key, newValue);
      }
      function baseNth(array5, n3) {
        var length = array5.length;
        if (!length) {
          return;
        }
        n3 += n3 < 0 ? length : 0;
        return isIndex(n3, length) ? array5[n3] : undefined6;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value15) {
                return baseGet(value15, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value15, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value15);
          });
          return { criteria, index: ++index, value: value15 };
        });
        return baseSortBy(result2, function(object13, other) {
          return compareMultiple(object13, other, orders);
        });
      }
      function basePick(object13, paths) {
        return basePickBy(object13, paths, function(value15, path) {
          return hasIn(object13, path);
        });
      }
      function basePickBy(object13, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value15 = baseGet(object13, path);
          if (predicate(value15, path)) {
            baseSet(result2, castPath(path, object13), value15);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object13) {
          return baseGet(object13, path);
        };
      }
      function basePullAll(array5, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array5;
        if (array5 === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array5, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value15 = values2[index], computed = iteratee2 ? iteratee2(value15) : value15;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array5) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array5, fromIndex, 1);
          }
        }
        return array5;
      }
      function basePullAt(array5, indexes) {
        var length = array5 ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array5, index, 1);
            } else {
              baseUnset(array5, index);
            }
          }
        }
        return array5;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array3(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string7, n3) {
        var result2 = "";
        if (!string7 || n3 < 1 || n3 > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n3 % 2) {
            result2 += string7;
          }
          n3 = nativeFloor(n3 / 2);
          if (n3) {
            string7 += string7;
          }
        } while (n3);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n3) {
        var array5 = values(collection);
        return shuffleSelf(array5, baseClamp(n3, 0, array5.length));
      }
      function baseSet(object13, path, value15, customizer) {
        if (!isObject(object13)) {
          return object13;
        }
        path = castPath(path, object13);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object13;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value15;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object13;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined6;
            if (newValue === undefined6) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object13;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string7) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string7),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array5, start, end) {
        var index = -1, length = array5.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array3(length);
        while (++index < length) {
          result2[index] = array5[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value15, index, collection2) {
          result2 = predicate(value15, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array5, value15, retHighest) {
        var low = 0, high = array5 == null ? low : array5.length;
        if (typeof value15 == "number" && value15 === value15 && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array5[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value15 : computed < value15)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array5, value15, identity, retHighest);
      }
      function baseSortedIndexBy(array5, value15, iteratee2, retHighest) {
        var low = 0, high = array5 == null ? 0 : array5.length;
        if (high === 0) {
          return 0;
        }
        value15 = iteratee2(value15);
        var valIsNaN = value15 !== value15, valIsNull = value15 === null, valIsSymbol = isSymbol(value15), valIsUndefined = value15 === undefined6;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array5[mid]), othIsDefined = computed !== undefined6, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value15 : computed < value15;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array5, iteratee2) {
        var index = -1, length = array5.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value15 = array5[index], computed = iteratee2 ? iteratee2(value15) : value15;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value15 === 0 ? 0 : value15;
          }
        }
        return result2;
      }
      function baseToNumber(value15) {
        if (typeof value15 == "number") {
          return value15;
        }
        if (isSymbol(value15)) {
          return NAN;
        }
        return +value15;
      }
      function baseToString(value15) {
        if (typeof value15 == "string") {
          return value15;
        }
        if (isArray(value15)) {
          return arrayMap(value15, baseToString) + "";
        }
        if (isSymbol(value15)) {
          return symbolToString ? symbolToString.call(value15) : "";
        }
        var result2 = value15 + "";
        return result2 == "0" && 1 / value15 == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array5, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array5.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array5);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache;
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value15 = array5[index], computed = iteratee2 ? iteratee2(value15) : value15;
            value15 = comparator || value15 !== 0 ? value15 : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value15);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value15);
            }
          }
        return result2;
      }
      function baseUnset(object13, path) {
        path = castPath(path, object13);
        object13 = parent(object13, path);
        return object13 == null || delete object13[toKey(last(path))];
      }
      function baseUpdate(object13, path, updater, customizer) {
        return baseSet(object13, path, updater(baseGet(object13, path)), customizer);
      }
      function baseWhile(array5, predicate, isDrop, fromRight) {
        var length = array5.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array5[index], index, array5)) {
        }
        return isDrop ? baseSlice(array5, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array5, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value15, actions) {
        var result2 = value15;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array3(length);
        while (++index < length) {
          var array5 = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array5, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value15 = index < valsLength ? values2[index] : undefined6;
          assignFunc(result2, props[index], value15);
        }
        return result2;
      }
      function castArrayLikeObject(value15) {
        return isArrayLikeObject(value15) ? value15 : [];
      }
      function castFunction(value15) {
        return typeof value15 == "function" ? value15 : identity;
      }
      function castPath(value15, object13) {
        if (isArray(value15)) {
          return value15;
        }
        return isKey(value15, object13) ? [value15] : stringToPath(toString(value15));
      }
      var castRest = baseRest;
      function castSlice(array5, start, end) {
        var length = array5.length;
        end = end === undefined6 ? length : end;
        return !start && end >= length ? array5 : baseSlice(array5, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array3(result2).set(new Uint8Array3(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp4) {
        var result2 = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
        result2.lastIndex = regexp4.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol5) {
        return symbolValueOf ? Object3(symbolValueOf.call(symbol5)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value15, other) {
        if (value15 !== other) {
          var valIsDefined = value15 !== undefined6, valIsNull = value15 === null, valIsReflexive = value15 === value15, valIsSymbol = isSymbol(value15);
          var othIsDefined = other !== undefined6, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value15 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value15 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object13, other, orders) {
        var index = -1, objCriteria = object13.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object13.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array3(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array3(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array5) {
        var index = -1, length = source.length;
        array5 || (array5 = Array3(length));
        while (++index < length) {
          array5[index] = source[index];
        }
        return array5;
      }
      function copyObject(source, props, object13, customizer) {
        var isNew = !object13;
        object13 || (object13 = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object13[key], source[key], key, object13, source) : undefined6;
          if (newValue === undefined6) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object13, key, newValue);
          } else {
            assignValue(object13, key, newValue);
          }
        }
        return object13;
      }
      function copySymbols(source, object13) {
        return copyObject(source, getSymbols(source), object13);
      }
      function copySymbolsIn(source, object13) {
        return copyObject(source, getSymbolsIn(source), object13);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object13, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined6, guard22 = length > 2 ? sources[2] : undefined6;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined6;
          if (guard22 && isIterateeCall(sources[0], sources[1], guard22)) {
            customizer = length < 3 ? undefined6 : customizer;
            length = 1;
          }
          object13 = Object3(object13);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object13, source, index, customizer);
            }
          }
          return object13;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object3(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object13, iteratee2, keysFunc) {
          var index = -1, iterable = Object3(object13), props = keysFunc(object13), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object13;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string7) {
          string7 = toString(string7);
          var strSymbols = hasUnicode(string7) ? stringToArray(string7) : undefined6;
          var chr = strSymbols ? strSymbols[0] : string7.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string7.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string7) {
          return arrayReduce(words(deburr(string7).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor;
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array3(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined6, args, holders, undefined6, undefined6, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object3(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined6;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined6;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value15 = args[0];
            if (wrapper && args.length == 1 && isArray(value15)) {
              return wrapper.plant(value15).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value15;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined6 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array3(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object13, iteratee2) {
          return baseInverter(object13, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value15, other) {
          var result2;
          if (value15 === undefined6 && other === undefined6) {
            return defaultValue;
          }
          if (value15 !== undefined6) {
            result2 = value15;
          }
          if (other !== undefined6) {
            if (result2 === undefined6) {
              return other;
            }
            if (typeof value15 == "string" || typeof other == "string") {
              value15 = baseToString(value15);
              other = baseToString(other);
            } else {
              value15 = baseToNumber(value15);
              other = baseToNumber(other);
            }
            result2 = operator(value15, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined6 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array3(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined6;
          }
          start = toFinite(start);
          if (end === undefined6) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined6 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value15, other) {
          if (!(typeof value15 == "string" && typeof other == "string")) {
            value15 = toNumber(value15);
            other = toNumber(other);
          }
          return operator(value15, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined6, newHoldersRight = isCurry ? undefined6 : holders, newPartials = isCurry ? partials : undefined6, newPartialsRight = isCurry ? undefined6 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined6, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number7, precision) {
          number7 = toNumber(number7);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number7)) {
            var pair = (toString(number7) + "e").split("e"), value15 = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value15) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number7);
        };
      }
      var createSet = !(Set5 && 1 / setToArray(new Set5([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set5(values2);
      };
      function createToPairs(keysFunc) {
        return function(object13) {
          var tag = getTag(object13);
          if (tag == mapTag) {
            return mapToArray(object13);
          }
          if (tag == setTag) {
            return setToPairs(object13);
          }
          return baseToPairs(object13, keysFunc(object13));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined6;
        }
        ary2 = ary2 === undefined6 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined6 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined6;
        }
        var data = isBindKey ? undefined6 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined6 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined6, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object13) {
        if (objValue === undefined6 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object13, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object13, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined6, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value15) {
        return isPlainObject(value15) ? undefined6 : value15;
      }
      function equalArrays(array5, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array5.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array5);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array5;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined6;
        stack.set(array5, other);
        stack.set(other, array5);
        while (++index < arrLength) {
          var arrValue = array5[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array5, stack) : customizer(arrValue, othValue, index, array5, other, stack);
          }
          if (compared !== undefined6) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array5);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object13, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object13.byteLength != other.byteLength || object13.byteOffset != other.byteOffset) {
              return false;
            }
            object13 = object13.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object13.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object13), new Uint8Array3(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object13, +other);
          case errorTag:
            return object13.name == other.name && object13.message == other.message;
          case regexpTag:
          case stringTag:
            return object13 == other + "";
          case mapTag:
            var convert4 = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert4 || (convert4 = setToArray);
            if (object13.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object13);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object13, other);
            var result2 = equalArrays(convert4(object13), convert4(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object13);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object13) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object13, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object13), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object13);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object13;
        }
        var result2 = true;
        stack.set(object13, other);
        stack.set(other, object13);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object13[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object13, stack) : customizer(objValue, othValue, key, object13, other, stack);
          }
          if (!(compared === undefined6 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object13.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && (("constructor" in object13) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object13);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined6, flatten), func + "");
      }
      function getAllKeys(object13) {
        return baseGetAllKeys(object13, keys, getSymbols);
      }
      function getAllKeysIn(object13) {
        return baseGetAllKeys(object13, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array5 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array5.length : 0;
        while (length--) {
          var data = array5[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object13 = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object13.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map5, key) {
        var data = map5.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object13) {
        var result2 = keys(object13), length = result2.length;
        while (length--) {
          var key = result2[length], value15 = object13[key];
          result2[length] = [key, value15, isStrictComparable(value15)];
        }
        return result2;
      }
      function getNative(object13, key) {
        var value15 = getValue(object13, key);
        return baseIsNative(value15) ? value15 : undefined6;
      }
      function getRawTag(value15) {
        var isOwn = hasOwnProperty.call(value15, symToStringTag), tag = value15[symToStringTag];
        try {
          value15[symToStringTag] = undefined6;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value15);
        if (unmasked) {
          if (isOwn) {
            value15[symToStringTag] = tag;
          } else {
            delete value15[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object13) {
        if (object13 == null) {
          return [];
        }
        object13 = Object3(object13);
        return arrayFilter(nativeGetSymbols(object13), function(symbol5) {
          return propertyIsEnumerable.call(object13, symbol5);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object13) {
        var result2 = [];
        while (object13) {
          arrayPush(result2, getSymbols(object13));
          object13 = getPrototype(object13);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise3 && getTag(Promise3.resolve()) != promiseTag || Set5 && getTag(new Set5) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
        getTag = function(value15) {
          var result2 = baseGetTag(value15), Ctor = result2 == objectTag ? value15.constructor : undefined6, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { start, end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object13, path, hasFunc) {
        path = castPath(path, object13);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object13 != null && hasFunc(object13, key))) {
            break;
          }
          object13 = object13[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object13 == null ? 0 : object13.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object13) || isArguments(object13));
      }
      function initCloneArray(array5) {
        var length = array5.length, result2 = new array5.constructor(length);
        if (length && typeof array5[0] == "string" && hasOwnProperty.call(array5, "index")) {
          result2.index = array5.index;
          result2.input = array5.input;
        }
        return result2;
      }
      function initCloneObject(object13) {
        return typeof object13.constructor == "function" && !isPrototype(object13) ? baseCreate(getPrototype(object13)) : {};
      }
      function initCloneByTag(object13, tag, isDeep) {
        var Ctor = object13.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object13);
          case boolTag:
          case dateTag:
            return new Ctor(+object13);
          case dataViewTag:
            return cloneDataView(object13, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object13, isDeep);
          case mapTag:
            return new Ctor;
          case numberTag:
          case stringTag:
            return new Ctor(object13);
          case regexpTag:
            return cloneRegExp(object13);
          case setTag:
            return new Ctor;
          case symbolTag:
            return cloneSymbol(object13);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value15) {
        return isArray(value15) || isArguments(value15) || !!(spreadableSymbol && value15 && value15[spreadableSymbol]);
      }
      function isIndex(value15, length) {
        var type47 = typeof value15;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type47 == "number" || type47 != "symbol" && reIsUint.test(value15)) && (value15 > -1 && value15 % 1 == 0 && value15 < length);
      }
      function isIterateeCall(value15, index, object13) {
        if (!isObject(object13)) {
          return false;
        }
        var type47 = typeof index;
        if (type47 == "number" ? isArrayLike2(object13) && isIndex(index, object13.length) : type47 == "string" && (index in object13)) {
          return eq(object13[index], value15);
        }
        return false;
      }
      function isKey(value15, object13) {
        if (isArray(value15)) {
          return false;
        }
        var type47 = typeof value15;
        if (type47 == "number" || type47 == "symbol" || type47 == "boolean" || value15 == null || isSymbol(value15)) {
          return true;
        }
        return reIsPlainProp.test(value15) || !reIsDeepProp.test(value15) || object13 != null && value15 in Object3(object13);
      }
      function isKeyable(value15) {
        var type47 = typeof value15;
        return type47 == "string" || type47 == "number" || type47 == "symbol" || type47 == "boolean" ? value15 !== "__proto__" : value15 === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value15) {
        var Ctor = value15 && value15.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value15 === proto2;
      }
      function isStrictComparable(value15) {
        return value15 === value15 && !isObject(value15);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object13) {
          if (object13 == null) {
            return false;
          }
          return object13[key] === srcValue && (srcValue !== undefined6 || (key in Object3(object13)));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value15 = source[3];
        if (value15) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value15, source[4]) : value15;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value15 = source[5];
        if (value15) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value15, source[6]) : value15;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value15 = source[7];
        if (value15) {
          data[7] = value15;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object13) {
        var result2 = [];
        if (object13 != null) {
          for (var key in Object3(object13)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value15) {
        return nativeObjectToString.call(value15);
      }
      function overRest(func, start, transform8) {
        start = nativeMax(start === undefined6 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array5 = Array3(length);
          while (++index < length) {
            array5[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array3(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform8(array5);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object13, path) {
        return path.length < 2 ? object13 : baseGet(object13, baseSlice(path, 0, -1));
      }
      function reorder(array5, indexes) {
        var arrLength = array5.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array5);
        while (length--) {
          var index = indexes[length];
          array5[length] = isIndex(index, arrLength) ? oldArray[index] : undefined6;
        }
        return array5;
      }
      function safeGet(object13, key) {
        if (key === "constructor" && typeof object13[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object13[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined6, arguments);
        };
      }
      function shuffleSelf(array5, size2) {
        var index = -1, length = array5.length, lastIndex = length - 1;
        size2 = size2 === undefined6 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value15 = array5[rand];
          array5[rand] = array5[index];
          array5[index] = value15;
        }
        array5.length = size2;
        return array5;
      }
      var stringToPath = memoizeCapped(function(string7) {
        var result2 = [];
        if (string7.charCodeAt(0) === 46) {
          result2.push("");
        }
        string7.replace(rePropName, function(match, number7, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number7 || match);
        });
        return result2;
      });
      function toKey(value15) {
        if (typeof value15 == "string" || isSymbol(value15)) {
          return value15;
        }
        var result2 = value15 + "";
        return result2 == "0" && 1 / value15 == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value15 = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value15)) {
            details.push(value15);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array5, size2, guard22) {
        if (guard22 ? isIterateeCall(array5, size2, guard22) : size2 === undefined6) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array5 == null ? 0 : array5.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array3(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array5, index, index += size2);
        }
        return result2;
      }
      function compact(array5) {
        var index = -1, length = array5 == null ? 0 : array5.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value15 = array5[index];
          if (value15) {
            result2[resIndex++] = value15;
          }
        }
        return result2;
      }
      function concat2() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array3(length - 1), array5 = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array5) ? copyArray(array5) : [array5], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array5, values2) {
        return isArrayLikeObject(array5) ? baseDifference(array5, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array5, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined6;
        }
        return isArrayLikeObject(array5) ? baseDifference(array5, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array5, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined6;
        }
        return isArrayLikeObject(array5) ? baseDifference(array5, baseFlatten(values2, 1, isArrayLikeObject, true), undefined6, comparator) : [];
      });
      function drop(array5, n3, guard22) {
        var length = array5 == null ? 0 : array5.length;
        if (!length) {
          return [];
        }
        n3 = guard22 || n3 === undefined6 ? 1 : toInteger(n3);
        return baseSlice(array5, n3 < 0 ? 0 : n3, length);
      }
      function dropRight(array5, n3, guard22) {
        var length = array5 == null ? 0 : array5.length;
        if (!length) {
          return [];
        }
        n3 = guard22 || n3 === undefined6 ? 1 : toInteger(n3);
        n3 = length - n3;
        return baseSlice(array5, 0, n3 < 0 ? 0 : n3);
      }
      function dropRightWhile(array5, predicate) {
        return array5 && array5.length ? baseWhile(array5, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array5, predicate) {
        return array5 && array5.length ? baseWhile(array5, getIteratee(predicate, 3), true) : [];
      }
      function fill(array5, value15, start, end) {
        var length = array5 == null ? 0 : array5.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array5, value15, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array5, value15, start, end);
      }
      function findIndex(array5, predicate, fromIndex) {
        var length = array5 == null ? 0 : array5.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array5, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array5, predicate, fromIndex) {
        var length = array5 == null ? 0 : array5.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined6) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array5, getIteratee(predicate, 3), index, true);
      }
      function flatten(array5) {
        var length = array5 == null ? 0 : array5.length;
        return length ? baseFlatten(array5, 1) : [];
      }
      function flattenDeep(array5) {
        var length = array5 == null ? 0 : array5.length;
        return length ? baseFlatten(array5, INFINITY) : [];
      }
      function flattenDepth(array5, depth) {
        var length = array5 == null ? 0 : array5.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined6 ? 1 : toInteger(depth);
        return baseFlatten(array5, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array5) {
        return array5 && array5.length ? array5[0] : undefined6;
      }
      function indexOf(array5, value15, fromIndex) {
        var length = array5 == null ? 0 : array5.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array5, value15, index);
      }
      function initial(array5) {
        var length = array5 == null ? 0 : array5.length;
        return length ? baseSlice(array5, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped20 = arrayMap(arrays, castArrayLikeObject);
        return mapped20.length && mapped20[0] === arrays[0] ? baseIntersection(mapped20) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped20 = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped20)) {
          iteratee2 = undefined6;
        } else {
          mapped20.pop();
        }
        return mapped20.length && mapped20[0] === arrays[0] ? baseIntersection(mapped20, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped20 = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined6;
        if (comparator) {
          mapped20.pop();
        }
        return mapped20.length && mapped20[0] === arrays[0] ? baseIntersection(mapped20, undefined6, comparator) : [];
      });
      function join2(array5, separator) {
        return array5 == null ? "" : nativeJoin.call(array5, separator);
      }
      function last(array5) {
        var length = array5 == null ? 0 : array5.length;
        return length ? array5[length - 1] : undefined6;
      }
      function lastIndexOf(array5, value15, fromIndex) {
        var length = array5 == null ? 0 : array5.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined6) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value15 === value15 ? strictLastIndexOf(array5, value15, index) : baseFindIndex(array5, baseIsNaN, index, true);
      }
      function nth(array5, n3) {
        return array5 && array5.length ? baseNth(array5, toInteger(n3)) : undefined6;
      }
      var pull = baseRest(pullAll);
      function pullAll(array5, values2) {
        return array5 && array5.length && values2 && values2.length ? basePullAll(array5, values2) : array5;
      }
      function pullAllBy(array5, values2, iteratee2) {
        return array5 && array5.length && values2 && values2.length ? basePullAll(array5, values2, getIteratee(iteratee2, 2)) : array5;
      }
      function pullAllWith(array5, values2, comparator) {
        return array5 && array5.length && values2 && values2.length ? basePullAll(array5, values2, undefined6, comparator) : array5;
      }
      var pullAt = flatRest(function(array5, indexes) {
        var length = array5 == null ? 0 : array5.length, result2 = baseAt(array5, indexes);
        basePullAt(array5, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array5, predicate) {
        var result2 = [];
        if (!(array5 && array5.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array5.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value15 = array5[index];
          if (predicate(value15, index, array5)) {
            result2.push(value15);
            indexes.push(index);
          }
        }
        basePullAt(array5, indexes);
        return result2;
      }
      function reverse(array5) {
        return array5 == null ? array5 : nativeReverse.call(array5);
      }
      function slice(array5, start, end) {
        var length = array5 == null ? 0 : array5.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array5, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined6 ? length : toInteger(end);
        }
        return baseSlice(array5, start, end);
      }
      function sortedIndex(array5, value15) {
        return baseSortedIndex(array5, value15);
      }
      function sortedIndexBy(array5, value15, iteratee2) {
        return baseSortedIndexBy(array5, value15, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array5, value15) {
        var length = array5 == null ? 0 : array5.length;
        if (length) {
          var index = baseSortedIndex(array5, value15);
          if (index < length && eq(array5[index], value15)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array5, value15) {
        return baseSortedIndex(array5, value15, true);
      }
      function sortedLastIndexBy(array5, value15, iteratee2) {
        return baseSortedIndexBy(array5, value15, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array5, value15) {
        var length = array5 == null ? 0 : array5.length;
        if (length) {
          var index = baseSortedIndex(array5, value15, true) - 1;
          if (eq(array5[index], value15)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array5) {
        return array5 && array5.length ? baseSortedUniq(array5) : [];
      }
      function sortedUniqBy(array5, iteratee2) {
        return array5 && array5.length ? baseSortedUniq(array5, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array5) {
        var length = array5 == null ? 0 : array5.length;
        return length ? baseSlice(array5, 1, length) : [];
      }
      function take(array5, n3, guard22) {
        if (!(array5 && array5.length)) {
          return [];
        }
        n3 = guard22 || n3 === undefined6 ? 1 : toInteger(n3);
        return baseSlice(array5, 0, n3 < 0 ? 0 : n3);
      }
      function takeRight(array5, n3, guard22) {
        var length = array5 == null ? 0 : array5.length;
        if (!length) {
          return [];
        }
        n3 = guard22 || n3 === undefined6 ? 1 : toInteger(n3);
        n3 = length - n3;
        return baseSlice(array5, n3 < 0 ? 0 : n3, length);
      }
      function takeRightWhile(array5, predicate) {
        return array5 && array5.length ? baseWhile(array5, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array5, predicate) {
        return array5 && array5.length ? baseWhile(array5, getIteratee(predicate, 3)) : [];
      }
      var union22 = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined6;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined6;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined6, comparator);
      });
      function uniq(array5) {
        return array5 && array5.length ? baseUniq(array5) : [];
      }
      function uniqBy(array5, iteratee2) {
        return array5 && array5.length ? baseUniq(array5, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array5, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined6;
        return array5 && array5.length ? baseUniq(array5, undefined6, comparator) : [];
      }
      function unzip(array5) {
        if (!(array5 && array5.length)) {
          return [];
        }
        var length = 0;
        array5 = arrayFilter(array5, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array5, baseProperty(index));
        });
      }
      function unzipWith(array5, iteratee2) {
        if (!(array5 && array5.length)) {
          return [];
        }
        var result2 = unzip(array5);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined6, group);
        });
      }
      var without = baseRest(function(array5, values2) {
        return isArrayLikeObject(array5) ? baseDifference(array5, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined6;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined6;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined6, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined6;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined6;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value15) {
        var result2 = lodash(value15);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value15, interceptor) {
        interceptor(value15);
        return value15;
      }
      function thru(value15, interceptor) {
        return interceptor(value15);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value15 = this.__wrapped__, interceptor = function(object13) {
          return baseAt(object13, paths);
        };
        if (length > 1 || this.__actions__.length || !(value15 instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value15 = value15.slice(start, +start + (length ? 1 : 0));
        value15.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined6
        });
        return new LodashWrapper(value15, this.__chain__).thru(function(array5) {
          if (length && !array5.length) {
            array5.push(undefined6);
          }
          return array5;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined6) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value15 = done ? undefined6 : this.__values__[this.__index__++];
        return { done, value: value15 };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value15) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone14 = wrapperClone(parent2);
          clone14.__index__ = 0;
          clone14.__values__ = undefined6;
          if (result2) {
            previous.__wrapped__ = clone14;
          } else {
            result2 = clone14;
          }
          var previous = clone14;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value15;
        return result2;
      }
      function wrapperReverse() {
        var value15 = this.__wrapped__;
        if (value15 instanceof LazyWrapper) {
          var wrapped = value15;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined6
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value15, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every2(collection, predicate, guard22) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard22 && isIterateeCall(collection, predicate, guard22)) {
          predicate = undefined6;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map4(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map4(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined6 ? 1 : toInteger(depth);
        return baseFlatten(map4(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value15, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value15);
        } else {
          baseAssignValue(result2, key, [value15]);
        }
      });
      function includes(collection, value15, fromIndex, guard22) {
        collection = isArrayLike2(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard22 ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value15, fromIndex) > -1 : !!length && baseIndexOf(collection, value15, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array3(collection.length) : [];
        baseEach(collection, function(value15) {
          result2[++index] = isFunc ? apply(path, value15, args) : baseInvoke(value15, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value15, key) {
        baseAssignValue(result2, key, value15);
      });
      function map4(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard22) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard22 ? undefined6 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value15, key) {
        result2[key ? 0 : 1].push(value15);
      }, function() {
        return [[], []];
      });
      function reduce2(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject2(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n3, guard22) {
        if (guard22 ? isIterateeCall(collection, n3, guard22) : n3 === undefined6) {
          n3 = 1;
        } else {
          n3 = toInteger(n3);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n3);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike2(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some2(collection, predicate, guard22) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard22 && isIterateeCall(collection, predicate, guard22)) {
          predicate = undefined6;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy2 = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n3, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n3 = toInteger(n3);
        return function() {
          if (--n3 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n3, guard22) {
        n3 = guard22 ? undefined6 : n3;
        n3 = func && n3 == null ? func.length : n3;
        return createWrap(func, WRAP_ARY_FLAG, undefined6, undefined6, undefined6, undefined6, n3);
      }
      function before(n3, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n3 = toInteger(n3);
        return function() {
          if (--n3 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n3 <= 1) {
            func = undefined6;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object13, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object13, partials, holders);
      });
      function curry(func, arity, guard22) {
        arity = guard22 ? undefined6 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined6, undefined6, undefined6, undefined6, undefined6, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard22) {
        arity = guard22 ? undefined6 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined6, undefined6, undefined6, undefined6, undefined6, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined6;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined6 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined6;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined6;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined6) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined6;
        }
        function flush() {
          return timerId === undefined6 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined6) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined6) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once2(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial5 = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial5));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined6, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined6, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined6, undefined6, undefined6, indexes);
      });
      function rest4(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined6 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array5 = args[start], otherArgs = castSlice(args, 0, start);
          if (array5) {
            arrayPush(otherArgs, array5);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap2(value15, wrapper) {
        return partial5(castFunction(wrapper), value15);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value15 = arguments[0];
        return isArray(value15) ? value15 : [value15];
      }
      function clone13(value15) {
        return baseClone(value15, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value15, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        return baseClone(value15, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value15) {
        return baseClone(value15, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value15, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        return baseClone(value15, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object13, source) {
        return source == null || baseConformsTo(object13, source, keys(source));
      }
      function eq(value15, other) {
        return value15 === other || value15 !== value15 && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value15, other) {
        return value15 >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value15) {
        return isObjectLike(value15) && hasOwnProperty.call(value15, "callee") && !propertyIsEnumerable.call(value15, "callee");
      };
      var isArray = Array3.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value15) {
        return value15 != null && isLength(value15.length) && !isFunction(value15);
      }
      function isArrayLikeObject(value15) {
        return isObjectLike(value15) && isArrayLike2(value15);
      }
      function isBoolean(value15) {
        return value15 === true || value15 === false || isObjectLike(value15) && baseGetTag(value15) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value15) {
        return isObjectLike(value15) && value15.nodeType === 1 && !isPlainObject(value15);
      }
      function isEmpty(value15) {
        if (value15 == null) {
          return true;
        }
        if (isArrayLike2(value15) && (isArray(value15) || typeof value15 == "string" || typeof value15.splice == "function" || isBuffer(value15) || isTypedArray(value15) || isArguments(value15))) {
          return !value15.length;
        }
        var tag = getTag(value15);
        if (tag == mapTag || tag == setTag) {
          return !value15.size;
        }
        if (isPrototype(value15)) {
          return !baseKeys(value15).length;
        }
        for (var key in value15) {
          if (hasOwnProperty.call(value15, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value15, other) {
        return baseIsEqual(value15, other);
      }
      function isEqualWith(value15, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        var result2 = customizer ? customizer(value15, other) : undefined6;
        return result2 === undefined6 ? baseIsEqual(value15, other, undefined6, customizer) : !!result2;
      }
      function isError(value15) {
        if (!isObjectLike(value15)) {
          return false;
        }
        var tag = baseGetTag(value15);
        return tag == errorTag || tag == domExcTag || typeof value15.message == "string" && typeof value15.name == "string" && !isPlainObject(value15);
      }
      function isFinite2(value15) {
        return typeof value15 == "number" && nativeIsFinite(value15);
      }
      function isFunction(value15) {
        if (!isObject(value15)) {
          return false;
        }
        var tag = baseGetTag(value15);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value15) {
        return typeof value15 == "number" && value15 == toInteger(value15);
      }
      function isLength(value15) {
        return typeof value15 == "number" && value15 > -1 && value15 % 1 == 0 && value15 <= MAX_SAFE_INTEGER;
      }
      function isObject(value15) {
        var type47 = typeof value15;
        return value15 != null && (type47 == "object" || type47 == "function");
      }
      function isObjectLike(value15) {
        return value15 != null && typeof value15 == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object13, source) {
        return object13 === source || baseIsMatch(object13, source, getMatchData(source));
      }
      function isMatchWith(object13, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        return baseIsMatch(object13, source, getMatchData(source), customizer);
      }
      function isNaN2(value15) {
        return isNumber(value15) && value15 != +value15;
      }
      function isNative(value15) {
        if (isMaskable(value15)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value15);
      }
      function isNull(value15) {
        return value15 === null;
      }
      function isNil(value15) {
        return value15 == null;
      }
      function isNumber(value15) {
        return typeof value15 == "number" || isObjectLike(value15) && baseGetTag(value15) == numberTag;
      }
      function isPlainObject(value15) {
        if (!isObjectLike(value15) || baseGetTag(value15) != objectTag) {
          return false;
        }
        var proto2 = getPrototype(value15);
        if (proto2 === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value15) {
        return isInteger(value15) && value15 >= -MAX_SAFE_INTEGER && value15 <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value15) {
        return typeof value15 == "string" || !isArray(value15) && isObjectLike(value15) && baseGetTag(value15) == stringTag;
      }
      function isSymbol(value15) {
        return typeof value15 == "symbol" || isObjectLike(value15) && baseGetTag(value15) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value15) {
        return value15 === undefined6;
      }
      function isWeakMap(value15) {
        return isObjectLike(value15) && getTag(value15) == weakMapTag;
      }
      function isWeakSet(value15) {
        return isObjectLike(value15) && baseGetTag(value15) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value15, other) {
        return value15 <= other;
      });
      function toArray(value15) {
        if (!value15) {
          return [];
        }
        if (isArrayLike2(value15)) {
          return isString(value15) ? stringToArray(value15) : copyArray(value15);
        }
        if (symIterator && value15[symIterator]) {
          return iteratorToArray(value15[symIterator]());
        }
        var tag = getTag(value15), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value15);
      }
      function toFinite(value15) {
        if (!value15) {
          return value15 === 0 ? value15 : 0;
        }
        value15 = toNumber(value15);
        if (value15 === INFINITY || value15 === -INFINITY) {
          var sign = value15 < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value15 === value15 ? value15 : 0;
      }
      function toInteger(value15) {
        var result2 = toFinite(value15), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value15) {
        return value15 ? baseClamp(toInteger(value15), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value15) {
        if (typeof value15 == "number") {
          return value15;
        }
        if (isSymbol(value15)) {
          return NAN;
        }
        if (isObject(value15)) {
          var other = typeof value15.valueOf == "function" ? value15.valueOf() : value15;
          value15 = isObject(other) ? other + "" : other;
        }
        if (typeof value15 != "string") {
          return value15 === 0 ? value15 : +value15;
        }
        value15 = baseTrim(value15);
        var isBinary = reIsBinary.test(value15);
        return isBinary || reIsOctal.test(value15) ? freeParseInt(value15.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value15) ? NAN : +value15;
      }
      function toPlainObject(value15) {
        return copyObject(value15, keysIn(value15));
      }
      function toSafeInteger(value15) {
        return value15 ? baseClamp(toInteger(value15), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value15 === 0 ? value15 : 0;
      }
      function toString(value15) {
        return value15 == null ? "" : baseToString(value15);
      }
      var assign = createAssigner(function(object13, source) {
        if (isPrototype(source) || isArrayLike2(source)) {
          copyObject(source, keys(source), object13);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object13, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object13, source) {
        copyObject(source, keysIn(source), object13);
      });
      var assignInWith = createAssigner(function(object13, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object13, customizer);
      });
      var assignWith = createAssigner(function(object13, source, srcIndex, customizer) {
        copyObject(source, keys(source), object13, customizer);
      });
      var at = flatRest(baseAt);
      function create5(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object13, sources) {
        object13 = Object3(object13);
        var index = -1;
        var length = sources.length;
        var guard22 = length > 2 ? sources[2] : undefined6;
        if (guard22 && isIterateeCall(sources[0], sources[1], guard22)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value15 = object13[key];
            if (value15 === undefined6 || eq(value15, objectProto[key]) && !hasOwnProperty.call(object13, key)) {
              object13[key] = source[key];
            }
          }
        }
        return object13;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined6, customDefaultsMerge);
        return apply(mergeWith, undefined6, args);
      });
      function findKey(object13, predicate) {
        return baseFindKey(object13, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object13, predicate) {
        return baseFindKey(object13, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object13, iteratee2) {
        return object13 == null ? object13 : baseFor(object13, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object13, iteratee2) {
        return object13 == null ? object13 : baseForRight(object13, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object13, iteratee2) {
        return object13 && baseForOwn(object13, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object13, iteratee2) {
        return object13 && baseForOwnRight(object13, getIteratee(iteratee2, 3));
      }
      function functions(object13) {
        return object13 == null ? [] : baseFunctions(object13, keys(object13));
      }
      function functionsIn(object13) {
        return object13 == null ? [] : baseFunctions(object13, keysIn(object13));
      }
      function get(object13, path, defaultValue) {
        var result2 = object13 == null ? undefined6 : baseGet(object13, path);
        return result2 === undefined6 ? defaultValue : result2;
      }
      function has2(object13, path) {
        return object13 != null && hasPath(object13, path, baseHas);
      }
      function hasIn(object13, path) {
        return object13 != null && hasPath(object13, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value15, key) {
        if (value15 != null && typeof value15.toString != "function") {
          value15 = nativeObjectToString.call(value15);
        }
        result2[value15] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value15, key) {
        if (value15 != null && typeof value15.toString != "function") {
          value15 = nativeObjectToString.call(value15);
        }
        if (hasOwnProperty.call(result2, value15)) {
          result2[value15].push(key);
        } else {
          result2[value15] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object13) {
        return isArrayLike2(object13) ? arrayLikeKeys(object13) : baseKeys(object13);
      }
      function keysIn(object13) {
        return isArrayLike2(object13) ? arrayLikeKeys(object13, true) : baseKeysIn(object13);
      }
      function mapKeys(object13, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object13, function(value15, key, object14) {
          baseAssignValue(result2, iteratee2(value15, key, object14), value15);
        });
        return result2;
      }
      function mapValues(object13, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object13, function(value15, key, object14) {
          baseAssignValue(result2, key, iteratee2(value15, key, object14));
        });
        return result2;
      }
      var merge = createAssigner(function(object13, source, srcIndex) {
        baseMerge(object13, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object13, source, srcIndex, customizer) {
        baseMerge(object13, source, srcIndex, customizer);
      });
      var omit6 = flatRest(function(object13, paths) {
        var result2 = {};
        if (object13 == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object13);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object13, getAllKeysIn(object13), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object13, predicate) {
        return pickBy(object13, negate(getIteratee(predicate)));
      }
      var pick6 = flatRest(function(object13, paths) {
        return object13 == null ? {} : basePick(object13, paths);
      });
      function pickBy(object13, predicate) {
        if (object13 == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object13), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object13, props, function(value15, path) {
          return predicate(value15, path[0]);
        });
      }
      function result(object13, path, defaultValue) {
        path = castPath(path, object13);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object13 = undefined6;
        }
        while (++index < length) {
          var value15 = object13 == null ? undefined6 : object13[toKey(path[index])];
          if (value15 === undefined6) {
            index = length;
            value15 = defaultValue;
          }
          object13 = isFunction(value15) ? value15.call(object13) : value15;
        }
        return object13;
      }
      function set2(object13, path, value15) {
        return object13 == null ? object13 : baseSet(object13, path, value15);
      }
      function setWith(object13, path, value15, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        return object13 == null ? object13 : baseSet(object13, path, value15, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform7(object13, iteratee2, accumulator) {
        var isArr = isArray(object13), isArrLike = isArr || isBuffer(object13) || isTypedArray(object13);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object13 && object13.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
          } else if (isObject(object13)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object13)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object13, function(value15, index, object14) {
          return iteratee2(accumulator, value15, index, object14);
        });
        return accumulator;
      }
      function unset(object13, path) {
        return object13 == null ? true : baseUnset(object13, path);
      }
      function update(object13, path, updater) {
        return object13 == null ? object13 : baseUpdate(object13, path, castFunction(updater));
      }
      function updateWith(object13, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        return object13 == null ? object13 : baseUpdate(object13, path, castFunction(updater), customizer);
      }
      function values(object13) {
        return object13 == null ? [] : baseValues(object13, keys(object13));
      }
      function valuesIn(object13) {
        return object13 == null ? [] : baseValues(object13, keysIn(object13));
      }
      function clamp(number7, lower, upper) {
        if (upper === undefined6) {
          upper = lower;
          lower = undefined6;
        }
        if (upper !== undefined6) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined6) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number7), lower, upper);
      }
      function inRange(number7, start, end) {
        start = toFinite(start);
        if (end === undefined6) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number7 = toNumber(number7);
        return baseInRange(number7, start, end);
      }
      function random2(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined6;
        }
        if (floating === undefined6) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined6;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined6;
          }
        }
        if (lower === undefined6 && upper === undefined6) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined6) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize2(word) : word);
      });
      function capitalize2(string7) {
        return upperFirst(toString(string7).toLowerCase());
      }
      function deburr(string7) {
        string7 = toString(string7);
        return string7 && string7.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string7, target, position) {
        string7 = toString(string7);
        target = baseToString(target);
        var length = string7.length;
        position = position === undefined6 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string7.slice(position, end) == target;
      }
      function escape(string7) {
        string7 = toString(string7);
        return string7 && reHasUnescapedHtml.test(string7) ? string7.replace(reUnescapedHtml, escapeHtmlChar) : string7;
      }
      function escapeRegExp(string7) {
        string7 = toString(string7);
        return string7 && reHasRegExpChar.test(string7) ? string7.replace(reRegExpChar, "\\$&") : string7;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string7, length, chars) {
        string7 = toString(string7);
        length = toInteger(length);
        var strLength = length ? stringSize(string7) : 0;
        if (!length || strLength >= length) {
          return string7;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string7 + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string7, length, chars) {
        string7 = toString(string7);
        length = toInteger(length);
        var strLength = length ? stringSize(string7) : 0;
        return length && strLength < length ? string7 + createPadding(length - strLength, chars) : string7;
      }
      function padStart(string7, length, chars) {
        string7 = toString(string7);
        length = toInteger(length);
        var strLength = length ? stringSize(string7) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string7 : string7;
      }
      function parseInt2(string7, radix, guard22) {
        if (guard22 || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string7).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string7, n3, guard22) {
        if (guard22 ? isIterateeCall(string7, n3, guard22) : n3 === undefined6) {
          n3 = 1;
        } else {
          n3 = toInteger(n3);
        }
        return baseRepeat(toString(string7), n3);
      }
      function replace() {
        var args = arguments, string7 = toString(args[0]);
        return args.length < 3 ? string7 : string7.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string7, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string7, separator, limit)) {
          separator = limit = undefined6;
        }
        limit = limit === undefined6 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string7 = toString(string7);
        if (string7 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string7)) {
            return castSlice(stringToArray(string7), 0, limit);
          }
        }
        return string7.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string7, target, position) {
        string7 = toString(string7);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string7.length);
        target = baseToString(target);
        return string7.slice(position, position + target.length) == target;
      }
      function template(string7, options, guard22) {
        var settings = lodash.templateSettings;
        if (guard22 && isIterateeCall(string7, options, guard22)) {
          options = undefined6;
        }
        string7 = toString(string7);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp3((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string7.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string7.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function3(importsKeys, sourceURL + "return " + source).apply(undefined6, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value15) {
        return toString(value15).toLowerCase();
      }
      function toUpper(value15) {
        return toString(value15).toUpperCase();
      }
      function trim(string7, chars, guard22) {
        string7 = toString(string7);
        if (string7 && (guard22 || chars === undefined6)) {
          return baseTrim(string7);
        }
        if (!string7 || !(chars = baseToString(chars))) {
          return string7;
        }
        var strSymbols = stringToArray(string7), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string7, chars, guard22) {
        string7 = toString(string7);
        if (string7 && (guard22 || chars === undefined6)) {
          return string7.slice(0, trimmedEndIndex(string7) + 1);
        }
        if (!string7 || !(chars = baseToString(chars))) {
          return string7;
        }
        var strSymbols = stringToArray(string7), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string7, chars, guard22) {
        string7 = toString(string7);
        if (string7 && (guard22 || chars === undefined6)) {
          return string7.replace(reTrimStart, "");
        }
        if (!string7 || !(chars = baseToString(chars))) {
          return string7;
        }
        var strSymbols = stringToArray(string7), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string7, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string7 = toString(string7);
        var strLength = string7.length;
        if (hasUnicode(string7)) {
          var strSymbols = stringToArray(string7);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string7;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string7.slice(0, end);
        if (separator === undefined6) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string7.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp3(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined6 ? end : newEnd);
          }
        } else if (string7.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape(string7) {
        string7 = toString(string7);
        return string7 && reHasEscapedHtml.test(string7) ? string7.replace(reEscapedHtml, unescapeHtmlChar) : string7;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string7, pattern3, guard22) {
        string7 = toString(string7);
        pattern3 = guard22 ? undefined6 : pattern3;
        if (pattern3 === undefined6) {
          return hasUnicodeWord(string7) ? unicodeWords(string7) : asciiWords(string7);
        }
        return string7.match(pattern3) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined6, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object13, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object13, key, bind(object13[key], object13));
        });
        return object13;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value15) {
        return function() {
          return value15;
        };
      }
      function defaultTo(value15, defaultValue) {
        return value15 == null || value15 !== value15 ? defaultValue : value15;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value15) {
        return value15;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object13) {
          return baseInvoke(object13, path, args);
        };
      });
      var methodOf = baseRest(function(object13, args) {
        return function(path) {
          return baseInvoke(object13, path, args);
        };
      });
      function mixin(object13, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object13;
          object13 = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options) && ("chain" in options)) || !!options.chain, isFunc = isFunction(object13);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object13[methodName] = func;
          if (isFunc) {
            object13.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object13(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ func, args: arguments, thisArg: object13 });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object13, arrayPush([this.value()], arguments));
            };
          }
        });
        return object13;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n3) {
        n3 = toInteger(n3);
        return baseRest(function(args) {
          return baseNth(args, n3);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object13) {
        return function(path) {
          return object13 == null ? undefined6 : baseGet(object13, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n3, iteratee2) {
        n3 = toInteger(n3);
        if (n3 < 1 || n3 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n3, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n3 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n3) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value15) {
        if (isArray(value15)) {
          return arrayMap(value15, toKey);
        }
        return isSymbol(value15) ? [value15] : copyArray(stringToPath(toString(value15)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array5) {
        return array5 && array5.length ? baseExtremum(array5, identity, baseGt) : undefined6;
      }
      function maxBy(array5, iteratee2) {
        return array5 && array5.length ? baseExtremum(array5, getIteratee(iteratee2, 2), baseGt) : undefined6;
      }
      function mean(array5) {
        return baseMean(array5, identity);
      }
      function meanBy(array5, iteratee2) {
        return baseMean(array5, getIteratee(iteratee2, 2));
      }
      function min(array5) {
        return array5 && array5.length ? baseExtremum(array5, identity, baseLt) : undefined6;
      }
      function minBy(array5, iteratee2) {
        return array5 && array5.length ? baseExtremum(array5, getIteratee(iteratee2, 2), baseLt) : undefined6;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array5) {
        return array5 && array5.length ? baseSum(array5, identity) : 0;
      }
      function sumBy(array5, iteratee2) {
        return array5 && array5.length ? baseSum(array5, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat2;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create5;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter2;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map4;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit6;
      lodash.omitBy = omitBy;
      lodash.once = once2;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial5;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick6;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject2;
      lodash.remove = remove;
      lodash.rest = rest4;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set2;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy2;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform7;
      lodash.unary = unary;
      lodash.union = union22;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap2;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize2;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone13;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every2;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has2;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike2;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join2;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random2;
      lodash.reduce = reduce2;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some2;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { chain: false });
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n3) {
          n3 = n3 === undefined6 ? 1 : nativeMax(toInteger(n3), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n3, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n3, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n3) {
          return this.reverse()[methodName](n3).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type47 = index + 1, isFilter = type47 == LAZY_FILTER_FLAG || type47 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type: type47
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value15) {
          return baseInvoke(value15, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined6) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value15 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value15 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value15);
          var interceptor = function(value16) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value16], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value15 = onlyLazy ? value15 : new LazyWrapper(this);
            var result2 = func.apply(value15, args);
            result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined6 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value15 = this.value();
            return func.apply(isArray(value15) ? value15 : [], args);
          }
          return this[chainName](function(value16) {
            return func.apply(isArray(value16) ? value16 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ name: methodName, func: lodashFunc });
        }
      });
      realNames[createHybrid(undefined6, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined6
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(exports);
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS((exports, module) => {
  module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x3) => `%${x3.charCodeAt(0).toString(16).toUpperCase()}`);
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS((exports, module) => {
  function decodeComponents(components, split) {
    try {
      return [decodeURIComponent(components.join(""))];
    } catch (err) {
    }
    if (components.length === 1) {
      return components;
    }
    split = split || 1;
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }
  function decode2(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher) || [];
      for (var i3 = 1;i3 < tokens.length; i3++) {
        input = decodeComponents(tokens, i3).join("");
        tokens = input.match(singleMatcher) || [];
      }
      return input;
    }
  }
  function customDecodeURIComponent(input) {
    var replaceMap = {
      "%FE%FF": "\uFFFD\uFFFD",
      "%FF%FE": "\uFFFD\uFFFD"
    };
    var match = multiMatcher.exec(input);
    while (match) {
      try {
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode2(match[0]);
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
      match = multiMatcher.exec(input);
    }
    replaceMap["%C2"] = "\uFFFD";
    var entries = Object.keys(replaceMap);
    for (var i3 = 0;i3 < entries.length; i3++) {
      var key = entries[i3];
      input = input.replace(new RegExp(key, "g"), replaceMap[key]);
    }
    return input;
  }
  var token = "%[a-f0-9]{2}";
  var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
  var multiMatcher = new RegExp("(" + token + ")+", "gi");
  module.exports = function(encodedURI) {
    if (typeof encodedURI !== "string") {
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
      encodedURI = encodedURI.replace(/\+/g, " ");
      return decodeURIComponent(encodedURI);
    } catch (err) {
      return customDecodeURIComponent(encodedURI);
    }
  };
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS((exports, module) => {
  module.exports = (string7, separator) => {
    if (!(typeof string7 === "string" && typeof separator === "string")) {
      throw new TypeError("Expected the arguments to be of type `string`");
    }
    if (separator === "") {
      return [string7];
    }
    const separatorIndex = string7.indexOf(separator);
    if (separatorIndex === -1) {
      return [string7];
    }
    return [
      string7.slice(0, separatorIndex),
      string7.slice(separatorIndex + separator.length)
    ];
  };
});

// node_modules/filter-obj/index.js
var require_filter_obj = __commonJS((exports, module) => {
  module.exports = function(obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for (var i3 = 0;i3 < keys.length; i3++) {
      var key = keys[i3];
      var val = obj[key];
      if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
        ret[key] = val;
      }
    }
    return ret;
  };
});

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS((exports) => {
  var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
  var regexName = new RegExp("^" + nameRegexp + "$");
  var getAllMatches = function(string7, regex) {
    const matches = [];
    let match = regex.exec(string7);
    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      const len = match.length;
      for (let index = 0;index < len; index++) {
        allmatches.push(match[index]);
      }
      matches.push(allmatches);
      match = regex.exec(string7);
    }
    return matches;
  };
  var isName = function(string7) {
    const match = regexName.exec(string7);
    return !(match === null || typeof match === "undefined");
  };
  exports.isExist = function(v3) {
    return typeof v3 !== "undefined";
  };
  exports.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };
  exports.merge = function(target, a, arrayMode) {
    if (a) {
      const keys = Object.keys(a);
      const len = keys.length;
      for (let i3 = 0;i3 < len; i3++) {
        if (arrayMode === "strict") {
          target[keys[i3]] = [a[keys[i3]]];
        } else {
          target[keys[i3]] = a[keys[i3]];
        }
      }
    }
  };
  exports.getValue = function(v3) {
    if (exports.isExist(v3)) {
      return v3;
    } else {
      return "";
    }
  };
  exports.isName = isName;
  exports.getAllMatches = getAllMatches;
  exports.nameRegexp = nameRegexp;
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS((exports) => {
  function isWhiteSpace(char) {
    return char === " " || char === "\t" || char === "\n" || char === "\r";
  }
  function readPI(xmlData, i3) {
    const start = i3;
    for (;i3 < xmlData.length; i3++) {
      if (xmlData[i3] == "?" || xmlData[i3] == " ") {
        const tagname = xmlData.substr(start, i3 - start);
        if (i3 > 5 && tagname === "xml") {
          return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i3));
        } else if (xmlData[i3] == "?" && xmlData[i3 + 1] == ">") {
          i3++;
          break;
        } else {
          continue;
        }
      }
    }
    return i3;
  }
  function readCommentAndCDATA(xmlData, i3) {
    if (xmlData.length > i3 + 5 && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === "-") {
      for (i3 += 3;i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "-" && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === ">") {
          i3 += 2;
          break;
        }
      }
    } else if (xmlData.length > i3 + 8 && xmlData[i3 + 1] === "D" && xmlData[i3 + 2] === "O" && xmlData[i3 + 3] === "C" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "Y" && xmlData[i3 + 6] === "P" && xmlData[i3 + 7] === "E") {
      let angleBracketsCount = 1;
      for (i3 += 8;i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<") {
          angleBracketsCount++;
        } else if (xmlData[i3] === ">") {
          angleBracketsCount--;
          if (angleBracketsCount === 0) {
            break;
          }
        }
      }
    } else if (xmlData.length > i3 + 9 && xmlData[i3 + 1] === "[" && xmlData[i3 + 2] === "C" && xmlData[i3 + 3] === "D" && xmlData[i3 + 4] === "A" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "A" && xmlData[i3 + 7] === "[") {
      for (i3 += 8;i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "]" && xmlData[i3 + 1] === "]" && xmlData[i3 + 2] === ">") {
          i3 += 2;
          break;
        }
      }
    }
    return i3;
  }
  function readAttributeStr(xmlData, i3) {
    let attrStr = "";
    let startChar = "";
    let tagClosed = false;
    for (;i3 < xmlData.length; i3++) {
      if (xmlData[i3] === doubleQuote || xmlData[i3] === singleQuote) {
        if (startChar === "") {
          startChar = xmlData[i3];
        } else if (startChar !== xmlData[i3]) {
        } else {
          startChar = "";
        }
      } else if (xmlData[i3] === ">") {
        if (startChar === "") {
          tagClosed = true;
          break;
        }
      }
      attrStr += xmlData[i3];
    }
    if (startChar !== "") {
      return false;
    }
    return {
      value: attrStr,
      index: i3,
      tagClosed
    };
  }
  function validateAttributeString(attrStr, options) {
    const matches = util2.getAllMatches(attrStr, validAttrStrRegxp);
    const attrNames = {};
    for (let i3 = 0;i3 < matches.length; i3++) {
      if (matches[i3][1].length === 0) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' has no space in starting.", getPositionFromMatch(matches[i3]));
      } else if (matches[i3][3] !== undefined && matches[i3][4] === undefined) {
        return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' is without value.", getPositionFromMatch(matches[i3]));
      } else if (matches[i3][3] === undefined && !options.allowBooleanAttributes) {
        return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i3][2] + "' is not allowed.", getPositionFromMatch(matches[i3]));
      }
      const attrName = matches[i3][2];
      if (!validateAttrName(attrName)) {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i3]));
      }
      if (!attrNames.hasOwnProperty(attrName)) {
        attrNames[attrName] = 1;
      } else {
        return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i3]));
      }
    }
    return true;
  }
  function validateNumberAmpersand(xmlData, i3) {
    let re = /\d/;
    if (xmlData[i3] === "x") {
      i3++;
      re = /[\da-fA-F]/;
    }
    for (;i3 < xmlData.length; i3++) {
      if (xmlData[i3] === ";")
        return i3;
      if (!xmlData[i3].match(re))
        break;
    }
    return -1;
  }
  function validateAmpersand(xmlData, i3) {
    i3++;
    if (xmlData[i3] === ";")
      return -1;
    if (xmlData[i3] === "#") {
      i3++;
      return validateNumberAmpersand(xmlData, i3);
    }
    let count = 0;
    for (;i3 < xmlData.length; i3++, count++) {
      if (xmlData[i3].match(/\w/) && count < 20)
        continue;
      if (xmlData[i3] === ";")
        break;
      return -1;
    }
    return i3;
  }
  function getErrorObject(code, message, lineNumber) {
    return {
      err: {
        code,
        msg: message,
        line: lineNumber.line || lineNumber,
        col: lineNumber.col
      }
    };
  }
  function validateAttrName(attrName) {
    return util2.isName(attrName);
  }
  function validateTagName(tagname) {
    return util2.isName(tagname);
  }
  function getLineNumberForPosition(xmlData, index) {
    const lines = xmlData.substring(0, index).split(/\r?\n/);
    return {
      line: lines.length,
      col: lines[lines.length - 1].length + 1
    };
  }
  function getPositionFromMatch(match) {
    return match.startIndex + match[1].length;
  }
  var util2 = require_util();
  var defaultOptions2 = {
    allowBooleanAttributes: false,
    unpairedTags: []
  };
  exports.validate = function(xmlData, options) {
    options = Object.assign({}, defaultOptions2, options);
    const tags = [];
    let tagFound = false;
    let reachedRoot = false;
    if (xmlData[0] === "\uFEFF") {
      xmlData = xmlData.substr(1);
    }
    for (let i3 = 0;i3 < xmlData.length; i3++) {
      if (xmlData[i3] === "<" && xmlData[i3 + 1] === "?") {
        i3 += 2;
        i3 = readPI(xmlData, i3);
        if (i3.err)
          return i3;
      } else if (xmlData[i3] === "<") {
        let tagStartPos = i3;
        i3++;
        if (xmlData[i3] === "!") {
          i3 = readCommentAndCDATA(xmlData, i3);
          continue;
        } else {
          let closingTag = false;
          if (xmlData[i3] === "/") {
            closingTag = true;
            i3++;
          }
          let tagName = "";
          for (;i3 < xmlData.length && xmlData[i3] !== ">" && xmlData[i3] !== " " && xmlData[i3] !== "\t" && xmlData[i3] !== "\n" && xmlData[i3] !== "\r"; i3++) {
            tagName += xmlData[i3];
          }
          tagName = tagName.trim();
          if (tagName[tagName.length - 1] === "/") {
            tagName = tagName.substring(0, tagName.length - 1);
            i3--;
          }
          if (!validateTagName(tagName)) {
            let msg;
            if (tagName.trim().length === 0) {
              msg = "Invalid space after '<'.";
            } else {
              msg = "Tag '" + tagName + "' is an invalid name.";
            }
            return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i3));
          }
          const result = readAttributeStr(xmlData, i3);
          if (result === false) {
            return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i3));
          }
          let attrStr = result.value;
          i3 = result.index;
          if (attrStr[attrStr.length - 1] === "/") {
            const attrStrStart = i3 - attrStr.length;
            attrStr = attrStr.substring(0, attrStr.length - 1);
            const isValid2 = validateAttributeString(attrStr, options);
            if (isValid2 === true) {
              tagFound = true;
            } else {
              return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid2.err.line));
            }
          } else if (closingTag) {
            if (!result.tagClosed) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i3));
            } else if (attrStr.trim().length > 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
            } else if (tags.length === 0) {
              return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
            } else {
              const otg = tags.pop();
              if (tagName !== otg.tagName) {
                let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
              }
              if (tags.length == 0) {
                reachedRoot = true;
              }
            }
          } else {
            const isValid2 = validateAttributeString(attrStr, options);
            if (isValid2 !== true) {
              return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, i3 - attrStr.length + isValid2.err.line));
            }
            if (reachedRoot === true) {
              return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i3));
            } else if (options.unpairedTags.indexOf(tagName) !== -1) {
            } else {
              tags.push({ tagName, tagStartPos });
            }
            tagFound = true;
          }
          for (i3++;i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "<") {
              if (xmlData[i3 + 1] === "!") {
                i3++;
                i3 = readCommentAndCDATA(xmlData, i3);
                continue;
              } else if (xmlData[i3 + 1] === "?") {
                i3 = readPI(xmlData, ++i3);
                if (i3.err)
                  return i3;
              } else {
                break;
              }
            } else if (xmlData[i3] === "&") {
              const afterAmp = validateAmpersand(xmlData, i3);
              if (afterAmp == -1)
                return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i3));
              i3 = afterAmp;
            } else {
              if (reachedRoot === true && !isWhiteSpace(xmlData[i3])) {
                return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i3));
              }
            }
          }
          if (xmlData[i3] === "<") {
            i3--;
          }
        }
      } else {
        if (isWhiteSpace(xmlData[i3])) {
          continue;
        }
        return getErrorObject("InvalidChar", "char '" + xmlData[i3] + "' is not expected.", getLineNumberForPosition(xmlData, i3));
      }
    }
    if (!tagFound) {
      return getErrorObject("InvalidXml", "Start tag expected.", 1);
    } else if (tags.length == 1) {
      return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    } else if (tags.length > 0) {
      return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
    }
    return true;
  };
  var doubleQuote = '"';
  var singleQuote = "'";
  var validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', "g");
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS((exports) => {
  var defaultOptions2 = {
    preserveOrder: false,
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    removeNSPrefix: false,
    allowBooleanAttributes: false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true,
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [],
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs) {
      return tagName;
    }
  };
  var buildOptions = function(options) {
    return Object.assign({}, defaultOptions2, options);
  };
  exports.buildOptions = buildOptions;
  exports.defaultOptions = defaultOptions2;
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS((exports, module) => {
  class XmlNode {
    constructor(tagname) {
      this.tagname = tagname;
      this.child = [];
      this[":@"] = {};
    }
    add(key, val) {
      if (key === "__proto__")
        key = "#__proto__";
      this.child.push({ [key]: val });
    }
    addChild(node) {
      if (node.tagname === "__proto__")
        node.tagname = "#__proto__";
      if (node[":@"] && Object.keys(node[":@"]).length > 0) {
        this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
      } else {
        this.child.push({ [node.tagname]: node.child });
      }
    }
  }
  module.exports = XmlNode;
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS((exports, module) => {
  function readDocType(xmlData, i3) {
    const entities = {};
    if (xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "C" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "Y" && xmlData[i3 + 7] === "P" && xmlData[i3 + 8] === "E") {
      i3 = i3 + 9;
      let angleBracketsCount = 1;
      let hasBody = false, comment = false;
      let exp = "";
      for (;i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<" && !comment) {
          if (hasBody && isEntity(xmlData, i3)) {
            i3 += 7;
            let entityName, val;
            [entityName, val, i3] = readEntityExp(xmlData, i3 + 1);
            if (val.indexOf("&") === -1)
              entities[validateEntityName(entityName)] = {
                regx: RegExp(`&${entityName};`, "g"),
                val
              };
          } else if (hasBody && isElement(xmlData, i3))
            i3 += 8;
          else if (hasBody && isAttlist(xmlData, i3))
            i3 += 8;
          else if (hasBody && isNotation(xmlData, i3))
            i3 += 9;
          else if (isComment)
            comment = true;
          else
            throw new Error("Invalid DOCTYPE");
          angleBracketsCount++;
          exp = "";
        } else if (xmlData[i3] === ">") {
          if (comment) {
            if (xmlData[i3 - 1] === "-" && xmlData[i3 - 2] === "-") {
              comment = false;
              angleBracketsCount--;
            }
          } else {
            angleBracketsCount--;
          }
          if (angleBracketsCount === 0) {
            break;
          }
        } else if (xmlData[i3] === "[") {
          hasBody = true;
        } else {
          exp += xmlData[i3];
        }
      }
      if (angleBracketsCount !== 0) {
        throw new Error(`Unclosed DOCTYPE`);
      }
    } else {
      throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return { entities, i: i3 };
  }
  function readEntityExp(xmlData, i3) {
    let entityName = "";
    for (;i3 < xmlData.length && (xmlData[i3] !== "'" && xmlData[i3] !== '"'); i3++) {
      entityName += xmlData[i3];
    }
    entityName = entityName.trim();
    if (entityName.indexOf(" ") !== -1)
      throw new Error("External entites are not supported");
    const startChar = xmlData[i3++];
    let val = "";
    for (;i3 < xmlData.length && xmlData[i3] !== startChar; i3++) {
      val += xmlData[i3];
    }
    return [entityName, val, i3];
  }
  function isComment(xmlData, i3) {
    if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "-" && xmlData[i3 + 3] === "-")
      return true;
    return false;
  }
  function isEntity(xmlData, i3) {
    if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "N" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "I" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "Y")
      return true;
    return false;
  }
  function isElement(xmlData, i3) {
    if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "L" && xmlData[i3 + 4] === "E" && xmlData[i3 + 5] === "M" && xmlData[i3 + 6] === "E" && xmlData[i3 + 7] === "N" && xmlData[i3 + 8] === "T")
      return true;
    return false;
  }
  function isAttlist(xmlData, i3) {
    if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "A" && xmlData[i3 + 3] === "T" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "L" && xmlData[i3 + 6] === "I" && xmlData[i3 + 7] === "S" && xmlData[i3 + 8] === "T")
      return true;
    return false;
  }
  function isNotation(xmlData, i3) {
    if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "N" && xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "A" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "I" && xmlData[i3 + 8] === "O" && xmlData[i3 + 9] === "N")
      return true;
    return false;
  }
  function validateEntityName(name) {
    if (util2.isName(name))
      return name;
    else
      throw new Error(`Invalid entity name ${name}`);
  }
  var util2 = require_util();
  module.exports = readDocType;
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS((exports, module) => {
  function toNumber(str, options = {}) {
    options = Object.assign({}, consider, options);
    if (!str || typeof str !== "string")
      return str;
    let trimmedStr = str.trim();
    if (options.skipLike !== undefined && options.skipLike.test(trimmedStr))
      return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
      return Number.parseInt(trimmedStr, 16);
    } else {
      const match = numRegex.exec(trimmedStr);
      if (match) {
        const sign = match[1];
        const leadingZeros = match[2];
        let numTrimmedByZeros = trimZeros(match[3]);
        const eNotation = match[4] || match[6];
        if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
          return str;
        else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
          return str;
        else {
          const num = Number(trimmedStr);
          const numStr = "" + num;
          if (numStr.search(/[eE]/) !== -1) {
            if (options.eNotation)
              return num;
            else
              return str;
          } else if (eNotation) {
            if (options.eNotation)
              return num;
            else
              return str;
          } else if (trimmedStr.indexOf(".") !== -1) {
            if (numStr === "0" && numTrimmedByZeros === "")
              return num;
            else if (numStr === numTrimmedByZeros)
              return num;
            else if (sign && numStr === "-" + numTrimmedByZeros)
              return num;
            else
              return str;
          }
          if (leadingZeros) {
            if (numTrimmedByZeros === numStr)
              return num;
            else if (sign + numTrimmedByZeros === numStr)
              return num;
            else
              return str;
          }
          if (trimmedStr === numStr)
            return num;
          else if (trimmedStr === sign + numStr)
            return num;
          return str;
        }
      } else {
        return str;
      }
    }
  }
  function trimZeros(numStr) {
    if (numStr && numStr.indexOf(".") !== -1) {
      numStr = numStr.replace(/0+$/, "");
      if (numStr === ".")
        numStr = "0";
      else if (numStr[0] === ".")
        numStr = "0" + numStr;
      else if (numStr[numStr.length - 1] === ".")
        numStr = numStr.substr(0, numStr.length - 1);
      return numStr;
    }
    return numStr;
  }
  var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
  var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
  if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
  }
  if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
  }
  var consider = {
    hex: true,
    leadingZeros: true,
    decimalPoint: ".",
    eNotation: true
  };
  module.exports = toNumber;
});

// node_modules/fast-xml-parser/src/ignoreAttributes.js
var require_ignoreAttributes = __commonJS((exports, module) => {
  function getIgnoreAttributesFn(ignoreAttributes) {
    if (typeof ignoreAttributes === "function") {
      return ignoreAttributes;
    }
    if (Array.isArray(ignoreAttributes)) {
      return (attrName) => {
        for (const pattern3 of ignoreAttributes) {
          if (typeof pattern3 === "string" && attrName === pattern3) {
            return true;
          }
          if (pattern3 instanceof RegExp && pattern3.test(attrName)) {
            return true;
          }
        }
      };
    }
    return () => false;
  }
  module.exports = getIgnoreAttributesFn;
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS((exports, module) => {
  function addExternalEntities(externalEntities) {
    const entKeys = Object.keys(externalEntities);
    for (let i3 = 0;i3 < entKeys.length; i3++) {
      const ent = entKeys[i3];
      this.lastEntities[ent] = {
        regex: new RegExp("&" + ent + ";", "g"),
        val: externalEntities[ent]
      };
    }
  }
  function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
    if (val !== undefined) {
      if (this.options.trimValues && !dontTrim) {
        val = val.trim();
      }
      if (val.length > 0) {
        if (!escapeEntities)
          val = this.replaceEntitiesValue(val);
        const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
        if (newval === null || newval === undefined) {
          return val;
        } else if (typeof newval !== typeof val || newval !== val) {
          return newval;
        } else if (this.options.trimValues) {
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          const trimmedVal = val.trim();
          if (trimmedVal === val) {
            return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            return val;
          }
        }
      }
    }
  }
  function resolveNameSpace(tagname) {
    if (this.options.removeNSPrefix) {
      const tags = tagname.split(":");
      const prefix = tagname.charAt(0) === "/" ? "/" : "";
      if (tags[0] === "xmlns") {
        return "";
      }
      if (tags.length === 2) {
        tagname = prefix + tags[1];
      }
    }
    return tagname;
  }
  function buildAttributesMap(attrStr, jPath, tagName) {
    if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
      const matches = util2.getAllMatches(attrStr, attrsRegx);
      const len = matches.length;
      const attrs = {};
      for (let i3 = 0;i3 < len; i3++) {
        const attrName = this.resolveNameSpace(matches[i3][1]);
        if (this.ignoreAttributesFn(attrName, jPath)) {
          continue;
        }
        let oldVal = matches[i3][4];
        let aName = this.options.attributeNamePrefix + attrName;
        if (attrName.length) {
          if (this.options.transformAttributeName) {
            aName = this.options.transformAttributeName(aName);
          }
          if (aName === "__proto__")
            aName = "#__proto__";
          if (oldVal !== undefined) {
            if (this.options.trimValues) {
              oldVal = oldVal.trim();
            }
            oldVal = this.replaceEntitiesValue(oldVal);
            const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
            if (newVal === null || newVal === undefined) {
              attrs[aName] = oldVal;
            } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
              attrs[aName] = newVal;
            } else {
              attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
            }
          } else if (this.options.allowBooleanAttributes) {
            attrs[aName] = true;
          }
        }
      }
      if (!Object.keys(attrs).length) {
        return;
      }
      if (this.options.attributesGroupName) {
        const attrCollection = {};
        attrCollection[this.options.attributesGroupName] = attrs;
        return attrCollection;
      }
      return attrs;
    }
  }
  function addChild(currentNode, childNode, jPath) {
    const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
    if (result === false) {
    } else if (typeof result === "string") {
      childNode.tagname = result;
      currentNode.addChild(childNode);
    } else {
      currentNode.addChild(childNode);
    }
  }
  function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
    if (textData) {
      if (isLeafNode === undefined)
        isLeafNode = Object.keys(currentNode.child).length === 0;
      textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
      if (textData !== undefined && textData !== "")
        currentNode.add(this.options.textNodeName, textData);
      textData = "";
    }
    return textData;
  }
  function isItStopNode(stopNodes, jPath, currentTagName) {
    const allNodesExp = "*." + currentTagName;
    for (const stopNodePath in stopNodes) {
      const stopNodeExp = stopNodes[stopNodePath];
      if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
        return true;
    }
    return false;
  }
  function tagExpWithClosingIndex(xmlData, i3, closingChar = ">") {
    let attrBoundary;
    let tagExp = "";
    for (let index = i3;index < xmlData.length; index++) {
      let ch = xmlData[index];
      if (attrBoundary) {
        if (ch === attrBoundary)
          attrBoundary = "";
      } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
      } else if (ch === closingChar[0]) {
        if (closingChar[1]) {
          if (xmlData[index + 1] === closingChar[1]) {
            return {
              data: tagExp,
              index
            };
          }
        } else {
          return {
            data: tagExp,
            index
          };
        }
      } else if (ch === "\t") {
        ch = " ";
      }
      tagExp += ch;
    }
  }
  function findClosingIndex(xmlData, str, i3, errMsg) {
    const closingIndex = xmlData.indexOf(str, i3);
    if (closingIndex === -1) {
      throw new Error(errMsg);
    } else {
      return closingIndex + str.length - 1;
    }
  }
  function readTagExp(xmlData, i3, removeNSPrefix, closingChar = ">") {
    const result = tagExpWithClosingIndex(xmlData, i3 + 1, closingChar);
    if (!result)
      return;
    let tagExp = result.data;
    const closeIndex = result.index;
    const separatorIndex = tagExp.search(/\s/);
    let tagName = tagExp;
    let attrExpPresent = true;
    if (separatorIndex !== -1) {
      tagName = tagExp.substring(0, separatorIndex);
      tagExp = tagExp.substring(separatorIndex + 1).trimStart();
    }
    const rawTagName = tagName;
    if (removeNSPrefix) {
      const colonIndex = tagName.indexOf(":");
      if (colonIndex !== -1) {
        tagName = tagName.substr(colonIndex + 1);
        attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
      }
    }
    return {
      tagName,
      tagExp,
      closeIndex,
      attrExpPresent,
      rawTagName
    };
  }
  function readStopNodeData(xmlData, tagName, i3) {
    const startIndex = i3;
    let openTagCount = 1;
    for (;i3 < xmlData.length; i3++) {
      if (xmlData[i3] === "<") {
        if (xmlData[i3 + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i3, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i3 + 2, closeIndex).trim();
          if (closeTagName === tagName) {
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i3),
                i: closeIndex
              };
            }
          }
          i3 = closeIndex;
        } else if (xmlData[i3 + 1] === "?") {
          const closeIndex = findClosingIndex(xmlData, "?>", i3 + 1, "StopNode is not closed.");
          i3 = closeIndex;
        } else if (xmlData.substr(i3 + 1, 3) === "!--") {
          const closeIndex = findClosingIndex(xmlData, "-->", i3 + 3, "StopNode is not closed.");
          i3 = closeIndex;
        } else if (xmlData.substr(i3 + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i3, "StopNode is not closed.") - 2;
          i3 = closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i3, ">");
          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
              openTagCount++;
            }
            i3 = tagData.closeIndex;
          }
        }
      }
    }
  }
  function parseValue(val, shouldParse, options) {
    if (shouldParse && typeof val === "string") {
      const newval = val.trim();
      if (newval === "true")
        return true;
      else if (newval === "false")
        return false;
      else
        return toNumber(val, options);
    } else {
      if (util2.isExist(val)) {
        return val;
      } else {
        return "";
      }
    }
  }
  var util2 = require_util();
  var xmlNode = require_xmlNode();
  var readDocType = require_DocTypeReader();
  var toNumber = require_strnum();
  var getIgnoreAttributesFn = require_ignoreAttributes();

  class OrderedObjParser {
    constructor(options) {
      this.options = options;
      this.currentNode = null;
      this.tagsNodeStack = [];
      this.docTypeEntities = {};
      this.lastEntities = {
        apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
        gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
        lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
        quot: { regex: /&(quot|#34|#x22);/g, val: "\"" }
      };
      this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
      this.htmlEntities = {
        space: { regex: /&(nbsp|#160);/g, val: " " },
        cent: { regex: /&(cent|#162);/g, val: "\xA2" },
        pound: { regex: /&(pound|#163);/g, val: "\xA3" },
        yen: { regex: /&(yen|#165);/g, val: "\xA5" },
        euro: { regex: /&(euro|#8364);/g, val: "\u20AC" },
        copyright: { regex: /&(copy|#169);/g, val: "\xA9" },
        reg: { regex: /&(reg|#174);/g, val: "\xAE" },
        inr: { regex: /&(inr|#8377);/g, val: "\u20B9" },
        num_dec: { regex: /&#([0-9]{1,7});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
        num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 16)) }
      };
      this.addExternalEntities = addExternalEntities;
      this.parseXml = parseXml;
      this.parseTextData = parseTextData;
      this.resolveNameSpace = resolveNameSpace;
      this.buildAttributesMap = buildAttributesMap;
      this.isItStopNode = isItStopNode;
      this.replaceEntitiesValue = replaceEntitiesValue;
      this.readStopNodeData = readStopNodeData;
      this.saveTextToParentTag = saveTextToParentTag;
      this.addChild = addChild;
      this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
    }
  }
  var attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', "gm");
  var parseXml = function(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new xmlNode("!xml");
    let currentNode = xmlObj;
    let textData = "";
    let jPath = "";
    for (let i3 = 0;i3 < xmlData.length; i3++) {
      const ch = xmlData[i3];
      if (ch === "<") {
        if (xmlData[i3 + 1] === "/") {
          const closeIndex = findClosingIndex(xmlData, ">", i3, "Closing Tag is not closed.");
          let tagName = xmlData.substring(i3 + 2, closeIndex).trim();
          if (this.options.removeNSPrefix) {
            const colonIndex = tagName.indexOf(":");
            if (colonIndex !== -1) {
              tagName = tagName.substr(colonIndex + 1);
            }
          }
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode) {
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
          }
          const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
          if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
            throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
          }
          let propIndex = 0;
          if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
            propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
            this.tagsNodeStack.pop();
          } else {
            propIndex = jPath.lastIndexOf(".");
          }
          jPath = jPath.substring(0, propIndex);
          currentNode = this.tagsNodeStack.pop();
          textData = "";
          i3 = closeIndex;
        } else if (xmlData[i3 + 1] === "?") {
          let tagData = readTagExp(xmlData, i3, false, "?>");
          if (!tagData)
            throw new Error("Pi Tag is not closed.");
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
          } else {
            const childNode = new xmlNode(tagData.tagName);
            childNode.add(this.options.textNodeName, "");
            if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
            }
            this.addChild(currentNode, childNode, jPath);
          }
          i3 = tagData.closeIndex + 1;
        } else if (xmlData.substr(i3 + 1, 3) === "!--") {
          const endIndex = findClosingIndex(xmlData, "-->", i3 + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const comment = xmlData.substring(i3 + 4, endIndex - 2);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
          }
          i3 = endIndex;
        } else if (xmlData.substr(i3 + 1, 2) === "!D") {
          const result = readDocType(xmlData, i3);
          this.docTypeEntities = result.entities;
          i3 = result.i;
        } else if (xmlData.substr(i3 + 1, 2) === "![") {
          const closeIndex = findClosingIndex(xmlData, "]]>", i3, "CDATA is not closed.") - 2;
          const tagExp = xmlData.substring(i3 + 9, closeIndex);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
          if (val == undefined)
            val = "";
          if (this.options.cdataPropName) {
            currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
          } else {
            currentNode.add(this.options.textNodeName, val);
          }
          i3 = closeIndex + 2;
        } else {
          let result = readTagExp(xmlData, i3, this.options.removeNSPrefix);
          let tagName = result.tagName;
          const rawTagName = result.rawTagName;
          let tagExp = result.tagExp;
          let attrExpPresent = result.attrExpPresent;
          let closeIndex = result.closeIndex;
          if (this.options.transformTagName) {
            tagName = this.options.transformTagName(tagName);
          }
          if (currentNode && textData) {
            if (currentNode.tagname !== "!xml") {
              textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
            }
          }
          const lastTag = currentNode;
          if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
            currentNode = this.tagsNodeStack.pop();
            jPath = jPath.substring(0, jPath.lastIndexOf("."));
          }
          if (tagName !== xmlObj.tagname) {
            jPath += jPath ? "." + tagName : tagName;
          }
          if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
            let tagContent = "";
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              i3 = result.closeIndex;
            } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
              i3 = result.closeIndex;
            } else {
              const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
              if (!result2)
                throw new Error(`Unexpected end of ${rawTagName}`);
              i3 = result2.i;
              tagContent = result2.tagContent;
            }
            const childNode = new xmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            if (tagContent) {
              tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            childNode.add(this.options.textNodeName, tagContent);
            this.addChild(currentNode, childNode, jPath);
          } else {
            if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substr(0, tagName.length - 1);
                jPath = jPath.substr(0, jPath.length - 1);
                tagExp = tagName;
              } else {
                tagExp = tagExp.substr(0, tagExp.length - 1);
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
            } else {
              const childNode = new xmlNode(tagName);
              this.tagsNodeStack.push(currentNode);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              this.addChild(currentNode, childNode, jPath);
              currentNode = childNode;
            }
            textData = "";
            i3 = closeIndex;
          }
        }
      } else {
        textData += xmlData[i3];
      }
    }
    return xmlObj.child;
  };
  var replaceEntitiesValue = function(val) {
    if (this.options.processEntities) {
      for (let entityName in this.docTypeEntities) {
        const entity = this.docTypeEntities[entityName];
        val = val.replace(entity.regx, entity.val);
      }
      for (let entityName in this.lastEntities) {
        const entity = this.lastEntities[entityName];
        val = val.replace(entity.regex, entity.val);
      }
      if (this.options.htmlEntities) {
        for (let entityName in this.htmlEntities) {
          const entity = this.htmlEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
      }
      val = val.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return val;
  };
  module.exports = OrderedObjParser;
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS((exports) => {
  function prettify(node, options) {
    return compress(node, options);
  }
  function compress(arr, options, jPath) {
    let text;
    const compressedObj = {};
    for (let i3 = 0;i3 < arr.length; i3++) {
      const tagObj = arr[i3];
      const property = propName(tagObj);
      let newJpath = "";
      if (jPath === undefined)
        newJpath = property;
      else
        newJpath = jPath + "." + property;
      if (property === options.textNodeName) {
        if (text === undefined)
          text = tagObj[property];
        else
          text += "" + tagObj[property];
      } else if (property === undefined) {
        continue;
      } else if (tagObj[property]) {
        let val = compress(tagObj[property], options, newJpath);
        const isLeaf = isLeafTag(val, options);
        if (tagObj[":@"]) {
          assignAttributes(val, tagObj[":@"], newJpath, options);
        } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {
          val = val[options.textNodeName];
        } else if (Object.keys(val).length === 0) {
          if (options.alwaysCreateTextNode)
            val[options.textNodeName] = "";
          else
            val = "";
        }
        if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
          if (!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [compressedObj[property]];
          }
          compressedObj[property].push(val);
        } else {
          if (options.isArray(property, newJpath, isLeaf)) {
            compressedObj[property] = [val];
          } else {
            compressedObj[property] = val;
          }
        }
      }
    }
    if (typeof text === "string") {
      if (text.length > 0)
        compressedObj[options.textNodeName] = text;
    } else if (text !== undefined)
      compressedObj[options.textNodeName] = text;
    return compressedObj;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i3 = 0;i3 < keys.length; i3++) {
      const key = keys[i3];
      if (key !== ":@")
        return key;
    }
  }
  function assignAttributes(obj, attrMap, jpath, options) {
    if (attrMap) {
      const keys = Object.keys(attrMap);
      const len = keys.length;
      for (let i3 = 0;i3 < len; i3++) {
        const atrrName = keys[i3];
        if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
          obj[atrrName] = [attrMap[atrrName]];
        } else {
          obj[atrrName] = attrMap[atrrName];
        }
      }
    }
  }
  function isLeafTag(obj, options) {
    const { textNodeName } = options;
    const propCount = Object.keys(obj).length;
    if (propCount === 0) {
      return true;
    }
    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
      return true;
    }
    return false;
  }
  exports.prettify = prettify;
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS((exports, module) => {
  var { buildOptions } = require_OptionsBuilder();
  var OrderedObjParser = require_OrderedObjParser();
  var { prettify } = require_node2json();
  var validator = require_validator();

  class XMLParser {
    constructor(options) {
      this.externalEntities = {};
      this.options = buildOptions(options);
    }
    parse(xmlData, validationOption) {
      if (typeof xmlData === "string") {
      } else if (xmlData.toString) {
        xmlData = xmlData.toString();
      } else {
        throw new Error("XML data is accepted in String or Bytes[] form.");
      }
      if (validationOption) {
        if (validationOption === true)
          validationOption = {};
        const result = validator.validate(xmlData, validationOption);
        if (result !== true) {
          throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
        }
      }
      const orderedObjParser = new OrderedObjParser(this.options);
      orderedObjParser.addExternalEntities(this.externalEntities);
      const orderedResult = orderedObjParser.parseXml(xmlData);
      if (this.options.preserveOrder || orderedResult === undefined)
        return orderedResult;
      else
        return prettify(orderedResult, this.options);
    }
    addEntity(key, value15) {
      if (value15.indexOf("&") !== -1) {
        throw new Error("Entity value can't have '&'");
      } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      } else if (value15 === "&") {
        throw new Error("An entity with value '&' is not permitted");
      } else {
        this.externalEntities[key] = value15;
      }
    }
  }
  module.exports = XMLParser;
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS((exports, module) => {
  function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
      indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
  }
  function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;
    for (let i3 = 0;i3 < arr.length; i3++) {
      const tagObj = arr[i3];
      const tagName = propName(tagObj);
      if (tagName === undefined)
        continue;
      let newJPath = "";
      if (jPath.length === 0)
        newJPath = tagName;
      else
        newJPath = `${jPath}.${tagName}`;
      if (tagName === options.textNodeName) {
        let tagText = tagObj[tagName];
        if (!isStopNode(newJPath, options)) {
          tagText = options.tagValueProcessor(tagName, tagText);
          tagText = replaceEntitiesValue(tagText, options);
        }
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += tagText;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options.cdataPropName) {
        if (isPreviousElementTag) {
          xmlStr += indentation;
        }
        xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
        isPreviousElementTag = false;
        continue;
      } else if (tagName === options.commentPropName) {
        xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
        isPreviousElementTag = true;
        continue;
      } else if (tagName[0] === "?") {
        const attStr2 = attr_to_str(tagObj[":@"], options);
        const tempInd = tagName === "?xml" ? "" : indentation;
        let piTextNodeName = tagObj[tagName][0][options.textNodeName];
        piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
        xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
        isPreviousElementTag = true;
        continue;
      }
      let newIdentation = indentation;
      if (newIdentation !== "") {
        newIdentation += options.indentBy;
      }
      const attStr = attr_to_str(tagObj[":@"], options);
      const tagStart = indentation + `<${tagName}${attStr}`;
      const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
      if (options.unpairedTags.indexOf(tagName) !== -1) {
        if (options.suppressUnpairedNode)
          xmlStr += tagStart + ">";
        else
          xmlStr += tagStart + "/>";
      } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
        xmlStr += tagStart + "/>";
      } else if (tagValue && tagValue.endsWith(">")) {
        xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
      } else {
        xmlStr += tagStart + ">";
        if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
          xmlStr += indentation + options.indentBy + tagValue + indentation;
        } else {
          xmlStr += tagValue;
        }
        xmlStr += `</${tagName}>`;
      }
      isPreviousElementTag = true;
    }
    return xmlStr;
  }
  function propName(obj) {
    const keys = Object.keys(obj);
    for (let i3 = 0;i3 < keys.length; i3++) {
      const key = keys[i3];
      if (!obj.hasOwnProperty(key))
        continue;
      if (key !== ":@")
        return key;
    }
  }
  function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
      for (let attr in attrMap) {
        if (!attrMap.hasOwnProperty(attr))
          continue;
        let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
        attrVal = replaceEntitiesValue(attrVal, options);
        if (attrVal === true && options.suppressBooleanAttributes) {
          attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
        } else {
          attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
        }
      }
    }
    return attrStr;
  }
  function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
      if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
        return true;
    }
    return false;
  }
  function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
      for (let i3 = 0;i3 < options.entities.length; i3++) {
        const entity = options.entities[i3];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  }
  var EOL = "\n";
  module.exports = toXml;
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS((exports, module) => {
  function Builder(options) {
    this.options = Object.assign({}, defaultOptions2, options);
    if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
      this.isAttribute = function() {
        return false;
      };
    } else {
      this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
      this.attrPrefixLen = this.options.attributeNamePrefix.length;
      this.isAttribute = isAttribute;
    }
    this.processTextOrObjNode = processTextOrObjNode;
    if (this.options.format) {
      this.indentate = indentate;
      this.tagEndChar = ">\n";
      this.newLine = "\n";
    } else {
      this.indentate = function() {
        return "";
      };
      this.tagEndChar = ">";
      this.newLine = "";
    }
  }
  function processTextOrObjNode(object13, key, level, ajPath) {
    const result = this.j2x(object13, level + 1, ajPath.concat(key));
    if (object13[this.options.textNodeName] !== undefined && Object.keys(object13).length === 1) {
      return this.buildTextValNode(object13[this.options.textNodeName], key, result.attrStr, level);
    } else {
      return this.buildObjectNode(result.val, key, result.attrStr, level);
    }
  }
  function indentate(level) {
    return this.options.indentBy.repeat(level);
  }
  function isAttribute(name) {
    if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
      return name.substr(this.attrPrefixLen);
    } else {
      return false;
    }
  }
  var buildFromOrderedJs = require_orderedJs2Xml();
  var getIgnoreAttributesFn = require_ignoreAttributes();
  var defaultOptions2 = {
    attributeNamePrefix: "@_",
    attributesGroupName: false,
    textNodeName: "#text",
    ignoreAttributes: true,
    cdataPropName: false,
    format: false,
    indentBy: "  ",
    suppressEmptyNode: false,
    suppressUnpairedNode: true,
    suppressBooleanAttributes: true,
    tagValueProcessor: function(key, a) {
      return a;
    },
    attributeValueProcessor: function(attrName, a) {
      return a;
    },
    preserveOrder: false,
    commentPropName: false,
    unpairedTags: [],
    entities: [
      { regex: new RegExp("&", "g"), val: "&amp;" },
      { regex: new RegExp(">", "g"), val: "&gt;" },
      { regex: new RegExp("<", "g"), val: "&lt;" },
      { regex: new RegExp("\'", "g"), val: "&apos;" },
      { regex: new RegExp("\"", "g"), val: "&quot;" }
    ],
    processEntities: true,
    stopNodes: [],
    oneListGroup: false
  };
  Builder.prototype.build = function(jObj) {
    if (this.options.preserveOrder) {
      return buildFromOrderedJs(jObj, this.options);
    } else {
      if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
        jObj = {
          [this.options.arrayNodeName]: jObj
        };
      }
      return this.j2x(jObj, 0, []).val;
    }
  };
  Builder.prototype.j2x = function(jObj, level, ajPath) {
    let attrStr = "";
    let val = "";
    const jPath = ajPath.join(".");
    for (let key in jObj) {
      if (!Object.prototype.hasOwnProperty.call(jObj, key))
        continue;
      if (typeof jObj[key] === "undefined") {
        if (this.isAttribute(key)) {
          val += "";
        }
      } else if (jObj[key] === null) {
        if (this.isAttribute(key)) {
          val += "";
        } else if (key[0] === "?") {
          val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
        } else {
          val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        }
      } else if (jObj[key] instanceof Date) {
        val += this.buildTextValNode(jObj[key], key, "", level);
      } else if (typeof jObj[key] !== "object") {
        const attr = this.isAttribute(key);
        if (attr && !this.ignoreAttributesFn(attr, jPath)) {
          attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
        } else if (!attr) {
          if (key === this.options.textNodeName) {
            let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
            val += this.replaceEntitiesValue(newval);
          } else {
            val += this.buildTextValNode(jObj[key], key, "", level);
          }
        }
      } else if (Array.isArray(jObj[key])) {
        const arrLen = jObj[key].length;
        let listTagVal = "";
        let listTagAttr = "";
        for (let j = 0;j < arrLen; j++) {
          const item = jObj[key][j];
          if (typeof item === "undefined") {
          } else if (item === null) {
            if (key[0] === "?")
              val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (typeof item === "object") {
            if (this.options.oneListGroup) {
              const result = this.j2x(item, level + 1, ajPath.concat(key));
              listTagVal += result.val;
              if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                listTagAttr += result.attrStr;
              }
            } else {
              listTagVal += this.processTextOrObjNode(item, key, level, ajPath);
            }
          } else {
            if (this.options.oneListGroup) {
              let textValue = this.options.tagValueProcessor(key, item);
              textValue = this.replaceEntitiesValue(textValue);
              listTagVal += textValue;
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
        }
        if (this.options.oneListGroup) {
          listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
        }
        val += listTagVal;
      } else {
        if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
          const Ks = Object.keys(jObj[key]);
          const L = Ks.length;
          for (let j = 0;j < L; j++) {
            attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
          }
        } else {
          val += this.processTextOrObjNode(jObj[key], key, level, ajPath);
        }
      }
    }
    return { attrStr, val };
  };
  Builder.prototype.buildAttrPairStr = function(attrName, val) {
    val = this.options.attributeValueProcessor(attrName, "" + val);
    val = this.replaceEntitiesValue(val);
    if (this.options.suppressBooleanAttributes && val === "true") {
      return " " + attrName;
    } else
      return " " + attrName + '="' + val + '"';
  };
  Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
    if (val === "") {
      if (key[0] === "?")
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      else {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      }
    } else {
      let tagEndExp = "</" + key + this.tagEndChar;
      let piClosingChar = "";
      if (key[0] === "?") {
        piClosingChar = "?";
        tagEndExp = "";
      }
      if ((attrStr || attrStr === "") && val.indexOf("<") === -1) {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else {
        return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
      }
    }
  };
  Builder.prototype.closeTag = function(key) {
    let closeTag = "";
    if (this.options.unpairedTags.indexOf(key) !== -1) {
      if (!this.options.suppressUnpairedNode)
        closeTag = "/";
    } else if (this.options.suppressEmptyNode) {
      closeTag = "/";
    } else {
      closeTag = `></${key}`;
    }
    return closeTag;
  };
  Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
    if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
      return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    } else if (key[0] === "?") {
      return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    } else {
      let textValue = this.options.tagValueProcessor(key, val);
      textValue = this.replaceEntitiesValue(textValue);
      if (textValue === "") {
        return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
      } else {
        return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
      }
    }
  };
  Builder.prototype.replaceEntitiesValue = function(textValue) {
    if (textValue && textValue.length > 0 && this.options.processEntities) {
      for (let i3 = 0;i3 < this.options.entities.length; i3++) {
        const entity = this.options.entities[i3];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  };
  module.exports = Builder;
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS((exports, module) => {
  var validator = require_validator();
  var XMLParser = require_XMLParser();
  var XMLBuilder = require_json2xml();
  module.exports = {
    XMLParser,
    XMLValidator: validator,
    XMLBuilder
  };
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS((exports, module) => {
  (function(root) {
    const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    const ipv4Regexes = {
      fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\$`, "i"),
      threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\$`, "i"),
      twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\$`, "i"),
      longValue: new RegExp(`^${ipv4Part}\$`, "i")
    };
    const octalRegex = new RegExp(`^0[0-7]+\$`, "i");
    const hexRegex = new RegExp(`^0x[a-f0-9]+\$`, "i");
    const zoneIndex = "%[0-9a-z]{1,}";
    const ipv6Part = "(?:[0-9a-f]+::?)+";
    const ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      native: new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?\$`, "i"),
      deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)\$`, "i"),
      transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?\$`, "i")
    };
    function expandIPv6(string7, parts) {
      if (string7.indexOf("::") !== string7.lastIndexOf("::")) {
        return null;
      }
      let colonCount = 0;
      let lastColon = -1;
      let zoneId = (string7.match(ipv6Regexes.zoneIndex) || [])[0];
      let replacement, replacementCount;
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string7 = string7.replace(/%.+$/, "");
      }
      while ((lastColon = string7.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string7.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string7.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string7 = string7.replace("::", replacement);
      if (string7[0] === ":") {
        string7 = string7.slice(1);
      }
      if (string7[string7.length - 1] === ":") {
        string7 = string7.slice(0, -1);
      }
      parts = function() {
        const ref4 = string7.split(":");
        const results = [];
        for (let i3 = 0;i3 < ref4.length; i3++) {
          results.push(parseInt(ref4[i3], 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    }
    function matchCIDR(first, second, partSize, cidrBits) {
      if (first.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      let part = 0;
      let shift;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    }
    function parseIntAuto(string7) {
      if (hexRegex.test(string7)) {
        return parseInt(string7, 16);
      }
      if (string7[0] === "0" && !isNaN(parseInt(string7[1], 10))) {
        if (octalRegex.test(string7)) {
          return parseInt(string7, 8);
        }
        throw new Error(`ipaddr: cannot parse ${string7} as octal`);
      }
      return parseInt(string7, 10);
    }
    function padPart(part, length) {
      while (part.length < length) {
        part = `0${part}`;
      }
      return part;
    }
    const ipaddr = {};
    ipaddr.IPv4 = function() {
      function IPv4(octets) {
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        let i3, octet;
        for (i3 = 0;i3 < octets.length; i3++) {
          octet = octets[i3];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        private: [
          [new IPv4([10, 0, 0, 0]), 8],
          [new IPv4([172, 16, 0, 0]), 12],
          [new IPv4([192, 168, 0, 0]), 16]
        ],
        reserved: [
          [new IPv4([192, 0, 0, 0]), 24],
          [new IPv4([192, 0, 2, 0]), 24],
          [new IPv4([192, 88, 99, 0]), 24],
          [new IPv4([198, 18, 0, 0]), 15],
          [new IPv4([198, 51, 100, 0]), 24],
          [new IPv4([203, 0, 113, 0]), 24],
          [new IPv4([240, 0, 0, 0]), 4]
        ],
        as112: [
          [new IPv4([192, 175, 48, 0]), 24],
          [new IPv4([192, 31, 196, 0]), 24]
        ],
        amt: [
          [new IPv4([192, 52, 193, 0]), 24]
        ]
      };
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.match = function(other, cidrRange) {
        let ref4;
        if (cidrRange === undefined) {
          ref4 = other;
          other = ref4[0];
          cidrRange = ref4[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        let cidr = 0;
        let stop = false;
        const zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        let i3, octet, zeros;
        for (i3 = 3;i3 >= 0; i3 -= 1) {
          octet = this.octets[i3];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      IPv4.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      return IPv4;
    }();
    ipaddr.IPv4.broadcastAddressFromCIDR = function(string7) {
      try {
        const cidr = this.parseCIDR(string7);
        const ipInterfaceOctets = cidr[0].toByteArray();
        const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        const octets = [];
        let i3 = 0;
        while (i3 < 4) {
          octets.push(parseInt(ipInterfaceOctets[i3], 10) | parseInt(subnetMaskOctets[i3], 10) ^ 255);
          i3++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv4.isIPv4 = function(string7) {
      return this.parser(string7) !== null;
    };
    ipaddr.IPv4.isValid = function(string7) {
      try {
        new this(this.parser(string7));
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv4.isValidCIDR = function(string7) {
      try {
        this.parseCIDR(string7);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv4.isValidFourPartDecimal = function(string7) {
      if (ipaddr.IPv4.isValid(string7) && string7.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr.IPv4.networkAddressFromCIDR = function(string7) {
      let cidr, i3, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string7);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i3 = 0;
        while (i3 < 4) {
          octets.push(parseInt(ipInterfaceOctets[i3], 10) & parseInt(subnetMaskOctets[i3], 10));
          i3++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv4.parse = function(string7) {
      const parts = this.parser(string7);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like an IPv4 Address");
      }
      return new this(parts);
    };
    ipaddr.IPv4.parseCIDR = function(string7) {
      let match;
      if (match = string7.match(/^(.+)\/(\d+)$/)) {
        const maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          const parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr.IPv4.parser = function(string7) {
      let match, part, value15;
      if (match = string7.match(ipv4Regexes.fourOctet)) {
        return function() {
          const ref4 = match.slice(1, 6);
          const results = [];
          for (let i3 = 0;i3 < ref4.length; i3++) {
            part = ref4[i3];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match = string7.match(ipv4Regexes.longValue)) {
        value15 = parseIntAuto(match[1]);
        if (value15 > 4294967295 || value15 < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          const results = [];
          let shift;
          for (shift = 0;shift <= 24; shift += 8) {
            results.push(value15 >> shift & 255);
          }
          return results;
        }().reverse();
      } else if (match = string7.match(ipv4Regexes.twoOctet)) {
        return function() {
          const ref4 = match.slice(1, 4);
          const results = [];
          value15 = parseIntAuto(ref4[1]);
          if (value15 > 16777215 || value15 < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          results.push(parseIntAuto(ref4[0]));
          results.push(value15 >> 16 & 255);
          results.push(value15 >> 8 & 255);
          results.push(value15 & 255);
          return results;
        }();
      } else if (match = string7.match(ipv4Regexes.threeOctet)) {
        return function() {
          const ref4 = match.slice(1, 5);
          const results = [];
          value15 = parseIntAuto(ref4[2]);
          if (value15 > 65535 || value15 < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          results.push(parseIntAuto(ref4[0]));
          results.push(parseIntAuto(ref4[1]));
          results.push(value15 >> 8 & 255);
          results.push(value15 & 255);
          return results;
        }();
      } else {
        return null;
      }
    };
    ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      const octets = [0, 0, 0, 0];
      let j = 0;
      const filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr.IPv6 = function() {
      function IPv6(parts, zoneId) {
        let i3, part;
        if (parts.length === 16) {
          this.parts = [];
          for (i3 = 0;i3 <= 14; i3 += 2) {
            this.parts.push(parts[i3] << 8 | parts[i3 + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        for (i3 = 0;i3 < this.parts.length; i3++) {
          part = this.parts[i3];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        discard: [new IPv6([256, 0, 0, 0, 0, 0, 0, 0]), 64],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
        amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
        as112v6: [
          [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          [new IPv6([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
        ],
        deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
        orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
        droneRemoteIdProtocolEntityTags: [new IPv6([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
        reserved: [
          [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
          [new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
        ]
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.match = function(other, cidrRange) {
        let ref4;
        if (cidrRange === undefined) {
          ref4 = other;
          other = ref4[0];
          cidrRange = ref4[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        let cidr = 0;
        let stop = false;
        const zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        let part, zeros;
        for (let i3 = 7;i3 >= 0; i3 -= 1) {
          part = this.parts[i3];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      IPv6.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.toByteArray = function() {
        let part;
        const bytes2 = [];
        const ref4 = this.parts;
        for (let i3 = 0;i3 < ref4.length; i3++) {
          part = ref4[i3];
          bytes2.push(part >> 8);
          bytes2.push(part & 255);
        }
        return bytes2;
      };
      IPv6.prototype.toFixedLengthString = function() {
        const addr = function() {
          const results = [];
          for (let i3 = 0;i3 < this.parts.length; i3++) {
            results.push(padPart(this.parts[i3].toString(16), 4));
          }
          return results;
        }.call(this).join(":");
        let suffix = "";
        if (this.zoneId) {
          suffix = `%${this.zoneId}`;
        }
        return addr + suffix;
      };
      IPv6.prototype.toIPv4Address = function() {
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        const ref4 = this.parts.slice(-2);
        const high = ref4[0];
        const low = ref4[1];
        return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.toNormalizedString = function() {
        const addr = function() {
          const results = [];
          for (let i3 = 0;i3 < this.parts.length; i3++) {
            results.push(this.parts[i3].toString(16));
          }
          return results;
        }.call(this).join(":");
        let suffix = "";
        if (this.zoneId) {
          suffix = `%${this.zoneId}`;
        }
        return addr + suffix;
      };
      IPv6.prototype.toRFC5952String = function() {
        const regex = /((^|:)(0(:|$)){2,})/g;
        const string7 = this.toNormalizedString();
        let bestMatchIndex = 0;
        let bestMatchLength = -1;
        let match;
        while (match = regex.exec(string7)) {
          if (match[0].length > bestMatchLength) {
            bestMatchIndex = match.index;
            bestMatchLength = match[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string7;
        }
        return `${string7.substring(0, bestMatchIndex)}::${string7.substring(bestMatchIndex + bestMatchLength)}`;
      };
      IPv6.prototype.toString = function() {
        return this.toRFC5952String();
      };
      return IPv6;
    }();
    ipaddr.IPv6.broadcastAddressFromCIDR = function(string7) {
      try {
        const cidr = this.parseCIDR(string7);
        const ipInterfaceOctets = cidr[0].toByteArray();
        const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        const octets = [];
        let i3 = 0;
        while (i3 < 16) {
          octets.push(parseInt(ipInterfaceOctets[i3], 10) | parseInt(subnetMaskOctets[i3], 10) ^ 255);
          i3++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
      }
    };
    ipaddr.IPv6.isIPv6 = function(string7) {
      return this.parser(string7) !== null;
    };
    ipaddr.IPv6.isValid = function(string7) {
      if (typeof string7 === "string" && string7.indexOf(":") === -1) {
        return false;
      }
      try {
        const addr = this.parser(string7);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv6.isValidCIDR = function(string7) {
      if (typeof string7 === "string" && string7.indexOf(":") === -1) {
        return false;
      }
      try {
        this.parseCIDR(string7);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv6.networkAddressFromCIDR = function(string7) {
      let cidr, i3, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string7);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i3 = 0;
        while (i3 < 16) {
          octets.push(parseInt(ipInterfaceOctets[i3], 10) & parseInt(subnetMaskOctets[i3], 10));
          i3++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
      }
    };
    ipaddr.IPv6.parse = function(string7) {
      const addr = this.parser(string7);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like an IPv6 Address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr.IPv6.parseCIDR = function(string7) {
      let maskLength, match, parsed;
      if (match = string7.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr.IPv6.parser = function(string7) {
      let addr, i3, match, octet, octets, zoneId;
      if (match = string7.match(ipv6Regexes.deprecatedTransitional)) {
        return this.parser(`::ffff:${match[1]}`);
      }
      if (ipv6Regexes.native.test(string7)) {
        return expandIPv6(string7, 8);
      }
      if (match = string7.match(ipv6Regexes.transitional)) {
        zoneId = match[6] || "";
        addr = match[1];
        if (!match[1].endsWith("::")) {
          addr = addr.slice(0, -1);
        }
        addr = expandIPv6(addr + zoneId, 6);
        if (addr.parts) {
          octets = [
            parseInt(match[2]),
            parseInt(match[3]),
            parseInt(match[4]),
            parseInt(match[5])
          ];
          for (i3 = 0;i3 < octets.length; i3++) {
            octet = octets[i3];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 128) {
        throw new Error("ipaddr: invalid IPv6 prefix length");
      }
      const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      let j = 0;
      const filledOctetCount = Math.floor(prefix / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 16) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr.fromByteArray = function(bytes2) {
      const length = bytes2.length;
      if (length === 4) {
        return new ipaddr.IPv4(bytes2);
      } else if (length === 16) {
        return new ipaddr.IPv6(bytes2);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr.isValid = function(string7) {
      return ipaddr.IPv6.isValid(string7) || ipaddr.IPv4.isValid(string7);
    };
    ipaddr.isValidCIDR = function(string7) {
      return ipaddr.IPv6.isValidCIDR(string7) || ipaddr.IPv4.isValidCIDR(string7);
    };
    ipaddr.parse = function(string7) {
      if (ipaddr.IPv6.isValid(string7)) {
        return ipaddr.IPv6.parse(string7);
      } else if (ipaddr.IPv4.isValid(string7)) {
        return ipaddr.IPv4.parse(string7);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr.parseCIDR = function(string7) {
      try {
        return ipaddr.IPv6.parseCIDR(string7);
      } catch (e) {
        try {
          return ipaddr.IPv4.parseCIDR(string7);
        } catch (e22) {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr.process = function(string7) {
      const addr = this.parse(string7);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
    ipaddr.subnetMatch = function(address, rangeList, defaultName) {
      let i3, rangeName, rangeSubnets, subnet;
      if (defaultName === undefined || defaultName === null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (i3 = 0;i3 < rangeSubnets.length; i3++) {
            subnet = rangeSubnets[i3];
            if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    if (typeof module !== "undefined" && module.exports) {
      module.exports = ipaddr;
    } else {
      root.ipaddr = ipaddr;
    }
  })(exports);
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  function Events() {
  }
  function EE(fn, context, once2) {
    this.fn = fn;
    this.context = context;
    this.once = once2 || false;
  }
  function addListener(emitter, event, fn, context, once2) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events;
    this._eventsCount = 0;
  }
  var has2 = Object.prototype.hasOwnProperty;
  var prefix = "~";
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has2.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i3 = 0, l3 = handlers.length, ee = new Array(l3);i3 < l3; i3++) {
      ee[i3] = handlers[i3].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i3;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a22), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a22, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
      }
      for (i3 = 1, args = new Array(len - 1);i3 < len; i3++) {
        args[i3 - 1] = arguments[i3];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i3 = 0;i3 < length; i3++) {
        if (listeners[i3].once)
          this.removeListener(event, listeners[i3].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i3].fn.call(listeners[i3].context);
            break;
          case 2:
            listeners[i3].fn.call(listeners[i3].context, a1);
            break;
          case 3:
            listeners[i3].fn.call(listeners[i3].context, a1, a22);
            break;
          case 4:
            listeners[i3].fn.call(listeners[i3].context, a1, a22, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i3].fn.apply(listeners[i3].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once2) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i3 = 0, events = [], length = listeners.length;i3 < length; i3++) {
        if (listeners[i3].fn !== fn || once2 && !listeners[i3].once || context && listeners[i3].context !== context) {
          events.push(listeners[i3]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/stream-json/utils/Utf8Stream.js
var require_Utf8Stream = __commonJS((exports, module) => {
  var { Transform: Transform2 } = import.meta.require("stream");
  var { StringDecoder } = import.meta.require("string_decoder");

  class Utf8Stream extends Transform2 {
    constructor(options) {
      super(Object.assign({}, options, { writableObjectMode: false }));
      this._buffer = "";
    }
    _transform(chunk, encoding5, callback) {
      if (typeof chunk == "string") {
        this._transform = this._transformString;
      } else {
        this._stringDecoder = new StringDecoder;
        this._transform = this._transformBuffer;
      }
      this._transform(chunk, encoding5, callback);
    }
    _transformBuffer(chunk, _5, callback) {
      this._buffer += this._stringDecoder.write(chunk);
      this._processBuffer(callback);
    }
    _transformString(chunk, _5, callback) {
      this._buffer += chunk.toString();
      this._processBuffer(callback);
    }
    _processBuffer(callback) {
      if (this._buffer) {
        this.push(this._buffer, "utf8");
        this._buffer = "";
      }
      callback(null);
    }
    _flushInput() {
      if (this._stringDecoder) {
        this._buffer += this._stringDecoder.end();
      }
    }
    _flush(callback) {
      this._flushInput();
      this._processBuffer(callback);
    }
  }
  module.exports = Utf8Stream;
});

// node_modules/stream-json/jsonl/Parser.js
var require_Parser = __commonJS((exports, module) => {
  var Utf8Stream = require_Utf8Stream();

  class JsonlParser extends Utf8Stream {
    static make(options) {
      return new JsonlParser(options);
    }
    static checkedParse(input, reviver, errorIndicator) {
      try {
        return JSON.parse(input, reviver);
      } catch (error23) {
        if (typeof errorIndicator == "function")
          return errorIndicator(error23, input, reviver);
      }
      return errorIndicator;
    }
    constructor(options) {
      super(Object.assign({}, options, { readableObjectMode: true }));
      this._rest = "";
      this._counter = 0;
      this._reviver = options && options.reviver;
      this._errorIndicator = options && options.errorIndicator;
      if (options && options.checkErrors) {
        this._processBuffer = this._checked_processBuffer;
        this._flush = this._checked_flush;
      }
      if (options && "errorIndicator" in options) {
        this._processBuffer = this._suppressed_processBuffer;
        this._flush = this._suppressed_flush;
      }
    }
    _processBuffer(callback) {
      const lines = this._buffer.split("\n");
      this._rest += lines[0];
      if (lines.length > 1) {
        this._rest && this.push({ key: this._counter++, value: JSON.parse(this._rest, this._reviver) });
        this._rest = lines.pop();
        for (let i3 = 1;i3 < lines.length; ++i3) {
          lines[i3] && this.push({ key: this._counter++, value: JSON.parse(lines[i3], this._reviver) });
        }
      }
      this._buffer = "";
      callback(null);
    }
    _flush(callback) {
      super._flush((error23) => {
        if (error23)
          return callback(error23);
        if (this._rest) {
          this.push({ key: this._counter++, value: JSON.parse(this._rest, this._reviver) });
          this._rest = "";
        }
        callback(null);
      });
    }
    _suppressed_processBuffer(callback) {
      const lines = this._buffer.split("\n");
      this._rest += lines[0];
      if (lines.length > 1) {
        if (this._rest) {
          const value15 = JsonlParser.checkedParse(this._rest, this._reviver, this._errorIndicator);
          value15 !== undefined && this.push({ key: this._counter++, value: value15 });
        }
        this._rest = lines.pop();
        for (let i3 = 1;i3 < lines.length; ++i3) {
          if (!lines[i3])
            continue;
          const value15 = JsonlParser.checkedParse(lines[i3], this._reviver, this._errorIndicator);
          value15 !== undefined && this.push({ key: this._counter++, value: value15 });
        }
      }
      this._buffer = "";
      callback(null);
    }
    _suppressed_flush(callback) {
      super._flush((error23) => {
        if (error23)
          return callback(error23);
        if (this._rest) {
          const value15 = JsonlParser.checkedParse(this._rest, this._reviver, this._errorIndicator);
          value15 !== undefined && this.push({ key: this._counter++, value: value15 });
          this._rest = "";
        }
        callback(null);
      });
    }
    _checked_processBuffer(callback) {
      const lines = this._buffer.split("\n");
      this._rest += lines[0];
      if (lines.length > 1) {
        try {
          this._rest && this.push({ key: this._counter++, value: JSON.parse(this._rest, this._reviver) });
          this._rest = lines.pop();
          for (let i3 = 1;i3 < lines.length; ++i3) {
            lines[i3] && this.push({ key: this._counter++, value: JSON.parse(lines[i3], this._reviver) });
          }
        } catch (cbErr) {
          this._buffer = "";
          callback(cbErr);
          return;
        }
      }
      this._buffer = "";
      callback(null);
    }
    _checked_flush(callback) {
      super._flush((error23) => {
        if (error23)
          return callback(error23);
        if (this._rest) {
          try {
            this.push({ key: this._counter++, value: JSON.parse(this._rest, this._reviver) });
          } catch (cbErr) {
            this._rest = "";
            callback(cbErr);
            return;
          }
          this._rest = "";
        }
        callback(null);
      });
    }
  }
  JsonlParser.parser = JsonlParser.make;
  JsonlParser.make.Constructor = JsonlParser;
  module.exports = JsonlParser;
});

// node_modules/through2/through2.js
var require_through2 = __commonJS((exports, module) => {
  function inherits(fn, sup) {
    fn.super_ = sup;
    fn.prototype = Object.create(sup.prototype, {
      constructor: { value: fn, enumerable: false, writable: true, configurable: true }
    });
  }
  function through2(construct) {
    return (options, transform7, flush) => {
      if (typeof options === "function") {
        flush = transform7;
        transform7 = options;
        options = {};
      }
      if (typeof transform7 !== "function") {
        transform7 = (chunk, enc, cb) => cb(null, chunk);
      }
      if (typeof flush !== "function") {
        flush = null;
      }
      return construct(options, transform7, flush);
    };
  }
  var { Transform: Transform2 } = require_readable();
  var make = through2((options, transform7, flush) => {
    const t22 = new Transform2(options);
    t22._transform = transform7;
    if (flush) {
      t22._flush = flush;
    }
    return t22;
  });
  var ctor = through2((options, transform7, flush) => {
    function Through2(override) {
      if (!(this instanceof Through2)) {
        return new Through2(override);
      }
      this.options = Object.assign({}, options, override);
      Transform2.call(this, this.options);
      this._transform = transform7;
      if (flush) {
        this._flush = flush;
      }
    }
    inherits(Through2, Transform2);
    return Through2;
  });
  var obj = through2(function(options, transform7, flush) {
    const t22 = new Transform2(Object.assign({ objectMode: true, highWaterMark: 16 }, options));
    t22._transform = transform7;
    if (flush) {
      t22._flush = flush;
    }
    return t22;
  });
  module.exports = make;
  module.exports.ctor = ctor;
  module.exports.obj = obj;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n3 = parseFloat(match[1]);
    var type50 = (match[2] || "ms").toLowerCase();
    switch (type50) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n3 * y3;
      case "weeks":
      case "week":
      case "w":
        return n3 * w;
      case "days":
      case "day":
      case "d":
        return n3 * d3;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n3 * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n3 * m3;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n3 * s3;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n3;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d3) {
      return Math.round(ms / d3) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m3) {
      return Math.round(ms / m3) + "m";
    }
    if (msAbs >= s3) {
      return Math.round(ms / s3) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d3) {
      return plural(ms, msAbs, d3, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m3) {
      return plural(ms, msAbs, m3, "minute");
    }
    if (msAbs >= s3) {
      return plural(ms, msAbs, s3, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n3, name) {
    var isPlural = msAbs >= n3 * 1.5;
    return Math.round(ms / n3) + " " + name + (isPlural ? "s" : "");
  }
  var s3 = 1000;
  var m3 = s3 * 60;
  var h = m3 * 60;
  var d3 = h * 24;
  var w = d3 * 7;
  var y3 = d3 * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type50 = typeof val;
    if (type50 === "string" && val.length > 0) {
      return parse4(val);
    } else if (type50 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env4) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env4).forEach((key) => {
      createDebug[key] = env4[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash7 = 0;
      for (let i3 = 0;i3 < namespace.length; i3++) {
        hash7 = (hash7 << 5) - hash7 + namespace.charCodeAt(i3);
        hash7 |= 0;
      }
      return createDebug.colors[Math.abs(hash7) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v3) => {
          enableOverride = v3;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip2 of createDebug.skips) {
        if (matchesTemplate(name, skip2)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m3;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m3 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m3[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c3 = "color: " + this.color;
    args.splice(1, 0, c3, "color: inherit");
    let index2 = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index2++;
      if (match === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c3);
  }
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error23) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error23) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error23) {
    }
  }
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v3) {
    try {
      return JSON.stringify(v3);
    } catch (error23) {
      return "[UnexpectedJSONParseError]: " + error23.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS((exports, module) => {
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c3 = this.color;
      const colorCode = "\x1B[3" + (c3 < 8 ? c3 : "8;5;" + c3);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args) {
    return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i3 = 0;i3 < keys.length; i3++) {
      debug.inspectOpts[keys[i3]] = exports.inspectOpts[keys[i3]];
    }
  }
  var tty2 = import.meta.require("tty");
  var util2 = import.meta.require("util");
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor2 = (()=>{throw new Error(`Cannot require module "supports-color"`);})();
    if (supportsColor2 && (supportsColor2.stderr || supportsColor2).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error23) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_5, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v3) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v3, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v3) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v3, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node2();
  }
});

// node_modules/short-unique-id/dist/short-unique-id.js
var require_short_unique_id = __commonJS((exports, module) => {
  var ShortUniqueId = (() => {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value15) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value15 }) : obj[key] = value15;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
    var __publicField = (obj, key, value15) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value15);
      return value15;
    };
    var src_exports = {};
    __export2(src_exports, {
      DEFAULT_OPTIONS: () => DEFAULT_OPTIONS,
      DEFAULT_UUID_LENGTH: () => DEFAULT_UUID_LENGTH,
      default: () => ShortUniqueId2
    });
    var version = "5.2.0";
    var DEFAULT_UUID_LENGTH = 6;
    var DEFAULT_OPTIONS = {
      dictionary: "alphanum",
      shuffle: true,
      debug: false,
      length: DEFAULT_UUID_LENGTH,
      counter: 0
    };
    var _ShortUniqueId = class _ShortUniqueId2 {
      constructor(argOptions = {}) {
        __publicField(this, "counter");
        __publicField(this, "debug");
        __publicField(this, "dict");
        __publicField(this, "version");
        __publicField(this, "dictIndex", 0);
        __publicField(this, "dictRange", []);
        __publicField(this, "lowerBound", 0);
        __publicField(this, "upperBound", 0);
        __publicField(this, "dictLength", 0);
        __publicField(this, "uuidLength");
        __publicField(this, "_digit_first_ascii", 48);
        __publicField(this, "_digit_last_ascii", 58);
        __publicField(this, "_alpha_lower_first_ascii", 97);
        __publicField(this, "_alpha_lower_last_ascii", 123);
        __publicField(this, "_hex_last_ascii", 103);
        __publicField(this, "_alpha_upper_first_ascii", 65);
        __publicField(this, "_alpha_upper_last_ascii", 91);
        __publicField(this, "_number_dict_ranges", {
          digits: [this._digit_first_ascii, this._digit_last_ascii]
        });
        __publicField(this, "_alpha_dict_ranges", {
          lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],
          upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]
        });
        __publicField(this, "_alpha_lower_dict_ranges", {
          lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii]
        });
        __publicField(this, "_alpha_upper_dict_ranges", {
          upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]
        });
        __publicField(this, "_alphanum_dict_ranges", {
          digits: [this._digit_first_ascii, this._digit_last_ascii],
          lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],
          upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]
        });
        __publicField(this, "_alphanum_lower_dict_ranges", {
          digits: [this._digit_first_ascii, this._digit_last_ascii],
          lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii]
        });
        __publicField(this, "_alphanum_upper_dict_ranges", {
          digits: [this._digit_first_ascii, this._digit_last_ascii],
          upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]
        });
        __publicField(this, "_hex_dict_ranges", {
          decDigits: [this._digit_first_ascii, this._digit_last_ascii],
          alphaDigits: [this._alpha_lower_first_ascii, this._hex_last_ascii]
        });
        __publicField(this, "_dict_ranges", {
          _number_dict_ranges: this._number_dict_ranges,
          _alpha_dict_ranges: this._alpha_dict_ranges,
          _alpha_lower_dict_ranges: this._alpha_lower_dict_ranges,
          _alpha_upper_dict_ranges: this._alpha_upper_dict_ranges,
          _alphanum_dict_ranges: this._alphanum_dict_ranges,
          _alphanum_lower_dict_ranges: this._alphanum_lower_dict_ranges,
          _alphanum_upper_dict_ranges: this._alphanum_upper_dict_ranges,
          _hex_dict_ranges: this._hex_dict_ranges
        });
        __publicField(this, "log", (...args) => {
          const finalArgs = [...args];
          finalArgs[0] = `[short-unique-id] ${args[0]}`;
          if (this.debug === true) {
            if (typeof console !== "undefined" && console !== null) {
              return console.log(...finalArgs);
            }
          }
        });
        __publicField(this, "_normalizeDictionary", (dictionary2, shuffle2) => {
          let finalDict;
          if (dictionary2 && Array.isArray(dictionary2) && dictionary2.length > 1) {
            finalDict = dictionary2;
          } else {
            finalDict = [];
            let i3;
            this.dictIndex = i3 = 0;
            const rangesName = `_${dictionary2}_dict_ranges`;
            const ranges = this._dict_ranges[rangesName];
            Object.keys(ranges).forEach((rangeType) => {
              const rangeTypeKey = rangeType;
              this.dictRange = ranges[rangeTypeKey];
              this.lowerBound = this.dictRange[0];
              this.upperBound = this.dictRange[1];
              for (this.dictIndex = i3 = this.lowerBound;this.lowerBound <= this.upperBound ? i3 < this.upperBound : i3 > this.upperBound; this.dictIndex = this.lowerBound <= this.upperBound ? i3 += 1 : i3 -= 1) {
                finalDict.push(String.fromCharCode(this.dictIndex));
              }
            });
          }
          if (shuffle2) {
            const PROBABILITY = 0.5;
            finalDict = finalDict.sort(() => Math.random() - PROBABILITY);
          }
          return finalDict;
        });
        __publicField(this, "setDictionary", (dictionary2, shuffle2) => {
          this.dict = this._normalizeDictionary(dictionary2, shuffle2);
          this.dictLength = this.dict.length;
          this.setCounter(0);
        });
        __publicField(this, "seq", () => {
          return this.sequentialUUID();
        });
        __publicField(this, "sequentialUUID", () => {
          let counterDiv;
          let counterRem;
          let id = "";
          counterDiv = this.counter;
          do {
            counterRem = counterDiv % this.dictLength;
            counterDiv = Math.trunc(counterDiv / this.dictLength);
            id += this.dict[counterRem];
          } while (counterDiv !== 0);
          this.counter += 1;
          return id;
        });
        __publicField(this, "rnd", (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH) => {
          return this.randomUUID(uuidLength);
        });
        __publicField(this, "randomUUID", (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH) => {
          let id;
          let randomPartIdx;
          let j;
          if (uuidLength === null || typeof uuidLength === "undefined" || uuidLength < 1) {
            throw new Error("Invalid UUID Length Provided");
          }
          const isPositive = uuidLength >= 0;
          id = "";
          for (j = 0;j < uuidLength; j += 1) {
            randomPartIdx = parseInt((Math.random() * this.dictLength).toFixed(0), 10) % this.dictLength;
            id += this.dict[randomPartIdx];
          }
          return id;
        });
        __publicField(this, "fmt", (format, date5) => {
          return this.formattedUUID(format, date5);
        });
        __publicField(this, "formattedUUID", (format, date5) => {
          const fnMap = {
            $r: this.randomUUID,
            $s: this.sequentialUUID,
            $t: this.stamp
          };
          const result = format.replace(/\$[rs]\d{0,}|\$t0|\$t[1-9]\d{1,}/g, (m3) => {
            const fn = m3.slice(0, 2);
            const len = parseInt(m3.slice(2), 10);
            if (fn === "$s") {
              return fnMap[fn]().padStart(len, "0");
            }
            if (fn === "$t" && date5) {
              return fnMap[fn](len, date5);
            }
            return fnMap[fn](len);
          });
          return result;
        });
        __publicField(this, "availableUUIDs", (uuidLength = this.uuidLength) => {
          return parseFloat(Math.pow([...new Set(this.dict)].length, uuidLength).toFixed(0));
        });
        __publicField(this, "approxMaxBeforeCollision", (rounds = this.availableUUIDs(this.uuidLength)) => {
          return parseFloat(Math.sqrt(Math.PI / 2 * rounds).toFixed(20));
        });
        __publicField(this, "collisionProbability", (rounds = this.availableUUIDs(this.uuidLength), uuidLength = this.uuidLength) => {
          return parseFloat((this.approxMaxBeforeCollision(rounds) / this.availableUUIDs(uuidLength)).toFixed(20));
        });
        __publicField(this, "uniqueness", (rounds = this.availableUUIDs(this.uuidLength)) => {
          const score = parseFloat((1 - this.approxMaxBeforeCollision(rounds) / rounds).toFixed(20));
          return score > 1 ? 1 : score < 0 ? 0 : score;
        });
        __publicField(this, "getVersion", () => {
          return this.version;
        });
        __publicField(this, "stamp", (finalLength, date5) => {
          const hexStamp = Math.floor(+(date5 || /* @__PURE__ */ new Date) / 1000).toString(16);
          if (typeof finalLength === "number" && finalLength === 0) {
            return hexStamp;
          }
          if (typeof finalLength !== "number" || finalLength < 10) {
            throw new Error([
              "Param finalLength must be a number greater than or equal to 10,",
              "or 0 if you want the raw hexadecimal timestamp"
            ].join("\n"));
          }
          const idLength = finalLength - 9;
          const rndIdx = Math.round(Math.random() * (idLength > 15 ? 15 : idLength));
          const id = this.randomUUID(idLength);
          return `${id.substring(0, rndIdx)}${hexStamp}${id.substring(rndIdx)}${rndIdx.toString(16)}`;
        });
        __publicField(this, "parseStamp", (suid, format) => {
          if (format && !/t0|t[1-9]\d{1,}/.test(format)) {
            throw new Error("Cannot extract date from a formated UUID with no timestamp in the format");
          }
          const stamp = format ? format.replace(/\$[rs]\d{0,}|\$t0|\$t[1-9]\d{1,}/g, (m3) => {
            const fnMap = {
              $r: (len2) => [...Array(len2)].map(() => "r").join(""),
              $s: (len2) => [...Array(len2)].map(() => "s").join(""),
              $t: (len2) => [...Array(len2)].map(() => "t").join("")
            };
            const fn = m3.slice(0, 2);
            const len = parseInt(m3.slice(2), 10);
            return fnMap[fn](len);
          }).replace(/^(.*?)(t{8,})(.*)$/g, (_m, p12, p22) => {
            return suid.substring(p12.length, p12.length + p22.length);
          }) : suid;
          if (stamp.length === 8) {
            return new Date(parseInt(stamp, 16) * 1000);
          }
          if (stamp.length < 10) {
            throw new Error("Stamp length invalid");
          }
          const rndIdx = parseInt(stamp.substring(stamp.length - 1), 16);
          return new Date(parseInt(stamp.substring(rndIdx, rndIdx + 8), 16) * 1000);
        });
        __publicField(this, "setCounter", (counter2) => {
          this.counter = counter2;
        });
        __publicField(this, "validate", (uid, dictionary2) => {
          const finalDictionary = dictionary2 ? this._normalizeDictionary(dictionary2) : this.dict;
          return uid.split("").every((c3) => finalDictionary.includes(c3));
        });
        const options = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), argOptions);
        this.counter = 0;
        this.debug = false;
        this.dict = [];
        this.version = version;
        const {
          dictionary,
          shuffle,
          length,
          counter
        } = options;
        this.uuidLength = length;
        this.setDictionary(dictionary, shuffle);
        this.setCounter(counter);
        this.debug = options.debug;
        this.log(this.dict);
        this.log(`Generator instantiated with Dictionary Size ${this.dictLength} and counter set to ${this.counter}`);
        this.log = this.log.bind(this);
        this.setDictionary = this.setDictionary.bind(this);
        this.setCounter = this.setCounter.bind(this);
        this.seq = this.seq.bind(this);
        this.sequentialUUID = this.sequentialUUID.bind(this);
        this.rnd = this.rnd.bind(this);
        this.randomUUID = this.randomUUID.bind(this);
        this.fmt = this.fmt.bind(this);
        this.formattedUUID = this.formattedUUID.bind(this);
        this.availableUUIDs = this.availableUUIDs.bind(this);
        this.approxMaxBeforeCollision = this.approxMaxBeforeCollision.bind(this);
        this.collisionProbability = this.collisionProbability.bind(this);
        this.uniqueness = this.uniqueness.bind(this);
        this.getVersion = this.getVersion.bind(this);
        this.stamp = this.stamp.bind(this);
        this.parseStamp = this.parseStamp.bind(this);
        return this;
      }
    };
    __publicField(_ShortUniqueId, "default", _ShortUniqueId);
    var ShortUniqueId2 = _ShortUniqueId;
    return __toCommonJS(src_exports);
  })();
  typeof module != "undefined" && (module.exports = ShortUniqueId.default), typeof window != "undefined" && (ShortUniqueId = ShortUniqueId.default);
});

// node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root();
  var Symbol3 = root.Symbol;
  module.exports = Symbol3;
});

// node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  function getRawTag(value15) {
    var isOwn = hasOwnProperty.call(value15, symToStringTag), tag = value15[symToStringTag];
    try {
      value15[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value15);
    if (unmasked) {
      if (isOwn) {
        value15[symToStringTag] = tag;
      } else {
        delete value15[symToStringTag];
      }
    }
    return result;
  }
  var Symbol3 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol3 ? Symbol3.toStringTag : undefined;
  module.exports = getRawTag;
});

// node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  function objectToString(value15) {
    return nativeObjectToString.call(value15);
  }
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  module.exports = objectToString;
});

// node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  function baseGetTag(value15) {
    if (value15 == null) {
      return value15 === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value15) ? getRawTag(value15) : objectToString(value15);
  }
  var Symbol3 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol3 ? Symbol3.toStringTag : undefined;
  module.exports = baseGetTag;
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  function isObject2(value15) {
    var type50 = typeof value15;
    return value15 != null && (type50 == "object" || type50 == "function");
  }
  module.exports = isObject2;
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports, module) => {
  function isFunction2(value15) {
    if (!isObject2(value15)) {
      return false;
    }
    var tag = baseGetTag(value15);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var baseGetTag = require__baseGetTag();
  var isObject2 = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  module.exports = isFunction2;
});

// node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root();
  var coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var coreJsData = require__coreJsData();
  var maskSrcKey = function() {
    var uid3 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid3 ? "Symbol(src)_1." + uid3 : "";
  }();
  module.exports = isMasked;
});

// node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  module.exports = toSource;
});

// node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  function baseIsNative(value15) {
    if (!isObject2(value15) || isMasked(value15)) {
      return false;
    }
    var pattern3 = isFunction2(value15) ? reIsNative : reIsHostCtor;
    return pattern3.test(toSource(value15));
  }
  var isFunction2 = require_isFunction();
  var isMasked = require__isMasked();
  var isObject2 = require_isObject();
  var toSource = require__toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  module.exports = baseIsNative;
});

// node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  function getValue(object13, key) {
    return object13 == null ? undefined : object13[key];
  }
  module.exports = getValue;
});

// node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  function getNative(object13, key) {
    var value15 = getValue(object13, key);
    return baseIsNative(value15) ? value15 : undefined;
  }
  var baseIsNative = require__baseIsNative();
  var getValue = require__getValue();
  module.exports = getNative;
});

// node_modules/lodash/_defineProperty.js
var require__defineProperty = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  module.exports = defineProperty;
});

// node_modules/lodash/_baseAssignValue.js
var require__baseAssignValue = __commonJS((exports, module) => {
  function baseAssignValue(object13, key, value15) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object13, key, {
        configurable: true,
        enumerable: true,
        value: value15,
        writable: true
      });
    } else {
      object13[key] = value15;
    }
  }
  var defineProperty = require__defineProperty();
  module.exports = baseAssignValue;
});

// node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  function eq(value15, other) {
    return value15 === other || value15 !== value15 && other !== other;
  }
  module.exports = eq;
});

// node_modules/lodash/_assignValue.js
var require__assignValue = __commonJS((exports, module) => {
  function assignValue(object13, key, value15) {
    var objValue = object13[key];
    if (!(hasOwnProperty.call(object13, key) && eq(objValue, value15)) || value15 === undefined && !(key in object13)) {
      baseAssignValue(object13, key, value15);
    }
  }
  var baseAssignValue = require__baseAssignValue();
  var eq = require_eq();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = assignValue;
});

// node_modules/lodash/_copyObject.js
var require__copyObject = __commonJS((exports, module) => {
  function copyObject(source, props, object13, customizer) {
    var isNew = !object13;
    object13 || (object13 = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = customizer ? customizer(object13[key], source[key], key, object13, source) : undefined;
      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object13, key, newValue);
      } else {
        assignValue(object13, key, newValue);
      }
    }
    return object13;
  }
  var assignValue = require__assignValue();
  var baseAssignValue = require__baseAssignValue();
  module.exports = copyObject;
});

// node_modules/lodash/identity.js
var require_identity = __commonJS((exports, module) => {
  function identity(value15) {
    return value15;
  }
  module.exports = identity;
});

// node_modules/lodash/_apply.js
var require__apply = __commonJS((exports, module) => {
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  module.exports = apply;
});

// node_modules/lodash/_overRest.js
var require__overRest = __commonJS((exports, module) => {
  function overRest(func, start, transform7) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array5 = Array(length);
      while (++index2 < length) {
        array5[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = transform7(array5);
      return apply(func, this, otherArgs);
    };
  }
  var apply = require__apply();
  var nativeMax = Math.max;
  module.exports = overRest;
});

// node_modules/lodash/constant.js
var require_constant = __commonJS((exports, module) => {
  function constant(value15) {
    return function() {
      return value15;
    };
  }
  module.exports = constant;
});

// node_modules/lodash/_baseSetToString.js
var require__baseSetToString = __commonJS((exports, module) => {
  var constant = require_constant();
  var defineProperty = require__defineProperty();
  var identity = require_identity();
  var baseSetToString = !defineProperty ? identity : function(func, string7) {
    return defineProperty(func, "toString", {
      configurable: true,
      enumerable: false,
      value: constant(string7),
      writable: true
    });
  };
  module.exports = baseSetToString;
});

// node_modules/lodash/_shortOut.js
var require__shortOut = __commonJS((exports, module) => {
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }
  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var nativeNow = Date.now;
  module.exports = shortOut;
});

// node_modules/lodash/_setToString.js
var require__setToString = __commonJS((exports, module) => {
  var baseSetToString = require__baseSetToString();
  var shortOut = require__shortOut();
  var setToString = shortOut(baseSetToString);
  module.exports = setToString;
});

// node_modules/lodash/_baseRest.js
var require__baseRest = __commonJS((exports, module) => {
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  var identity = require_identity();
  var overRest = require__overRest();
  var setToString = require__setToString();
  module.exports = baseRest;
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS((exports, module) => {
  function isLength(value15) {
    return typeof value15 == "number" && value15 > -1 && value15 % 1 == 0 && value15 <= MAX_SAFE_INTEGER;
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  module.exports = isLength;
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS((exports, module) => {
  function isArrayLike2(value15) {
    return value15 != null && isLength(value15.length) && !isFunction2(value15);
  }
  var isFunction2 = require_isFunction();
  var isLength = require_isLength();
  module.exports = isArrayLike2;
});

// node_modules/lodash/_isIndex.js
var require__isIndex = __commonJS((exports, module) => {
  function isIndex(value15, length) {
    var type50 = typeof value15;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type50 == "number" || type50 != "symbol" && reIsUint.test(value15)) && (value15 > -1 && value15 % 1 == 0 && value15 < length);
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  module.exports = isIndex;
});

// node_modules/lodash/_isIterateeCall.js
var require__isIterateeCall = __commonJS((exports, module) => {
  function isIterateeCall(value15, index2, object13) {
    if (!isObject2(object13)) {
      return false;
    }
    var type50 = typeof index2;
    if (type50 == "number" ? isArrayLike2(object13) && isIndex(index2, object13.length) : type50 == "string" && (index2 in object13)) {
      return eq(object13[index2], value15);
    }
    return false;
  }
  var eq = require_eq();
  var isArrayLike2 = require_isArrayLike();
  var isIndex = require__isIndex();
  var isObject2 = require_isObject();
  module.exports = isIterateeCall;
});

// node_modules/lodash/_createAssigner.js
var require__createAssigner = __commonJS((exports, module) => {
  function createAssigner(assigner) {
    return baseRest(function(object13, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard22 = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
      if (guard22 && isIterateeCall(sources[0], sources[1], guard22)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object13 = Object(object13);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object13, source, index2, customizer);
        }
      }
      return object13;
    });
  }
  var baseRest = require__baseRest();
  var isIterateeCall = require__isIterateeCall();
  module.exports = createAssigner;
});

// node_modules/lodash/_baseTimes.js
var require__baseTimes = __commonJS((exports, module) => {
  function baseTimes(n3, iteratee) {
    var index2 = -1, result = Array(n3);
    while (++index2 < n3) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  module.exports = baseTimes;
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  function isObjectLike(value15) {
    return value15 != null && typeof value15 == "object";
  }
  module.exports = isObjectLike;
});

// node_modules/lodash/_baseIsArguments.js
var require__baseIsArguments = __commonJS((exports, module) => {
  function baseIsArguments(value15) {
    return isObjectLike(value15) && baseGetTag(value15) == argsTag;
  }
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var argsTag = "[object Arguments]";
  module.exports = baseIsArguments;
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS((exports, module) => {
  var baseIsArguments = require__baseIsArguments();
  var isObjectLike = require_isObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value15) {
    return isObjectLike(value15) && hasOwnProperty.call(value15, "callee") && !propertyIsEnumerable.call(value15, "callee");
  };
  module.exports = isArguments;
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS((exports, module) => {
  function stubFalse() {
    return false;
  }
  module.exports = stubFalse;
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS((exports, module) => {
  var root = require__root();
  var stubFalse = require_stubFalse();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
});

// node_modules/lodash/_baseIsTypedArray.js
var require__baseIsTypedArray = __commonJS((exports, module) => {
  function baseIsTypedArray(value15) {
    return isObjectLike(value15) && isLength(value15.length) && !!typedArrayTags[baseGetTag(value15)];
  }
  var baseGetTag = require__baseGetTag();
  var isLength = require_isLength();
  var isObjectLike = require_isObjectLike();
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  module.exports = baseIsTypedArray;
});

// node_modules/lodash/_baseUnary.js
var require__baseUnary = __commonJS((exports, module) => {
  function baseUnary(func) {
    return function(value15) {
      return func(value15);
    };
  }
  module.exports = baseUnary;
});

// node_modules/lodash/_nodeUtil.js
var require__nodeUtil = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil;
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS((exports, module) => {
  var baseIsTypedArray = require__baseIsTypedArray();
  var baseUnary = require__baseUnary();
  var nodeUtil = require__nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module.exports = isTypedArray;
});

// node_modules/lodash/_arrayLikeKeys.js
var require__arrayLikeKeys = __commonJS((exports, module) => {
  function arrayLikeKeys(value15, inherited) {
    var isArr = isArray(value15), isArg = !isArr && isArguments(value15), isBuff = !isArr && !isArg && isBuffer(value15), isType = !isArr && !isArg && !isBuff && isTypedArray(value15), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value15.length, String) : [], length = result.length;
    for (var key in value15) {
      if ((inherited || hasOwnProperty.call(value15, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  var baseTimes = require__baseTimes();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var isBuffer = require_isBuffer();
  var isIndex = require__isIndex();
  var isTypedArray = require_isTypedArray();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = arrayLikeKeys;
});

// node_modules/lodash/_isPrototype.js
var require__isPrototype = __commonJS((exports, module) => {
  function isPrototype(value15) {
    var Ctor = value15 && value15.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value15 === proto2;
  }
  var objectProto = Object.prototype;
  module.exports = isPrototype;
});

// node_modules/lodash/_nativeKeysIn.js
var require__nativeKeysIn = __commonJS((exports, module) => {
  function nativeKeysIn(object13) {
    var result = [];
    if (object13 != null) {
      for (var key in Object(object13)) {
        result.push(key);
      }
    }
    return result;
  }
  module.exports = nativeKeysIn;
});

// node_modules/lodash/_baseKeysIn.js
var require__baseKeysIn = __commonJS((exports, module) => {
  function baseKeysIn(object13) {
    if (!isObject2(object13)) {
      return nativeKeysIn(object13);
    }
    var isProto = isPrototype(object13), result = [];
    for (var key in object13) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object13, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  var isObject2 = require_isObject();
  var isPrototype = require__isPrototype();
  var nativeKeysIn = require__nativeKeysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = baseKeysIn;
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS((exports, module) => {
  function keysIn(object13) {
    return isArrayLike2(object13) ? arrayLikeKeys(object13, true) : baseKeysIn(object13);
  }
  var arrayLikeKeys = require__arrayLikeKeys();
  var baseKeysIn = require__baseKeysIn();
  var isArrayLike2 = require_isArrayLike();
  module.exports = keysIn;
});

// node_modules/lodash/assignIn.js
var require_assignIn = __commonJS((exports, module) => {
  var copyObject = require__copyObject();
  var createAssigner = require__createAssigner();
  var keysIn = require_keysIn();
  var assignIn = createAssigner(function(object13, source) {
    copyObject(source, keysIn(source), object13);
  });
  module.exports = assignIn;
});

// node_modules/lodash/isString.js
var require_isString = __commonJS((exports, module) => {
  function isString2(value15) {
    return typeof value15 == "string" || !isArray(value15) && isObjectLike(value15) && baseGetTag(value15) == stringTag;
  }
  var baseGetTag = require__baseGetTag();
  var isArray = require_isArray();
  var isObjectLike = require_isObjectLike();
  var stringTag = "[object String]";
  module.exports = isString2;
});

// node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS((exports, module) => {
  function isUndefined(value15) {
    return value15 === undefined;
  }
  module.exports = isUndefined;
});

// node_modules/lodash/_overArg.js
var require__overArg = __commonJS((exports, module) => {
  function overArg(func, transform7) {
    return function(arg) {
      return func(transform7(arg));
    };
  }
  module.exports = overArg;
});

// node_modules/lodash/_nativeKeys.js
var require__nativeKeys = __commonJS((exports, module) => {
  var overArg = require__overArg();
  var nativeKeys = overArg(Object.keys, Object);
  module.exports = nativeKeys;
});

// node_modules/lodash/_baseKeys.js
var require__baseKeys = __commonJS((exports, module) => {
  function baseKeys(object13) {
    if (!isPrototype(object13)) {
      return nativeKeys(object13);
    }
    var result = [];
    for (var key in Object(object13)) {
      if (hasOwnProperty.call(object13, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  var isPrototype = require__isPrototype();
  var nativeKeys = require__nativeKeys();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = baseKeys;
});

// node_modules/lodash/_DataView.js
var require__DataView = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var DataView2 = getNative(root, "DataView");
  module.exports = DataView2;
});

// node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// node_modules/lodash/_Promise.js
var require__Promise = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Promise3 = getNative(root, "Promise");
  module.exports = Promise3;
});

// node_modules/lodash/_Set.js
var require__Set = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Set5 = getNative(root, "Set");
  module.exports = Set5;
});

// node_modules/lodash/_WeakMap.js
var require__WeakMap = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var WeakMap2 = getNative(root, "WeakMap");
  module.exports = WeakMap2;
});

// node_modules/lodash/_getTag.js
var require__getTag = __commonJS((exports, module) => {
  var DataView2 = require__DataView();
  var Map2 = require__Map();
  var Promise3 = require__Promise();
  var Set5 = require__Set();
  var WeakMap2 = require__WeakMap();
  var baseGetTag = require__baseGetTag();
  var toSource = require__toSource();
  var mapTag = "[object Map]";
  var objectTag = "[object Object]";
  var promiseTag = "[object Promise]";
  var setTag = "[object Set]";
  var weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView2);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise3);
  var setCtorString = toSource(Set5);
  var weakMapCtorString = toSource(WeakMap2);
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise3 && getTag(Promise3.resolve()) != promiseTag || Set5 && getTag(new Set5) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
    getTag = function(value15) {
      var result = baseGetTag(value15), Ctor = result == objectTag ? value15.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  module.exports = getTag;
});

// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS((exports, module) => {
  function isEmpty2(value15) {
    if (value15 == null) {
      return true;
    }
    if (isArrayLike2(value15) && (isArray(value15) || typeof value15 == "string" || typeof value15.splice == "function" || isBuffer(value15) || isTypedArray(value15) || isArguments(value15))) {
      return !value15.length;
    }
    var tag = getTag(value15);
    if (tag == mapTag || tag == setTag) {
      return !value15.size;
    }
    if (isPrototype(value15)) {
      return !baseKeys(value15).length;
    }
    for (var key in value15) {
      if (hasOwnProperty.call(value15, key)) {
        return false;
      }
    }
    return true;
  }
  var baseKeys = require__baseKeys();
  var getTag = require__getTag();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var isArrayLike2 = require_isArrayLike();
  var isBuffer = require_isBuffer();
  var isPrototype = require__isPrototype();
  var isTypedArray = require_isTypedArray();
  var mapTag = "[object Map]";
  var setTag = "[object Set]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = isEmpty2;
});

// node_modules/cloudinary/lib/utils/entries.js
var require_entries = __commonJS((exports, module) => {
  module.exports = Object.entries ? Object.entries : function(obj) {
    let ownProps = Object.keys(obj), i3 = ownProps.length, resArray = new Array(i3);
    while (i3--) {
      resArray[i3] = [ownProps[i3], obj[ownProps[i3]]];
    }
    return resArray;
  };
});

// node_modules/cloudinary/lib/config.js
var require_config = __commonJS((exports, module) => {
  function putNestedValue(params, key, value15) {
    let chain = key.split(/[\[\]]+/).filter((i3) => i3.length);
    let outer = params;
    let lastKey = chain.pop();
    for (let j = 0;j < chain.length; j++) {
      let innerKey = chain[j];
      let inner = outer[innerKey];
      if (inner == null) {
        inner = {};
        outer[innerKey] = inner;
      }
      outer = inner;
    }
    outer[lastKey] = value15;
    return params;
  }
  function parseCloudinaryConfigFromEnvURL(ENV_STR) {
    let conf = {};
    let uri = url.parse(ENV_STR, true);
    if (uri.protocol === "cloudinary:") {
      conf = Object.assign({}, conf, {
        cloud_name: uri.host,
        api_key: uri.auth && uri.auth.split(":")[0],
        api_secret: uri.auth && uri.auth.split(":")[1],
        private_cdn: uri.pathname != null,
        secure_distribution: uri.pathname && uri.pathname.substring(1)
      });
    } else if (uri.protocol === "account:") {
      conf = Object.assign({}, conf, {
        account_id: uri.host,
        provisioning_api_key: uri.auth && uri.auth.split(":")[0],
        provisioning_api_secret: uri.auth && uri.auth.split(":")[1]
      });
    }
    return conf;
  }
  function extendCloudinaryConfigFromQuery(ENV_URL, confToExtend = {}) {
    let uri = url.parse(ENV_URL, true);
    if (uri.query != null) {
      entries(uri.query).forEach(([key, value15]) => putNestedValue(confToExtend, key, value15));
    }
  }
  function extendCloudinaryConfig(parsedConfig, confToExtend = {}) {
    entries(parsedConfig).forEach(([key, value15]) => {
      if (value15 !== undefined) {
        confToExtend[key] = value15;
      }
    });
    return confToExtend;
  }
  var url = import.meta.require("url");
  var extend = require_assignIn();
  var isObject2 = require_isObject();
  var isString2 = require_isString();
  var isUndefined = require_isUndefined();
  var isEmpty2 = require_isEmpty();
  var entries = require_entries();
  var cloudinary_config = undefined;
  module.exports = function(new_config, new_value) {
    if (cloudinary_config == null || new_config === true) {
      if (cloudinary_config == null) {
        cloudinary_config = {};
      } else {
        Object.keys(cloudinary_config).forEach((key) => delete cloudinary_config[key]);
      }
      let CLOUDINARY_ENV_URL = process.env.CLOUDINARY_URL;
      let CLOUDINARY_ENV_ACCOUNT_URL = process.env.CLOUDINARY_ACCOUNT_URL;
      let CLOUDINARY_API_PROXY = process.env.CLOUDINARY_API_PROXY;
      if (CLOUDINARY_ENV_URL && !CLOUDINARY_ENV_URL.toLowerCase().startsWith("cloudinary://")) {
        throw new Error("Invalid CLOUDINARY_URL protocol. URL should begin with 'cloudinary://'");
      }
      if (CLOUDINARY_ENV_ACCOUNT_URL && !CLOUDINARY_ENV_ACCOUNT_URL.toLowerCase().startsWith("account://")) {
        throw new Error("Invalid CLOUDINARY_ACCOUNT_URL protocol. URL should begin with 'account://'");
      }
      if (!isEmpty2(CLOUDINARY_API_PROXY)) {
        extendCloudinaryConfig({ api_proxy: CLOUDINARY_API_PROXY }, cloudinary_config);
      }
      [CLOUDINARY_ENV_URL, CLOUDINARY_ENV_ACCOUNT_URL].forEach((ENV_URL) => {
        if (ENV_URL) {
          let parsedConfig = parseCloudinaryConfigFromEnvURL(ENV_URL);
          extendCloudinaryConfig(parsedConfig, cloudinary_config);
          extendCloudinaryConfigFromQuery(ENV_URL, cloudinary_config);
        }
      });
    }
    if (!isUndefined(new_value)) {
      cloudinary_config[new_config] = new_value;
    } else if (isString2(new_config)) {
      return cloudinary_config[new_config];
    } else if (isObject2(new_config)) {
      extend(cloudinary_config, new_config);
    }
    return cloudinary_config;
  };
});

// node_modules/lodash/compact.js
var require_compact = __commonJS((exports, module) => {
  function compact(array5) {
    var index2 = -1, length = array5 == null ? 0 : array5.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value15 = array5[index2];
      if (value15) {
        result[resIndex++] = value15;
      }
    }
    return result;
  }
  module.exports = compact;
});

// node_modules/lodash/head.js
var require_head = __commonJS((exports, module) => {
  function head(array5) {
    return array5 && array5.length ? array5[0] : undefined;
  }
  module.exports = head;
});

// node_modules/lodash/_getPrototype.js
var require__getPrototype = __commonJS((exports, module) => {
  var overArg = require__overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  module.exports = getPrototype;
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS((exports, module) => {
  function isPlainObject(value15) {
    if (!isObjectLike(value15) || baseGetTag(value15) != objectTag) {
      return false;
    }
    var proto2 = getPrototype(value15);
    if (proto2 === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  var baseGetTag = require__baseGetTag();
  var getPrototype = require__getPrototype();
  var isObjectLike = require_isObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  module.exports = isPlainObject;
});

// node_modules/lodash/last.js
var require_last = __commonJS((exports, module) => {
  function last(array5) {
    var length = array5 == null ? 0 : array5.length;
    return length ? array5[length - 1] : undefined;
  }
  module.exports = last;
});

// node_modules/lodash/_arrayMap.js
var require__arrayMap = __commonJS((exports, module) => {
  function arrayMap(array5, iteratee) {
    var index2 = -1, length = array5 == null ? 0 : array5.length, result = Array(length);
    while (++index2 < length) {
      result[index2] = iteratee(array5[index2], index2, array5);
    }
    return result;
  }
  module.exports = arrayMap;
});

// node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  module.exports = listCacheClear;
});

// node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  function assocIndexOf(array5, key) {
    var length = array5.length;
    while (length--) {
      if (eq(array5[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var eq = require_eq();
  module.exports = assocIndexOf;
});

// node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  var assocIndexOf = require__assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  module.exports = listCacheDelete;
});

// node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    return index2 < 0 ? undefined : data[index2][1];
  }
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheGet;
});

// node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheHas;
});

// node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  function listCacheSet(key, value15) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value15]);
    } else {
      data[index2][1] = value15;
    }
    return this;
  }
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheSet;
});

// node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  var listCacheClear = require__listCacheClear();
  var listCacheDelete = require__listCacheDelete();
  var listCacheGet = require__listCacheGet();
  var listCacheHas = require__listCacheHas();
  var listCacheSet = require__listCacheSet();
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// node_modules/lodash/_stackClear.js
var require__stackClear = __commonJS((exports, module) => {
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }
  var ListCache = require__ListCache();
  module.exports = stackClear;
});

// node_modules/lodash/_stackDelete.js
var require__stackDelete = __commonJS((exports, module) => {
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  module.exports = stackDelete;
});

// node_modules/lodash/_stackGet.js
var require__stackGet = __commonJS((exports, module) => {
  function stackGet(key) {
    return this.__data__.get(key);
  }
  module.exports = stackGet;
});

// node_modules/lodash/_stackHas.js
var require__stackHas = __commonJS((exports, module) => {
  function stackHas(key) {
    return this.__data__.has(key);
  }
  module.exports = stackHas;
});

// node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  var nativeCreate = require__nativeCreate();
  module.exports = hashClear;
});

// node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  module.exports = hashDelete;
});

// node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = hashGet;
});

// node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  var nativeCreate = require__nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = hashHas;
});

// node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  function hashSet(key, value15) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value15 === undefined ? HASH_UNDEFINED : value15;
    return this;
  }
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = hashSet;
});

// node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  function Hash3(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  var hashClear = require__hashClear();
  var hashDelete = require__hashDelete();
  var hashGet = require__hashGet();
  var hashHas = require__hashHas();
  var hashSet = require__hashSet();
  Hash3.prototype.clear = hashClear;
  Hash3.prototype["delete"] = hashDelete;
  Hash3.prototype.get = hashGet;
  Hash3.prototype.has = hashHas;
  Hash3.prototype.set = hashSet;
  module.exports = Hash3;
});

// node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash3,
      map: new (Map2 || ListCache),
      string: new Hash3
    };
  }
  var Hash3 = require__Hash();
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  module.exports = mapCacheClear;
});

// node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  function isKeyable(value15) {
    var type50 = typeof value15;
    return type50 == "string" || type50 == "number" || type50 == "symbol" || type50 == "boolean" ? value15 !== "__proto__" : value15 === null;
  }
  module.exports = isKeyable;
});

// node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  function getMapData(map4, key) {
    var data = map4.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  var isKeyable = require__isKeyable();
  module.exports = getMapData;
});

// node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var getMapData = require__getMapData();
  module.exports = mapCacheDelete;
});

// node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  var getMapData = require__getMapData();
  module.exports = mapCacheGet;
});

// node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  var getMapData = require__getMapData();
  module.exports = mapCacheHas;
});

// node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  function mapCacheSet(key, value15) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value15);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  var getMapData = require__getMapData();
  module.exports = mapCacheSet;
});

// node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  var mapCacheClear = require__mapCacheClear();
  var mapCacheDelete = require__mapCacheDelete();
  var mapCacheGet = require__mapCacheGet();
  var mapCacheHas = require__mapCacheHas();
  var mapCacheSet = require__mapCacheSet();
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// node_modules/lodash/_stackSet.js
var require__stackSet = __commonJS((exports, module) => {
  function stackSet(key, value15) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value15]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value15);
    this.size = data.size;
    return this;
  }
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  var MapCache = require__MapCache();
  var LARGE_ARRAY_SIZE = 200;
  module.exports = stackSet;
});

// node_modules/lodash/_Stack.js
var require__Stack = __commonJS((exports, module) => {
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  var ListCache = require__ListCache();
  var stackClear = require__stackClear();
  var stackDelete = require__stackDelete();
  var stackGet = require__stackGet();
  var stackHas = require__stackHas();
  var stackSet = require__stackSet();
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  module.exports = Stack;
});

// node_modules/lodash/_setCacheAdd.js
var require__setCacheAdd = __commonJS((exports, module) => {
  function setCacheAdd(value15) {
    this.__data__.set(value15, HASH_UNDEFINED);
    return this;
  }
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = setCacheAdd;
});

// node_modules/lodash/_setCacheHas.js
var require__setCacheHas = __commonJS((exports, module) => {
  function setCacheHas(value15) {
    return this.__data__.has(value15);
  }
  module.exports = setCacheHas;
});

// node_modules/lodash/_SetCache.js
var require__SetCache = __commonJS((exports, module) => {
  function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  var MapCache = require__MapCache();
  var setCacheAdd = require__setCacheAdd();
  var setCacheHas = require__setCacheHas();
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
});

// node_modules/lodash/_arraySome.js
var require__arraySome = __commonJS((exports, module) => {
  function arraySome(array5, predicate) {
    var index2 = -1, length = array5 == null ? 0 : array5.length;
    while (++index2 < length) {
      if (predicate(array5[index2], index2, array5)) {
        return true;
      }
    }
    return false;
  }
  module.exports = arraySome;
});

// node_modules/lodash/_cacheHas.js
var require__cacheHas = __commonJS((exports, module) => {
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  module.exports = cacheHas;
});

// node_modules/lodash/_equalArrays.js
var require__equalArrays = __commonJS((exports, module) => {
  function equalArrays(array5, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array5.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array5);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array5;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
    stack.set(array5, other);
    stack.set(other, array5);
    while (++index2 < arrLength) {
      var arrValue = array5[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array5, stack) : customizer(arrValue, othValue, index2, array5, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array5);
    stack["delete"](other);
    return result;
  }
  var SetCache = require__SetCache();
  var arraySome = require__arraySome();
  var cacheHas = require__cacheHas();
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  module.exports = equalArrays;
});

// node_modules/lodash/_Uint8Array.js
var require__Uint8Array = __commonJS((exports, module) => {
  var root = require__root();
  var Uint8Array3 = root.Uint8Array;
  module.exports = Uint8Array3;
});

// node_modules/lodash/_mapToArray.js
var require__mapToArray = __commonJS((exports, module) => {
  function mapToArray(map4) {
    var index2 = -1, result = Array(map4.size);
    map4.forEach(function(value15, key) {
      result[++index2] = [key, value15];
    });
    return result;
  }
  module.exports = mapToArray;
});

// node_modules/lodash/_setToArray.js
var require__setToArray = __commonJS((exports, module) => {
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value15) {
      result[++index2] = value15;
    });
    return result;
  }
  module.exports = setToArray;
});

// node_modules/lodash/_equalByTag.js
var require__equalByTag = __commonJS((exports, module) => {
  function equalByTag(object13, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object13.byteLength != other.byteLength || object13.byteOffset != other.byteOffset) {
          return false;
        }
        object13 = object13.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object13.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object13), new Uint8Array3(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object13, +other);
      case errorTag:
        return object13.name == other.name && object13.message == other.message;
      case regexpTag:
      case stringTag:
        return object13 == other + "";
      case mapTag:
        var convert4 = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert4 || (convert4 = setToArray);
        if (object13.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object13);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object13, other);
        var result = equalArrays(convert4(object13), convert4(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object13);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object13) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var Symbol3 = require__Symbol();
  var Uint8Array3 = require__Uint8Array();
  var eq = require_eq();
  var equalArrays = require__equalArrays();
  var mapToArray = require__mapToArray();
  var setToArray = require__setToArray();
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var symbolProto = Symbol3 ? Symbol3.prototype : undefined;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  module.exports = equalByTag;
});

// node_modules/lodash/_arrayPush.js
var require__arrayPush = __commonJS((exports, module) => {
  function arrayPush(array5, values) {
    var index2 = -1, length = values.length, offset = array5.length;
    while (++index2 < length) {
      array5[offset + index2] = values[index2];
    }
    return array5;
  }
  module.exports = arrayPush;
});

// node_modules/lodash/_baseGetAllKeys.js
var require__baseGetAllKeys = __commonJS((exports, module) => {
  function baseGetAllKeys(object13, keysFunc, symbolsFunc) {
    var result = keysFunc(object13);
    return isArray(object13) ? result : arrayPush(result, symbolsFunc(object13));
  }
  var arrayPush = require__arrayPush();
  var isArray = require_isArray();
  module.exports = baseGetAllKeys;
});

// node_modules/lodash/_arrayFilter.js
var require__arrayFilter = __commonJS((exports, module) => {
  function arrayFilter(array5, predicate) {
    var index2 = -1, length = array5 == null ? 0 : array5.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value15 = array5[index2];
      if (predicate(value15, index2, array5)) {
        result[resIndex++] = value15;
      }
    }
    return result;
  }
  module.exports = arrayFilter;
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS((exports, module) => {
  function stubArray() {
    return [];
  }
  module.exports = stubArray;
});

// node_modules/lodash/_getSymbols.js
var require__getSymbols = __commonJS((exports, module) => {
  var arrayFilter = require__arrayFilter();
  var stubArray = require_stubArray();
  var objectProto = Object.prototype;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object13) {
    if (object13 == null) {
      return [];
    }
    object13 = Object(object13);
    return arrayFilter(nativeGetSymbols(object13), function(symbol5) {
      return propertyIsEnumerable.call(object13, symbol5);
    });
  };
  module.exports = getSymbols;
});

// node_modules/lodash/keys.js
var require_keys = __commonJS((exports, module) => {
  function keys(object13) {
    return isArrayLike2(object13) ? arrayLikeKeys(object13) : baseKeys(object13);
  }
  var arrayLikeKeys = require__arrayLikeKeys();
  var baseKeys = require__baseKeys();
  var isArrayLike2 = require_isArrayLike();
  module.exports = keys;
});

// node_modules/lodash/_getAllKeys.js
var require__getAllKeys = __commonJS((exports, module) => {
  function getAllKeys(object13) {
    return baseGetAllKeys(object13, keys, getSymbols);
  }
  var baseGetAllKeys = require__baseGetAllKeys();
  var getSymbols = require__getSymbols();
  var keys = require_keys();
  module.exports = getAllKeys;
});

// node_modules/lodash/_equalObjects.js
var require__equalObjects = __commonJS((exports, module) => {
  function equalObjects(object13, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object13), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object13);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object13;
    }
    var result = true;
    stack.set(object13, other);
    stack.set(other, object13);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object13[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object13, stack) : customizer(objValue, othValue, key, object13, other, stack);
      }
      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object13.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && (("constructor" in object13) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object13);
    stack["delete"](other);
    return result;
  }
  var getAllKeys = require__getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = equalObjects;
});

// node_modules/lodash/_baseIsEqualDeep.js
var require__baseIsEqualDeep = __commonJS((exports, module) => {
  function baseIsEqualDeep(object13, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object13), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object13), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object13)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack);
      return objIsArr || isTypedArray(object13) ? equalArrays(object13, other, bitmask, customizer, equalFunc, stack) : equalByTag(object13, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object13, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object13.value() : object13, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object13, other, bitmask, customizer, equalFunc, stack);
  }
  var Stack = require__Stack();
  var equalArrays = require__equalArrays();
  var equalByTag = require__equalByTag();
  var equalObjects = require__equalObjects();
  var getTag = require__getTag();
  var isArray = require_isArray();
  var isBuffer = require_isBuffer();
  var isTypedArray = require_isTypedArray();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = baseIsEqualDeep;
});

// node_modules/lodash/_baseIsEqual.js
var require__baseIsEqual = __commonJS((exports, module) => {
  function baseIsEqual(value15, other, bitmask, customizer, stack) {
    if (value15 === other) {
      return true;
    }
    if (value15 == null || other == null || !isObjectLike(value15) && !isObjectLike(other)) {
      return value15 !== value15 && other !== other;
    }
    return baseIsEqualDeep(value15, other, bitmask, customizer, baseIsEqual, stack);
  }
  var baseIsEqualDeep = require__baseIsEqualDeep();
  var isObjectLike = require_isObjectLike();
  module.exports = baseIsEqual;
});

// node_modules/lodash/_baseIsMatch.js
var require__baseIsMatch = __commonJS((exports, module) => {
  function baseIsMatch(object13, source, matchData, customizer) {
    var index2 = matchData.length, length = index2, noCustomizer = !customizer;
    if (object13 == null) {
      return !length;
    }
    object13 = Object(object13);
    while (index2--) {
      var data = matchData[index2];
      if (noCustomizer && data[2] ? data[1] !== object13[data[0]] : !(data[0] in object13)) {
        return false;
      }
    }
    while (++index2 < length) {
      data = matchData[index2];
      var key = data[0], objValue = object13[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object13)) {
          return false;
        }
      } else {
        var stack = new Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object13, source, stack);
        }
        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  var Stack = require__Stack();
  var baseIsEqual = require__baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  module.exports = baseIsMatch;
});

// node_modules/lodash/_isStrictComparable.js
var require__isStrictComparable = __commonJS((exports, module) => {
  function isStrictComparable(value15) {
    return value15 === value15 && !isObject2(value15);
  }
  var isObject2 = require_isObject();
  module.exports = isStrictComparable;
});

// node_modules/lodash/_getMatchData.js
var require__getMatchData = __commonJS((exports, module) => {
  function getMatchData(object13) {
    var result = keys(object13), length = result.length;
    while (length--) {
      var key = result[length], value15 = object13[key];
      result[length] = [key, value15, isStrictComparable(value15)];
    }
    return result;
  }
  var isStrictComparable = require__isStrictComparable();
  var keys = require_keys();
  module.exports = getMatchData;
});

// node_modules/lodash/_matchesStrictComparable.js
var require__matchesStrictComparable = __commonJS((exports, module) => {
  function matchesStrictComparable(key, srcValue) {
    return function(object13) {
      if (object13 == null) {
        return false;
      }
      return object13[key] === srcValue && (srcValue !== undefined || (key in Object(object13)));
    };
  }
  module.exports = matchesStrictComparable;
});

// node_modules/lodash/_baseMatches.js
var require__baseMatches = __commonJS((exports, module) => {
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object13) {
      return object13 === source || baseIsMatch(object13, source, matchData);
    };
  }
  var baseIsMatch = require__baseIsMatch();
  var getMatchData = require__getMatchData();
  var matchesStrictComparable = require__matchesStrictComparable();
  module.exports = baseMatches;
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS((exports, module) => {
  function isSymbol(value15) {
    return typeof value15 == "symbol" || isObjectLike(value15) && baseGetTag(value15) == symbolTag;
  }
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var symbolTag = "[object Symbol]";
  module.exports = isSymbol;
});

// node_modules/lodash/_isKey.js
var require__isKey = __commonJS((exports, module) => {
  function isKey(value15, object13) {
    if (isArray(value15)) {
      return false;
    }
    var type50 = typeof value15;
    if (type50 == "number" || type50 == "symbol" || type50 == "boolean" || value15 == null || isSymbol(value15)) {
      return true;
    }
    return reIsPlainProp.test(value15) || !reIsDeepProp.test(value15) || object13 != null && value15 in Object(object13);
  }
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  module.exports = isKey;
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS((exports, module) => {
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }
  var MapCache = require__MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  memoize.Cache = MapCache;
  module.exports = memoize;
});

// node_modules/lodash/_memoizeCapped.js
var require__memoizeCapped = __commonJS((exports, module) => {
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  var memoize = require_memoize();
  var MAX_MEMOIZE_SIZE = 500;
  module.exports = memoizeCapped;
});

// node_modules/lodash/_stringToPath.js
var require__stringToPath = __commonJS((exports, module) => {
  var memoizeCapped = require__memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string7) {
    var result = [];
    if (string7.charCodeAt(0) === 46) {
      result.push("");
    }
    string7.replace(rePropName, function(match, number7, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number7 || match);
    });
    return result;
  });
  module.exports = stringToPath;
});

// node_modules/lodash/_baseToString.js
var require__baseToString = __commonJS((exports, module) => {
  function baseToString(value15) {
    if (typeof value15 == "string") {
      return value15;
    }
    if (isArray(value15)) {
      return arrayMap(value15, baseToString) + "";
    }
    if (isSymbol(value15)) {
      return symbolToString ? symbolToString.call(value15) : "";
    }
    var result = value15 + "";
    return result == "0" && 1 / value15 == -INFINITY ? "-0" : result;
  }
  var Symbol3 = require__Symbol();
  var arrayMap = require__arrayMap();
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol3 ? Symbol3.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  module.exports = baseToString;
});

// node_modules/lodash/toString.js
var require_toString = __commonJS((exports, module) => {
  function toString(value15) {
    return value15 == null ? "" : baseToString(value15);
  }
  var baseToString = require__baseToString();
  module.exports = toString;
});

// node_modules/lodash/_castPath.js
var require__castPath = __commonJS((exports, module) => {
  function castPath(value15, object13) {
    if (isArray(value15)) {
      return value15;
    }
    return isKey(value15, object13) ? [value15] : stringToPath(toString(value15));
  }
  var isArray = require_isArray();
  var isKey = require__isKey();
  var stringToPath = require__stringToPath();
  var toString = require_toString();
  module.exports = castPath;
});

// node_modules/lodash/_toKey.js
var require__toKey = __commonJS((exports, module) => {
  function toKey(value15) {
    if (typeof value15 == "string" || isSymbol(value15)) {
      return value15;
    }
    var result = value15 + "";
    return result == "0" && 1 / value15 == -INFINITY ? "-0" : result;
  }
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  module.exports = toKey;
});

// node_modules/lodash/_baseGet.js
var require__baseGet = __commonJS((exports, module) => {
  function baseGet(object13, path2) {
    path2 = castPath(path2, object13);
    var index2 = 0, length = path2.length;
    while (object13 != null && index2 < length) {
      object13 = object13[toKey(path2[index2++])];
    }
    return index2 && index2 == length ? object13 : undefined;
  }
  var castPath = require__castPath();
  var toKey = require__toKey();
  module.exports = baseGet;
});

// node_modules/lodash/get.js
var require_get = __commonJS((exports, module) => {
  function get(object13, path2, defaultValue) {
    var result = object13 == null ? undefined : baseGet(object13, path2);
    return result === undefined ? defaultValue : result;
  }
  var baseGet = require__baseGet();
  module.exports = get;
});

// node_modules/lodash/_baseHasIn.js
var require__baseHasIn = __commonJS((exports, module) => {
  function baseHasIn(object13, key) {
    return object13 != null && key in Object(object13);
  }
  module.exports = baseHasIn;
});

// node_modules/lodash/_hasPath.js
var require__hasPath = __commonJS((exports, module) => {
  function hasPath(object13, path2, hasFunc) {
    path2 = castPath(path2, object13);
    var index2 = -1, length = path2.length, result = false;
    while (++index2 < length) {
      var key = toKey(path2[index2]);
      if (!(result = object13 != null && hasFunc(object13, key))) {
        break;
      }
      object13 = object13[key];
    }
    if (result || ++index2 != length) {
      return result;
    }
    length = object13 == null ? 0 : object13.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object13) || isArguments(object13));
  }
  var castPath = require__castPath();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var isIndex = require__isIndex();
  var isLength = require_isLength();
  var toKey = require__toKey();
  module.exports = hasPath;
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS((exports, module) => {
  function hasIn(object13, path2) {
    return object13 != null && hasPath(object13, path2, baseHasIn);
  }
  var baseHasIn = require__baseHasIn();
  var hasPath = require__hasPath();
  module.exports = hasIn;
});

// node_modules/lodash/_baseMatchesProperty.js
var require__baseMatchesProperty = __commonJS((exports, module) => {
  function baseMatchesProperty(path2, srcValue) {
    if (isKey(path2) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path2), srcValue);
    }
    return function(object13) {
      var objValue = get(object13, path2);
      return objValue === undefined && objValue === srcValue ? hasIn(object13, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  var baseIsEqual = require__baseIsEqual();
  var get = require_get();
  var hasIn = require_hasIn();
  var isKey = require__isKey();
  var isStrictComparable = require__isStrictComparable();
  var matchesStrictComparable = require__matchesStrictComparable();
  var toKey = require__toKey();
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  module.exports = baseMatchesProperty;
});

// node_modules/lodash/_baseProperty.js
var require__baseProperty = __commonJS((exports, module) => {
  function baseProperty(key) {
    return function(object13) {
      return object13 == null ? undefined : object13[key];
    };
  }
  module.exports = baseProperty;
});

// node_modules/lodash/_basePropertyDeep.js
var require__basePropertyDeep = __commonJS((exports, module) => {
  function basePropertyDeep(path2) {
    return function(object13) {
      return baseGet(object13, path2);
    };
  }
  var baseGet = require__baseGet();
  module.exports = basePropertyDeep;
});

// node_modules/lodash/property.js
var require_property = __commonJS((exports, module) => {
  function property(path2) {
    return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
  }
  var baseProperty = require__baseProperty();
  var basePropertyDeep = require__basePropertyDeep();
  var isKey = require__isKey();
  var toKey = require__toKey();
  module.exports = property;
});

// node_modules/lodash/_baseIteratee.js
var require__baseIteratee = __commonJS((exports, module) => {
  function baseIteratee(value15) {
    if (typeof value15 == "function") {
      return value15;
    }
    if (value15 == null) {
      return identity;
    }
    if (typeof value15 == "object") {
      return isArray(value15) ? baseMatchesProperty(value15[0], value15[1]) : baseMatches(value15);
    }
    return property(value15);
  }
  var baseMatches = require__baseMatches();
  var baseMatchesProperty = require__baseMatchesProperty();
  var identity = require_identity();
  var isArray = require_isArray();
  var property = require_property();
  module.exports = baseIteratee;
});

// node_modules/lodash/_createBaseFor.js
var require__createBaseFor = __commonJS((exports, module) => {
  function createBaseFor(fromRight) {
    return function(object13, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object13), props = keysFunc(object13), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object13;
    };
  }
  module.exports = createBaseFor;
});

// node_modules/lodash/_baseFor.js
var require__baseFor = __commonJS((exports, module) => {
  var createBaseFor = require__createBaseFor();
  var baseFor = createBaseFor();
  module.exports = baseFor;
});

// node_modules/lodash/_baseForOwn.js
var require__baseForOwn = __commonJS((exports, module) => {
  function baseForOwn(object13, iteratee) {
    return object13 && baseFor(object13, iteratee, keys);
  }
  var baseFor = require__baseFor();
  var keys = require_keys();
  module.exports = baseForOwn;
});

// node_modules/lodash/_createBaseEach.js
var require__createBaseEach = __commonJS((exports, module) => {
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike2(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  var isArrayLike2 = require_isArrayLike();
  module.exports = createBaseEach;
});

// node_modules/lodash/_baseEach.js
var require__baseEach = __commonJS((exports, module) => {
  var baseForOwn = require__baseForOwn();
  var createBaseEach = require__createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  module.exports = baseEach;
});

// node_modules/lodash/_baseMap.js
var require__baseMap = __commonJS((exports, module) => {
  function baseMap(collection, iteratee) {
    var index2 = -1, result = isArrayLike2(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value15, key, collection2) {
      result[++index2] = iteratee(value15, key, collection2);
    });
    return result;
  }
  var baseEach = require__baseEach();
  var isArrayLike2 = require_isArrayLike();
  module.exports = baseMap;
});

// node_modules/lodash/map.js
var require_map = __commonJS((exports, module) => {
  function map4(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee, 3));
  }
  var arrayMap = require__arrayMap();
  var baseIteratee = require__baseIteratee();
  var baseMap = require__baseMap();
  var isArray = require_isArray();
  module.exports = map4;
});

// node_modules/lodash/_baseSlice.js
var require__baseSlice = __commonJS((exports, module) => {
  function baseSlice(array5, start, end) {
    var index2 = -1, length = array5.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index2 < length) {
      result[index2] = array5[index2 + start];
    }
    return result;
  }
  module.exports = baseSlice;
});

// node_modules/lodash/_trimmedEndIndex.js
var require__trimmedEndIndex = __commonJS((exports, module) => {
  function trimmedEndIndex(string7) {
    var index2 = string7.length;
    while (index2-- && reWhitespace.test(string7.charAt(index2))) {
    }
    return index2;
  }
  var reWhitespace = /\s/;
  module.exports = trimmedEndIndex;
});

// node_modules/lodash/_baseTrim.js
var require__baseTrim = __commonJS((exports, module) => {
  function baseTrim(string7) {
    return string7 ? string7.slice(0, trimmedEndIndex(string7) + 1).replace(reTrimStart, "") : string7;
  }
  var trimmedEndIndex = require__trimmedEndIndex();
  var reTrimStart = /^\s+/;
  module.exports = baseTrim;
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS((exports, module) => {
  function toNumber(value15) {
    if (typeof value15 == "number") {
      return value15;
    }
    if (isSymbol(value15)) {
      return NAN;
    }
    if (isObject2(value15)) {
      var other = typeof value15.valueOf == "function" ? value15.valueOf() : value15;
      value15 = isObject2(other) ? other + "" : other;
    }
    if (typeof value15 != "string") {
      return value15 === 0 ? value15 : +value15;
    }
    value15 = baseTrim(value15);
    var isBinary = reIsBinary.test(value15);
    return isBinary || reIsOctal.test(value15) ? freeParseInt(value15.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value15) ? NAN : +value15;
  }
  var baseTrim = require__baseTrim();
  var isObject2 = require_isObject();
  var isSymbol = require_isSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  module.exports = toNumber;
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS((exports, module) => {
  function toFinite(value15) {
    if (!value15) {
      return value15 === 0 ? value15 : 0;
    }
    value15 = toNumber(value15);
    if (value15 === INFINITY || value15 === -INFINITY) {
      var sign = value15 < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value15 === value15 ? value15 : 0;
  }
  var toNumber = require_toNumber();
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  module.exports = toFinite;
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS((exports, module) => {
  function toInteger(value15) {
    var result = toFinite(value15), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  var toFinite = require_toFinite();
  module.exports = toInteger;
});

// node_modules/lodash/take.js
var require_take = __commonJS((exports, module) => {
  function take(array5, n3, guard22) {
    if (!(array5 && array5.length)) {
      return [];
    }
    n3 = guard22 || n3 === undefined ? 1 : toInteger(n3);
    return baseSlice(array5, 0, n3 < 0 ? 0 : n3);
  }
  var baseSlice = require__baseSlice();
  var toInteger = require_toInteger();
  module.exports = take;
});

// node_modules/lodash/_baseAt.js
var require__baseAt = __commonJS((exports, module) => {
  function baseAt(object13, paths) {
    var index2 = -1, length = paths.length, result = Array(length), skip2 = object13 == null;
    while (++index2 < length) {
      result[index2] = skip2 ? undefined : get(object13, paths[index2]);
    }
    return result;
  }
  var get = require_get();
  module.exports = baseAt;
});

// node_modules/lodash/_isFlattenable.js
var require__isFlattenable = __commonJS((exports, module) => {
  function isFlattenable(value15) {
    return isArray(value15) || isArguments(value15) || !!(spreadableSymbol && value15 && value15[spreadableSymbol]);
  }
  var Symbol3 = require__Symbol();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : undefined;
  module.exports = isFlattenable;
});

// node_modules/lodash/_baseFlatten.js
var require__baseFlatten = __commonJS((exports, module) => {
  function baseFlatten(array5, depth, predicate, isStrict, result) {
    var index2 = -1, length = array5.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length) {
      var value15 = array5[index2];
      if (depth > 0 && predicate(value15)) {
        if (depth > 1) {
          baseFlatten(value15, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value15);
        }
      } else if (!isStrict) {
        result[result.length] = value15;
      }
    }
    return result;
  }
  var arrayPush = require__arrayPush();
  var isFlattenable = require__isFlattenable();
  module.exports = baseFlatten;
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS((exports, module) => {
  function flatten(array5) {
    var length = array5 == null ? 0 : array5.length;
    return length ? baseFlatten(array5, 1) : [];
  }
  var baseFlatten = require__baseFlatten();
  module.exports = flatten;
});

// node_modules/lodash/_flatRest.js
var require__flatRest = __commonJS((exports, module) => {
  function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + "");
  }
  var flatten = require_flatten();
  var overRest = require__overRest();
  var setToString = require__setToString();
  module.exports = flatRest;
});

// node_modules/lodash/at.js
var require_at = __commonJS((exports, module) => {
  var baseAt = require__baseAt();
  var flatRest = require__flatRest();
  var at = flatRest(baseAt);
  module.exports = at;
});

// node_modules/lodash/_arrayEach.js
var require__arrayEach = __commonJS((exports, module) => {
  function arrayEach(array5, iteratee) {
    var index2 = -1, length = array5 == null ? 0 : array5.length;
    while (++index2 < length) {
      if (iteratee(array5[index2], index2, array5) === false) {
        break;
      }
    }
    return array5;
  }
  module.exports = arrayEach;
});

// node_modules/lodash/_baseAssign.js
var require__baseAssign = __commonJS((exports, module) => {
  function baseAssign(object13, source) {
    return object13 && copyObject(source, keys(source), object13);
  }
  var copyObject = require__copyObject();
  var keys = require_keys();
  module.exports = baseAssign;
});

// node_modules/lodash/_baseAssignIn.js
var require__baseAssignIn = __commonJS((exports, module) => {
  function baseAssignIn(object13, source) {
    return object13 && copyObject(source, keysIn(source), object13);
  }
  var copyObject = require__copyObject();
  var keysIn = require_keysIn();
  module.exports = baseAssignIn;
});

// node_modules/lodash/_cloneBuffer.js
var require__cloneBuffer = __commonJS((exports, module) => {
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  var root = require__root();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined;
  module.exports = cloneBuffer;
});

// node_modules/lodash/_copyArray.js
var require__copyArray = __commonJS((exports, module) => {
  function copyArray(source, array5) {
    var index2 = -1, length = source.length;
    array5 || (array5 = Array(length));
    while (++index2 < length) {
      array5[index2] = source[index2];
    }
    return array5;
  }
  module.exports = copyArray;
});

// node_modules/lodash/_copySymbols.js
var require__copySymbols = __commonJS((exports, module) => {
  function copySymbols(source, object13) {
    return copyObject(source, getSymbols(source), object13);
  }
  var copyObject = require__copyObject();
  var getSymbols = require__getSymbols();
  module.exports = copySymbols;
});

// node_modules/lodash/_getSymbolsIn.js
var require__getSymbolsIn = __commonJS((exports, module) => {
  var arrayPush = require__arrayPush();
  var getPrototype = require__getPrototype();
  var getSymbols = require__getSymbols();
  var stubArray = require_stubArray();
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object13) {
    var result = [];
    while (object13) {
      arrayPush(result, getSymbols(object13));
      object13 = getPrototype(object13);
    }
    return result;
  };
  module.exports = getSymbolsIn;
});

// node_modules/lodash/_copySymbolsIn.js
var require__copySymbolsIn = __commonJS((exports, module) => {
  function copySymbolsIn(source, object13) {
    return copyObject(source, getSymbolsIn(source), object13);
  }
  var copyObject = require__copyObject();
  var getSymbolsIn = require__getSymbolsIn();
  module.exports = copySymbolsIn;
});

// node_modules/lodash/_getAllKeysIn.js
var require__getAllKeysIn = __commonJS((exports, module) => {
  function getAllKeysIn(object13) {
    return baseGetAllKeys(object13, keysIn, getSymbolsIn);
  }
  var baseGetAllKeys = require__baseGetAllKeys();
  var getSymbolsIn = require__getSymbolsIn();
  var keysIn = require_keysIn();
  module.exports = getAllKeysIn;
});

// node_modules/lodash/_initCloneArray.js
var require__initCloneArray = __commonJS((exports, module) => {
  function initCloneArray(array5) {
    var length = array5.length, result = new array5.constructor(length);
    if (length && typeof array5[0] == "string" && hasOwnProperty.call(array5, "index")) {
      result.index = array5.index;
      result.input = array5.input;
    }
    return result;
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = initCloneArray;
});

// node_modules/lodash/_cloneArrayBuffer.js
var require__cloneArrayBuffer = __commonJS((exports, module) => {
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
    return result;
  }
  var Uint8Array3 = require__Uint8Array();
  module.exports = cloneArrayBuffer;
});

// node_modules/lodash/_cloneDataView.js
var require__cloneDataView = __commonJS((exports, module) => {
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  var cloneArrayBuffer = require__cloneArrayBuffer();
  module.exports = cloneDataView;
});

// node_modules/lodash/_cloneRegExp.js
var require__cloneRegExp = __commonJS((exports, module) => {
  function cloneRegExp(regexp4) {
    var result = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
    result.lastIndex = regexp4.lastIndex;
    return result;
  }
  var reFlags = /\w*$/;
  module.exports = cloneRegExp;
});

// node_modules/lodash/_cloneSymbol.js
var require__cloneSymbol = __commonJS((exports, module) => {
  function cloneSymbol(symbol5) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol5)) : {};
  }
  var Symbol3 = require__Symbol();
  var symbolProto = Symbol3 ? Symbol3.prototype : undefined;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  module.exports = cloneSymbol;
});

// node_modules/lodash/_cloneTypedArray.js
var require__cloneTypedArray = __commonJS((exports, module) => {
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  var cloneArrayBuffer = require__cloneArrayBuffer();
  module.exports = cloneTypedArray;
});

// node_modules/lodash/_initCloneByTag.js
var require__initCloneByTag = __commonJS((exports, module) => {
  function initCloneByTag(object13, tag, isDeep) {
    var Ctor = object13.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object13);
      case boolTag:
      case dateTag:
        return new Ctor(+object13);
      case dataViewTag:
        return cloneDataView(object13, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object13, isDeep);
      case mapTag:
        return new Ctor;
      case numberTag:
      case stringTag:
        return new Ctor(object13);
      case regexpTag:
        return cloneRegExp(object13);
      case setTag:
        return new Ctor;
      case symbolTag:
        return cloneSymbol(object13);
    }
  }
  var cloneArrayBuffer = require__cloneArrayBuffer();
  var cloneDataView = require__cloneDataView();
  var cloneRegExp = require__cloneRegExp();
  var cloneSymbol = require__cloneSymbol();
  var cloneTypedArray = require__cloneTypedArray();
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  module.exports = initCloneByTag;
});

// node_modules/lodash/_baseCreate.js
var require__baseCreate = __commonJS((exports, module) => {
  var isObject2 = require_isObject();
  var objectCreate = Object.create;
  var baseCreate = function() {
    function object13() {
    }
    return function(proto2) {
      if (!isObject2(proto2)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto2);
      }
      object13.prototype = proto2;
      var result = new object13;
      object13.prototype = undefined;
      return result;
    };
  }();
  module.exports = baseCreate;
});

// node_modules/lodash/_initCloneObject.js
var require__initCloneObject = __commonJS((exports, module) => {
  function initCloneObject(object13) {
    return typeof object13.constructor == "function" && !isPrototype(object13) ? baseCreate(getPrototype(object13)) : {};
  }
  var baseCreate = require__baseCreate();
  var getPrototype = require__getPrototype();
  var isPrototype = require__isPrototype();
  module.exports = initCloneObject;
});

// node_modules/lodash/_baseIsMap.js
var require__baseIsMap = __commonJS((exports, module) => {
  function baseIsMap(value15) {
    return isObjectLike(value15) && getTag(value15) == mapTag;
  }
  var getTag = require__getTag();
  var isObjectLike = require_isObjectLike();
  var mapTag = "[object Map]";
  module.exports = baseIsMap;
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS((exports, module) => {
  var baseIsMap = require__baseIsMap();
  var baseUnary = require__baseUnary();
  var nodeUtil = require__nodeUtil();
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  module.exports = isMap;
});

// node_modules/lodash/_baseIsSet.js
var require__baseIsSet = __commonJS((exports, module) => {
  function baseIsSet(value15) {
    return isObjectLike(value15) && getTag(value15) == setTag;
  }
  var getTag = require__getTag();
  var isObjectLike = require_isObjectLike();
  var setTag = "[object Set]";
  module.exports = baseIsSet;
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS((exports, module) => {
  var baseIsSet = require__baseIsSet();
  var baseUnary = require__baseUnary();
  var nodeUtil = require__nodeUtil();
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  module.exports = isSet;
});

// node_modules/lodash/_baseClone.js
var require__baseClone = __commonJS((exports, module) => {
  function baseClone(value15, bitmask, customizer, key, object13, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
      result = object13 ? customizer(value15, key, object13, stack) : customizer(value15);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject2(value15)) {
      return value15;
    }
    var isArr = isArray(value15);
    if (isArr) {
      result = initCloneArray(value15);
      if (!isDeep) {
        return copyArray(value15, result);
      }
    } else {
      var tag = getTag(value15), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value15)) {
        return cloneBuffer(value15, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object13) {
        result = isFlat || isFunc ? {} : initCloneObject(value15);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value15, baseAssignIn(result, value15)) : copySymbols(value15, baseAssign(result, value15));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object13 ? value15 : {};
        }
        result = initCloneByTag(value15, tag, isDeep);
      }
    }
    stack || (stack = new Stack);
    var stacked = stack.get(value15);
    if (stacked) {
      return stacked;
    }
    stack.set(value15, result);
    if (isSet(value15)) {
      value15.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value15, stack));
      });
    } else if (isMap(value15)) {
      value15.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value15, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? undefined : keysFunc(value15);
    arrayEach(props || value15, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value15[key2];
      }
      assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value15, stack));
    });
    return result;
  }
  var Stack = require__Stack();
  var arrayEach = require__arrayEach();
  var assignValue = require__assignValue();
  var baseAssign = require__baseAssign();
  var baseAssignIn = require__baseAssignIn();
  var cloneBuffer = require__cloneBuffer();
  var copyArray = require__copyArray();
  var copySymbols = require__copySymbols();
  var copySymbolsIn = require__copySymbolsIn();
  var getAllKeys = require__getAllKeys();
  var getAllKeysIn = require__getAllKeysIn();
  var getTag = require__getTag();
  var initCloneArray = require__initCloneArray();
  var initCloneByTag = require__initCloneByTag();
  var initCloneObject = require__initCloneObject();
  var isArray = require_isArray();
  var isBuffer = require_isBuffer();
  var isMap = require_isMap();
  var isObject2 = require_isObject();
  var isSet = require_isSet();
  var keys = require_keys();
  var keysIn = require_keysIn();
  var CLONE_DEEP_FLAG = 1;
  var CLONE_FLAT_FLAG = 2;
  var CLONE_SYMBOLS_FLAG = 4;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  module.exports = baseClone;
});

// node_modules/lodash/clone.js
var require_clone = __commonJS((exports, module) => {
  function clone13(value15) {
    return baseClone(value15, CLONE_SYMBOLS_FLAG);
  }
  var baseClone = require__baseClone();
  var CLONE_SYMBOLS_FLAG = 4;
  module.exports = clone13;
});

// node_modules/lodash/_baseFilter.js
var require__baseFilter = __commonJS((exports, module) => {
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value15, index2, collection2) {
      if (predicate(value15, index2, collection2)) {
        result.push(value15);
      }
    });
    return result;
  }
  var baseEach = require__baseEach();
  module.exports = baseFilter;
});

// node_modules/lodash/filter.js
var require_filter = __commonJS((exports, module) => {
  function filter2(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, baseIteratee(predicate, 3));
  }
  var arrayFilter = require__arrayFilter();
  var baseFilter = require__baseFilter();
  var baseIteratee = require__baseIteratee();
  var isArray = require_isArray();
  module.exports = filter2;
});

// node_modules/lodash/_baseFindIndex.js
var require__baseFindIndex = __commonJS((exports, module) => {
  function baseFindIndex(array5, predicate, fromIndex, fromRight) {
    var length = array5.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length) {
      if (predicate(array5[index2], index2, array5)) {
        return index2;
      }
    }
    return -1;
  }
  module.exports = baseFindIndex;
});

// node_modules/lodash/_baseIsNaN.js
var require__baseIsNaN = __commonJS((exports, module) => {
  function baseIsNaN(value15) {
    return value15 !== value15;
  }
  module.exports = baseIsNaN;
});

// node_modules/lodash/_strictIndexOf.js
var require__strictIndexOf = __commonJS((exports, module) => {
  function strictIndexOf(array5, value15, fromIndex) {
    var index2 = fromIndex - 1, length = array5.length;
    while (++index2 < length) {
      if (array5[index2] === value15) {
        return index2;
      }
    }
    return -1;
  }
  module.exports = strictIndexOf;
});

// node_modules/lodash/_baseIndexOf.js
var require__baseIndexOf = __commonJS((exports, module) => {
  function baseIndexOf(array5, value15, fromIndex) {
    return value15 === value15 ? strictIndexOf(array5, value15, fromIndex) : baseFindIndex(array5, baseIsNaN, fromIndex);
  }
  var baseFindIndex = require__baseFindIndex();
  var baseIsNaN = require__baseIsNaN();
  var strictIndexOf = require__strictIndexOf();
  module.exports = baseIndexOf;
});

// node_modules/lodash/_baseValues.js
var require__baseValues = __commonJS((exports, module) => {
  function baseValues(object13, props) {
    return arrayMap(props, function(key) {
      return object13[key];
    });
  }
  var arrayMap = require__arrayMap();
  module.exports = baseValues;
});

// node_modules/lodash/values.js
var require_values = __commonJS((exports, module) => {
  function values(object13) {
    return object13 == null ? [] : baseValues(object13, keys(object13));
  }
  var baseValues = require__baseValues();
  var keys = require_keys();
  module.exports = values;
});

// node_modules/lodash/includes.js
var require_includes = __commonJS((exports, module) => {
  function includes2(collection, value15, fromIndex, guard22) {
    collection = isArrayLike2(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard22 ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString2(collection) ? fromIndex <= length && collection.indexOf(value15, fromIndex) > -1 : !!length && baseIndexOf(collection, value15, fromIndex) > -1;
  }
  var baseIndexOf = require__baseIndexOf();
  var isArrayLike2 = require_isArrayLike();
  var isString2 = require_isString();
  var toInteger = require_toInteger();
  var values = require_values();
  var nativeMax = Math.max;
  module.exports = includes2;
});

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS((exports, module) => {
  function isNumber2(value15) {
    return typeof value15 == "number" || isObjectLike(value15) && baseGetTag(value15) == numberTag;
  }
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var numberTag = "[object Number]";
  module.exports = isNumber2;
});

// node_modules/cloudinary/lib/utils/encoding/smart_escape.js
var require_smart_escape = __commonJS((exports, module) => {
  function smart_escape(string7, unsafe5 = /([^a-zA-Z0-9_.\-\/:]+)/g) {
    return string7.replace(unsafe5, function(match) {
      return match.split("").map(function(c3) {
        return "%" + c3.charCodeAt(0).toString(16).toUpperCase();
      }).join("");
    });
  }
  module.exports = smart_escape;
});

// node_modules/cloudinary/lib/utils/parsing/consumeOption.js
var require_consumeOption = __commonJS((exports, module) => {
  function consumeOption(options, option_name, default_value) {
    let result = options[option_name];
    delete options[option_name];
    return result != null ? result : default_value;
  }
  module.exports = consumeOption;
});

// node_modules/cloudinary/lib/utils/parsing/toArray.js
var require_toArray = __commonJS((exports, module) => {
  function toArray2(arg) {
    switch (true) {
      case arg == null:
        return [];
      case isArray(arg):
        return arg;
      default:
        return [arg];
    }
  }
  var isArray = require_isArray();
  module.exports = toArray2;
});

// node_modules/cloudinary/lib/utils/encoding/base64Encode.js
var require_base64Encode = __commonJS((exports, module) => {
  function base64Encode(input) {
    if (!(input instanceof Buffer)) {
      input = Buffer.from(String(input), "binary");
    }
    return input.toString("base64");
  }
  exports.base64Encode = base64Encode;
});

// node_modules/cloudinary/lib/utils/encoding/base64EncodeURL.js
var require_base64EncodeURL = __commonJS((exports, module) => {
  function base64EncodeURL(sourceUrl) {
    try {
      sourceUrl = decodeURI(sourceUrl);
    } catch (error23) {
    }
    sourceUrl = encodeURI(sourceUrl);
    return base64Encode(sourceUrl).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  var { base64Encode } = require_base64Encode();
  exports.base64EncodeURL = base64EncodeURL;
});

// node_modules/cloudinary/lib/utils/encoding/encodeDoubleArray.js
var require_encodeDoubleArray = __commonJS((exports, module) => {
  function encodeDoubleArray(array5) {
    array5 = toArray2(array5);
    if (!isArray(array5[0])) {
      array5 = [array5];
    }
    return array5.map((e) => toArray2(e).join(",")).join("|");
  }
  var isArray = require_isArray();
  var toArray2 = require_toArray();
  module.exports = encodeDoubleArray;
});

// node_modules/cloudinary/lib/auth_token.js
var require_auth_token = __commonJS((exports, module) => {
  function digest(message, key) {
    return crypto8.createHmac("sha256", Buffer.from(key, "hex")).update(message).digest("hex");
  }
  function escapeToLower(url) {
    const safeUrl = smart_escape(url, unsafe5);
    return safeUrl.replace(/%../g, function(match) {
      return match.toLowerCase();
    });
  }
  var crypto8 = import.meta.require("crypto");
  var smart_escape = require_smart_escape();
  var unsafe5 = /([ "#%&'/:;<=>?@[\]^`{|}~]+)/g;
  module.exports = function(options) {
    const tokenName = options.token_name ? options.token_name : "__cld_token__";
    const tokenSeparator = "~";
    if (options.expiration == null) {
      if (options.duration != null) {
        let start = options.start_time != null ? options.start_time : Math.round(Date.now() / 1000);
        options.expiration = start + options.duration;
      } else {
        throw new Error("Must provide either expiration or duration");
      }
    }
    let tokenParts = [];
    if (options.ip != null) {
      tokenParts.push(`ip=${options.ip}`);
    }
    if (options.start_time != null) {
      tokenParts.push(`st=${options.start_time}`);
    }
    tokenParts.push(`exp=${options.expiration}`);
    if (options.acl != null) {
      if (Array.isArray(options.acl) === true) {
        options.acl = options.acl.join("!");
      }
      tokenParts.push(`acl=${escapeToLower(options.acl)}`);
    }
    let toSign = [...tokenParts];
    if (options.url != null && options.acl == null) {
      let url = escapeToLower(options.url);
      toSign.push(`url=${url}`);
    }
    let auth3 = digest(toSign.join(tokenSeparator), options.key);
    tokenParts.push(`hmac=${auth3}`);
    if (!options.url && !options.acl) {
      throw "authToken must contain either an acl or a url property";
    }
    return `${tokenName}=${tokenParts.join(tokenSeparator)}`;
  };
});

// node_modules/cloudinary/lib/utils/utf8_encode.js
var require_utf8_encode = __commonJS((exports, module) => {
  module.exports = function utf8_encode(argString) {
    let c12, enc, n3;
    if (argString == null) {
      return "";
    }
    let string7 = argString + "";
    let utftext = "";
    let start = 0;
    let end = 0;
    let stringl = string7.length;
    n3 = 0;
    while (n3 < stringl) {
      c12 = string7.charCodeAt(n3);
      enc = null;
      if (c12 < 128) {
        end++;
      } else if (c12 > 127 && c12 < 2048) {
        enc = String.fromCharCode(c12 >> 6 | 192, c12 & 63 | 128);
      } else {
        enc = String.fromCharCode(c12 >> 12 | 224, c12 >> 6 & 63 | 128, c12 & 63 | 128);
      }
      if (enc !== null) {
        if (end > start) {
          utftext += string7.slice(start, end);
        }
        utftext += enc;
        start = n3 + 1;
        end = start;
      }
      n3++;
    }
    if (end > start) {
      utftext += string7.slice(start, stringl);
    }
    return utftext;
  };
});

// node_modules/cloudinary/lib/utils/crc32.js
var require_crc32 = __commonJS((exports, module) => {
  function crc322(str) {
    let crc, i3, iTop, table, x3, y3;
    str = utf8_encode(str);
    table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";
    crc = 0;
    x3 = 0;
    y3 = 0;
    crc = crc ^ -1;
    i3 = 0;
    iTop = str.length;
    while (i3 < iTop) {
      y3 = (crc ^ str.charCodeAt(i3)) & 255;
      x3 = "0x" + table.substr(y3 * 9, 8);
      crc = crc >>> 8 ^ x3;
      i3++;
    }
    crc = crc ^ -1;
    if (crc < 0) {
      crc += 4294967296;
    }
    return crc;
  }
  var utf8_encode = require_utf8_encode();
  module.exports = crc322;
});

// node_modules/cloudinary/lib/utils/ensurePresenceOf.js
var require_ensurePresenceOf = __commonJS((exports, module) => {
  function ensurePresenceOf(parameters4) {
    let missing = Object.keys(parameters4).filter((key) => parameters4[key] === undefined);
    if (missing.length) {
      console.error(missing.join(",") + " cannot be undefined");
    }
  }
  module.exports = ensurePresenceOf;
});

// node_modules/cloudinary/lib/utils/ensureOption.js
var require_ensureOption = __commonJS((exports, module) => {
  function defaults(defaultOptions2) {
    return function ensureOption(options, name, defaultValue) {
      let value15;
      if (typeof options[name] !== "undefined") {
        value15 = options[name];
      } else if (typeof defaultOptions2[name] !== "undefined") {
        value15 = defaultOptions2[name];
      } else if (typeof defaultValue !== "undefined") {
        value15 = defaultValue;
      } else {
        throw new Error(`Must supply ${name}`);
      }
      return value15;
    };
  }
  module.exports = defaults({});
  module.exports.defaults = defaults;
});

// node_modules/cloudinary/lib/utils/isRemoteUrl.js
var require_isRemoteUrl = __commonJS((exports, module) => {
  function isRemoteUrl(url) {
    const SUBSTRING_LENGTH = 120;
    const urlSubstring = isString2(url) && url.substring(0, SUBSTRING_LENGTH);
    return isString2(url) && /^ftp:|^https?:|^gs:|^s3:|^data:([\w-.]+\/[\w-.]+(\+[\w-.]+)?)?(;[\w-.]+=[\w-.]+)*;base64,([a-zA-Z0-9\/+\n=]+)$/.test(urlSubstring);
  }
  var isString2 = require_isString();
  module.exports = isRemoteUrl;
});

// node_modules/cloudinary/lib/utils/analytics/getSDKVersions.js
var require_getSDKVersions = __commonJS((exports, module) => {
  function readSdkSemver() {
    const pkgJsonPath = path2.join(__dirname, "../../../package.json");
    try {
      const pkgJSONFile = fs4.readFileSync(pkgJsonPath, "utf-8");
      return JSON.parse(pkgJSONFile).version;
    } catch (e) {
      if (e.code === "ENOENT") {
        return "0.0.0";
      }
      return "n/a";
    }
  }
  function getSDKVersions(useSDKVersion = "default", useNodeVersion = "default") {
    const sdkSemver = useSDKVersion === "default" ? readSdkSemver() : useSDKVersion;
    const techVersion = useNodeVersion === "default" ? process.versions.node : useNodeVersion;
    const product = "A";
    return {
      sdkSemver,
      techVersion,
      sdkCode,
      product
    };
  }
  var __dirname = "/home/natee/workspace/portfolio-v3-api/node_modules/cloudinary/lib/utils/analytics";
  var fs4 = import.meta.require("fs");
  var path2 = import.meta.require("path");
  var sdkCode = "M";
  module.exports = getSDKVersions;
});

// node_modules/cloudinary/lib/utils/analytics/removePatchFromSemver.js
var require_removePatchFromSemver = __commonJS((exports, module) => {
  module.exports = (semVerStr) => {
    let parts = semVerStr.split(".");
    return `${parts[0]}.${parts[1]}`;
  };
});

// node_modules/cloudinary/lib/utils/analytics/stringPad.js
var require_stringPad = __commonJS((exports, module) => {
  function repeatStringNumTimes(string7, times) {
    let repeatedString = "";
    while (times > 0) {
      repeatedString += string7;
      times--;
    }
    return repeatedString;
  }
  module.exports = (value15, targetLength, padString) => {
    targetLength = targetLength >> 0;
    padString = String(typeof padString !== "undefined" ? padString : " ");
    if (value15.length > targetLength) {
      return String(value15);
    } else {
      targetLength = targetLength - value15.length;
      if (targetLength > padString.length) {
        padString += repeatStringNumTimes(padString, targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + String(value15);
    }
  };
});

// node_modules/cloudinary/lib/utils/analytics/reverseVersion.js
var require_reverseVersion = __commonJS((exports, module) => {
  var stringPad = require_stringPad();
  module.exports = (semVer) => {
    if (semVer.split(".").length < 2) {
      throw new Error("invalid semVer, must have at least two segments");
    }
    return semVer.split(".").reverse().map((segment) => {
      return stringPad(segment, 2, "0");
    }).join(".");
  };
});

// node_modules/cloudinary/lib/utils/encoding/base64Map.js
var require_base64Map = __commonJS((exports, module) => {
  var stringPad = require_stringPad();
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var num = 0;
  var base64Map = {};
  [...chars].forEach((char) => {
    let key = num.toString(2);
    key = stringPad(key, 6, "0");
    base64Map[key] = char;
    num++;
  });
  module.exports = base64Map;
});

// node_modules/cloudinary/lib/utils/analytics/encodeVersion.js
var require_encodeVersion = __commonJS((exports, module) => {
  var reverseVersion = require_reverseVersion();
  var stringPad = require_stringPad();
  var base64Map = require_base64Map();
  module.exports = (semVer) => {
    let strResult = "";
    let parts = semVer.split(".").length;
    let paddedStringLength = parts * 6;
    let paddedReversedSemver = reverseVersion(semVer);
    let num = parseInt(paddedReversedSemver.split(".").join(""));
    let paddedBinary = num.toString(2);
    paddedBinary = stringPad(paddedBinary, paddedStringLength, "0");
    if (paddedBinary.length % 6 !== 0) {
      throw "Version must be smaller than 43.21.26)";
    }
    paddedBinary.match(/.{1,6}/g).forEach((bitString) => {
      strResult += base64Map[bitString];
    });
    return strResult;
  };
});

// node_modules/cloudinary/lib/utils/analytics/index.js
var require_analytics = __commonJS((exports, module) => {
  function getSDKAnalyticsSignature(analyticsOptions = {}) {
    try {
      const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);
      const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);
      const encodedTechVersion = encodeVersion(twoPartVersion);
      const featureCode = analyticsOptions.feature;
      const SDKCode = analyticsOptions.sdkCode;
      const product = analyticsOptions.product;
      const algoVersion = "B";
      return `${algoVersion}${product}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${featureCode}`;
    } catch (e) {
      return "E";
    }
  }
  function getAnalyticsOptions(options) {
    let analyticsOptions = {
      sdkSemver: options.sdkSemver,
      techVersion: options.techVersion,
      sdkCode: options.sdkCode,
      product: options.product,
      feature: "0"
    };
    if (options.urlAnalytics) {
      if (options.accessibility) {
        analyticsOptions.feature = "D";
      }
      if (options.loading === "lazy") {
        analyticsOptions.feature = "C";
      }
      if (options.responsive) {
        analyticsOptions.feature = "A";
      }
      if (options.placeholder) {
        analyticsOptions.feature = "B";
      }
      return analyticsOptions;
    } else {
      return {};
    }
  }
  var removePatchFromSemver = require_removePatchFromSemver();
  var encodeVersion = require_encodeVersion();
  module.exports = {
    getSDKAnalyticsSignature,
    getAnalyticsOptions
  };
});

// node_modules/cloudinary/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    author: "Cloudinary <info@cloudinary.com>",
    name: "cloudinary",
    description: "Cloudinary NPM for node.js integration",
    version: "2.4.0",
    homepage: "https://cloudinary.com",
    license: "MIT",
    repository: {
      type: "git",
      url: "https://github.com/cloudinary/cloudinary_npm.git"
    },
    main: "cloudinary.js",
    dependencies: {
      lodash: "^4.17.21",
      q: "^1.5.1"
    },
    devDependencies: {
      "@types/mocha": "^7.0.2",
      "@types/node": "^13.5.0",
      "@types/expect.js": "^0.3.29",
      "date-fns": "^2.16.1",
      dotenv: "4.x",
      dtslint: "^0.9.1",
      eslint: "^6.8.0",
      "eslint-config-airbnb-base": "^14.2.1",
      "eslint-plugin-import": "^2.20.2",
      "expect.js": "0.3.x",
      glob: "^7.1.6",
      jsdoc: "3.5.5",
      jsdom: "^9.12.0",
      "jsdom-global": "2.1.1",
      mocha: "^6.2.3",
      "mock-fs": "^4.12.0",
      nyc: "^13.3.0",
      rimraf: "^3.0.0",
      sinon: "^6.1.4",
      typescript: "^3.7.5",
      "webpack-cli": "^3.2.1"
    },
    files: [
      "lib/**/*",
      "cloudinary.js",
      "babel.config.js",
      "package.json",
      "types/index.d.ts"
    ],
    types: "types",
    scripts: {
      test: "tools/scripts/test.sh",
      "test:unit": "tools/scripts/test.es6.unit.sh",
      "test-with-temp-cloud": "tools/scripts/tests-with-temp-cloud.sh",
      dtslint: "tools/scripts/ditslint.sh",
      lint: "tools/scripts/lint.sh",
      coverage: "tools/scripts/test.es6.sh --coverage",
      "test-es6": "tools/scripts/test.es6.sh",
      docs: "tools/scripts/docs.sh"
    },
    engines: {
      node: ">=9"
    }
  };
});

// node_modules/cloudinary/lib/utils/consts.js
var require_consts = __commonJS((exports, module) => {
  var DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION = {
    width: "auto",
    crop: "limit"
  };
  var DEFAULT_POSTER_OPTIONS = {
    format: "jpg",
    resource_type: "video"
  };
  var DEFAULT_VIDEO_SOURCE_TYPES = ["webm", "mp4", "ogv"];
  var CONDITIONAL_OPERATORS = {
    "=": "eq",
    "!=": "ne",
    "<": "lt",
    ">": "gt",
    "<=": "lte",
    ">=": "gte",
    "&&": "and",
    "||": "or",
    "*": "mul",
    "/": "div",
    "+": "add",
    "-": "sub",
    "^": "pow"
  };
  var SIMPLE_PARAMS = [
    ["audio_codec", "ac"],
    ["audio_frequency", "af"],
    ["bit_rate", "br"],
    ["color_space", "cs"],
    ["default_image", "d"],
    ["delay", "dl"],
    ["density", "dn"],
    ["duration", "du"],
    ["end_offset", "eo"],
    ["fetch_format", "f"],
    ["gravity", "g"],
    ["page", "pg"],
    ["prefix", "p"],
    ["start_offset", "so"],
    ["streaming_profile", "sp"],
    ["video_codec", "vc"],
    ["video_sampling", "vs"]
  ];
  var PREDEFINED_VARS = {
    aspect_ratio: "ar",
    aspectRatio: "ar",
    current_page: "cp",
    currentPage: "cp",
    duration: "du",
    face_count: "fc",
    faceCount: "fc",
    height: "h",
    initial_aspect_ratio: "iar",
    initial_height: "ih",
    initial_width: "iw",
    initialAspectRatio: "iar",
    initialHeight: "ih",
    initialWidth: "iw",
    initial_duration: "idu",
    initialDuration: "idu",
    page_count: "pc",
    page_x: "px",
    page_y: "py",
    pageCount: "pc",
    pageX: "px",
    pageY: "py",
    tags: "tags",
    width: "w"
  };
  var TRANSFORMATION_PARAMS = [
    "angle",
    "aspect_ratio",
    "audio_codec",
    "audio_frequency",
    "background",
    "bit_rate",
    "border",
    "color",
    "color_space",
    "crop",
    "default_image",
    "delay",
    "density",
    "dpr",
    "duration",
    "effect",
    "end_offset",
    "fetch_format",
    "flags",
    "fps",
    "gravity",
    "height",
    "if",
    "keyframe_interval",
    "offset",
    "opacity",
    "overlay",
    "page",
    "prefix",
    "quality",
    "radius",
    "raw_transformation",
    "responsive_width",
    "size",
    "start_offset",
    "streaming_profile",
    "transformation",
    "underlay",
    "variables",
    "video_codec",
    "video_sampling",
    "width",
    "x",
    "y",
    "zoom"
  ];
  var LAYER_KEYWORD_PARAMS = {
    font_weight: "normal",
    font_style: "normal",
    text_decoration: "none",
    text_align: null,
    stroke: "none"
  };
  var UPLOAD_PREFIX = "https://api.cloudinary.com";
  var SUPPORTED_SIGNATURE_ALGORITHMS = ["sha1", "sha256"];
  var DEFAULT_SIGNATURE_ALGORITHM = "sha1";
  module.exports = {
    DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION,
    DEFAULT_POSTER_OPTIONS,
    DEFAULT_VIDEO_SOURCE_TYPES,
    CONDITIONAL_OPERATORS,
    PREDEFINED_VARS,
    LAYER_KEYWORD_PARAMS,
    TRANSFORMATION_PARAMS,
    SIMPLE_PARAMS,
    UPLOAD_PREFIX,
    SUPPORTED_SIGNATURE_ALGORITHMS,
    DEFAULT_SIGNATURE_ALGORITHM
  };
});

// node_modules/cloudinary/lib/utils/index.js
var require_utils = __commonJS((exports, module) => {
  function generate_auth_token(options) {
    let token_options = Object.assign({}, config2().auth_token, options);
    return generate_token(token_options);
  }
  function getUserAgent() {
    return isEmpty2(utils.userPlatform) ? `${utils.USER_AGENT}` : `${utils.userPlatform} ${utils.USER_AGENT}`;
  }
  function textStyle(layer) {
    let keywords = [];
    let style = "";
    if (!isEmpty2(layer.text_style)) {
      return layer.text_style;
    }
    Object.keys(LAYER_KEYWORD_PARAMS).forEach((attr) => {
      let default_value = LAYER_KEYWORD_PARAMS[attr];
      let attr_value = layer[attr] || default_value;
      if (attr_value !== default_value) {
        keywords.push(attr_value);
      }
    });
    Object.keys(layer).forEach((attr) => {
      if (attr === "letter_spacing" || attr === "line_spacing") {
        keywords.push(`${attr}_${layer[attr]}`);
      }
      if (attr === "font_hinting") {
        keywords.push(`${attr.split("_").pop()}_${layer[attr]}`);
      }
      if (attr === "font_antialiasing") {
        keywords.push(`antialias_${layer[attr]}`);
      }
    });
    if (layer.hasOwnProperty("font_size") || !isEmpty2(keywords)) {
      if (!layer.font_size)
        throw new Error("Must supply font_size for text in overlay/underlay");
      if (!layer.font_family)
        throw new Error("Must supply font_family for text in overlay/underlay");
      keywords.unshift(layer.font_size);
      keywords.unshift(layer.font_family);
      style = compact(keywords).join("_");
    }
    return style;
  }
  function normalize_expression(expression) {
    if (!isString2(expression) || expression.length === 0 || expression.match(/^!.+!$/)) {
      return expression;
    }
    const operators = "\\|\\||>=|<=|&&|!=|>|=|<|/|-|\\^|\\+|\\*";
    const operatorsPattern = "((" + operators + ")(?=[ _]))";
    const operatorsReplaceRE = new RegExp(operatorsPattern, "g");
    expression = expression.replace(operatorsReplaceRE, (match) => CONDITIONAL_OPERATORS[match]);
    const predefinedVarsPattern = "(" + Object.keys(PREDEFINED_VARS).map((v3) => `:${v3}|${v3}`).join("|") + ")";
    const userVariablePattern = "(\\$_*[^_ ]+)";
    const variablesReplaceRE = new RegExp(`${userVariablePattern}|${predefinedVarsPattern}`, "g");
    expression = expression.replace(variablesReplaceRE, (match) => PREDEFINED_VARS[match] || match);
    return expression.replace(/[ _]+/g, "_");
  }
  function process_custom_function(customFunction) {
    if (!isObject2(customFunction)) {
      return customFunction;
    }
    if (customFunction.function_type === "remote") {
      const encodedSource = base64EncodeURL(customFunction.source);
      return [customFunction.function_type, encodedSource].join(":");
    }
    return [customFunction.function_type, customFunction.source].join(":");
  }
  function process_custom_pre_function(customPreFunction) {
    let result = process_custom_function(customPreFunction);
    return utils.isString(result) ? `pre:${result}` : null;
  }
  function process_if(ifValue) {
    return ifValue ? "if_" + normalize_expression(ifValue) : ifValue;
  }
  function process_layer(layer) {
    if (isString2(layer)) {
      let resourceType = null;
      let layerUrl = "";
      let fetchLayerBegin = "fetch:";
      if (layer.startsWith(fetchLayerBegin)) {
        layerUrl = layer.substring(fetchLayerBegin.length);
      } else if (layer.indexOf(":fetch:", 0) !== -1) {
        const parts = layer.split(":", 3);
        resourceType = parts[0];
        layerUrl = parts[2];
      } else {
        return layer;
      }
      layer = {
        url: layerUrl,
        type: "fetch"
      };
      if (resourceType) {
        layer.resource_type = resourceType;
      }
    }
    if (typeof layer !== "object") {
      return layer;
    }
    let {
      resource_type,
      text,
      type: type50,
      public_id,
      format,
      url: fetchUrl
    } = layer;
    const components = [];
    if (!isEmpty2(text) && isEmpty2(resource_type)) {
      resource_type = "text";
    }
    if (!isEmpty2(fetchUrl) && isEmpty2(type50)) {
      type50 = "fetch";
    }
    if (!isEmpty2(public_id) && !isEmpty2(format)) {
      public_id = `${public_id}.${format}`;
    }
    if (isEmpty2(public_id) && resource_type !== "text" && type50 !== "fetch") {
      throw new Error("Must supply public_id for non-text overlay");
    }
    if (!isEmpty2(resource_type) && resource_type !== "image") {
      components.push(resource_type);
    }
    if (!isEmpty2(type50) && type50 !== "upload") {
      components.push(type50);
    }
    if (resource_type === "text" || resource_type === "subtitles") {
      if (isEmpty2(public_id) && isEmpty2(text)) {
        throw new Error("Must supply either text or public_in in overlay");
      }
      const textOptions = textStyle(layer);
      if (!isEmpty2(textOptions)) {
        components.push(textOptions);
      }
      if (!isEmpty2(public_id)) {
        public_id = public_id.replace("/", ":");
        components.push(public_id);
      }
      if (!isEmpty2(text)) {
        const variablesRegex = new RegExp(/(\$\([a-zA-Z]\w+\))/g);
        const textDividedByVariables = text.split(variablesRegex).filter((x3) => x3);
        const encodedParts = textDividedByVariables.map((subText) => {
          const matches = variablesRegex[Symbol.match](subText);
          const isVariable = matches ? matches.length > 0 : false;
          if (isVariable) {
            return subText;
          }
          return encodeCurlyBraces(encodeURIComponent(smart_escape(subText, new RegExp(/([,\/])/g))));
        });
        components.push(encodedParts.join(""));
      }
    } else if (type50 === "fetch") {
      const encodedUrl = base64EncodeURL(fetchUrl);
      components.push(encodedUrl);
    } else {
      public_id = public_id.replace("/", ":");
      components.push(public_id);
    }
    return components.join(":");
  }
  function replaceAllSubstrings(string7, search, replacement = "") {
    return string7.split(search).join(replacement);
  }
  function encodeCurlyBraces(input) {
    return replaceAllSubstrings(replaceAllSubstrings(input, "(", "%28"), ")", "%29");
  }
  function process_radius(radius) {
    if (!radius) {
      return radius;
    }
    if (!isArray(radius)) {
      radius = [radius];
    }
    if (radius.length === 0 || radius.length > 4) {
      throw new Error("Radius array should contain between 1 and 4 values");
    }
    if (radius.findIndex((x3) => x3 === null) >= 0) {
      throw new Error("Corner: Cannot be null");
    }
    return radius.map(normalize_expression).join(":");
  }
  function build_multi_and_sprite_params(tagOrOptions, options) {
    let tag = null;
    if (typeof tagOrOptions === "string") {
      tag = tagOrOptions;
    } else {
      if (isEmpty2(options)) {
        options = tagOrOptions;
      } else {
        throw new Error("First argument must be a tag when additional options are passed");
      }
      tag = null;
    }
    if (!options && !tag) {
      throw new Error("Either tag or urls are required");
    }
    if (!options) {
      options = {};
    }
    const urls = options.urls;
    const transformation = generate_transformation_string(extend({}, options, {
      fetch_format: options.format
    }));
    return {
      tag,
      transformation,
      urls,
      timestamp: utils.timestamp(),
      async: options.async,
      notification_url: options.notification_url
    };
  }
  function build_upload_params(options) {
    let params = {
      access_mode: options.access_mode,
      allowed_formats: options.allowed_formats && toArray2(options.allowed_formats).join(","),
      asset_folder: options.asset_folder,
      async: utils.as_safe_bool(options.async),
      backup: utils.as_safe_bool(options.backup),
      callback: options.callback,
      cinemagraph_analysis: utils.as_safe_bool(options.cinemagraph_analysis),
      colors: utils.as_safe_bool(options.colors),
      display_name: options.display_name,
      discard_original_filename: utils.as_safe_bool(options.discard_original_filename),
      eager: utils.build_eager(options.eager),
      eager_async: utils.as_safe_bool(options.eager_async),
      eager_notification_url: options.eager_notification_url,
      eval: options.eval,
      exif: utils.as_safe_bool(options.exif),
      faces: utils.as_safe_bool(options.faces),
      folder: options.folder,
      format: options.format,
      filename_override: options.filename_override,
      image_metadata: utils.as_safe_bool(options.image_metadata),
      media_metadata: utils.as_safe_bool(options.media_metadata),
      invalidate: utils.as_safe_bool(options.invalidate),
      moderation: options.moderation,
      notification_url: options.notification_url,
      overwrite: utils.as_safe_bool(options.overwrite),
      phash: utils.as_safe_bool(options.phash),
      proxy: options.proxy,
      public_id: options.public_id,
      public_id_prefix: options.public_id_prefix,
      quality_analysis: utils.as_safe_bool(options.quality_analysis),
      responsive_breakpoints: utils.generate_responsive_breakpoints_string(options.responsive_breakpoints),
      return_delete_token: utils.as_safe_bool(options.return_delete_token),
      timestamp: options.timestamp || exports.timestamp(),
      transformation: decodeURIComponent(utils.generate_transformation_string(clone13(options))),
      type: options.type,
      unique_filename: utils.as_safe_bool(options.unique_filename),
      upload_preset: options.upload_preset,
      use_filename: utils.as_safe_bool(options.use_filename),
      use_filename_as_display_name: utils.as_safe_bool(options.use_filename_as_display_name),
      quality_override: options.quality_override,
      accessibility_analysis: utils.as_safe_bool(options.accessibility_analysis),
      use_asset_folder_as_public_id_prefix: utils.as_safe_bool(options.use_asset_folder_as_public_id_prefix),
      visual_search: utils.as_safe_bool(options.visual_search),
      on_success: options.on_success
    };
    return utils.updateable_resource_params(options, params);
  }
  function encode_key_value(arg) {
    if (!isObject2(arg)) {
      return arg;
    }
    return entries(arg).map(([k, v3]) => `${k}=${v3}`).join("|");
  }
  function escapeMetadataValue(value15) {
    return value15.toString().replace(/([=|])/g, "\\$&");
  }
  function encode_context(metadataObj) {
    if (!isObject2(metadataObj)) {
      return metadataObj;
    }
    return entries(metadataObj).map(([key, value15]) => {
      if (isString2(value15)) {
        return `${key}=${escapeMetadataValue(value15)}`;
      } else if (isArray(value15)) {
        let values = value15.map((innerVal) => {
          return `\"${escapeMetadataValue(innerVal)}\"`;
        }).join(",");
        return `${key}=[${values}]`;
      } else if (Number.isInteger(value15)) {
        return `${key}=${escapeMetadataValue(String(value15))}`;
      } else {
        return value15.toString();
      }
    }).join("|");
  }
  function build_eager(transformations) {
    return toArray2(transformations).map((transformation) => {
      const transformationString = utils.generate_transformation_string(clone13(transformation));
      const format = transformation.format;
      return format == null ? transformationString : `${transformationString}/${format}`;
    }).join("|");
  }
  function build_custom_headers(headers) {
    switch (true) {
      case headers == null:
        return;
      case isArray(headers):
        return headers.join("\n");
      case isObject2(headers):
        return entries(headers).map(([k, v3]) => `${k}:${v3}`).join("\n");
      default:
        return headers;
    }
  }
  function generate_transformation_string(options) {
    if (utils.isString(options)) {
      return options;
    }
    if (isArray(options)) {
      return options.map((t3) => utils.generate_transformation_string(clone13(t3))).filter(utils.present).join("/");
    }
    let responsive_width = consumeOption(options, "responsive_width", config2().responsive_width);
    let width = options.width;
    let height = options.height;
    let size = consumeOption(options, "size");
    if (size) {
      [width, height] = size.split("x");
      [options.width, options.height] = [width, height];
    }
    let has_layer = options.overlay || options.underlay;
    let crop = consumeOption(options, "crop");
    let angle = toArray2(consumeOption(options, "angle")).join(".");
    let no_html_sizes = has_layer || utils.present(angle) || crop === "fit" || crop === "limit" || responsive_width;
    if (width && (width.toString().indexOf("auto") === 0 || no_html_sizes || parseFloat(width) < 1)) {
      delete options.width;
    }
    if (height && (no_html_sizes || parseFloat(height) < 1)) {
      delete options.height;
    }
    let background = consumeOption(options, "background");
    background = background && background.replace(/^#/, "rgb:");
    let color = consumeOption(options, "color");
    color = color && color.replace(/^#/, "rgb:");
    let base_transformations = toArray2(consumeOption(options, "transformation", []));
    let named_transformation = [];
    if (base_transformations.some(isObject2)) {
      base_transformations = base_transformations.map((tr) => utils.generate_transformation_string(isObject2(tr) ? clone13(tr) : { transformation: tr }));
    } else {
      named_transformation = base_transformations.join(".");
      base_transformations = [];
    }
    let effect = consumeOption(options, "effect");
    if (isArray(effect)) {
      effect = effect.join(":");
    } else if (isObject2(effect)) {
      effect = entries(effect).map(([key, value15]) => `${key}:${value15}`);
    }
    let border = consumeOption(options, "border");
    if (isObject2(border)) {
      border = `${border.width != null ? border.width : 2}px_solid_${(border.color != null ? border.color : "black").replace(/^#/, "rgb:")}`;
    } else if (/^\d+$/.exec(border)) {
      options.border = border;
      border = undefined;
    }
    let flags = toArray2(consumeOption(options, "flags")).join(".");
    let dpr = consumeOption(options, "dpr", config2().dpr);
    if (options.offset != null) {
      [options.start_offset, options.end_offset] = split_range(consumeOption(options, "offset"));
    }
    if (options.start_offset) {
      options.start_offset = normalize_expression(options.start_offset);
    }
    if (options.end_offset) {
      options.end_offset = normalize_expression(options.end_offset);
    }
    let overlay = process_layer(consumeOption(options, "overlay"));
    let radius = process_radius(consumeOption(options, "radius"));
    let underlay = process_layer(consumeOption(options, "underlay"));
    let ifValue = process_if(consumeOption(options, "if"));
    let custom_function = process_custom_function(consumeOption(options, "custom_function"));
    let custom_pre_function = process_custom_pre_function(consumeOption(options, "custom_pre_function"));
    let fps = consumeOption(options, "fps");
    if (isArray(fps)) {
      fps = fps.join("-");
    }
    let params = {
      a: normalize_expression(angle),
      ar: normalize_expression(consumeOption(options, "aspect_ratio")),
      b: background,
      bo: border,
      c: crop,
      co: color,
      dpr: normalize_expression(dpr),
      e: normalize_expression(effect),
      fl: flags,
      fn: custom_function || custom_pre_function,
      fps,
      h: normalize_expression(height),
      ki: normalize_expression(consumeOption(options, "keyframe_interval")),
      l: overlay,
      o: normalize_expression(consumeOption(options, "opacity")),
      q: normalize_expression(consumeOption(options, "quality")),
      r: radius,
      t: named_transformation,
      u: underlay,
      w: normalize_expression(width),
      x: normalize_expression(consumeOption(options, "x")),
      y: normalize_expression(consumeOption(options, "y")),
      z: normalize_expression(consumeOption(options, "zoom"))
    };
    SIMPLE_PARAMS.forEach(([name, short]) => {
      let value15 = consumeOption(options, name);
      if (value15 !== undefined) {
        params[short] = value15;
      }
    });
    if (params.vc != null) {
      params.vc = process_video_params(params.vc);
    }
    ["so", "eo", "du"].forEach((short) => {
      if (params[short] !== undefined) {
        params[short] = norm_range_value(params[short]);
      }
    });
    let variablesParam = consumeOption(options, "variables", []);
    let variables = entries(options).filter(([key, value15]) => key.startsWith("$")).map(([key, value15]) => {
      delete options[key];
      return `${key}_${normalize_expression(value15)}`;
    }).sort().concat(variablesParam.map(([name, value15]) => `${name}_${normalize_expression(value15)}`)).join(",");
    let transformations = entries(params).filter(([key, value15]) => utils.present(value15)).map(([key, value15]) => key + "_" + value15).sort().join(",");
    let raw_transformation = consumeOption(options, "raw_transformation");
    transformations = compact([ifValue, variables, transformations, raw_transformation]).join(",");
    base_transformations.push(transformations);
    transformations = base_transformations;
    if (responsive_width) {
      let responsive_width_transformation = config2().responsive_width_transformation || DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION;
      transformations.push(utils.generate_transformation_string(clone13(responsive_width_transformation)));
    }
    if (String(width).startsWith("auto") || responsive_width) {
      options.responsive = true;
    }
    if (dpr === "auto") {
      options.hidpi = true;
    }
    return filter2(transformations, utils.present).join("/");
  }
  function updateable_resource_params(options, params = {}) {
    if (options.access_control != null) {
      params.access_control = utils.jsonArrayParam(options.access_control);
    }
    if (options.auto_tagging != null) {
      params.auto_tagging = options.auto_tagging;
    }
    if (options.background_removal != null) {
      params.background_removal = options.background_removal;
    }
    if (options.categorization != null) {
      params.categorization = options.categorization;
    }
    if (options.context != null) {
      params.context = utils.encode_context(options.context);
    }
    if (options.metadata != null) {
      params.metadata = utils.encode_context(options.metadata);
    }
    if (options.custom_coordinates != null) {
      params.custom_coordinates = encodeDoubleArray(options.custom_coordinates);
    }
    if (options.detection != null) {
      params.detection = options.detection;
    }
    if (options.face_coordinates != null) {
      params.face_coordinates = encodeDoubleArray(options.face_coordinates);
    }
    if (options.headers != null) {
      params.headers = utils.build_custom_headers(options.headers);
    }
    if (options.notification_url != null) {
      params.notification_url = options.notification_url;
    }
    if (options.ocr != null) {
      params.ocr = options.ocr;
    }
    if (options.raw_convert != null) {
      params.raw_convert = options.raw_convert;
    }
    if (options.similarity_search != null) {
      params.similarity_search = options.similarity_search;
    }
    if (options.tags != null) {
      params.tags = toArray2(options.tags).join(",");
    }
    if (options.quality_override != null) {
      params.quality_override = options.quality_override;
    }
    if (options.asset_folder != null) {
      params.asset_folder = options.asset_folder;
    }
    if (options.display_name != null) {
      params.display_name = options.display_name;
    }
    if (options.unique_display_name != null) {
      params.unique_display_name = options.unique_display_name;
    }
    if (options.visual_search != null) {
      params.visual_search = options.visual_search;
    }
    if (options.regions != null) {
      params.regions = JSON.stringify(options.regions);
    }
    return params;
  }
  function extractUrlParams(options) {
    return pickOnlyExistingValues(options, ...URL_KEYS);
  }
  function extractTransformationParams(options) {
    return pickOnlyExistingValues(options, ...TRANSFORMATION_PARAMS);
  }
  function patchFetchFormat(options = {}) {
    if (options.type === "fetch") {
      if (options.fetch_format == null) {
        options.fetch_format = consumeOption(options, "format");
      }
    }
  }
  function build_distribution_domain(source, options) {
    const cloud_name = consumeOption(options, "cloud_name", config2().cloud_name);
    if (!cloud_name) {
      throw new Error("Must supply cloud_name in tag or in configuration");
    }
    let secure = consumeOption(options, "secure", true);
    const ssl_detected = consumeOption(options, "ssl_detected", config2().ssl_detected);
    if (secure === null) {
      secure = ssl_detected || config2().secure;
    }
    const private_cdn = consumeOption(options, "private_cdn", config2().private_cdn);
    const cname = consumeOption(options, "cname", config2().cname);
    const secure_distribution = consumeOption(options, "secure_distribution", config2().secure_distribution);
    const cdn_subdomain = consumeOption(options, "cdn_subdomain", config2().cdn_subdomain);
    const secure_cdn_subdomain = consumeOption(options, "secure_cdn_subdomain", config2().secure_cdn_subdomain);
    return unsigned_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution);
  }
  function url(public_id, options = {}) {
    let signature, source_to_sign;
    utils.patchFetchFormat(options);
    let type50 = consumeOption(options, "type", null);
    let transformation = utils.generate_transformation_string(options);
    let resource_type = consumeOption(options, "resource_type", "image");
    let version = consumeOption(options, "version");
    let force_version = consumeOption(options, "force_version", config2().force_version);
    if (force_version == null) {
      force_version = true;
    }
    let long_url_signature = !!consumeOption(options, "long_url_signature", config2().long_url_signature);
    let format = consumeOption(options, "format");
    let shorten = consumeOption(options, "shorten", config2().shorten);
    let sign_url = consumeOption(options, "sign_url", config2().sign_url);
    let api_secret = consumeOption(options, "api_secret", config2().api_secret);
    let url_suffix = consumeOption(options, "url_suffix");
    let use_root_path = consumeOption(options, "use_root_path", config2().use_root_path);
    let signature_algorithm = consumeOption(options, "signature_algorithm", config2().signature_algorithm || DEFAULT_SIGNATURE_ALGORITHM);
    if (long_url_signature) {
      signature_algorithm = "sha256";
    }
    let auth_token = consumeOption(options, "auth_token");
    if (auth_token !== false) {
      auth_token = exports.merge(config2().auth_token, auth_token);
    }
    let preloaded = /^(image|raw)\/([a-z0-9_]+)\/v(\d+)\/([^#]+)$/.exec(public_id);
    if (preloaded) {
      resource_type = preloaded[1];
      type50 = preloaded[2];
      version = preloaded[3];
      public_id = preloaded[4];
    }
    let original_source = public_id;
    if (public_id == null) {
      return original_source;
    }
    public_id = public_id.toString();
    if (type50 === null && public_id.match(/^https?:\//i)) {
      return original_source;
    }
    [resource_type, type50] = finalize_resource_type(resource_type, type50, url_suffix, use_root_path, shorten);
    [public_id, source_to_sign] = finalize_source(public_id, format, url_suffix);
    if (version == null && force_version && source_to_sign.indexOf("/") >= 0 && !source_to_sign.match(/^v[0-9]+/) && !source_to_sign.match(/^https?:\//)) {
      version = 1;
    }
    if (version != null) {
      version = `v${version}`;
    } else {
      version = null;
    }
    transformation = transformation.replace(/([^:])\/\//g, "$1/");
    if (sign_url && isEmpty2(auth_token)) {
      let to_sign = [transformation, source_to_sign].filter(function(part) {
        return part != null && part !== "";
      }).join("/");
      const signatureConfig = {};
      if (long_url_signature) {
        signatureConfig.algorithm = "sha256";
        signatureConfig.signatureLength = 32;
      } else {
        signatureConfig.algorithm = signature_algorithm;
        signatureConfig.signatureLength = 8;
      }
      const truncated = compute_hash(to_sign + api_secret, signatureConfig.algorithm, "base64").slice(0, signatureConfig.signatureLength).replace(/\//g, "_").replace(/\+/g, "-");
      signature = `s--${truncated}--`;
    }
    let prefix = build_distribution_domain(public_id, options);
    let resultUrl = [prefix, resource_type, type50, signature, transformation, version, public_id].filter(function(part) {
      return part != null && part !== "";
    }).join("/").replace(/ /g, "%20");
    if (sign_url && !isEmpty2(auth_token)) {
      auth_token.url = urlParse(resultUrl).path;
      let token = generate_token(auth_token);
      resultUrl += `?${token}`;
    }
    const urlAnalytics = ensureOption(options, "urlAnalytics", ensureOption(options, "analytics", true));
    if (urlAnalytics === true) {
      let {
        sdkCode: sdkCodeDefault,
        sdkSemver: sdkSemverDefault,
        techVersion: techVersionDefault,
        product: productDefault
      } = getSDKVersions();
      const sdkCode = ensureOption(options, "sdkCode", ensureOption(options, "sdk_code", sdkCodeDefault));
      const sdkSemver = ensureOption(options, "sdkSemver", ensureOption(options, "sdk_semver", sdkSemverDefault));
      const techVersion = ensureOption(options, "techVersion", ensureOption(options, "tech_version", techVersionDefault));
      const product = ensureOption(options, "product", productDefault);
      let sdkVersions = {
        sdkCode,
        sdkSemver,
        techVersion,
        product,
        urlAnalytics
      };
      let analyticsOptions = getAnalyticsOptions(Object.assign({}, options, sdkVersions));
      let sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions);
      let appender = "?";
      if (resultUrl.indexOf("?") >= 0) {
        appender = "&";
      }
      resultUrl = `${resultUrl}${appender}_a=${sdkAnalyticsSignature}`;
    }
    return resultUrl;
  }
  function video_url(public_id, options) {
    options = extend({
      resource_type: "video"
    }, options);
    return utils.url(public_id, options);
  }
  function finalize_source(source, format, url_suffix) {
    let source_to_sign;
    source = source.replace(/([^:])\/\//g, "$1/");
    if (source.match(/^https?:\//i)) {
      source = smart_escape(source);
      source_to_sign = source;
    } else {
      source = encodeURIComponent(decodeURIComponent(source)).replace(/%3A/g, ":").replace(/%2F/g, "/");
      source_to_sign = source;
      if (url_suffix) {
        if (url_suffix.match(/[\.\/]/)) {
          throw new Error("url_suffix should not include . or /");
        }
        source = source + "/" + url_suffix;
      }
      if (format != null) {
        source = source + "." + format;
        source_to_sign = source_to_sign + "." + format;
      }
    }
    return [source, source_to_sign];
  }
  function video_thumbnail_url(public_id, options) {
    options = extend({}, DEFAULT_POSTER_OPTIONS, options);
    return utils.url(public_id, options);
  }
  function finalize_resource_type(resource_type, type50, url_suffix, use_root_path, shorten) {
    if (type50 == null) {
      type50 = "upload";
    }
    if (url_suffix != null) {
      if (resource_type === "image" && type50 === "upload") {
        resource_type = "images";
        type50 = null;
      } else if (resource_type === "image" && type50 === "private") {
        resource_type = "private_images";
        type50 = null;
      } else if (resource_type === "image" && type50 === "authenticated") {
        resource_type = "authenticated_images";
        type50 = null;
      } else if (resource_type === "raw" && type50 === "upload") {
        resource_type = "files";
        type50 = null;
      } else if (resource_type === "video" && type50 === "upload") {
        resource_type = "videos";
        type50 = null;
      } else {
        throw new Error("URL Suffix only supported for image/upload, image/private, image/authenticated, video/upload and raw/upload");
      }
    }
    if (use_root_path) {
      if (resource_type === "image" && type50 === "upload" || resource_type === "images" && type50 == null) {
        resource_type = null;
        type50 = null;
      } else {
        throw new Error("Root path only supported for image/upload");
      }
    }
    if (shorten && resource_type === "image" && type50 === "upload") {
      resource_type = "iu";
      type50 = null;
    }
    return [resource_type, type50];
  }
  function unsigned_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution) {
    let prefix;
    if (cloud_name.indexOf("/") === 0) {
      return "/res" + cloud_name;
    }
    let shared_domain = !private_cdn;
    if (secure) {
      if (secure_distribution == null || secure_distribution === exports.OLD_AKAMAI_SHARED_CDN) {
        secure_distribution = private_cdn ? cloud_name + "-res.cloudinary.com" : exports.SHARED_CDN;
      }
      if (shared_domain == null) {
        shared_domain = secure_distribution === exports.SHARED_CDN;
      }
      if (secure_cdn_subdomain == null && shared_domain) {
        secure_cdn_subdomain = cdn_subdomain;
      }
      if (secure_cdn_subdomain) {
        secure_distribution = secure_distribution.replace("res.cloudinary.com", "res-" + (crc322(source) % 5 + 1 + ".cloudinary.com"));
      }
      prefix = "https://" + secure_distribution;
    } else if (cname) {
      let subdomain = cdn_subdomain ? "a" + (crc322(source) % 5 + 1) + "." : "";
      prefix = "http://" + subdomain + cname;
    } else {
      let cdn_part = private_cdn ? cloud_name + "-" : "";
      let subdomain_part = cdn_subdomain ? "-" + (crc322(source) % 5 + 1) : "";
      let host = [cdn_part, "res", subdomain_part, ".cloudinary.com"].join("");
      prefix = "http://" + host;
    }
    if (shared_domain) {
      prefix += "/" + cloud_name;
    }
    return prefix;
  }
  function base_api_url_v1_1() {
    return base_api_url("v1_1");
  }
  function base_api_url_v2() {
    return base_api_url("v2");
  }
  function base_api_url(api_version) {
    if (!api_version || api_version.length === 0) {
      throw new Error("api_version needs to be a non-empty string");
    }
    return (path2 = [], options = []) => {
      let cloudinary = ensureOption(options, "upload_prefix", UPLOAD_PREFIX);
      let cloud_name = ensureOption(options, "cloud_name");
      let encode_path = (unencoded_path) => encodeURIComponent(unencoded_path).replace("'", "%27");
      let encoded_path = Array.isArray(path2) ? path2.map(encode_path) : encode_path(path2);
      return [cloudinary, api_version, cloud_name].concat(encoded_path).join("/");
    };
  }
  function api_url(action = "upload", options = {}) {
    let resource_type = options.resource_type || "image";
    return base_api_url_v1_1()([resource_type, action], options);
  }
  function random_public_id() {
    return crypto8.randomBytes(12).toString("base64").replace(/[^a-z0-9]/g, "");
  }
  function signed_preloaded_image(result) {
    return `${result.resource_type}/upload/v${result.version}/${filter2([result.public_id, result.format], utils.present).join(".")}#${result.signature}`;
  }
  function api_sign_request(params_to_sign, api_secret) {
    let to_sign = entries(params_to_sign).filter(([k, v3]) => utils.present(v3)).map(([k, v3]) => `${k}=${toArray2(v3).join(",")}`).sort().join("&");
    return compute_hash(to_sign + api_secret, config2().signature_algorithm || DEFAULT_SIGNATURE_ALGORITHM, "hex");
  }
  function compute_hash(input, signature_algorithm, encoding5) {
    if (!SUPPORTED_SIGNATURE_ALGORITHMS.includes(signature_algorithm)) {
      throw new Error(`Signature algorithm ${signature_algorithm} is not supported. Supported algorithms: ${SUPPORTED_SIGNATURE_ALGORITHMS.join(", ")}`);
    }
    const hash7 = crypto8.createHash(signature_algorithm).update(input).digest();
    return Buffer.from(hash7).toString(encoding5);
  }
  function clear_blank(hash7) {
    let filtered_hash = {};
    entries(hash7).filter(([k, v3]) => utils.present(v3)).forEach(([k, v3]) => {
      filtered_hash[k] = v3.filter ? v3.filter((x3) => x3) : v3;
    });
    return filtered_hash;
  }
  function sort_object_by_key(object13) {
    return Object.keys(object13).sort().reduce((obj, key) => {
      obj[key] = object13[key];
      return obj;
    }, {});
  }
  function merge(hash1, hash22) {
    return { ...hash1, ...hash22 };
  }
  function sign_request(params, options = {}) {
    let apiKey = ensureOption(options, "api_key");
    let apiSecret = ensureOption(options, "api_secret");
    params = exports.clear_blank(params);
    params.signature = exports.api_sign_request(params, apiSecret);
    params.api_key = apiKey;
    return params;
  }
  function webhook_signature(data, timestamp, options = {}) {
    ensurePresenceOf({
      data,
      timestamp
    });
    let api_secret = ensureOption(options, "api_secret");
    let signature_algorithm = ensureOption(options, "signature_algorithm", DEFAULT_SIGNATURE_ALGORITHM);
    return compute_hash(data + timestamp + api_secret, signature_algorithm, "hex");
  }
  function verifyNotificationSignature(body, timestamp, signature, valid_for = 7200) {
    if (timestamp < Math.round(Date.now() / 1000) - valid_for) {
      return false;
    }
    const payload_hash = utils.webhook_signature(body, timestamp, {
      api_secret: config2().api_secret,
      signature_algorithm: config2().signature_algorithm
    });
    return signature === payload_hash;
  }
  function process_request_params(params, options) {
    if (options.unsigned != null && options.unsigned) {
      params = exports.clear_blank(params);
      delete params.timestamp;
    } else if (options.oauth_token || config2().oauth_token) {
      params = exports.clear_blank(params);
    } else if (options.signature) {
      params = exports.clear_blank(options);
    } else {
      params = exports.sign_request(params, options);
    }
    return params;
  }
  function private_download_url(public_id, format, options = {}) {
    let params = exports.sign_request({
      timestamp: options.timestamp || exports.timestamp(),
      public_id,
      format,
      type: options.type,
      attachment: options.attachment,
      expires_at: options.expires_at
    }, options);
    return exports.api_url("download", options) + "?" + querystring.stringify(params);
  }
  function zip_download_url(tag, options = {}) {
    let params = exports.sign_request({
      timestamp: options.timestamp || exports.timestamp(),
      tag,
      transformation: utils.generate_transformation_string(options)
    }, options);
    return exports.api_url("download_tag.zip", options) + "?" + hashToQuery(params);
  }
  function download_backedup_asset(asset_id, version_id, options = {}) {
    let params = exports.sign_request({
      timestamp: options.timestamp || exports.timestamp(),
      asset_id,
      version_id
    }, options);
    return exports.base_api_url_v1()(["download_backup"], options) + "?" + hashToQuery(params);
  }
  function api_download_url(action, params, options) {
    const download_params = {
      ...params,
      mode: "download"
    };
    let cloudinary_params = exports.sign_request(download_params, options);
    return exports.api_url(action, options) + "?" + hashToQuery(cloudinary_params);
  }
  function download_archive_url(options = {}) {
    const params = exports.archive_params(merge(options, {
      mode: "download"
    }));
    return api_download_url("generate_archive", params, options);
  }
  function download_zip_url(options = {}) {
    return exports.download_archive_url(merge(options, {
      target_format: "zip"
    }));
  }
  function download_folder(folder_path, options = {}) {
    options.resource_type = options.resource_type || "all";
    options.prefixes = folder_path;
    let cloudinary_params = exports.sign_request(exports.archive_params(merge(options, {
      mode: "download"
    })), options);
    return exports.api_url("generate_archive", options) + "?" + hashToQuery(cloudinary_params);
  }
  function join_pair(key, value15) {
    if (!value15) {
      return;
    }
    return value15 === true ? key : key + "='" + value15 + "'";
  }
  function escapeQuotes(value15) {
    return isString2(value15) ? value15.replace(/\"/g, "&#34;").replace(/\'/g, "&#39;") : value15;
  }
  function cloudinary_js_config() {
    let params = pickOnlyExistingValues(config2(), ...CLOUDINARY_JS_CONFIG_PARAMS);
    return `<script type='text/javascript'>\n\$.cloudinary.config(${JSON.stringify(params)});\n</script>`;
  }
  function v1_result_adapter(callback) {
    if (callback == null) {
      return;
    }
    return function(result) {
      if (result.error != null) {
        return callback(result.error);
      }
      return callback(undefined, result);
    };
  }
  function v1_adapter(name, num_pass_args, v12) {
    return function(...args) {
      let pass_args = take(args, num_pass_args);
      let options = args[num_pass_args];
      let callback = args[num_pass_args + 1];
      if (callback == null && isFunction2(options)) {
        callback = options;
        options = {};
      }
      callback = v1_result_adapter(callback);
      args = pass_args.concat([callback, options]);
      return v12[name].apply(this, args);
    };
  }
  function v1_adapters(exports2, v12, mapping) {
    return Object.keys(mapping).map((name) => {
      let num_pass_args = mapping[name];
      exports2[name] = v1_adapter(name, num_pass_args, v12);
      return exports2[name];
    });
  }
  function as_safe_bool(value15) {
    if (value15 == null) {
      return;
    }
    if (value15 === true || value15 === "true" || value15 === "1") {
      value15 = 1;
    }
    if (value15 === false || value15 === "false" || value15 === "0") {
      value15 = 0;
    }
    return value15;
  }
  function split_range(range) {
    switch (range.constructor) {
      case String:
        if (!OFFSET_ANY_PATTERN_RE.test(range)) {
          return range;
        }
        return range.split("..");
      case Array:
        return [first(range), last(range)];
      default:
        return [null, null];
    }
  }
  function norm_range_value(value15) {
    let offset = String(value15).match(RANGE_VALUE_RE);
    if (offset) {
      let modifier = offset[5] ? "p" : "";
      value15 = `${offset[1] || offset[4]}${modifier}`;
    }
    return value15;
  }
  function process_video_params(param) {
    switch (param.constructor) {
      case Object: {
        let video = "";
        if ("codec" in param) {
          video = param.codec;
          if ("profile" in param) {
            video += ":" + param.profile;
            if ("level" in param) {
              video += ":" + param.level;
            }
          }
        }
        return video;
      }
      case String:
        return param;
      default:
        return null;
    }
  }
  function archive_params(options = {}) {
    return {
      allow_missing: exports.as_safe_bool(options.allow_missing),
      async: exports.as_safe_bool(options.async),
      expires_at: options.expires_at,
      flatten_folders: exports.as_safe_bool(options.flatten_folders),
      flatten_transformations: exports.as_safe_bool(options.flatten_transformations),
      keep_derived: exports.as_safe_bool(options.keep_derived),
      mode: options.mode,
      notification_url: options.notification_url,
      prefixes: options.prefixes && toArray2(options.prefixes),
      fully_qualified_public_ids: options.fully_qualified_public_ids && toArray2(options.fully_qualified_public_ids),
      public_ids: options.public_ids && toArray2(options.public_ids),
      skip_transformation_name: exports.as_safe_bool(options.skip_transformation_name),
      tags: options.tags && toArray2(options.tags),
      target_format: options.target_format,
      target_public_id: options.target_public_id,
      target_tags: options.target_tags && toArray2(options.target_tags),
      timestamp: options.timestamp || exports.timestamp(),
      transformations: utils.build_eager(options.transformations),
      type: options.type,
      use_original_filename: exports.as_safe_bool(options.use_original_filename)
    };
  }
  function build_explicit_api_params(public_id, options = {}) {
    return [exports.build_upload_params(extend({}, { public_id }, options))];
  }
  function generate_responsive_breakpoints_string(breakpoints) {
    if (breakpoints == null) {
      return null;
    }
    breakpoints = clone13(breakpoints);
    if (!isArray(breakpoints)) {
      breakpoints = [breakpoints];
    }
    for (let j = 0;j < breakpoints.length; j++) {
      let breakpoint_settings = breakpoints[j];
      if (breakpoint_settings != null) {
        if (breakpoint_settings.transformation) {
          breakpoint_settings.transformation = utils.generate_transformation_string(clone13(breakpoint_settings.transformation));
        }
      }
    }
    return JSON.stringify(breakpoints);
  }
  function build_streaming_profiles_param(options = {}) {
    let params = pickOnlyExistingValues(options, "display_name", "representations");
    if (isArray(params.representations)) {
      params.representations = JSON.stringify(params.representations.map((r) => ({
        transformation: utils.generate_transformation_string(r.transformation)
      })));
    }
    return params;
  }
  function hashToParameters(hash7) {
    return entries(hash7).reduce((parameters4, [key, value15]) => {
      if (isArray(value15)) {
        key = key.endsWith("[]") ? key : key + "[]";
        const items = value15.map((v3) => [key, v3]);
        parameters4 = parameters4.concat(items);
      } else {
        parameters4.push([key, value15]);
      }
      return parameters4;
    }, []);
  }
  function hashToQuery(hash7) {
    return hashToParameters(hash7).map(([key, value15]) => `${querystring.escape(key)}=${querystring.escape(value15)}`).join("&");
  }
  function present(value15) {
    return value15 != null && ("" + value15).length > 0;
  }
  function pickOnlyExistingValues(source, ...keys) {
    let result = {};
    if (source) {
      keys.forEach((key) => {
        if (source[key] != null) {
          result[key] = source[key];
        }
      });
    }
    return result;
  }
  function jsonArrayParam(data, modifier) {
    if (!data) {
      return null;
    }
    if (isString2(data)) {
      data = JSON.parse(data);
    }
    if (!isArray(data)) {
      data = [data];
    }
    if (isFunction2(modifier)) {
      data = modifier(data);
    }
    return JSON.stringify(data);
  }
  var crypto8 = import.meta.require("crypto");
  var querystring = import.meta.require("querystring");
  var urlParse = import.meta.require("url").parse;
  var compact = require_compact();
  var first = require_head();
  var isFunction2 = require_isFunction();
  var isPlainObject = require_isPlainObject();
  var last = require_last();
  var map4 = require_map();
  var take = require_take();
  var at = require_at();
  var clone13 = require_clone();
  var extend = require_assignIn();
  var filter2 = require_filter();
  var includes2 = require_includes();
  var isArray = require_isArray();
  var isEmpty2 = require_isEmpty();
  var isNumber2 = require_isNumber();
  var isObject2 = require_isObject();
  var isString2 = require_isString();
  var isUndefined = require_isUndefined();
  var smart_escape = require_smart_escape();
  var consumeOption = require_consumeOption();
  var toArray2 = require_toArray();
  var { base64EncodeURL } = require_base64EncodeURL();
  var encodeDoubleArray = require_encodeDoubleArray();
  var config2 = require_config();
  var generate_token = require_auth_token();
  var crc322 = require_crc32();
  var ensurePresenceOf = require_ensurePresenceOf();
  var ensureOption = require_ensureOption().defaults(config2());
  var entries = require_entries();
  var isRemoteUrl = require_isRemoteUrl();
  var getSDKVersions = require_getSDKVersions();
  var {
    getAnalyticsOptions,
    getSDKAnalyticsSignature
  } = require_analytics();
  exports = module.exports;
  var utils = module.exports;
  try {
    utils.VERSION = require_package2().version;
  } catch (error23) {
    utils.VERSION = "";
  }
  exports.CF_SHARED_CDN = "d3jpl91pxevbkh.cloudfront.net";
  exports.OLD_AKAMAI_SHARED_CDN = "cloudinary-a.akamaihd.net";
  exports.AKAMAI_SHARED_CDN = "res.cloudinary.com";
  exports.SHARED_CDN = exports.AKAMAI_SHARED_CDN;
  exports.USER_AGENT = `CloudinaryNodeJS/${exports.VERSION} (Node ${process.versions.node})`;
  exports.userPlatform = "";
  var {
    DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION,
    DEFAULT_POSTER_OPTIONS,
    DEFAULT_VIDEO_SOURCE_TYPES,
    CONDITIONAL_OPERATORS,
    PREDEFINED_VARS,
    LAYER_KEYWORD_PARAMS,
    TRANSFORMATION_PARAMS,
    SIMPLE_PARAMS,
    UPLOAD_PREFIX,
    SUPPORTED_SIGNATURE_ALGORITHMS,
    DEFAULT_SIGNATURE_ALGORITHM
  } = require_consts();
  var URL_KEYS = [
    "api_secret",
    "auth_token",
    "cdn_subdomain",
    "cloud_name",
    "cname",
    "format",
    "long_url_signature",
    "private_cdn",
    "resource_type",
    "secure",
    "secure_cdn_subdomain",
    "secure_distribution",
    "shorten",
    "sign_url",
    "ssl_detected",
    "type",
    "url_suffix",
    "use_root_path",
    "version"
  ];
  exports.html_attrs = function html_attrs(attrs) {
    return filter2(map4(attrs, function(value15, key) {
      return join_pair(key, escapeQuotes(value15));
    })).sort().join(" ");
  };
  var CLOUDINARY_JS_CONFIG_PARAMS = ["api_key", "cloud_name", "private_cdn", "secure_distribution", "cdn_subdomain"];
  var NUMBER_PATTERN = "([0-9]*)\\.([0-9]+)|([0-9]+)";
  var OFFSET_ANY_PATTERN = `(${NUMBER_PATTERN})([%pP])?`;
  var RANGE_VALUE_RE = RegExp(`^${OFFSET_ANY_PATTERN}\$`);
  var OFFSET_ANY_PATTERN_RE = RegExp(`(${OFFSET_ANY_PATTERN})\\.\\.(${OFFSET_ANY_PATTERN})`);
  exports.process_layer = process_layer;
  exports.create_source_tag = function create_source_tag(src, source_type, codecs = null) {
    let video_type = source_type === "ogv" ? "ogg" : source_type;
    let mime_type = `video/${video_type}`;
    if (!isEmpty2(codecs)) {
      let codecs_str = isArray(codecs) ? codecs.join(", ") : codecs;
      mime_type += `; codecs=${codecs_str}`;
    }
    return `<source ${utils.html_attrs({
      src,
      type: mime_type
    })}>`;
  };
  exports.NOP = function() {
  };
  exports.generate_auth_token = generate_auth_token;
  exports.getUserAgent = getUserAgent;
  exports.build_upload_params = build_upload_params;
  exports.build_multi_and_sprite_params = build_multi_and_sprite_params;
  exports.api_download_url = api_download_url;
  exports.timestamp = () => Math.floor(new Date().getTime() / 1000);
  exports.option_consume = consumeOption;
  exports.build_array = toArray2;
  exports.encode_double_array = encodeDoubleArray;
  exports.encode_key_value = encode_key_value;
  exports.encode_context = encode_context;
  exports.build_eager = build_eager;
  exports.build_custom_headers = build_custom_headers;
  exports.generate_transformation_string = generate_transformation_string;
  exports.updateable_resource_params = updateable_resource_params;
  exports.extractUrlParams = extractUrlParams;
  exports.extractTransformationParams = extractTransformationParams;
  exports.patchFetchFormat = patchFetchFormat;
  exports.url = url;
  exports.video_url = video_url;
  exports.video_thumbnail_url = video_thumbnail_url;
  exports.api_url = api_url;
  exports.random_public_id = random_public_id;
  exports.signed_preloaded_image = signed_preloaded_image;
  exports.api_sign_request = api_sign_request;
  exports.clear_blank = clear_blank;
  exports.merge = merge;
  exports.sign_request = sign_request;
  exports.webhook_signature = webhook_signature;
  exports.verifyNotificationSignature = verifyNotificationSignature;
  exports.process_request_params = process_request_params;
  exports.private_download_url = private_download_url;
  exports.zip_download_url = zip_download_url;
  exports.download_archive_url = download_archive_url;
  exports.download_zip_url = download_zip_url;
  exports.cloudinary_js_config = cloudinary_js_config;
  exports.v1_adapters = v1_adapters;
  exports.as_safe_bool = as_safe_bool;
  exports.archive_params = archive_params;
  exports.build_explicit_api_params = build_explicit_api_params;
  exports.generate_responsive_breakpoints_string = generate_responsive_breakpoints_string;
  exports.build_streaming_profiles_param = build_streaming_profiles_param;
  exports.hashToParameters = hashToParameters;
  exports.present = present;
  exports.only = pickOnlyExistingValues;
  exports.pickOnlyExistingValues = pickOnlyExistingValues;
  exports.jsonArrayParam = jsonArrayParam;
  exports.download_folder = download_folder;
  exports.base_api_url_v1 = base_api_url_v1_1;
  exports.base_api_url_v2 = base_api_url_v2;
  exports.download_backedup_asset = download_backedup_asset;
  exports.compute_hash = compute_hash;
  exports.build_distribution_domain = build_distribution_domain;
  exports.sort_object_by_key = sort_object_by_key;
  exports.DEFAULT_POSTER_OPTIONS = DEFAULT_POSTER_OPTIONS;
  exports.DEFAULT_VIDEO_SOURCE_TYPES = DEFAULT_VIDEO_SOURCE_TYPES;
  Object.assign(module.exports, {
    normalize_expression,
    at,
    clone: clone13,
    extend,
    filter: filter2,
    includes: includes2,
    isArray,
    isEmpty: isEmpty2,
    isNumber: isNumber2,
    isObject: isObject2,
    isRemoteUrl,
    isString: isString2,
    isUndefined,
    keys: (source) => Object.keys(source),
    ensurePresenceOf
  });
});

// node_modules/q/q.js
var require_q = __commonJS((exports, module) => {
  /*!
   *
   * Copyright 2009-2017 Kris Kowal under the terms of the MIT
   * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
   *
   * With parts by Tyler Close
   * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
   * at http://www.opensource.org/licenses/mit-license.html
   * Forked at ref_send.js version: 2009-05-11
   *
   * With parts by Mark Miller
   * Copyright (C) 2011 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   */
  (function(definition) {
    if (typeof bootstrap === "function") {
      bootstrap("promise", definition);
    } else if (typeof exports === "object" && typeof module === "object") {
      module.exports = definition();
    } else if (typeof define === "function" && define.amd) {
      define(definition);
    } else if (typeof ses !== "undefined") {
      if (!ses.ok()) {
        return;
      } else {
        ses.makeQ = definition;
      }
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
      var global2 = typeof window !== "undefined" ? window : self;
      var previousQ = global2.Q;
      global2.Q = definition();
      global2.Q.noConflict = function() {
        global2.Q = previousQ;
        return this;
      };
    } else {
      throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }
  })(function() {
    var hasStacks = false;
    try {
      throw new Error;
    } catch (e) {
      hasStacks = !!e.stack;
    }
    var qStartingLine = captureLine();
    var qFileName;
    var noop = function() {
    };
    var nextTick2 = function() {
      var head = { task: undefined, next: null };
      var tail = head;
      var flushing = false;
      var requestTick = undefined;
      var isNodeJS = false;
      var laterQueue = [];
      function flush() {
        var task, domain;
        while (head.next) {
          head = head.next;
          task = head.task;
          head.task = undefined;
          domain = head.domain;
          if (domain) {
            head.domain = undefined;
            domain.enter();
          }
          runSingle(task, domain);
        }
        while (laterQueue.length) {
          task = laterQueue.pop();
          runSingle(task);
        }
        flushing = false;
      }
      function runSingle(task, domain) {
        try {
          task();
        } catch (e) {
          if (isNodeJS) {
            if (domain) {
              domain.exit();
            }
            setTimeout(flush, 0);
            if (domain) {
              domain.enter();
            }
            throw e;
          } else {
            setTimeout(function() {
              throw e;
            }, 0);
          }
        }
        if (domain) {
          domain.exit();
        }
      }
      nextTick2 = function(task) {
        tail = tail.next = {
          task,
          domain: isNodeJS && process.domain,
          next: null
        };
        if (!flushing) {
          flushing = true;
          requestTick();
        }
      };
      if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
        isNodeJS = true;
        requestTick = function() {
          process.nextTick(flush);
        };
      } else if (typeof setImmediate === "function") {
        if (typeof window !== "undefined") {
          requestTick = setImmediate.bind(window, flush);
        } else {
          requestTick = function() {
            setImmediate(flush);
          };
        }
      } else if (typeof MessageChannel !== "undefined") {
        var channel = new MessageChannel;
        channel.port1.onmessage = function() {
          requestTick = requestPortTick;
          channel.port1.onmessage = flush;
          flush();
        };
        var requestPortTick = function() {
          channel.port2.postMessage(0);
        };
        requestTick = function() {
          setTimeout(flush, 0);
          requestPortTick();
        };
      } else {
        requestTick = function() {
          setTimeout(flush, 0);
        };
      }
      nextTick2.runAfter = function(task) {
        laterQueue.push(task);
        if (!flushing) {
          flushing = true;
          requestTick();
        }
      };
      return nextTick2;
    }();
    var call = Function.call;
    function uncurryThis(f3) {
      return function() {
        return call.apply(f3, arguments);
      };
    }
    var array_slice = uncurryThis(Array.prototype.slice);
    var array_reduce = uncurryThis(Array.prototype.reduce || function(callback, basis) {
      var index2 = 0, length = this.length;
      if (arguments.length === 1) {
        do {
          if (index2 in this) {
            basis = this[index2++];
            break;
          }
          if (++index2 >= length) {
            throw new TypeError;
          }
        } while (1);
      }
      for (;index2 < length; index2++) {
        if (index2 in this) {
          basis = callback(basis, this[index2], index2);
        }
      }
      return basis;
    });
    var array_indexOf = uncurryThis(Array.prototype.indexOf || function(value15) {
      for (var i3 = 0;i3 < this.length; i3++) {
        if (this[i3] === value15) {
          return i3;
        }
      }
      return -1;
    });
    var array_map = uncurryThis(Array.prototype.map || function(callback, thisp) {
      var self2 = this;
      var collect = [];
      array_reduce(self2, function(undefined6, value15, index2) {
        collect.push(callback.call(thisp, value15, index2, self2));
      }, undefined);
      return collect;
    });
    var object_create = Object.create || function(prototype) {
      function Type2() {
      }
      Type2.prototype = prototype;
      return new Type2;
    };
    var object_defineProperty = Object.defineProperty || function(obj, prop, descriptor) {
      obj[prop] = descriptor.value;
      return obj;
    };
    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
    var object_keys = Object.keys || function(object13) {
      var keys = [];
      for (var key in object13) {
        if (object_hasOwnProperty(object13, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    var object_toString = uncurryThis(Object.prototype.toString);
    function isObject2(value15) {
      return value15 === Object(value15);
    }
    function isStopIteration(exception) {
      return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
    }
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
      QReturnValue = ReturnValue;
    } else {
      QReturnValue = function(value15) {
        this.value = value15;
      };
    }
    var STACK_JUMP_SEPARATOR = "From previous event:";
    function makeStackTraceLong(error23, promise6) {
      if (hasStacks && promise6.stack && typeof error23 === "object" && error23 !== null && error23.stack) {
        var stacks = [];
        for (var p = promise6;p; p = p.source) {
          if (p.stack && (!error23.__minimumStackCounter__ || error23.__minimumStackCounter__ > p.stackCounter)) {
            object_defineProperty(error23, "__minimumStackCounter__", { value: p.stackCounter, configurable: true });
            stacks.unshift(p.stack);
          }
        }
        stacks.unshift(error23.stack);
        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        var stack = filterStackString(concatedStacks);
        object_defineProperty(error23, "stack", { value: stack, configurable: true });
      }
    }
    function filterStackString(stackString) {
      var lines = stackString.split("\n");
      var desiredLines = [];
      for (var i3 = 0;i3 < lines.length; ++i3) {
        var line = lines[i3];
        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
          desiredLines.push(line);
        }
      }
      return desiredLines.join("\n");
    }
    function isNodeFrame(stackLine) {
      return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
    }
    function getFileNameAndLineNumber(stackLine) {
      var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
      if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
      }
      var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
      if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
      }
      var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
      if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
      }
    }
    function isInternalFrame(stackLine) {
      var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
      if (!fileNameAndLineNumber) {
        return false;
      }
      var fileName = fileNameAndLineNumber[0];
      var lineNumber = fileNameAndLineNumber[1];
      return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
    }
    function captureLine() {
      if (!hasStacks) {
        return;
      }
      try {
        throw new Error;
      } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
          return;
        }
        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
      }
    }
    function deprecate(callback, name, alternative) {
      return function() {
        if (typeof console !== "undefined" && typeof console.warn === "function") {
          console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
      };
    }
    function Q(value15) {
      if (value15 instanceof Promise3) {
        return value15;
      }
      if (isPromiseAlike(value15)) {
        return coerce2(value15);
      } else {
        return fulfill(value15);
      }
    }
    Q.resolve = Q;
    Q.nextTick = nextTick2;
    Q.longStackSupport = false;
    var longStackCounter = 1;
    if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
      Q.longStackSupport = true;
    }
    Q.defer = defer;
    function defer() {
      var messages = [], progressListeners = [], resolvedPromise;
      var deferred = object_create(defer.prototype);
      var promise6 = object_create(Promise3.prototype);
      promise6.promiseDispatch = function(resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
          messages.push(args);
          if (op === "when" && operands[1]) {
            progressListeners.push(operands[1]);
          }
        } else {
          Q.nextTick(function() {
            resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
          });
        }
      };
      promise6.valueOf = function() {
        if (messages) {
          return promise6;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
          resolvedPromise = nearerValue;
        }
        return nearerValue;
      };
      promise6.inspect = function() {
        if (!resolvedPromise) {
          return { state: "pending" };
        }
        return resolvedPromise.inspect();
      };
      if (Q.longStackSupport && hasStacks) {
        try {
          throw new Error;
        } catch (e) {
          promise6.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
          promise6.stackCounter = longStackCounter++;
        }
      }
      function become(newPromise) {
        resolvedPromise = newPromise;
        if (Q.longStackSupport && hasStacks) {
          promise6.source = newPromise;
        }
        array_reduce(messages, function(undefined6, message) {
          Q.nextTick(function() {
            newPromise.promiseDispatch.apply(newPromise, message);
          });
        }, undefined);
        messages = undefined;
        progressListeners = undefined;
      }
      deferred.promise = promise6;
      deferred.resolve = function(value15) {
        if (resolvedPromise) {
          return;
        }
        become(Q(value15));
      };
      deferred.fulfill = function(value15) {
        if (resolvedPromise) {
          return;
        }
        become(fulfill(value15));
      };
      deferred.reject = function(reason) {
        if (resolvedPromise) {
          return;
        }
        become(reject2(reason));
      };
      deferred.notify = function(progress2) {
        if (resolvedPromise) {
          return;
        }
        array_reduce(progressListeners, function(undefined6, progressListener) {
          Q.nextTick(function() {
            progressListener(progress2);
          });
        }, undefined);
      };
      return deferred;
    }
    defer.prototype.makeNodeResolver = function() {
      var self2 = this;
      return function(error23, value15) {
        if (error23) {
          self2.reject(error23);
        } else if (arguments.length > 2) {
          self2.resolve(array_slice(arguments, 1));
        } else {
          self2.resolve(value15);
        }
      };
    };
    Q.Promise = promise5;
    Q.promise = promise5;
    function promise5(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
      }
      var deferred = defer();
      try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
      } catch (reason) {
        deferred.reject(reason);
      }
      return deferred.promise;
    }
    promise5.race = race2;
    promise5.all = all;
    promise5.reject = reject2;
    promise5.resolve = Q;
    Q.passByCopy = function(object13) {
      return object13;
    };
    Promise3.prototype.passByCopy = function() {
      return this;
    };
    Q.join = function(x3, y3) {
      return Q(x3).join(y3);
    };
    Promise3.prototype.join = function(that) {
      return Q([this, that]).spread(function(x3, y3) {
        if (x3 === y3) {
          return x3;
        } else {
          throw new Error("Q can't join: not the same: " + x3 + " " + y3);
        }
      });
    };
    Q.race = race2;
    function race2(answerPs) {
      return promise5(function(resolve, reject3) {
        for (var i3 = 0, len = answerPs.length;i3 < len; i3++) {
          Q(answerPs[i3]).then(resolve, reject3);
        }
      });
    }
    Promise3.prototype.race = function() {
      return this.then(Q.race);
    };
    Q.makePromise = Promise3;
    function Promise3(descriptor, fallback2, inspect) {
      if (fallback2 === undefined) {
        fallback2 = function(op) {
          return reject2(new Error("Promise does not support operation: " + op));
        };
      }
      if (inspect === undefined) {
        inspect = function() {
          return { state: "unknown" };
        };
      }
      var promise6 = object_create(Promise3.prototype);
      promise6.promiseDispatch = function(resolve, op, args) {
        var result;
        try {
          if (descriptor[op]) {
            result = descriptor[op].apply(promise6, args);
          } else {
            result = fallback2.call(promise6, op, args);
          }
        } catch (exception) {
          result = reject2(exception);
        }
        if (resolve) {
          resolve(result);
        }
      };
      promise6.inspect = inspect;
      if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
          promise6.exception = inspected.reason;
        }
        promise6.valueOf = function() {
          var inspected2 = inspect();
          if (inspected2.state === "pending" || inspected2.state === "rejected") {
            return promise6;
          }
          return inspected2.value;
        };
      }
      return promise6;
    }
    Promise3.prototype.toString = function() {
      return "[object Promise]";
    };
    Promise3.prototype.then = function(fulfilled, rejected, progressed) {
      var self2 = this;
      var deferred = defer();
      var done = false;
      function _fulfilled(value15) {
        try {
          return typeof fulfilled === "function" ? fulfilled(value15) : value15;
        } catch (exception) {
          return reject2(exception);
        }
      }
      function _rejected(exception) {
        if (typeof rejected === "function") {
          makeStackTraceLong(exception, self2);
          try {
            return rejected(exception);
          } catch (newException) {
            return reject2(newException);
          }
        }
        return reject2(exception);
      }
      function _progressed(value15) {
        return typeof progressed === "function" ? progressed(value15) : value15;
      }
      Q.nextTick(function() {
        self2.promiseDispatch(function(value15) {
          if (done) {
            return;
          }
          done = true;
          deferred.resolve(_fulfilled(value15));
        }, "when", [function(exception) {
          if (done) {
            return;
          }
          done = true;
          deferred.resolve(_rejected(exception));
        }]);
      });
      self2.promiseDispatch(undefined, "when", [undefined, function(value15) {
        var newValue;
        var threw = false;
        try {
          newValue = _progressed(value15);
        } catch (e) {
          threw = true;
          if (Q.onerror) {
            Q.onerror(e);
          } else {
            throw e;
          }
        }
        if (!threw) {
          deferred.notify(newValue);
        }
      }]);
      return deferred.promise;
    };
    Q.tap = function(promise6, callback) {
      return Q(promise6).tap(callback);
    };
    Promise3.prototype.tap = function(callback) {
      callback = Q(callback);
      return this.then(function(value15) {
        return callback.fcall(value15).thenResolve(value15);
      });
    };
    Q.when = when;
    function when(value15, fulfilled, rejected, progressed) {
      return Q(value15).then(fulfilled, rejected, progressed);
    }
    Promise3.prototype.thenResolve = function(value15) {
      return this.then(function() {
        return value15;
      });
    };
    Q.thenResolve = function(promise6, value15) {
      return Q(promise6).thenResolve(value15);
    };
    Promise3.prototype.thenReject = function(reason) {
      return this.then(function() {
        throw reason;
      });
    };
    Q.thenReject = function(promise6, reason) {
      return Q(promise6).thenReject(reason);
    };
    Q.nearer = nearer;
    function nearer(value15) {
      if (isPromise(value15)) {
        var inspected = value15.inspect();
        if (inspected.state === "fulfilled") {
          return inspected.value;
        }
      }
      return value15;
    }
    Q.isPromise = isPromise;
    function isPromise(object13) {
      return object13 instanceof Promise3;
    }
    Q.isPromiseAlike = isPromiseAlike;
    function isPromiseAlike(object13) {
      return isObject2(object13) && typeof object13.then === "function";
    }
    Q.isPending = isPending;
    function isPending(object13) {
      return isPromise(object13) && object13.inspect().state === "pending";
    }
    Promise3.prototype.isPending = function() {
      return this.inspect().state === "pending";
    };
    Q.isFulfilled = isFulfilled;
    function isFulfilled(object13) {
      return !isPromise(object13) || object13.inspect().state === "fulfilled";
    }
    Promise3.prototype.isFulfilled = function() {
      return this.inspect().state === "fulfilled";
    };
    Q.isRejected = isRejected;
    function isRejected(object13) {
      return isPromise(object13) && object13.inspect().state === "rejected";
    }
    Promise3.prototype.isRejected = function() {
      return this.inspect().state === "rejected";
    };
    var unhandledReasons = [];
    var unhandledRejections = [];
    var reportedUnhandledRejections = [];
    var trackUnhandledRejections = true;
    function resetUnhandledRejections() {
      unhandledReasons.length = 0;
      unhandledRejections.length = 0;
      if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
      }
    }
    function trackRejection(promise6, reason) {
      if (!trackUnhandledRejections) {
        return;
      }
      if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function() {
          if (array_indexOf(unhandledRejections, promise6) !== -1) {
            process.emit("unhandledRejection", reason, promise6);
            reportedUnhandledRejections.push(promise6);
          }
        });
      }
      unhandledRejections.push(promise6);
      if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
      } else {
        unhandledReasons.push("(no stack) " + reason);
      }
    }
    function untrackRejection(promise6) {
      if (!trackUnhandledRejections) {
        return;
      }
      var at = array_indexOf(unhandledRejections, promise6);
      if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
          Q.nextTick.runAfter(function() {
            var atReport = array_indexOf(reportedUnhandledRejections, promise6);
            if (atReport !== -1) {
              process.emit("rejectionHandled", unhandledReasons[at], promise6);
              reportedUnhandledRejections.splice(atReport, 1);
            }
          });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
      }
    }
    Q.resetUnhandledRejections = resetUnhandledRejections;
    Q.getUnhandledReasons = function() {
      return unhandledReasons.slice();
    };
    Q.stopUnhandledRejectionTracking = function() {
      resetUnhandledRejections();
      trackUnhandledRejections = false;
    };
    resetUnhandledRejections();
    Q.reject = reject2;
    function reject2(reason) {
      var rejection = Promise3({
        when: function(rejected) {
          if (rejected) {
            untrackRejection(this);
          }
          return rejected ? rejected(reason) : this;
        }
      }, function fallback() {
        return this;
      }, function inspect() {
        return { state: "rejected", reason };
      });
      trackRejection(rejection, reason);
      return rejection;
    }
    Q.fulfill = fulfill;
    function fulfill(value15) {
      return Promise3({
        when: function() {
          return value15;
        },
        get: function(name) {
          return value15[name];
        },
        set: function(name, rhs) {
          value15[name] = rhs;
        },
        delete: function(name) {
          delete value15[name];
        },
        post: function(name, args) {
          if (name === null || name === undefined) {
            return value15.apply(undefined, args);
          } else {
            return value15[name].apply(value15, args);
          }
        },
        apply: function(thisp, args) {
          return value15.apply(thisp, args);
        },
        keys: function() {
          return object_keys(value15);
        }
      }, undefined, function inspect() {
        return { state: "fulfilled", value: value15 };
      });
    }
    function coerce2(promise6) {
      var deferred = defer();
      Q.nextTick(function() {
        try {
          promise6.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
          deferred.reject(exception);
        }
      });
      return deferred.promise;
    }
    Q.master = master;
    function master(object13) {
      return Promise3({
        isDef: function() {
        }
      }, function fallback(op, args) {
        return dispatch(object13, op, args);
      }, function() {
        return Q(object13).inspect();
      });
    }
    Q.spread = spread;
    function spread(value15, fulfilled, rejected) {
      return Q(value15).spread(fulfilled, rejected);
    }
    Promise3.prototype.spread = function(fulfilled, rejected) {
      return this.all().then(function(array5) {
        return fulfilled.apply(undefined, array5);
      }, rejected);
    };
    Q.async = async3;
    function async3(makeGenerator) {
      return function() {
        function continuer(verb, arg) {
          var result;
          if (typeof StopIteration === "undefined") {
            try {
              result = generator[verb](arg);
            } catch (exception) {
              return reject2(exception);
            }
            if (result.done) {
              return Q(result.value);
            } else {
              return when(result.value, callback, errback);
            }
          } else {
            try {
              result = generator[verb](arg);
            } catch (exception) {
              if (isStopIteration(exception)) {
                return Q(exception.value);
              } else {
                return reject2(exception);
              }
            }
            return when(result, callback, errback);
          }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
      };
    }
    Q.spawn = spawn;
    function spawn(makeGenerator) {
      Q.done(Q.async(makeGenerator)());
    }
    Q["return"] = _return;
    function _return(value15) {
      throw new QReturnValue(value15);
    }
    Q.promised = promised;
    function promised(callback) {
      return function() {
        return spread([this, all(arguments)], function(self2, args) {
          return callback.apply(self2, args);
        });
      };
    }
    Q.dispatch = dispatch;
    function dispatch(object13, op, args) {
      return Q(object13).dispatch(op, args);
    }
    Promise3.prototype.dispatch = function(op, args) {
      var self2 = this;
      var deferred = defer();
      Q.nextTick(function() {
        self2.promiseDispatch(deferred.resolve, op, args);
      });
      return deferred.promise;
    };
    Q.get = function(object13, key) {
      return Q(object13).dispatch("get", [key]);
    };
    Promise3.prototype.get = function(key) {
      return this.dispatch("get", [key]);
    };
    Q.set = function(object13, key, value15) {
      return Q(object13).dispatch("set", [key, value15]);
    };
    Promise3.prototype.set = function(key, value15) {
      return this.dispatch("set", [key, value15]);
    };
    Q.del = Q["delete"] = function(object13, key) {
      return Q(object13).dispatch("delete", [key]);
    };
    Promise3.prototype.del = Promise3.prototype["delete"] = function(key) {
      return this.dispatch("delete", [key]);
    };
    Q.mapply = Q.post = function(object13, name, args) {
      return Q(object13).dispatch("post", [name, args]);
    };
    Promise3.prototype.mapply = Promise3.prototype.post = function(name, args) {
      return this.dispatch("post", [name, args]);
    };
    Q.send = Q.mcall = Q.invoke = function(object13, name) {
      return Q(object13).dispatch("post", [name, array_slice(arguments, 2)]);
    };
    Promise3.prototype.send = Promise3.prototype.mcall = Promise3.prototype.invoke = function(name) {
      return this.dispatch("post", [name, array_slice(arguments, 1)]);
    };
    Q.fapply = function(object13, args) {
      return Q(object13).dispatch("apply", [undefined, args]);
    };
    Promise3.prototype.fapply = function(args) {
      return this.dispatch("apply", [undefined, args]);
    };
    Q["try"] = Q.fcall = function(object13) {
      return Q(object13).dispatch("apply", [undefined, array_slice(arguments, 1)]);
    };
    Promise3.prototype.fcall = function() {
      return this.dispatch("apply", [undefined, array_slice(arguments)]);
    };
    Q.fbind = function(object13) {
      var promise6 = Q(object13);
      var args = array_slice(arguments, 1);
      return function fbound() {
        return promise6.dispatch("apply", [
          this,
          args.concat(array_slice(arguments))
        ]);
      };
    };
    Promise3.prototype.fbind = function() {
      var promise6 = this;
      var args = array_slice(arguments);
      return function fbound() {
        return promise6.dispatch("apply", [
          this,
          args.concat(array_slice(arguments))
        ]);
      };
    };
    Q.keys = function(object13) {
      return Q(object13).dispatch("keys", []);
    };
    Promise3.prototype.keys = function() {
      return this.dispatch("keys", []);
    };
    Q.all = all;
    function all(promises3) {
      return when(promises3, function(promises4) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises4, function(undefined6, promise6, index2) {
          var snapshot;
          if (isPromise(promise6) && (snapshot = promise6.inspect()).state === "fulfilled") {
            promises4[index2] = snapshot.value;
          } else {
            ++pendingCount;
            when(promise6, function(value15) {
              promises4[index2] = value15;
              if (--pendingCount === 0) {
                deferred.resolve(promises4);
              }
            }, deferred.reject, function(progress2) {
              deferred.notify({ index: index2, value: progress2 });
            });
          }
        }, undefined);
        if (pendingCount === 0) {
          deferred.resolve(promises4);
        }
        return deferred.promise;
      });
    }
    Promise3.prototype.all = function() {
      return all(this);
    };
    Q.any = any6;
    function any6(promises3) {
      if (promises3.length === 0) {
        return Q.resolve();
      }
      var deferred = Q.defer();
      var pendingCount = 0;
      array_reduce(promises3, function(prev, current, index2) {
        var promise6 = promises3[index2];
        pendingCount++;
        when(promise6, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
          deferred.resolve(result);
        }
        function onRejected(err2) {
          pendingCount--;
          if (pendingCount === 0) {
            var rejection = err2 || new Error("" + err2);
            rejection.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + rejection.message;
            deferred.reject(rejection);
          }
        }
        function onProgress(progress2) {
          deferred.notify({
            index: index2,
            value: progress2
          });
        }
      }, undefined);
      return deferred.promise;
    }
    Promise3.prototype.any = function() {
      return any6(this);
    };
    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
    function allResolved(promises3) {
      return when(promises3, function(promises4) {
        promises4 = array_map(promises4, Q);
        return when(all(array_map(promises4, function(promise6) {
          return when(promise6, noop, noop);
        })), function() {
          return promises4;
        });
      });
    }
    Promise3.prototype.allResolved = function() {
      return allResolved(this);
    };
    Q.allSettled = allSettled;
    function allSettled(promises3) {
      return Q(promises3).allSettled();
    }
    Promise3.prototype.allSettled = function() {
      return this.then(function(promises3) {
        return all(array_map(promises3, function(promise6) {
          promise6 = Q(promise6);
          function regardless() {
            return promise6.inspect();
          }
          return promise6.then(regardless, regardless);
        }));
      });
    };
    Q.fail = Q["catch"] = function(object13, rejected) {
      return Q(object13).then(undefined, rejected);
    };
    Promise3.prototype.fail = Promise3.prototype["catch"] = function(rejected) {
      return this.then(undefined, rejected);
    };
    Q.progress = progress;
    function progress(object13, progressed) {
      return Q(object13).then(undefined, undefined, progressed);
    }
    Promise3.prototype.progress = function(progressed) {
      return this.then(undefined, undefined, progressed);
    };
    Q.fin = Q["finally"] = function(object13, callback) {
      return Q(object13)["finally"](callback);
    };
    Promise3.prototype.fin = Promise3.prototype["finally"] = function(callback) {
      if (!callback || typeof callback.apply !== "function") {
        throw new Error("Q can't apply finally callback");
      }
      callback = Q(callback);
      return this.then(function(value15) {
        return callback.fcall().then(function() {
          return value15;
        });
      }, function(reason) {
        return callback.fcall().then(function() {
          throw reason;
        });
      });
    };
    Q.done = function(object13, fulfilled, rejected, progress2) {
      return Q(object13).done(fulfilled, rejected, progress2);
    };
    Promise3.prototype.done = function(fulfilled, rejected, progress2) {
      var onUnhandledError = function(error23) {
        Q.nextTick(function() {
          makeStackTraceLong(error23, promise6);
          if (Q.onerror) {
            Q.onerror(error23);
          } else {
            throw error23;
          }
        });
      };
      var promise6 = fulfilled || rejected || progress2 ? this.then(fulfilled, rejected, progress2) : this;
      if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
      }
      promise6.then(undefined, onUnhandledError);
    };
    Q.timeout = function(object13, ms, error23) {
      return Q(object13).timeout(ms, error23);
    };
    Promise3.prototype.timeout = function(ms, error23) {
      var deferred = defer();
      var timeoutId = setTimeout(function() {
        if (!error23 || typeof error23 === "string") {
          error23 = new Error(error23 || "Timed out after " + ms + " ms");
          error23.code = "ETIMEDOUT";
        }
        deferred.reject(error23);
      }, ms);
      this.then(function(value15) {
        clearTimeout(timeoutId);
        deferred.resolve(value15);
      }, function(exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
      }, deferred.notify);
      return deferred.promise;
    };
    Q.delay = function(object13, timeout) {
      if (timeout === undefined) {
        timeout = object13;
        object13 = undefined;
      }
      return Q(object13).delay(timeout);
    };
    Promise3.prototype.delay = function(timeout) {
      return this.then(function(value15) {
        var deferred = defer();
        setTimeout(function() {
          deferred.resolve(value15);
        }, timeout);
        return deferred.promise;
      });
    };
    Q.nfapply = function(callback, args) {
      return Q(callback).nfapply(args);
    };
    Promise3.prototype.nfapply = function(args) {
      var deferred = defer();
      var nodeArgs = array_slice(args);
      nodeArgs.push(deferred.makeNodeResolver());
      this.fapply(nodeArgs).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nfcall = function(callback) {
      var args = array_slice(arguments, 1);
      return Q(callback).nfapply(args);
    };
    Promise3.prototype.nfcall = function() {
      var nodeArgs = array_slice(arguments);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      this.fapply(nodeArgs).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nfbind = Q.denodeify = function(callback) {
      if (callback === undefined) {
        throw new Error("Q can't wrap an undefined function");
      }
      var baseArgs = array_slice(arguments, 1);
      return function() {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
    };
    Promise3.prototype.nfbind = Promise3.prototype.denodeify = function() {
      var args = array_slice(arguments);
      args.unshift(this);
      return Q.denodeify.apply(undefined, args);
    };
    Q.nbind = function(callback, thisp) {
      var baseArgs = array_slice(arguments, 2);
      return function() {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
          return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
    };
    Promise3.prototype.nbind = function() {
      var args = array_slice(arguments, 0);
      args.unshift(this);
      return Q.nbind.apply(undefined, args);
    };
    Q.nmapply = Q.npost = function(object13, name, args) {
      return Q(object13).npost(name, args);
    };
    Promise3.prototype.nmapply = Promise3.prototype.npost = function(name, args) {
      var nodeArgs = array_slice(args || []);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nsend = Q.nmcall = Q.ninvoke = function(object13, name) {
      var nodeArgs = array_slice(arguments, 2);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      Q(object13).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
      return deferred.promise;
    };
    Promise3.prototype.nsend = Promise3.prototype.nmcall = Promise3.prototype.ninvoke = function(name) {
      var nodeArgs = array_slice(arguments, 1);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nodeify = nodeify;
    function nodeify(object13, nodeback) {
      return Q(object13).nodeify(nodeback);
    }
    Promise3.prototype.nodeify = function(nodeback) {
      if (nodeback) {
        this.then(function(value15) {
          Q.nextTick(function() {
            nodeback(null, value15);
          });
        }, function(error23) {
          Q.nextTick(function() {
            nodeback(error23);
          });
        });
      } else {
        return this;
      }
    };
    Q.noConflict = function() {
      throw new Error("Q.noConflict only works when Q is used as a global");
    };
    var qEndingLine = captureLine();
    return Q;
  });
});

// node_modules/cloudinary/lib/cache.js
var require_cache = __commonJS((exports, module) => {
  var CACHE = Symbol.for("com.cloudinary.cache");
  var CACHE_ADAPTER = Symbol.for("com.cloudinary.cacheAdapter");
  var { ensurePresenceOf, generate_transformation_string } = require_utils();

  class CacheAdapter {
    get(publicId, type50, resourceType, transformation, format) {
    }
    set(publicId, type50, resourceType, transformation, format, value15) {
    }
    flushAll() {
    }
  }
  var Cache = {
    CacheAdapter,
    setAdapter(adapter2) {
      if (this.adapter) {
        console.warn("Overriding existing cache adapter");
      }
      this.adapter = adapter2;
    },
    getAdapter() {
      return this.adapter;
    },
    get(publicId, options) {
      if (!this.adapter) {
        return;
      }
      ensurePresenceOf({ publicId });
      let transformation = generate_transformation_string({ ...options });
      return this.adapter.get(publicId, options.type || "upload", options.resource_type || "image", transformation, options.format);
    },
    set(publicId, options, value15) {
      if (!this.adapter) {
        return;
      }
      ensurePresenceOf({ publicId, value: value15 });
      let transformation = generate_transformation_string({ ...options });
      return this.adapter.set(publicId, options.type || "upload", options.resource_type || "image", transformation, options.format, value15);
    },
    flushAll() {
      if (!this.adapter) {
        return;
      }
      return this.adapter.flushAll();
    }
  };
  Object.defineProperty(Cache, "instance", {
    get() {
      return global[CACHE];
    }
  });
  Object.defineProperty(Cache, "adapter", {
    get() {
      return global[CACHE_ADAPTER];
    },
    set(adapter2) {
      global[CACHE_ADAPTER] = adapter2;
    }
  });
  Object.freeze(Cache);
  var symbols70 = Object.getOwnPropertySymbols(global);
  if (symbols70.indexOf(CACHE) < 0) {
    global[CACHE] = Cache;
  }
  module.exports = Cache;
});

// node_modules/cloudinary/lib/upload_stream.js
var require_upload_stream = __commonJS((exports, module) => {
  var Transform2 = import.meta.require("stream").Transform;

  class UploadStream extends Transform2 {
    constructor(options) {
      super();
      this.boundary = options.boundary;
    }
    _transform(data, encoding5, next) {
      let buffer = Buffer.isBuffer(data) ? data : Buffer.from(data, encoding5);
      this.push(buffer);
      next();
    }
    _flush(next) {
      this.push(Buffer.from("\r\n", "ascii"));
      this.push(Buffer.from("--" + this.boundary + "--", "ascii"));
      return next();
    }
  }
  module.exports = UploadStream;
});

// node_modules/cloudinary/lib/uploader.js
var require_uploader = __commonJS((exports) => {
  function call_tags_api(tag, command, public_ids = [], callback, options = {}) {
    return call_api("tags", callback, options, function() {
      let params = {
        timestamp: utils.timestamp(),
        public_ids: utils.build_array(public_ids),
        command,
        type: options.type
      };
      if (tag != null) {
        params.tag = tag;
      }
      return [params];
    });
  }
  function call_context_api(context, command, public_ids = [], callback, options = {}) {
    return call_api("context", callback, options, function() {
      let params = {
        timestamp: utils.timestamp(),
        public_ids: utils.build_array(public_ids),
        command,
        type: options.type
      };
      if (context != null) {
        params.context = utils.encode_context(context);
      }
      return [params];
    });
  }
  function cacheResults(result, { type: type50, resource_type }) {
    if (result.responsive_breakpoints) {
      result.responsive_breakpoints.forEach(({
        transformation,
        url,
        breakpoints
      }) => Cache.set(result.public_id, { type: type50, resource_type, raw_transformation: transformation, format: extname2(breakpoints[0].url).slice(1) }, breakpoints.map((i3) => i3.width)));
    }
  }
  function parseResult(buffer, res) {
    let result = "";
    try {
      result = JSON.parse(buffer);
      if (result.error && !result.error.name) {
        result.error.name = "Error";
      }
    } catch (jsonError) {
      result = {
        error: {
          message: `Server return invalid JSON response. Status Code ${res.statusCode}. ${jsonError}`,
          name: "Error"
        }
      };
    }
    return result;
  }
  function call_api(action, callback, options, get_params) {
    if (typeof callback !== "function") {
      callback = function() {
      };
    }
    const USE_PROMISES = !options.disable_promises;
    let deferred = Q.defer();
    if (options == null) {
      options = {};
    }
    let [params, unsigned_params, file] = get_params.call();
    params = utils.process_request_params(params, options);
    params = extend(params, unsigned_params);
    let api_url = utils.api_url(action, options);
    let boundary = utils.random_public_id();
    let errorRaised = false;
    let handle_response = function(res) {
      if (errorRaised) {
      } else if (res.error) {
        errorRaised = true;
        if (USE_PROMISES) {
          deferred.reject(res);
        }
        callback(res);
      } else if (includes2([200, 400, 401, 404, 420, 500], res.statusCode)) {
        let buffer = "";
        res.on("data", (d3) => {
          buffer += d3;
          return buffer;
        });
        res.on("end", () => {
          let result2;
          if (errorRaised) {
            return;
          }
          result2 = parseResult(buffer, res);
          if (result2.error) {
            result2.error.http_code = res.statusCode;
            if (USE_PROMISES) {
              deferred.reject(result2.error);
            }
          } else {
            cacheResults(result2, options);
            if (USE_PROMISES) {
              deferred.resolve(result2);
            }
          }
          callback(result2);
        });
        res.on("error", (error23) => {
          errorRaised = true;
          if (USE_PROMISES) {
            deferred.reject(error23);
          }
          callback({ error: error23 });
        });
      } else {
        let error23 = {
          message: `Server returned unexpected status code - ${res.statusCode}`,
          http_code: res.statusCode,
          name: "UnexpectedResponse"
        };
        if (USE_PROMISES) {
          deferred.reject(error23);
        }
        callback({ error: error23 });
      }
    };
    let post_data = utils.hashToParameters(params).filter(([key, value15]) => value15 != null).map(([key, value15]) => Buffer.from(encodeFieldPart(boundary, key, value15), "utf8"));
    let result = post(api_url, post_data, boundary, file, handle_response, options);
    if (isObject2(result)) {
      return result;
    }
    if (USE_PROMISES) {
      return deferred.promise;
    }
  }
  function post(url, post_data, boundary, file, callback, options) {
    let file_header;
    let finish_buffer = Buffer.from("--" + boundary + "--", "ascii");
    let oauth_token = options.oauth_token || config2().oauth_token;
    if (file != null || options.stream) {
      let filename = options.stream ? options.filename ? options.filename : "file" : basename(file);
      file_header = Buffer.from(encodeFilePart(boundary, "application/octet-stream", "file", filename), "binary");
    }
    let post_options = urlLib.parse(url);
    let headers = {
      "Content-Type": `multipart/form-data; boundary=${boundary}`,
      "User-Agent": utils.getUserAgent()
    };
    if (options.content_range != null) {
      headers["Content-Range"] = options.content_range;
    }
    if (options.x_unique_upload_id != null) {
      headers["X-Unique-Upload-Id"] = options.x_unique_upload_id;
    }
    if (options.extra_headers !== null) {
      headers = merge(headers, options.extra_headers);
    }
    if (oauth_token != null) {
      headers.Authorization = `Bearer ${oauth_token}`;
    }
    post_options = extend(post_options, {
      method: "POST",
      headers
    });
    if (options.agent != null) {
      post_options.agent = options.agent;
    }
    let proxy = options.api_proxy || config2().api_proxy;
    if (!isEmpty2(proxy)) {
      if (!post_options.agent && agent) {
        post_options.agent = agent;
      } else if (!post_options.agent) {
        post_options.agent = new https2.Agent(proxy);
      } else {
        console.warn("Proxy is set, but request uses a custom agent, proxy is ignored.");
      }
    }
    let post_request = https2.request(post_options, callback);
    let upload_stream = new UploadStream({ boundary });
    upload_stream.pipe(post_request);
    let timeout = false;
    post_request.on("error", function(error23) {
      if (timeout) {
        error23 = {
          message: "Request Timeout",
          http_code: 499,
          name: "TimeoutError"
        };
      }
      return callback({ error: error23 });
    });
    post_request.setTimeout(options.timeout != null ? options.timeout : 60000, function() {
      timeout = true;
      return post_request.abort();
    });
    post_data.forEach((postDatum) => post_request.write(postDatum));
    if (options.stream) {
      post_request.write(file_header);
      return upload_stream;
    }
    if (file != null) {
      post_request.write(file_header);
      fs4.createReadStream(file).on("error", function(error23) {
        callback({
          error: error23
        });
        return post_request.abort();
      }).pipe(upload_stream);
    } else {
      post_request.write(finish_buffer);
      post_request.end();
    }
    return true;
  }
  function encodeFieldPart(boundary, name, value15) {
    return [
      `--${boundary}\r\n`,
      `Content-Disposition: form-data; name="${name}"\r\n`,
      "\r\n",
      `${value15}\r\n`,
      ""
    ].join("");
  }
  function encodeFilePart(boundary, type50, name, filename) {
    return [
      `--${boundary}\r\n`,
      `Content-Disposition: form-data; name="${name}"; filename="${filename}"\r\n`,
      `Content-Type: ${type50}\r\n`,
      "\r\n",
      ""
    ].join("");
  }
  var fs4 = import.meta.require("fs");
  var { extname: extname2, basename } = import.meta.require("path");
  var Q = require_q();
  var Writable = import.meta.require("stream").Writable;
  var urlLib = import.meta.require("url");
  var { upload_prefix } = require_config()();
  var isSecure = !(upload_prefix && upload_prefix.slice(0, 5) === "http:");
  var https2 = isSecure ? import.meta.require("https") : import.meta.require("http");
  var Cache = require_cache();
  var utils = require_utils();
  var UploadStream = require_upload_stream();
  var config2 = require_config();
  var ensureOption = require_ensureOption().defaults(config2());
  var agent = config2.api_proxy ? new https2.Agent(config2.api_proxy) : null;
  var {
    build_upload_params,
    extend,
    includes: includes2,
    isEmpty: isEmpty2,
    isObject: isObject2,
    isRemoteUrl,
    merge,
    pickOnlyExistingValues
  } = utils;
  exports.unsigned_upload_stream = function unsigned_upload_stream(upload_preset, callback, options = {}) {
    return exports.upload_stream(callback, merge(options, {
      unsigned: true,
      upload_preset
    }));
  };
  exports.upload_stream = function upload_stream(callback, options = {}) {
    return exports.upload(null, callback, extend({
      stream: true
    }, options));
  };
  exports.unsigned_upload = function unsigned_upload(file, upload_preset, callback, options = {}) {
    return exports.upload(file, callback, merge(options, {
      unsigned: true,
      upload_preset
    }));
  };
  exports.upload = function upload(file, callback, options = {}) {
    return call_api("upload", callback, options, function() {
      let params = build_upload_params(options);
      return isRemoteUrl(file) ? [params, { file }] : [params, {}, file];
    });
  };
  exports.upload_large = function upload_large(path2, callback, options = {}) {
    if (path2 != null && isRemoteUrl(path2)) {
      return exports.upload(path2, callback, options);
    }
    if (path2 != null && !options.filename) {
      options.filename = path2.split(/(\\|\/)/g).pop().replace(/\.[^/.]+$/, "");
    }
    return exports.upload_chunked(path2, callback, extend({
      resource_type: "raw"
    }, options));
  };
  exports.upload_chunked = function upload_chunked(path2, callback, options) {
    let file_reader = fs4.createReadStream(path2);
    let out_stream = exports.upload_chunked_stream(callback, options);
    return file_reader.pipe(out_stream);
  };

  class Chunkable extends Writable {
    constructor(options) {
      super(options);
      this.chunk_size = options.chunk_size != null ? options.chunk_size : 20000000;
      this.buffer = Buffer.alloc(0);
      this.active = true;
      this.on("finish", () => {
        if (this.active) {
          this.emit("ready", this.buffer, true, function() {
          });
        }
      });
    }
    _write(data, encoding5, done) {
      if (!this.active) {
        done();
      }
      if (this.buffer.length + data.length <= this.chunk_size) {
        this.buffer = Buffer.concat([this.buffer, data], this.buffer.length + data.length);
        done();
      } else {
        const grab = this.chunk_size - this.buffer.length;
        this.buffer = Buffer.concat([this.buffer, data.slice(0, grab)], this.buffer.length + grab);
        this.emit("ready", this.buffer, false, (active) => {
          this.active = active;
          if (this.active) {
            const remaining = data.slice(grab);
            this.buffer = Buffer.alloc(0);
            this._write(remaining, encoding5, done);
          }
        });
      }
    }
  }
  exports.upload_large_stream = function upload_large_stream(_unused_, callback, options = {}) {
    return exports.upload_chunked_stream(callback, extend({
      resource_type: "raw"
    }, options));
  };
  exports.upload_chunked_stream = function upload_chunked_stream(callback, options = {}) {
    options = extend({}, options, {
      stream: true
    });
    options.x_unique_upload_id = utils.random_public_id();
    let params = build_upload_params(options);
    let chunk_size = options.chunk_size != null ? options.chunk_size : options.part_size;
    let chunker = new Chunkable({
      chunk_size
    });
    let sent = 0;
    chunker.on("ready", function(buffer, is_last, done) {
      let chunk_start = sent;
      sent += buffer.length;
      options.content_range = `bytes ${chunk_start}-${sent - 1}/${is_last ? sent : -1}`;
      params.timestamp = utils.timestamp();
      let finished_part = function(result) {
        const errorOrLast = result.error != null || is_last;
        if (errorOrLast && typeof callback === "function") {
          callback(result);
        }
        return done(!errorOrLast);
      };
      let stream5 = call_api("upload", finished_part, options, function() {
        return [params, {}, buffer];
      });
      return stream5.write(buffer, "buffer", function() {
        return stream5.end();
      });
    });
    return chunker;
  };
  exports.explicit = function explicit(public_id, callback, options = {}) {
    return call_api("explicit", callback, options, function() {
      return utils.build_explicit_api_params(public_id, options);
    });
  };
  exports.create_archive = function create_archive(callback, options = {}, target_format = null) {
    return call_api("generate_archive", callback, options, function() {
      let opt = utils.archive_params(options);
      if (target_format) {
        opt.target_format = target_format;
      }
      return [opt];
    });
  };
  exports.create_zip = function create_zip(callback, options = {}) {
    return exports.create_archive(callback, options, "zip");
  };
  exports.create_slideshow = function create_slideshow(options, callback) {
    options.resource_type = ensureOption(options, "resource_type", "video");
    return call_api("create_slideshow", callback, options, function() {
      const manifest_transformation = utils.generate_transformation_string(extend({}, options.manifest_transformation));
      const transformation = utils.generate_transformation_string(extend({}, ensureOption(options, "transformation", {})));
      return [
        {
          timestamp: utils.timestamp(),
          manifest_transformation,
          upload_preset: options.upload_preset,
          overwrite: options.overwrite,
          public_id: options.public_id,
          notification_url: options.notification_url,
          manifest_json: options.manifest_json,
          tags: options.tags,
          transformation
        }
      ];
    });
  };
  exports.destroy = function destroy(public_id, callback, options = {}) {
    return call_api("destroy", callback, options, function() {
      return [
        {
          timestamp: utils.timestamp(),
          type: options.type,
          invalidate: options.invalidate,
          public_id,
          notification_url: options.notification_url
        }
      ];
    });
  };
  exports.rename = function rename(from_public_id, to_public_id, callback, options = {}) {
    return call_api("rename", callback, options, function() {
      return [
        {
          timestamp: utils.timestamp(),
          type: options.type,
          from_public_id,
          to_public_id,
          overwrite: options.overwrite,
          invalidate: options.invalidate,
          to_type: options.to_type,
          context: options.context,
          metadata: options.metadata,
          notification_url: options.notification_url
        }
      ];
    });
  };
  var TEXT_PARAMS = ["public_id", "font_family", "font_size", "font_color", "text_align", "font_weight", "font_style", "background", "opacity", "text_decoration", "font_hinting", "font_antialiasing"];
  exports.text = function text(content, callback, options = {}) {
    return call_api("text", callback, options, function() {
      let textParams = pickOnlyExistingValues(options, ...TEXT_PARAMS);
      let params = {
        timestamp: utils.timestamp(),
        text: content,
        ...textParams
      };
      return [params];
    });
  };
  exports.generate_sprite = function generate_sprite(tag, callback, options = {}) {
    return call_api("sprite", callback, options, function() {
      return [utils.build_multi_and_sprite_params(tag, options)];
    });
  };
  exports.download_generated_sprite = function download_generated_sprite(tag, options = {}) {
    return utils.api_download_url("sprite", utils.build_multi_and_sprite_params(tag, options), options);
  };
  exports.download_multi = function download_multi(tag, options = {}) {
    return utils.api_download_url("multi", utils.build_multi_and_sprite_params(tag, options), options);
  };
  exports.multi = function multi(tag, callback, options = {}) {
    return call_api("multi", callback, options, function() {
      return [utils.build_multi_and_sprite_params(tag, options)];
    });
  };
  exports.explode = function explode(public_id, callback, options = {}) {
    return call_api("explode", callback, options, function() {
      const transformation = utils.generate_transformation_string(extend({}, options));
      return [
        {
          timestamp: utils.timestamp(),
          public_id,
          transformation,
          format: options.format,
          type: options.type,
          notification_url: options.notification_url
        }
      ];
    });
  };
  exports.add_tag = function add_tag(tag, public_ids = [], callback, options = {}) {
    const exclusive = utils.option_consume("exclusive", options);
    const command = exclusive ? "set_exclusive" : "add";
    return call_tags_api(tag, command, public_ids, callback, options);
  };
  exports.remove_tag = function remove_tag(tag, public_ids = [], callback, options = {}) {
    return call_tags_api(tag, "remove", public_ids, callback, options);
  };
  exports.remove_all_tags = function remove_all_tags(public_ids = [], callback, options = {}) {
    return call_tags_api(null, "remove_all", public_ids, callback, options);
  };
  exports.replace_tag = function replace_tag(tag, public_ids = [], callback, options = {}) {
    return call_tags_api(tag, "replace", public_ids, callback, options);
  };
  exports.add_context = function add_context(context, public_ids = [], callback, options = {}) {
    return call_context_api(context, "add", public_ids, callback, options);
  };
  exports.remove_all_context = function remove_all_context(public_ids = [], callback, options = {}) {
    return call_context_api(null, "remove_all", public_ids, callback, options);
  };
  exports.direct_upload = function direct_upload(callback_url, options = {}) {
    let params = build_upload_params(extend({
      callback: callback_url
    }, options));
    params = utils.process_request_params(params, options);
    let api_url = utils.api_url("upload", options);
    return {
      hidden_fields: params,
      form_attrs: {
        action: api_url,
        method: "POST",
        enctype: "multipart/form-data"
      }
    };
  };
  exports.upload_tag_params = function upload_tag_params(options = {}) {
    let params = build_upload_params(options);
    params = utils.process_request_params(params, options);
    return JSON.stringify(params);
  };
  exports.upload_url = function upload_url(options = {}) {
    if (options.resource_type == null) {
      options.resource_type = "auto";
    }
    return utils.api_url("upload", options);
  };
  exports.image_upload_tag = function image_upload_tag(field, options = {}) {
    let html_options = options.html || {};
    let tag_options = extend({
      type: "file",
      name: "file",
      "data-url": exports.upload_url(options),
      "data-form-data": exports.upload_tag_params(options),
      "data-cloudinary-field": field,
      "data-max-chunk-size": options.chunk_size,
      class: [html_options.class, "cloudinary-fileupload"].join(" ")
    }, html_options);
    return `<input ${utils.html_attrs(tag_options)}/>`;
  };
  exports.unsigned_image_upload_tag = function unsigned_image_upload_tag(field, upload_preset, options = {}) {
    return exports.image_upload_tag(field, merge(options, {
      unsigned: true,
      upload_preset
    }));
  };
  exports.update_metadata = function update_metadata(metadata, public_ids, callback, options = {}) {
    return call_api("metadata", callback, options, function() {
      let params = {
        metadata: utils.encode_context(metadata),
        public_ids: utils.build_array(public_ids),
        timestamp: utils.timestamp(),
        type: options.type,
        clear_invalid: options.clear_invalid
      };
      return [params];
    });
  };
});

// node_modules/cloudinary/lib/api_client/execute_request.js
var require_execute_request = __commonJS((exports, module) => {
  function execute_request(method, params, auth3, api_url, callback, options = {}) {
    method = method.toUpperCase();
    const deferred = Q.defer();
    let query_params, handle_response;
    let key = auth3.key;
    let secret = auth3.secret;
    let oauth_token = auth3.oauth_token;
    let content_type = "application/x-www-form-urlencoded";
    if (options.content_type === "json") {
      query_params = JSON.stringify(params);
      content_type = "application/json";
    } else {
      query_params = querystring.stringify(params);
    }
    if (method === "GET") {
      api_url += "?" + query_params;
    }
    let request_options = url.parse(api_url);
    request_options = extend(request_options, {
      method,
      headers: {
        "Content-Type": content_type,
        "User-Agent": utils.getUserAgent()
      }
    });
    if (oauth_token) {
      request_options.headers.Authorization = `Bearer ${oauth_token}`;
    } else {
      request_options.auth = key + ":" + secret;
    }
    if (options.agent != null) {
      request_options.agent = options.agent;
    }
    let proxy = options.api_proxy || config2().api_proxy;
    if (!isEmpty2(proxy)) {
      if (!request_options.agent && agent) {
        request_options.agent = agent;
      } else if (!request_options.agent) {
        request_options.agent = new https2.Agent(proxy);
      } else {
        console.warn("Proxy is set, but request uses a custom agent, proxy is ignored.");
      }
    }
    if (method !== "GET") {
      request_options.headers["Content-Length"] = Buffer.byteLength(query_params);
    }
    handle_response = function(res) {
      const { hide_sensitive = false } = config2();
      const sanitizedOptions = { ...request_options };
      if (hide_sensitive === true) {
        if ("auth" in sanitizedOptions) {
          delete sanitizedOptions.auth;
        }
        if ("Authorization" in sanitizedOptions.headers) {
          delete sanitizedOptions.headers.Authorization;
        }
      }
      if (includes2([200, 400, 401, 403, 404, 409, 420, 500], res.statusCode)) {
        let buffer = "";
        let error23 = false;
        res.on("data", function(d3) {
          buffer += d3;
          return buffer;
        });
        res.on("end", function() {
          let result;
          if (error23) {
            return;
          }
          try {
            result = JSON.parse(buffer);
          } catch (e) {
            result = {
              error: {
                message: "Server return invalid JSON response. Status Code " + res.statusCode
              }
            };
          }
          if (result.error) {
            result.error.http_code = res.statusCode;
          } else {
            if (res.headers["x-featureratelimit-limit"]) {
              result.rate_limit_allowed = parseInt(res.headers["x-featureratelimit-limit"]);
            }
            if (res.headers["x-featureratelimit-reset"]) {
              result.rate_limit_reset_at = new Date(res.headers["x-featureratelimit-reset"]);
            }
            if (res.headers["x-featureratelimit-remaining"]) {
              result.rate_limit_remaining = parseInt(res.headers["x-featureratelimit-remaining"]);
            }
          }
          if (result.error) {
            deferred.reject(Object.assign({
              request_options: sanitizedOptions,
              query_params
            }, result));
          } else {
            deferred.resolve(result);
          }
          if (typeof callback === "function") {
            callback(result);
          }
        });
        res.on("error", function(e) {
          error23 = true;
          let err_obj = {
            error: {
              message: e,
              http_code: res.statusCode,
              request_options: sanitizedOptions,
              query_params
            }
          };
          deferred.reject(err_obj.error);
          if (typeof callback === "function") {
            callback(err_obj);
          }
        });
      } else {
        let err_obj = {
          error: {
            message: "Server returned unexpected status code - " + res.statusCode,
            http_code: res.statusCode,
            request_options: sanitizedOptions,
            query_params
          }
        };
        deferred.reject(err_obj.error);
        if (typeof callback === "function") {
          callback(err_obj);
        }
      }
    };
    const request27 = https2.request(request_options, handle_response);
    request27.on("error", function(e) {
      deferred.reject(e);
      return typeof callback === "function" ? callback({ error: e }) : undefined;
    });
    request27.setTimeout(ensureOption(options, "timeout", 60000));
    if (method !== "GET") {
      request27.write(query_params);
    }
    request27.end();
    return deferred.promise;
  }
  var config2 = require_config();
  var https2 = /^http:/.test(config2().upload_prefix) ? import.meta.require("http") : import.meta.require("https");
  var querystring = import.meta.require("querystring");
  var Q = require_q();
  var url = import.meta.require("url");
  var utils = require_utils();
  var ensureOption = require_ensureOption().defaults(config2());
  var { extend, includes: includes2, isEmpty: isEmpty2 } = utils;
  var agent = config2.api_proxy ? new https2.Agent(config2.api_proxy) : null;
  module.exports = execute_request;
});

// node_modules/cloudinary/lib/api_client/call_api.js
var require_call_api = __commonJS((exports, module) => {
  function call_api(method, uri, params, callback, options) {
    ensurePresenceOf({ method, uri });
    const api_url = utils.base_api_url_v1()(uri, options);
    let auth3 = {};
    if (options.oauth_token || config2().oauth_token) {
      auth3 = {
        oauth_token: ensureOption(options, "oauth_token")
      };
    } else {
      auth3 = {
        key: ensureOption(options, "api_key"),
        secret: ensureOption(options, "api_secret")
      };
    }
    return execute_request(method, params, auth3, api_url, callback, options);
  }
  var config2 = require_config();
  var utils = require_utils();
  var ensureOption = require_ensureOption().defaults(config2());
  var execute_request = require_execute_request();
  var { ensurePresenceOf } = utils;
  module.exports = call_api;
});

// node_modules/cloudinary/lib/api.js
var require_api = __commonJS((exports) => {
  function deleteResourcesParams(options, params = {}) {
    return extend(params, pickOnlyExistingValues(options, "keep_original", "invalidate", "next_cursor", "transformations"));
  }
  function getResourceParams(options) {
    return pickOnlyExistingValues(options, "exif", "cinemagraph_analysis", "colors", "derived_next_cursor", "faces", "image_metadata", "media_metadata", "pages", "phash", "coordinates", "max_results", "versions", "accessibility_analysis", "related", "related_next_cursor");
  }
  function publishResource(byKey, value15, callback, options = {}) {
    let params, resource_type, uri;
    params = pickOnlyExistingValues(options, "type", "invalidate", "overwrite");
    params[byKey] = value15;
    resource_type = options.resource_type || "image";
    uri = ["resources", resource_type, "publish_resources"];
    options = extend({
      resource_type
    }, options);
    return call_api("post", uri, params, callback, options);
  }
  function updateResourcesAccessMode(access_mode, by_key, value15, callback, options = {}) {
    let params, resource_type, type50;
    resource_type = options.resource_type || "image";
    type50 = options.type || "upload";
    params = {
      access_mode
    };
    params[by_key] = value15;
    return call_api("post", "resources/" + resource_type + "/" + type50 + "/update_access_mode", params, callback, options);
  }
  var utils = require_utils();
  var call_api = require_call_api();
  var {
    extend,
    pickOnlyExistingValues
  } = utils;
  var TRANSFORMATIONS_URI = "transformations";
  exports.ping = function ping(callback, options = {}) {
    return call_api("get", ["ping"], {}, callback, options);
  };
  exports.usage = function usage(callback, options = {}) {
    const uri = ["usage"];
    if (options.date) {
      uri.push(options.date);
    }
    return call_api("get", uri, {}, callback, options);
  };
  exports.resource_types = function resource_types(callback, options = {}) {
    return call_api("get", ["resources"], {}, callback, options);
  };
  exports.resources = function resources(callback, options = {}) {
    let resource_type, type50, uri;
    resource_type = options.resource_type || "image";
    type50 = options.type;
    uri = ["resources", resource_type];
    if (type50 != null) {
      uri.push(type50);
    }
    if (options.start_at != null && Object.prototype.toString.call(options.start_at) === "[object Date]") {
      options.start_at = options.start_at.toUTCString();
    }
    return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "prefix", "tags", "context", "direction", "moderations", "start_at", "metadata", "fields"), callback, options);
  };
  exports.resources_by_tag = function resources_by_tag(tag, callback, options = {}) {
    let resource_type, uri;
    resource_type = options.resource_type || "image";
    uri = ["resources", resource_type, "tags", tag];
    return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "direction", "moderations", "metadata", "fields"), callback, options);
  };
  exports.resources_by_context = function resources_by_context(key, value15, callback, options = {}) {
    let params, resource_type, uri;
    resource_type = options.resource_type || "image";
    uri = ["resources", resource_type, "context"];
    params = pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "direction", "moderations", "metadata", "fields");
    params.key = key;
    if (value15 != null) {
      params.value = value15;
    }
    return call_api("get", uri, params, callback, options);
  };
  exports.resources_by_moderation = function resources_by_moderation(kind28, status, callback, options = {}) {
    let resource_type, uri;
    resource_type = options.resource_type || "image";
    uri = ["resources", resource_type, "moderations", kind28, status];
    return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "direction", "moderations", "metadata", "fields"), callback, options);
  };
  exports.resource_by_asset_id = function resource_by_asset_id(asset_id, callback, options = {}) {
    const uri = ["resources", asset_id];
    return call_api("get", uri, getResourceParams(options), callback, options);
  };
  exports.resources_by_asset_folder = function resources_by_asset_folder(asset_folder, callback, options = {}) {
    let params, uri;
    uri = ["resources", "by_asset_folder"];
    params = pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "moderations", "fields");
    params.asset_folder = asset_folder;
    return call_api("get", uri, params, callback, options);
  };
  exports.resources_by_asset_ids = function resources_by_asset_ids(asset_ids, callback, options = {}) {
    let params, uri;
    uri = ["resources", "by_asset_ids"];
    params = pickOnlyExistingValues(options, "tags", "context", "moderations", "fields");
    params["asset_ids[]"] = asset_ids;
    return call_api("get", uri, params, callback, options);
  };
  exports.resources_by_ids = function resources_by_ids(public_ids, callback, options = {}) {
    let params, resource_type, type50, uri;
    resource_type = options.resource_type || "image";
    type50 = options.type || "upload";
    uri = ["resources", resource_type, type50];
    params = pickOnlyExistingValues(options, "tags", "context", "moderations", "fields");
    params["public_ids[]"] = public_ids;
    return call_api("get", uri, params, callback, options);
  };
  exports.resource = function resource(public_id, callback, options = {}) {
    let resource_type, type50, uri;
    resource_type = options.resource_type || "image";
    type50 = options.type || "upload";
    uri = ["resources", resource_type, type50, public_id];
    return call_api("get", uri, getResourceParams(options), callback, options);
  };
  exports.restore = function restore(public_ids, callback, options = {}) {
    options.content_type = "json";
    let resource_type, type50, uri;
    resource_type = options.resource_type || "image";
    type50 = options.type || "upload";
    uri = ["resources", resource_type, type50, "restore"];
    return call_api("post", uri, {
      public_ids,
      versions: options.versions
    }, callback, options);
  };
  exports.update = function update(public_id, callback, options = {}) {
    let params, resource_type, type50, uri;
    resource_type = options.resource_type || "image";
    type50 = options.type || "upload";
    uri = ["resources", resource_type, type50, public_id];
    params = utils.updateable_resource_params(options);
    if (options.moderation_status != null) {
      params.moderation_status = options.moderation_status;
    }
    if (options.clear_invalid != null) {
      params.clear_invalid = options.clear_invalid;
    }
    return call_api("post", uri, params, callback, options);
  };
  exports.delete_resources = function delete_resources(public_ids, callback, options = {}) {
    let resource_type, type50, uri;
    resource_type = options.resource_type || "image";
    type50 = options.type || "upload";
    uri = ["resources", resource_type, type50];
    return call_api("delete", uri, deleteResourcesParams(options, {
      "public_ids[]": public_ids
    }), callback, options);
  };
  exports.delete_resources_by_prefix = function delete_resources_by_prefix(prefix, callback, options = {}) {
    let resource_type, type50, uri;
    resource_type = options.resource_type || "image";
    type50 = options.type || "upload";
    uri = ["resources", resource_type, type50];
    return call_api("delete", uri, deleteResourcesParams(options, {
      prefix
    }), callback, options);
  };
  exports.delete_resources_by_tag = function delete_resources_by_tag(tag, callback, options = {}) {
    let resource_type, uri;
    resource_type = options.resource_type || "image";
    uri = ["resources", resource_type, "tags", tag];
    return call_api("delete", uri, deleteResourcesParams(options), callback, options);
  };
  exports.delete_all_resources = function delete_all_resources(callback, options = {}) {
    let resource_type, type50, uri;
    resource_type = options.resource_type || "image";
    type50 = options.type || "upload";
    uri = ["resources", resource_type, type50];
    return call_api("delete", uri, deleteResourcesParams(options, {
      all: true
    }), callback, options);
  };
  var createRelationParams = (publicIds = []) => {
    return {
      assets_to_relate: Array.isArray(publicIds) ? publicIds : [publicIds]
    };
  };
  var deleteRelationParams = (publicIds = []) => {
    return {
      assets_to_unrelate: Array.isArray(publicIds) ? publicIds : [publicIds]
    };
  };
  exports.add_related_assets = (publicId, assetsToRelate, callback, options = {}) => {
    const params = createRelationParams(assetsToRelate);
    return call_api("post", ["resources", "related_assets", options.resource_type, options.type, publicId], params, callback, options);
  };
  exports.add_related_assets_by_asset_id = (assetId, assetsToRelate, callback, options = {}) => {
    const params = createRelationParams(assetsToRelate);
    return call_api("post", ["resources", "related_assets", assetId], params, callback, options);
  };
  exports.delete_related_assets = (publicId, assetsToUnrelate, callback, options = {}) => {
    const params = deleteRelationParams(assetsToUnrelate);
    return call_api("delete", ["resources", "related_assets", options.resource_type, options.type, publicId], params, callback, options);
  };
  exports.delete_related_assets_by_asset_id = (assetId, assetsToUnrelate, callback, options = {}) => {
    const params = deleteRelationParams(assetsToUnrelate);
    return call_api("delete", ["resources", "related_assets", assetId], params, callback, options);
  };
  exports.delete_derived_resources = function delete_derived_resources(derived_resource_ids, callback, options = {}) {
    let uri;
    uri = ["derived_resources"];
    return call_api("delete", uri, {
      "derived_resource_ids[]": derived_resource_ids
    }, callback, options);
  };
  exports.delete_derived_by_transformation = function delete_derived_by_transformation(public_ids, transformations, callback, options = {}) {
    let params, resource_type, type50, uri;
    resource_type = options.resource_type || "image";
    type50 = options.type || "upload";
    uri = "resources/" + resource_type + "/" + type50;
    params = extend({
      "public_ids[]": public_ids
    }, pickOnlyExistingValues(options, "invalidate"));
    params.keep_original = true;
    params.transformations = utils.build_eager(transformations);
    return call_api("delete", uri, params, callback, options);
  };
  exports.tags = function tags(callback, options = {}) {
    let resource_type, uri;
    resource_type = options.resource_type || "image";
    uri = ["tags", resource_type];
    return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "prefix"), callback, options);
  };
  exports.transformations = function transformations(callback, options = {}) {
    const params = pickOnlyExistingValues(options, "next_cursor", "max_results", "named");
    return call_api("get", TRANSFORMATIONS_URI, params, callback, options);
  };
  exports.transformation = function transformation(transformationName, callback, options = {}) {
    const params = pickOnlyExistingValues(options, "next_cursor", "max_results");
    params.transformation = utils.build_eager(transformationName);
    return call_api("get", TRANSFORMATIONS_URI, params, callback, options);
  };
  exports.delete_transformation = function delete_transformation(transformationName, callback, options = {}) {
    const params = {};
    params.transformation = utils.build_eager(transformationName);
    return call_api("delete", TRANSFORMATIONS_URI, params, callback, options);
  };
  exports.update_transformation = function update_transformation(transformationName, updates, callback, options = {}) {
    const params = pickOnlyExistingValues(updates, "allowed_for_strict");
    params.transformation = utils.build_eager(transformationName);
    if (updates.unsafe_update != null) {
      params.unsafe_update = utils.build_eager(updates.unsafe_update);
    }
    return call_api("put", TRANSFORMATIONS_URI, params, callback, options);
  };
  exports.create_transformation = function create_transformation(name, definition, callback, options = {}) {
    const params = { name };
    params.transformation = utils.build_eager(definition);
    return call_api("post", TRANSFORMATIONS_URI, params, callback, options);
  };
  exports.upload_presets = function upload_presets(callback, options = {}) {
    return call_api("get", ["upload_presets"], pickOnlyExistingValues(options, "next_cursor", "max_results"), callback, options);
  };
  exports.upload_preset = function upload_preset(name, callback, options = {}) {
    let uri;
    uri = ["upload_presets", name];
    return call_api("get", uri, {}, callback, options);
  };
  exports.delete_upload_preset = function delete_upload_preset(name, callback, options = {}) {
    let uri;
    uri = ["upload_presets", name];
    return call_api("delete", uri, {}, callback, options);
  };
  exports.update_upload_preset = function update_upload_preset(name, callback, options = {}) {
    let params, uri;
    uri = ["upload_presets", name];
    params = utils.merge(utils.clear_blank(utils.build_upload_params(options)), pickOnlyExistingValues(options, "unsigned", "disallow_public_id", "live"));
    return call_api("put", uri, params, callback, options);
  };
  exports.create_upload_preset = function create_upload_preset(callback, options = {}) {
    let params, uri;
    uri = ["upload_presets"];
    params = utils.merge(utils.clear_blank(utils.build_upload_params(options)), pickOnlyExistingValues(options, "name", "unsigned", "disallow_public_id", "live"));
    return call_api("post", uri, params, callback, options);
  };
  exports.root_folders = function root_folders(callback, options = {}) {
    let uri, params;
    uri = ["folders"];
    params = pickOnlyExistingValues(options, "next_cursor", "max_results");
    return call_api("get", uri, params, callback, options);
  };
  exports.sub_folders = function sub_folders(path2, callback, options = {}) {
    let uri, params;
    uri = ["folders", path2];
    params = pickOnlyExistingValues(options, "next_cursor", "max_results");
    return call_api("get", uri, params, callback, options);
  };
  exports.create_folder = function create_folder(path2, callback, options = {}) {
    let uri;
    uri = ["folders", path2];
    return call_api("post", uri, {}, callback, options);
  };
  exports.delete_folder = function delete_folder(path2, callback, options = {}) {
    let uri;
    uri = ["folders", path2];
    return call_api("delete", uri, {}, callback, options);
  };
  exports.rename_folder = function rename_folder(old_path, new_path, callback, options = {}) {
    let uri;
    uri = ["folders", old_path];
    let rename_folder_params = {
      to_folder: new_path
    };
    options.content_type = "json";
    return call_api("put", uri, rename_folder_params, callback, options);
  };
  exports.upload_mappings = function upload_mappings(callback, options = {}) {
    let params;
    params = pickOnlyExistingValues(options, "next_cursor", "max_results");
    return call_api("get", "upload_mappings", params, callback, options);
  };
  exports.upload_mapping = function upload_mapping(name, callback, options = {}) {
    if (name == null) {
      name = null;
    }
    return call_api("get", "upload_mappings", {
      folder: name
    }, callback, options);
  };
  exports.delete_upload_mapping = function delete_upload_mapping(name, callback, options = {}) {
    return call_api("delete", "upload_mappings", {
      folder: name
    }, callback, options);
  };
  exports.update_upload_mapping = function update_upload_mapping(name, callback, options = {}) {
    let params;
    params = pickOnlyExistingValues(options, "template");
    params.folder = name;
    return call_api("put", "upload_mappings", params, callback, options);
  };
  exports.create_upload_mapping = function create_upload_mapping(name, callback, options = {}) {
    let params;
    params = pickOnlyExistingValues(options, "template");
    params.folder = name;
    return call_api("post", "upload_mappings", params, callback, options);
  };
  exports.publish_by_prefix = function publish_by_prefix(prefix, callback, options = {}) {
    return publishResource("prefix", prefix, callback, options);
  };
  exports.publish_by_tag = function publish_by_tag(tag, callback, options = {}) {
    return publishResource("tag", tag, callback, options);
  };
  exports.publish_by_ids = function publish_by_ids(public_ids, callback, options = {}) {
    return publishResource("public_ids", public_ids, callback, options);
  };
  exports.list_streaming_profiles = function list_streaming_profiles(callback, options = {}) {
    return call_api("get", "streaming_profiles", {}, callback, options);
  };
  exports.get_streaming_profile = function get_streaming_profile(name, callback, options = {}) {
    return call_api("get", "streaming_profiles/" + name, {}, callback, options);
  };
  exports.delete_streaming_profile = function delete_streaming_profile(name, callback, options = {}) {
    return call_api("delete", "streaming_profiles/" + name, {}, callback, options);
  };
  exports.update_streaming_profile = function update_streaming_profile(name, callback, options = {}) {
    let params;
    params = utils.build_streaming_profiles_param(options);
    return call_api("put", "streaming_profiles/" + name, params, callback, options);
  };
  exports.create_streaming_profile = function create_streaming_profile(name, callback, options = {}) {
    let params;
    params = utils.build_streaming_profiles_param(options);
    params.name = name;
    return call_api("post", "streaming_profiles", params, callback, options);
  };
  exports.search = function search(params, callback, options = {}) {
    options.content_type = "json";
    return call_api("post", "resources/search", params, callback, options);
  };
  exports.visual_search = function visual_search(params, callback, options = {}) {
    const allowedParams = pickOnlyExistingValues(params, "image_url", "image_asset_id", "text");
    return call_api("get", ["resources", "visual_search"], allowedParams, callback, options);
  };
  exports.search_folders = function search_folders(params, callback, options = {}) {
    options.content_type = "json";
    return call_api("post", "folders/search", params, callback, options);
  };
  exports.update_resources_access_mode_by_prefix = function update_resources_access_mode_by_prefix(access_mode, prefix, callback, options = {}) {
    return updateResourcesAccessMode(access_mode, "prefix", prefix, callback, options);
  };
  exports.update_resources_access_mode_by_tag = function update_resources_access_mode_by_tag(access_mode, tag, callback, options = {}) {
    return updateResourcesAccessMode(access_mode, "tag", tag, callback, options);
  };
  exports.update_resources_access_mode_by_ids = function update_resources_access_mode_by_ids(access_mode, ids, callback, options = {}) {
    return updateResourcesAccessMode(access_mode, "public_ids[]", ids, callback, options);
  };
  exports.add_metadata_field = function add_metadata_field(field, callback, options = {}) {
    const params = pickOnlyExistingValues(field, "external_id", "type", "label", "mandatory", "default_value", "validation", "datasource", "restrictions");
    options.content_type = "json";
    return call_api("post", ["metadata_fields"], params, callback, options);
  };
  exports.list_metadata_fields = function list_metadata_fields(callback, options = {}) {
    return call_api("get", ["metadata_fields"], {}, callback, options);
  };
  exports.delete_metadata_field = function delete_metadata_field(field_external_id, callback, options = {}) {
    return call_api("delete", ["metadata_fields", field_external_id], {}, callback, options);
  };
  exports.metadata_field_by_field_id = function metadata_field_by_field_id(external_id, callback, options = {}) {
    return call_api("get", ["metadata_fields", external_id], {}, callback, options);
  };
  exports.update_metadata_field = function update_metadata_field(external_id, field, callback, options = {}) {
    const params = pickOnlyExistingValues(field, "external_id", "type", "label", "mandatory", "default_value", "validation", "datasource", "restrictions", "default_disabled");
    options.content_type = "json";
    return call_api("put", ["metadata_fields", external_id], params, callback, options);
  };
  exports.update_metadata_field_datasource = function update_metadata_field_datasource(field_external_id, entries_external_id, callback, options = {}) {
    const params = pickOnlyExistingValues(entries_external_id, "values");
    options.content_type = "json";
    return call_api("put", ["metadata_fields", field_external_id, "datasource"], params, callback, options);
  };
  exports.delete_datasource_entries = function delete_datasource_entries(field_external_id, entries_external_id, callback, options = {}) {
    options.content_type = "json";
    const params = { external_ids: entries_external_id };
    return call_api("delete", ["metadata_fields", field_external_id, "datasource"], params, callback, options);
  };
  exports.restore_metadata_field_datasource = function restore_metadata_field_datasource(field_external_id, entries_external_id, callback, options = {}) {
    options.content_type = "json";
    const params = { external_ids: entries_external_id };
    return call_api("post", ["metadata_fields", field_external_id, "datasource_restore"], params, callback, options);
  };
  exports.order_metadata_field_datasource = function order_metadata_field_datasource(field_external_id, sort_by, direction, callback, options = {}) {
    options.content_type = "json";
    const params = {
      order_by: sort_by,
      direction
    };
    return call_api("post", ["metadata_fields", field_external_id, "datasource", "order"], params, callback, options);
  };
  exports.reorder_metadata_fields = function reorder_metadata_fields(order_by, direction, callback, options = {}) {
    options.content_type = "json";
    const params = {
      order_by,
      direction
    };
    return call_api("put", ["metadata_fields", "order"], params, callback, options);
  };
  exports.list_metadata_rules = function list_metadata_rules(callback, options = {}) {
    return call_api("get", ["metadata_rules"], {}, callback, options);
  };
  exports.add_metadata_rule = function add_metadata_rule(metadata_rule, callback, options = {}) {
    options.content_type = "json";
    const params = pickOnlyExistingValues(metadata_rule, "metadata_field_id", "condition", "result", "name");
    return call_api("post", ["metadata_rules"], params, callback, options);
  };
  exports.update_metadata_rule = function update_metadata_rule(field_external_id, updated_metadata_rule, callback, options = {}) {
    options.content_type = "json";
    const params = pickOnlyExistingValues(updated_metadata_rule, "metadata_field_id", "condition", "result", "name", "state");
    return call_api("put", ["metadata_rules", field_external_id], params, callback, options);
  };
  exports.delete_metadata_rule = function delete_metadata_rule(field_external_id, callback, options = {}) {
    return call_api("delete", ["metadata_rules", field_external_id], {}, callback, options);
  };
  exports.config = function config(callback, options = {}) {
    const params = pickOnlyExistingValues(options, "settings");
    return call_api("get", ["config"], params, callback, options);
  };
});

// node_modules/cloudinary/lib/api_client/call_analysis_api.js
var require_call_analysis_api = __commonJS((exports, module) => {
  function call_analysis_api(method, uri, params, callback, options) {
    ensurePresenceOf({
      method,
      uri
    });
    const api_url = utils.base_api_url_v2()(uri, options);
    let auth3 = {};
    if (options.oauth_token || config2().oauth_token) {
      auth3 = {
        oauth_token: ensureOption(options, "oauth_token")
      };
    } else {
      auth3 = {
        key: ensureOption(options, "api_key"),
        secret: ensureOption(options, "api_secret")
      };
    }
    options.content_type = "json";
    return execute_request(method, params, auth3, api_url, callback, options);
  }
  var utils = require_utils();
  var config2 = require_config();
  var ensureOption = require_ensureOption().defaults(config2());
  var execute_request = require_execute_request();
  var { ensurePresenceOf } = utils;
  module.exports = {
    call_analysis_api
  };
});

// node_modules/cloudinary/lib/analysis/index.js
var require_analysis = __commonJS((exports, module) => {
  function analyze_uri(uri, analysis_type, options = {}, callback) {
    const params = {
      uri,
      analysis_type
    };
    if (analysis_type === "custom") {
      if (!("model_name" in options) || !("model_version" in options)) {
        throw new Error('Setting analysis_type to "custom" requires additional params: "model_name" and "model_version"');
      }
      params.parameters = {
        custom: {
          model_name: options.model_name,
          model_version: options.model_version
        }
      };
    }
    let api_uri = ["analysis", "analyze", "uri"];
    return call_analysis_api("POST", api_uri, params, callback, options);
  }
  var utils = require_utils();
  var { call_analysis_api } = require_call_analysis_api();
  module.exports = {
    analyze_uri
  };
});

// node_modules/cloudinary/lib/api_client/call_account_api.js
var require_call_account_api = __commonJS((exports, module) => {
  function call_account_api(method, uri, params, callback, options) {
    ensurePresenceOf({ method, uri });
    const cloudinary = ensureOption(options, "upload_prefix", "https://api.cloudinary.com");
    const account_id = ensureOption(options, "account_id");
    const api_url = [cloudinary, "v1_1", "provisioning", "accounts", account_id].concat(uri).join("/");
    const auth3 = {
      key: ensureOption(options, "provisioning_api_key"),
      secret: ensureOption(options, "provisioning_api_secret")
    };
    return execute_request(method, params, auth3, api_url, callback, options);
  }
  var config2 = require_config();
  var utils = require_utils();
  var ensureOption = require_ensureOption().defaults(config2());
  var execute_request = require_execute_request();
  var { ensurePresenceOf } = utils;
  module.exports = call_account_api;
});

// node_modules/cloudinary/lib/provisioning/account.js
var require_account = __commonJS((exports, module) => {
  function sub_accounts(enabled, ids = [], prefix, options = {}, callback) {
    let params = {
      enabled,
      ids,
      prefix
    };
    let uri = ["sub_accounts"];
    return call_account_api("GET", uri, params, callback, options);
  }
  function sub_account(sub_account_id, options = {}, callback) {
    let uri = ["sub_accounts", sub_account_id];
    return call_account_api("GET", uri, {}, callback, options);
  }
  function create_sub_account(name, cloud_name, custom_attributes, enabled, base_account, options = {}, callback) {
    let params = {
      cloud_name,
      name,
      custom_attributes,
      enabled,
      base_sub_account_id: base_account
    };
    options.content_type = "json";
    let uri = ["sub_accounts"];
    return call_account_api("POST", uri, params, callback, options);
  }
  function delete_sub_account(sub_account_id, options = {}, callback) {
    let uri = ["sub_accounts", sub_account_id];
    return call_account_api("DELETE", uri, {}, callback, options);
  }
  function update_sub_account(sub_account_id, name, cloud_name, custom_attributes, enabled, options = {}, callback) {
    let params = {
      cloud_name,
      name,
      custom_attributes,
      enabled
    };
    options.content_type = "json";
    let uri = ["sub_accounts", sub_account_id];
    return call_account_api("PUT", uri, params, callback, options);
  }
  function user3(user_id, options = {}, callback) {
    let uri = ["users", user_id];
    return call_account_api("GET", uri, {}, callback, options);
  }
  function users(pending, user_ids, prefix, sub_account_id, options = {}, callback) {
    let uri = ["users"];
    let params = {
      ids: user_ids,
      pending,
      prefix,
      sub_account_id
    };
    return call_account_api("GET", uri, pickOnlyExistingValues(params, "ids", "pending", "prefix", "sub_account_id"), callback, options);
  }
  function create_user(name, email, role, sub_account_ids, options = {}, callback) {
    let uri = ["users"];
    let params = {
      name,
      email,
      role,
      sub_account_ids
    };
    options.content_type = "json";
    return call_account_api("POST", uri, params, callback, options);
  }
  function update_user(user_id, name, email, role, sub_account_ids, options = {}, callback) {
    let uri = ["users", user_id];
    let params = {
      name,
      email,
      role,
      sub_account_ids
    };
    options.content_type = "json";
    return call_account_api("PUT", uri, params, callback, options);
  }
  function delete_user(user_id, options = {}, callback) {
    let uri = ["users", user_id];
    return call_account_api("DELETE", uri, {}, callback, options);
  }
  function create_user_group(name, options = {}, callback) {
    let uri = ["user_groups"];
    options.content_type = "json";
    let params = {
      name
    };
    return call_account_api("POST", uri, params, callback, options);
  }
  function update_user_group(group_id, name, options = {}, callback) {
    let uri = ["user_groups", group_id];
    let params = {
      name
    };
    return call_account_api("PUT", uri, params, callback, options);
  }
  function delete_user_group(group_id, options = {}, callback) {
    let uri = ["user_groups", group_id];
    return call_account_api("DELETE", uri, {}, callback, options);
  }
  function add_user_to_group(group_id, user_id, options = {}, callback) {
    let uri = ["user_groups", group_id, "users", user_id];
    return call_account_api("POST", uri, {}, callback, options);
  }
  function remove_user_from_group(group_id, user_id, options = {}, callback) {
    let uri = ["user_groups", group_id, "users", user_id];
    return call_account_api("DELETE", uri, {}, callback, options);
  }
  function user_group(group_id, options = {}, callback) {
    let uri = ["user_groups", group_id];
    return call_account_api("GET", uri, {}, callback, options);
  }
  function user_groups(options = {}, callback) {
    let uri = ["user_groups"];
    return call_account_api("GET", uri, {}, callback, options);
  }
  function user_group_users(group_id, options = {}, callback) {
    let uri = ["user_groups", group_id, "users"];
    return call_account_api("GET", uri, {}, callback, options);
  }
  var utils = require_utils();
  var call_account_api = require_call_account_api();
  var { pickOnlyExistingValues } = utils;
  module.exports = {
    sub_accounts,
    create_sub_account,
    delete_sub_account,
    sub_account,
    update_sub_account,
    user: user3,
    users,
    user_group,
    user_groups,
    user_group_users,
    remove_user_from_group,
    delete_user,
    update_user_group,
    update_user,
    create_user,
    create_user_group,
    add_user_to_group,
    delete_user_group
  };
});

// node_modules/cloudinary/lib/preloaded_file.js
var require_preloaded_file = __commonJS((exports, module) => {
  var PRELOADED_CLOUDINARY_PATH;
  var config2;
  var utils;
  utils = require_utils();
  config2 = require_config();
  PRELOADED_CLOUDINARY_PATH = /^([^\/]+)\/([^\/]+)\/v(\d+)\/([^#]+)#([^\/]+)$/;

  class PreloadedFile {
    constructor(file_info) {
      let matches, public_id_and_format;
      matches = file_info.match(PRELOADED_CLOUDINARY_PATH);
      if (!matches) {
        throw "Invalid preloaded file info";
      }
      this.resource_type = matches[1];
      this.type = matches[2];
      this.version = matches[3];
      this.filename = matches[4];
      this.signature = matches[5];
      public_id_and_format = PreloadedFile.split_format(this.filename);
      this.public_id = public_id_and_format[0];
      this.format = public_id_and_format[1];
    }
    is_valid() {
      let expected_signature;
      expected_signature = utils.api_sign_request({
        public_id: this.public_id,
        version: this.version
      }, config2().api_secret);
      return this.signature === expected_signature;
    }
    static split_format(identifier) {
      let format, last_dot, public_id;
      last_dot = identifier.lastIndexOf(".");
      if (last_dot === -1) {
        return [identifier, null];
      }
      public_id = identifier.substr(0, last_dot);
      format = identifier.substr(last_dot + 1);
      return [public_id, format];
    }
    identifier() {
      return `v${this.version}/${this.filename}`;
    }
    toString() {
      return `${this.resource_type}/${this.type}/v${this.version}/${this.filename}#${this.signature}`;
    }
    toJSON() {
      let result = {};
      Object.getOwnPropertyNames(this).forEach((key) => {
        let val = this[key];
        if (typeof val !== "function") {
          result[key] = val;
        }
      });
      return result;
    }
  }
  module.exports = PreloadedFile;
});

// node_modules/cloudinary/lib/utils/generateBreakpoints.js
var require_generateBreakpoints = __commonJS((exports, module) => {
  function generateBreakpoints(srcset) {
    let breakpoints = srcset.breakpoints || [];
    if (breakpoints.length) {
      return breakpoints;
    }
    let [min_width, max_width, max_images] = [srcset.min_width, srcset.max_width, srcset.max_images].map(Number);
    if ([min_width, max_width, max_images].some(Number.isNaN)) {
      throw "Either (min_width, max_width, max_images) " + "or breakpoints must be provided to the image srcset attribute";
    }
    if (min_width > max_width) {
      throw "min_width must be less than max_width";
    }
    if (max_images <= 0) {
      throw "max_images must be a positive integer";
    } else if (max_images === 1) {
      min_width = max_width;
    }
    let stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));
    for (let current = min_width;current < max_width; current += stepSize) {
      breakpoints.push(current);
    }
    breakpoints.push(max_width);
    return breakpoints;
  }
  module.exports = generateBreakpoints;
});

// node_modules/cloudinary/lib/utils/srcsetUtils.js
var require_srcsetUtils = __commonJS((exports, module) => {
  function scaledUrl(public_id, width, transformation, options = {}) {
    let configParams = utils.extractUrlParams(options);
    transformation = transformation || options;
    configParams.raw_transformation = utils.generate_transformation_string([utils.extend({}, transformation), { crop: "scale", width }]);
    return utils.url(public_id, configParams);
  }
  function getOrGenerateBreakpoints(public_id, srcset = {}, options = {}) {
    let breakpoints = [];
    if (srcset.useCache) {
      breakpoints = Cache.get(public_id, options);
      if (!breakpoints) {
        breakpoints = [];
      }
    } else {
      breakpoints = generateBreakpoints(srcset);
    }
    return breakpoints;
  }
  function generateSrcsetAttribute(public_id, breakpoints, transformation, options) {
    options = utils.clone(options);
    utils.patchFetchFormat(options);
    return breakpoints.map((width) => `${scaledUrl(public_id, width, transformation, options)} ${width}w`).join(", ");
  }
  function generateSizesAttribute(breakpoints = []) {
    return breakpoints.map((width) => `(max-width: ${width}px) ${width}px`).join(", ");
  }
  function generateImageResponsiveAttributes(publicId, attributes = {}, srcsetData = {}, options = {}) {
    let responsiveAttributes = {};
    if (isEmpty2(srcsetData)) {
      return responsiveAttributes;
    }
    const generateSizes = !attributes.sizes && srcsetData.sizes === true;
    const generateSrcset = !attributes.srcset;
    if (generateSrcset || generateSizes) {
      let breakpoints = getOrGenerateBreakpoints(publicId, srcsetData, options);
      if (generateSrcset) {
        let transformation = srcsetData.transformation;
        let srcsetAttr = generateSrcsetAttribute(publicId, breakpoints, transformation, options);
        if (!isEmpty2(srcsetAttr)) {
          responsiveAttributes.srcset = srcsetAttr;
        }
      }
      if (generateSizes) {
        let sizesAttr = generateSizesAttribute(breakpoints);
        if (!isEmpty2(sizesAttr)) {
          responsiveAttributes.sizes = sizesAttr;
        }
      }
    }
    return responsiveAttributes;
  }
  function generateMediaAttr(options = {}) {
    let mediaQuery = [];
    if (options.min_width != null) {
      mediaQuery.push(`(min-width: ${options.min_width}px)`);
    }
    if (options.max_width != null) {
      mediaQuery.push(`(max-width: ${options.max_width}px)`);
    }
    return mediaQuery.join(" and ");
  }
  var utils = require_utils();
  var generateBreakpoints = require_generateBreakpoints();
  var Cache = require_cache();
  var isEmpty2 = utils.isEmpty;
  module.exports = {
    srcsetUrl: scaledUrl,
    generateSrcsetAttribute,
    generateSizesAttribute,
    generateMediaAttr,
    generateImageResponsiveAttributes
  };
});

// node_modules/cloudinary/lib/v2/api.js
var require_api2 = __commonJS((exports) => {
  var api = require_api();
  var v1_adapters = require_utils().v1_adapters;
  v1_adapters(exports, api, {
    ping: 0,
    usage: 0,
    resource_types: 0,
    resources: 0,
    resources_by_tag: 1,
    resources_by_context: 2,
    resources_by_moderation: 2,
    resource_by_asset_id: 1,
    resources_by_asset_ids: 1,
    resources_by_ids: 1,
    resources_by_asset_folder: 1,
    resource: 1,
    restore: 1,
    update: 1,
    delete_resources: 1,
    delete_resources_by_prefix: 1,
    delete_resources_by_tag: 1,
    delete_all_resources: 0,
    delete_derived_resources: 1,
    tags: 0,
    transformations: 0,
    transformation: 1,
    delete_transformation: 1,
    update_transformation: 2,
    create_transformation: 2,
    upload_presets: 0,
    upload_preset: 1,
    delete_upload_preset: 1,
    update_upload_preset: 1,
    create_upload_preset: 0,
    root_folders: 0,
    sub_folders: 1,
    delete_folder: 1,
    rename_folder: 2,
    create_folder: 1,
    upload_mappings: 0,
    upload_mapping: 1,
    delete_upload_mapping: 1,
    update_upload_mapping: 1,
    create_upload_mapping: 1,
    list_streaming_profiles: 0,
    get_streaming_profile: 1,
    delete_streaming_profile: 1,
    update_streaming_profile: 1,
    create_streaming_profile: 1,
    publish_by_ids: 1,
    publish_by_tag: 1,
    publish_by_prefix: 1,
    update_resources_access_mode_by_prefix: 2,
    update_resources_access_mode_by_tag: 2,
    update_resources_access_mode_by_ids: 2,
    search: 1,
    search_folders: 1,
    visual_search: 1,
    delete_derived_by_transformation: 2,
    add_metadata_field: 1,
    list_metadata_fields: 1,
    delete_metadata_field: 1,
    metadata_field_by_field_id: 1,
    update_metadata_field: 2,
    update_metadata_field_datasource: 2,
    delete_datasource_entries: 2,
    restore_metadata_field_datasource: 2,
    order_metadata_field_datasource: 3,
    reorder_metadata_fields: 2,
    list_metadata_rules: 1,
    add_metadata_rule: 1,
    delete_metadata_rule: 1,
    update_metadata_rule: 2,
    add_related_assets: 2,
    add_related_assets_by_asset_id: 2,
    delete_related_assets: 2,
    delete_related_assets_by_asset_id: 2,
    config: 0
  });
});

// node_modules/cloudinary/lib/v2/uploader.js
var require_uploader2 = __commonJS((exports) => {
  var uploader = require_uploader();
  var v1_adapters = require_utils().v1_adapters;
  v1_adapters(exports, uploader, {
    unsigned_upload_stream: 1,
    upload_stream: 0,
    unsigned_upload: 2,
    upload: 1,
    upload_large_part: 0,
    upload_large: 1,
    upload_chunked: 1,
    upload_chunked_stream: 0,
    explicit: 1,
    destroy: 1,
    rename: 2,
    text: 1,
    generate_sprite: 1,
    multi: 1,
    explode: 1,
    add_tag: 2,
    remove_tag: 2,
    remove_all_tags: 1,
    add_context: 2,
    remove_all_context: 1,
    replace_tag: 2,
    create_archive: 0,
    create_zip: 0,
    update_metadata: 2
  });
  exports.direct_upload = uploader.direct_upload;
  exports.upload_tag_params = uploader.upload_tag_params;
  exports.upload_url = uploader.upload_url;
  exports.image_upload_tag = uploader.image_upload_tag;
  exports.unsigned_image_upload_tag = uploader.unsigned_image_upload_tag;
  exports.create_slideshow = uploader.create_slideshow;
  exports.download_generated_sprite = uploader.download_generated_sprite;
  exports.download_multi = uploader.download_multi;
});

// node_modules/cloudinary/lib/v2/search.js
var require_search = __commonJS((exports, module) => {
  var api = require_api2();
  var config2 = require_config();
  var {
    isEmpty: isEmpty2,
    isNumber: isNumber2,
    compute_hash,
    build_distribution_domain,
    clear_blank,
    sort_object_by_key
  } = require_utils();
  var { base64Encode } = require_base64Encode();
  var Search = class Search2 {
    constructor() {
      this.query_hash = {
        sort_by: [],
        aggregate: [],
        with_field: [],
        fields: []
      };
      this._ttl = 300;
    }
    static instance() {
      return new Search2;
    }
    static expression(value15) {
      return this.instance().expression(value15);
    }
    static max_results(value15) {
      return this.instance().max_results(value15);
    }
    static next_cursor(value15) {
      return this.instance().next_cursor(value15);
    }
    static aggregate(value15) {
      return this.instance().aggregate(value15);
    }
    static with_field(value15) {
      return this.instance().with_field(value15);
    }
    static fields(value15) {
      return this.instance().fields(value15);
    }
    static sort_by(field_name, dir2 = "asc") {
      return this.instance().sort_by(field_name, dir2);
    }
    static ttl(newTtl) {
      return this.instance().ttl(newTtl);
    }
    static execute(options, callback) {
      return this.instance().execute(options, callback);
    }
    expression(value15) {
      this.query_hash.expression = value15;
      return this;
    }
    max_results(value15) {
      this.query_hash.max_results = value15;
      return this;
    }
    next_cursor(value15) {
      this.query_hash.next_cursor = value15;
      return this;
    }
    aggregate(value15) {
      const found = this.query_hash.aggregate.find((v3) => v3 === value15);
      if (!found) {
        this.query_hash.aggregate.push(value15);
      }
      return this;
    }
    with_field(value15) {
      if (Array.isArray(value15)) {
        this.query_hash.with_field = this.query_hash.with_field.concat(value15);
      } else {
        this.query_hash.with_field.push(value15);
      }
      this.query_hash.with_field = Array.from(new Set(this.query_hash.with_field));
      return this;
    }
    fields(value15) {
      if (Array.isArray(value15)) {
        this.query_hash.fields = this.query_hash.fields.concat(value15);
      } else {
        this.query_hash.fields.push(value15);
      }
      this.query_hash.fields = Array.from(new Set(this.query_hash.fields));
      return this;
    }
    sort_by(field_name, dir2 = "desc") {
      let sort_bucket;
      sort_bucket = {};
      sort_bucket[field_name] = dir2;
      const previously_sorted_obj = this.query_hash.sort_by.find((sort_by) => sort_by[field_name]);
      if (previously_sorted_obj) {
        previously_sorted_obj[field_name] = dir2;
      } else {
        this.query_hash.sort_by.push(sort_bucket);
      }
      return this;
    }
    ttl(newTtl) {
      if (isNumber2(newTtl)) {
        this._ttl = newTtl;
        return this;
      }
      throw new Error("New TTL value has to be a Number.");
    }
    to_query() {
      Object.keys(this.query_hash).forEach((k) => {
        let v3 = this.query_hash[k];
        if (!isNumber2(v3) && isEmpty2(v3)) {
          delete this.query_hash[k];
        }
      });
      return this.query_hash;
    }
    execute(options, callback) {
      if (callback === null) {
        callback = options;
      }
      options = options || {};
      return api.search(this.to_query(), options, callback);
    }
    to_url(ttl, next_cursor, options = {}) {
      const apiSecret = "api_secret" in options ? options.api_secret : config2().api_secret;
      if (!apiSecret) {
        throw new Error("Must supply api_secret");
      }
      const urlTtl = ttl || this._ttl;
      const query = this.to_query();
      let urlCursor = next_cursor;
      if (query.next_cursor && !next_cursor) {
        urlCursor = query.next_cursor;
      }
      delete query.next_cursor;
      const dataOrderedByKey = sort_object_by_key(clear_blank(query));
      const encodedQuery = base64Encode(JSON.stringify(dataOrderedByKey));
      const urlPrefix = build_distribution_domain(options.source, options);
      const signature = compute_hash(`${urlTtl}${encodedQuery}${apiSecret}`, "sha256", "hex");
      const urlWithoutCursor = `${urlPrefix}/search/${signature}/${urlTtl}/${encodedQuery}`;
      return urlCursor ? `${urlWithoutCursor}/${urlCursor}` : urlWithoutCursor;
    }
  };
  module.exports = Search;
});

// node_modules/cloudinary/lib/v2/search_folders.js
var require_search_folders = __commonJS((exports, module) => {
  var Search = require_search();
  var api = require_api2();
  var SearchFolders = class SearchFolders2 extends Search {
    constructor() {
      super();
    }
    static instance() {
      return new SearchFolders2;
    }
    execute(options, callback) {
      if (callback === null) {
        callback = options;
      }
      options = options || {};
      return api.search_folders(this.to_query(), options, callback);
    }
  };
  module.exports = SearchFolders;
});

// node_modules/cloudinary/lib/v2/index.js
var require_v2 = __commonJS((exports, module) => {
  var v12 = require_cloudinary();
  var api = require_api2();
  var uploader = require_uploader2();
  var search = require_search();
  var search_folders = require_search_folders();
  var v22 = {
    ...v12,
    api,
    uploader,
    search,
    search_folders
  };
  module.exports = v22;
});

// node_modules/cloudinary/lib/cloudinary.js
var require_cloudinary = __commonJS((exports, module) => {
  function chainTransformations(options, transformation = []) {
    let urlOptions = cloudinary.utils.extractUrlParams(options);
    let currentTransformation = cloudinary.utils.extractTransformationParams(options);
    transformation = cloudinary.utils.build_array(transformation);
    urlOptions.transformation = [currentTransformation, ...transformation];
    return urlOptions;
  }
  var _5 = require_lodash();
  exports.config = require_config();
  exports.utils = require_utils();
  exports.uploader = require_uploader();
  exports.api = require_api();
  exports.analysis = require_analysis();
  var account = require_account();
  exports.provisioning = {
    account
  };
  exports.PreloadedFile = require_preloaded_file();
  exports.Cache = require_cache();
  var cloudinary = exports;
  var optionConsume = cloudinary.utils.option_consume;
  exports.url = function url(public_id, options) {
    options = _5.extend({}, options);
    return cloudinary.utils.url(public_id, options);
  };
  var { generateImageResponsiveAttributes, generateMediaAttr } = require_srcsetUtils();
  exports.image = function image(source, options) {
    let localOptions = _5.extend({}, options);
    let srcsetParam = optionConsume(localOptions, "srcset");
    let attributes = optionConsume(localOptions, "attributes", {});
    let src = cloudinary.utils.url(source, localOptions);
    if ("html_width" in localOptions)
      localOptions.width = optionConsume(localOptions, "html_width");
    if ("html_height" in localOptions)
      localOptions.height = optionConsume(localOptions, "html_height");
    let client_hints = optionConsume(localOptions, "client_hints", cloudinary.config().client_hints);
    let responsive = optionConsume(localOptions, "responsive");
    let hidpi = optionConsume(localOptions, "hidpi");
    if ((responsive || hidpi) && !client_hints) {
      localOptions["data-src"] = src;
      let classes = [responsive ? "cld-responsive" : "cld-hidpi"];
      let current_class = optionConsume(localOptions, "class");
      if (current_class)
        classes.push(current_class);
      localOptions.class = classes.join(" ");
      src = optionConsume(localOptions, "responsive_placeholder", cloudinary.config().responsive_placeholder);
      if (src === "blank") {
        src = cloudinary.BLANK;
      }
    }
    let html = "<img ";
    if (src)
      html += "src='" + src + "' ";
    let responsiveAttributes = {};
    if (cloudinary.utils.isString(srcsetParam)) {
      responsiveAttributes.srcset = srcsetParam;
    } else {
      responsiveAttributes = generateImageResponsiveAttributes(source, attributes, srcsetParam, options);
    }
    if (!cloudinary.utils.isEmpty(responsiveAttributes)) {
      delete localOptions.width;
      delete localOptions.height;
    }
    html += cloudinary.utils.html_attrs(_5.extend(localOptions, responsiveAttributes, attributes)) + "/>";
    return html;
  };
  exports.video = function video(public_id, options) {
    options = _5.extend({}, options);
    public_id = public_id.replace(/\.(mp4|ogv|webm)$/, "");
    let source_types = optionConsume(options, "source_types", []);
    let source_transformation = optionConsume(options, "source_transformation", {});
    let sources = optionConsume(options, "sources", []);
    let fallback2 = optionConsume(options, "fallback_content", "");
    if (source_types.length === 0)
      source_types = cloudinary.utils.DEFAULT_VIDEO_SOURCE_TYPES;
    let video_options = _5.cloneDeep(options);
    if (video_options.hasOwnProperty("poster")) {
      if (_5.isPlainObject(video_options.poster)) {
        if (video_options.poster.hasOwnProperty("public_id")) {
          video_options.poster = cloudinary.utils.url(video_options.poster.public_id, video_options.poster);
        } else {
          video_options.poster = cloudinary.utils.url(public_id, _5.extend({}, cloudinary.utils.DEFAULT_POSTER_OPTIONS, video_options.poster));
        }
      }
    } else {
      video_options.poster = cloudinary.utils.url(public_id, _5.extend({}, cloudinary.utils.DEFAULT_POSTER_OPTIONS, options));
    }
    if (!video_options.poster)
      delete video_options.poster;
    let html = "<video ";
    if (!video_options.hasOwnProperty("resource_type"))
      video_options.resource_type = "video";
    let multi_source_types = _5.isArray(source_types) && source_types.length > 1;
    let has_sources = _5.isArray(sources) && sources.length > 0;
    let source = public_id;
    if (!multi_source_types && !has_sources) {
      source = source + "." + cloudinary.utils.build_array(source_types)[0];
    }
    let src = cloudinary.utils.url(source, video_options);
    if (!multi_source_types && !has_sources)
      video_options.src = src;
    if (video_options.hasOwnProperty("html_width"))
      video_options.width = optionConsume(video_options, "html_width");
    if (video_options.hasOwnProperty("html_height"))
      video_options.height = optionConsume(video_options, "html_height");
    html = html + cloudinary.utils.html_attrs(video_options) + ">";
    if (multi_source_types && !has_sources) {
      sources = source_types.map((source_type) => ({
        type: source_type,
        transformations: source_transformation[source_type] || {}
      }));
    }
    if (_5.isArray(sources) && sources.length > 0) {
      html += sources.map((source_data) => {
        let source_type = source_data.type;
        let codecs = source_data.codecs;
        let transformation = source_data.transformations || {};
        src = cloudinary.utils.url(source + "." + source_type, _5.extend({ resource_type: "video" }, _5.cloneDeep(options), _5.cloneDeep(transformation)));
        return cloudinary.utils.create_source_tag(src, source_type, codecs);
      }).join("");
    }
    return `${html}${fallback2}</video>`;
  };
  exports.source = function source(public_id, options = {}) {
    let srcsetParam = cloudinary.utils.extend({}, options.srcset, cloudinary.config().srcset);
    let attributes = options.attributes || {};
    cloudinary.utils.extend(attributes, generateImageResponsiveAttributes(public_id, attributes, srcsetParam, options));
    if (!attributes.srcset) {
      attributes.srcset = cloudinary.url(public_id, options);
    }
    if (!attributes.media && options.media) {
      attributes.media = generateMediaAttr(options.media);
    }
    return `<source ${cloudinary.utils.html_attrs(attributes)}>`;
  };
  exports.picture = function picture(public_id, options = {}) {
    let sources = options.sources || [];
    options = cloudinary.utils.clone(options);
    delete options.sources;
    cloudinary.utils.patchFetchFormat(options);
    return "<picture>" + sources.map((source) => {
      let sourceOptions = chainTransformations(options, source.transformation);
      sourceOptions.media = source;
      return cloudinary.source(public_id, sourceOptions);
    }).join("") + cloudinary.image(public_id, options) + "</picture>";
  };
  exports.cloudinary_js_config = cloudinary.utils.cloudinary_js_config;
  exports.CF_SHARED_CDN = cloudinary.utils.CF_SHARED_CDN;
  exports.AKAMAI_SHARED_CDN = cloudinary.utils.AKAMAI_SHARED_CDN;
  exports.SHARED_CDN = cloudinary.utils.SHARED_CDN;
  exports.BLANK = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  exports.v2 = require_v2();
});

// node_modules/dargs/index.js
var require_dargs = __commonJS((exports, module) => {
  var match = (array5, value15) => array5.some((x3) => x3 instanceof RegExp ? x3.test(value15) : x3 === value15);
  var dargs = (object13, options) => {
    const arguments_ = [];
    let extraArguments = [];
    let separatedArguments = [];
    options = {
      useEquals: true,
      shortFlag: true,
      ...options
    };
    const makeArguments = (key, value15) => {
      const prefix = options.shortFlag && key.length === 1 ? "-" : "--";
      const theKey = options.allowCamelCase ? key : key.replace(/[A-Z]/g, "-$&").toLowerCase();
      key = prefix + theKey;
      if (options.useEquals) {
        arguments_.push(key + (value15 ? `=${value15}` : ""));
      } else {
        arguments_.push(key);
        if (value15) {
          arguments_.push(value15);
        }
      }
    };
    const makeAliasArg = (key, value15) => {
      arguments_.push(`-${key}`);
      if (value15) {
        arguments_.push(value15);
      }
    };
    for (let [key, value15] of Object.entries(object13)) {
      let pushArguments = makeArguments;
      if (Array.isArray(options.excludes) && match(options.excludes, key)) {
        continue;
      }
      if (Array.isArray(options.includes) && !match(options.includes, key)) {
        continue;
      }
      if (typeof options.aliases === "object" && options.aliases[key]) {
        key = options.aliases[key];
        pushArguments = makeAliasArg;
      }
      if (key === "--") {
        if (!Array.isArray(value15)) {
          throw new TypeError(`Expected key \`--\` to be Array, got ${typeof value15}`);
        }
        separatedArguments = value15;
        continue;
      }
      if (key === "_") {
        if (!Array.isArray(value15)) {
          throw new TypeError(`Expected key \`_\` to be Array, got ${typeof value15}`);
        }
        extraArguments = value15;
        continue;
      }
      if (value15 === true) {
        pushArguments(key, "");
      }
      if (value15 === false && !options.ignoreFalse) {
        pushArguments(`no-${key}`);
      }
      if (typeof value15 === "string") {
        pushArguments(key, value15);
      }
      if (typeof value15 === "number" && !Number.isNaN(value15)) {
        pushArguments(key, String(value15));
      }
      if (Array.isArray(value15)) {
        for (const arrayValue of value15) {
          pushArguments(key, arrayValue);
        }
      }
    }
    for (const argument of extraArguments) {
      arguments_.push(String(argument));
    }
    if (separatedArguments.length > 0) {
      arguments_.push("--");
    }
    for (const argument of separatedArguments) {
      arguments_.push(String(argument));
    }
    return arguments_;
  };
  module.exports = dargs;
});

// node_modules/tinyspawn/src/index.js
var require_src2 = __commonJS((exports, module) => {
  var { spawn } = import.meta.require("child_process");
  var { EOL } = import.meta.require("os");
  var EE_PROPS = Object.getOwnPropertyNames(import.meta.require("events").EventEmitter.prototype).filter((name) => !name.startsWith("_")).concat(["kill", "ref", "unref"]);
  var eos = (stream5, listener, buffer = []) => stream5[listener] ? stream5[listener].on("data", (data) => buffer.push(data)) && buffer : buffer;
  var createChildProcessError = ({ cmd, cmdArgs, childProcess }) => {
    const command = `${cmd} ${cmdArgs.join(" ")}`;
    let message = `The command spawned as:${EOL}${EOL}`;
    message += `  \`${command}\`${EOL}${EOL}`;
    message += `exited with:${EOL}${EOL}`;
    message += `  \`{ signal: '${childProcess.signalCode}', code: ${childProcess.exitCode} }\` ${EOL}${EOL}`;
    message += `with the following trace:${EOL}`;
    const error23 = new Error(message);
    error23.command = command;
    error23.name = "ChildProcessError";
    Object.keys(childProcess).filter((key) => !key.startsWith("_") && !["stdio", "stdin"].includes(key)).forEach((key) => {
      error23[key] = childProcess[key];
    });
    return error23;
  };
  var clean4 = (str) => str.trim().replace(/\n$/, "");
  var parse4 = (buffer, { json: json2 } = {}) => (encoding5, start, end) => {
    const data = clean4(Buffer.concat(buffer).toString(encoding5, start, end));
    return json2 ? JSON.parse(data) : data;
  };
  var extend = (defaults) => (input, args, options) => {
    if (!(args instanceof Array)) {
      options = args;
      args = [];
    }
    const [cmd, ...cmdArgs] = input.split(" ").concat(args).filter(Boolean);
    let childProcess;
    const promise5 = new Promise((resolve, reject2) => {
      const opts = { ...defaults, ...options };
      childProcess = spawn(cmd, cmdArgs, opts);
      const stdout = eos(childProcess, "stdout");
      const stderr = eos(childProcess, "stderr");
      childProcess.on("error", reject2).on("exit", (exitCode) => {
        Object.defineProperty(childProcess, "stdout", {
          get: parse4(stdout, opts)
        });
        Object.defineProperty(childProcess, "stderr", { get: parse4(stderr) });
        if (exitCode !== 0) {
          const error23 = createChildProcessError({ cmd, cmdArgs, childProcess });
          if (opts.reject !== false)
            return reject2(error23);
          childProcess.error = error23;
        }
        return resolve(childProcess);
      });
    });
    const subprocess = Object.assign(promise5, childProcess);
    if (childProcess) {
      EE_PROPS.forEach((name) => subprocess[name] = childProcess[name].bind(childProcess));
    }
    return subprocess;
  };
  var $ = extend();
  $.extend = extend;
  $.json = $.extend({ json: true });
  module.exports = $;
});

// node_modules/is-unix/index.js
var require_is_unix = __commonJS((exports, module) => {
  module.exports = (platform = "") => {
    platform = platform.toLowerCase();
    return [
      "aix",
      "android",
      "darwin",
      "freebsd",
      "linux",
      "openbsd",
      "sunos"
    ].indexOf(platform) !== -1;
  };
});

// node_modules/youtube-dl-exec/src/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var __dirname = "/home/natee/workspace/portfolio-v3-api/node_modules/youtube-dl-exec/src";
  var isUnix = require_is_unix();
  var path2 = import.meta.require("path");
  var PLATFORM_WIN = "win32";
  var PLATFORM_UNIX = "unix";
  var YOUTUBE_DL_HOST = process.env.YOUTUBE_DL_HOST ?? "https://api.github.com/repos/yt-dlp/yt-dlp/releases/latest";
  var YOUTUBE_DL_DIR = process.env.YOUTUBE_DL_DIR ?? path2.join(__dirname, "..", "bin");
  var YOUTUBE_DL_PLATFORM = process.env.YOUTUBE_DL_PLATFORM ?? isUnix(process.platform) ? PLATFORM_UNIX : PLATFORM_WIN;
  var YOUTUBE_DL_FILENAME = process.env.YOUTUBE_DL_FILENAME || "yt-dlp";
  var YOUTUBE_DL_FILE = !YOUTUBE_DL_FILENAME.endsWith(".exe") && YOUTUBE_DL_PLATFORM === "win32" ? `${YOUTUBE_DL_FILENAME}.exe` : YOUTUBE_DL_FILENAME;
  var YOUTUBE_DL_PATH = path2.join(YOUTUBE_DL_DIR, YOUTUBE_DL_FILE);
  var YOUTUBE_DL_SKIP_DOWNLOAD = process.env.YOUTUBE_DL_SKIP_DOWNLOAD;
  var GITHUB_TOKEN = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
  module.exports = {
    GITHUB_TOKEN,
    YOUTUBE_DL_DIR,
    YOUTUBE_DL_FILE,
    YOUTUBE_DL_FILENAME,
    YOUTUBE_DL_HOST,
    YOUTUBE_DL_PATH,
    YOUTUBE_DL_PLATFORM,
    YOUTUBE_DL_SKIP_DOWNLOAD
  };
});

// node_modules/youtube-dl-exec/src/index.js
var require_src3 = __commonJS((exports, module) => {
  var dargs = require_dargs();
  var $ = require_src2();
  var constants = require_constants2();
  var args = (flags = {}) => dargs(flags, { useEquals: false }).filter(Boolean);
  var isJSON = (str = "") => str.startsWith("{");
  var parse4 = ({ stdout, stderr, ...details }) => {
    if (details.exitCode === 0) {
      return isJSON(stdout) ? JSON.parse(stdout) : stdout;
    }
    throw Object.assign(new Error(stderr), { stderr, stdout }, details);
  };
  var create5 = (binaryPath) => {
    const fn = (...args2) => fn.exec(...args2).then(parse4).catch(parse4);
    fn.exec = (url, flags, opts) => $(binaryPath, [url].concat(args(flags)), opts);
    return fn;
  };
  var defaultInstance = create5(constants.YOUTUBE_DL_PATH);
  module.exports = defaultInstance;
  module.exports.youtubeDl = defaultInstance;
  module.exports.create = create5;
  module.exports.args = args;
  module.exports.isJSON = isJSON;
  module.exports.constants = constants;
});

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
var map = new Map;
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
var map2 = new Map;
// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/esm/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined2,
  IsUint8Array: () => IsUint8Array2,
  IsSymbol: () => IsSymbol2,
  IsString: () => IsString2,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject2,
  IsNumber: () => IsNumber2,
  IsNull: () => IsNull2,
  IsIterator: () => IsIterator2,
  IsFunction: () => IsFunction2,
  IsDate: () => IsDate2,
  IsBoolean: () => IsBoolean2,
  IsBigInt: () => IsBigInt2,
  IsAsyncIterator: () => IsAsyncIterator2,
  IsArray: () => IsArray2
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value2, key) {
  const { [key]: _, ...rest } = value2;
  return rest;
}
function Discard(value2, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value2);
}
// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value2) {
  return IsObject2(value2) && value2[ReadonlyKind] === "Readonly";
}
function IsOptional(value2) {
  return IsObject2(value2) && value2[OptionalKind] === "Optional";
}
function IsAny(value2) {
  return IsKindOf(value2, "Any");
}
function IsArray3(value2) {
  return IsKindOf(value2, "Array");
}
function IsAsyncIterator3(value2) {
  return IsKindOf(value2, "AsyncIterator");
}
function IsBigInt3(value2) {
  return IsKindOf(value2, "BigInt");
}
function IsBoolean3(value2) {
  return IsKindOf(value2, "Boolean");
}
function IsConstructor(value2) {
  return IsKindOf(value2, "Constructor");
}
function IsDate3(value2) {
  return IsKindOf(value2, "Date");
}
function IsFunction3(value2) {
  return IsKindOf(value2, "Function");
}
function IsInteger2(value2) {
  return IsKindOf(value2, "Integer");
}
function IsIntersect(value2) {
  return IsKindOf(value2, "Intersect");
}
function IsIterator3(value2) {
  return IsKindOf(value2, "Iterator");
}
function IsKindOf(value2, kind) {
  return IsObject2(value2) && Kind in value2 && value2[Kind] === kind;
}
function IsLiteral(value2) {
  return IsKindOf(value2, "Literal");
}
function IsMappedKey(value2) {
  return IsKindOf(value2, "MappedKey");
}
function IsMappedResult(value2) {
  return IsKindOf(value2, "MappedResult");
}
function IsNever(value2) {
  return IsKindOf(value2, "Never");
}
function IsNot(value2) {
  return IsKindOf(value2, "Not");
}
function IsNull3(value2) {
  return IsKindOf(value2, "Null");
}
function IsNumber3(value2) {
  return IsKindOf(value2, "Number");
}
function IsObject3(value2) {
  return IsKindOf(value2, "Object");
}
function IsPromise2(value2) {
  return IsKindOf(value2, "Promise");
}
function IsRecord(value2) {
  return IsKindOf(value2, "Record");
}
function IsRef(value2) {
  return IsKindOf(value2, "Ref");
}
function IsRegExp2(value2) {
  return IsKindOf(value2, "RegExp");
}
function IsString3(value2) {
  return IsKindOf(value2, "String");
}
function IsSymbol3(value2) {
  return IsKindOf(value2, "Symbol");
}
function IsTemplateLiteral(value2) {
  return IsKindOf(value2, "TemplateLiteral");
}
function IsThis(value2) {
  return IsKindOf(value2, "This");
}
function IsTransform(value2) {
  return IsObject2(value2) && TransformKind in value2;
}
function IsTuple(value2) {
  return IsKindOf(value2, "Tuple");
}
function IsUndefined3(value2) {
  return IsKindOf(value2, "Undefined");
}
function IsUnion(value2) {
  return IsKindOf(value2, "Union");
}
function IsUint8Array3(value2) {
  return IsKindOf(value2, "Uint8Array");
}
function IsUnknown(value2) {
  return IsKindOf(value2, "Unknown");
}
function IsUnsafe(value2) {
  return IsKindOf(value2, "Unsafe");
}
function IsVoid(value2) {
  return IsKindOf(value2, "Void");
}
function IsKind(value2) {
  return IsObject2(value2) && Kind in value2 && IsString2(value2[Kind]);
}
function IsSchema(value2) {
  return IsAny(value2) || IsArray3(value2) || IsBoolean3(value2) || IsBigInt3(value2) || IsAsyncIterator3(value2) || IsConstructor(value2) || IsDate3(value2) || IsFunction3(value2) || IsInteger2(value2) || IsIntersect(value2) || IsIterator3(value2) || IsLiteral(value2) || IsMappedKey(value2) || IsMappedResult(value2) || IsNever(value2) || IsNot(value2) || IsNull3(value2) || IsNumber3(value2) || IsObject3(value2) || IsPromise2(value2) || IsRecord(value2) || IsRef(value2) || IsRegExp2(value2) || IsString3(value2) || IsSymbol3(value2) || IsTemplateLiteral(value2) || IsThis(value2) || IsTuple(value2) || IsUndefined3(value2) || IsUnion(value2) || IsUint8Array3(value2) || IsUnknown(value2) || IsUnsafe(value2) || IsVoid(value2) || IsKind(value2);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
}
function AddOptional(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult(R, F) {
  return FromProperties(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(T) {
  return T.every((L) => IsOptional(L));
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function RemoveOptionalFromRest(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
}
function ResolveIntersect(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
}
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(T) {
  return T.some((L) => IsOptional(L));
}
function RemoveOptionalFromRest2(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
}
function RemoveOptionalFromType2(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
}
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value2, index) {
    if (!IsOpenParen(value2, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value2.length; scan++) {
      if (IsOpenParen(value2, scan))
        count += 1;
      if (IsCloseParen(value2, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

class TemplateLiteralParserError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

class TemplateLiteralFiniteError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

class TemplateLiteralGenerateError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value2, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value2,
    type: typeof value2
  };
}
// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal3) => Literal(literal3.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
function Escape(value2) {
  return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern2 = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern: pattern2 };
}
// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
}
function FromUnion2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexPropertyKeys(L));
  return Acc;
}
function FromLiteral(T) {
  return [T.toString()];
}
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties2(T, P, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P)) {
    Acc[K2] = Index(T, IndexPropertyKeys(P[K2]), options);
  }
  return Acc;
}
function FromMappedResult2(T, R, options) {
  return FromProperties2(T, R.properties, options);
}
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
}
function FromIntersectRest(T) {
  return T.filter((L) => !IsNever(L));
}
function FromIntersect(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
}
function FromUnionRest(T) {
  return T.some((L) => IsNever(L)) ? [] : T;
}
function FromUnion3(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
}
function FromTuple(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
}
function FromArray(T, K) {
  return K === "[number]" ? T : Never();
}
function FromProperty(T, K) {
  return K in T ? T[K] : Never();
}
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
function FromSchema(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
}
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(T, K, options) {
  return { [K]: Index(T, [K], options) };
}
function MappedIndexPropertyKeys(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
}
function MappedIndexProperties(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
}
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key of propertyKeys)
    clonedProperties[key] = CloneType(properties[key]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
}
function AddReadonly(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties3(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult3(R, F) {
  return FromProperties3(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult4(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties4(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest3(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(KeyOfPropertyKeys(L));
  return Acc;
}
function FromIntersect2(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
}
function FromUnion4(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
}
function FromTuple2(T) {
  return T.map((_, I) => I.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern3 = keys.map((key) => `(${key})`);
  return `^(${pattern3.join("|")})\$`;
}
var includePatternProperties = false;

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = KeyOf(K[K2], options);
  return Acc;
}
function FromMappedResult5(R, options) {
  return FromProperties6(R.properties, options);
}
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error7) {
  switch (error7.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error7.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error7.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error7.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error7.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error7.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error7.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error7.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error7.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error7.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error7.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error7.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error7.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error7.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error7.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error7.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error7.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error7.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error7.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error7.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error7.schema.const === "string" ? `'${error7.schema.const}'` : error7.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error7.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error7.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error7.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error7.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error7.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error7.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error7.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error7.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error7.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error7.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error7.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error7.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error7.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error7.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error7.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error7.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction() {
  return errorFunction;
}
var errorFunction = DefaultErrorFunction;

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
function* NumberToBytes(value3) {
  const byteCount = value3 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value3) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value3 >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value3) {
  FNV1A64(ByteMarker.Array);
  for (const item of value3) {
    Visit3(item);
  }
}
function BooleanType(value3) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value3 ? 1 : 0);
}
function BigIntType(value3) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value3) {
  FNV1A64(ByteMarker.Date);
  Visit3(value3.getTime());
}
function NullType(value3) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value3) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value3) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value3).sort()) {
    Visit3(key);
    Visit3(value3[key]);
  }
}
function StringType(value3) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value3.length; i++) {
    for (const byte of NumberToBytes(value3.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value3) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value3.description);
}
function Uint8ArrayType2(value3) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value3.length; i++) {
    FNV1A64(value3[i]);
  }
}
function UndefinedType(value3) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit3(value3) {
  if (IsArray(value3))
    return ArrayType2(value3);
  if (IsBoolean(value3))
    return BooleanType(value3);
  if (IsBigInt(value3))
    return BigIntType(value3);
  if (IsDate(value3))
    return DateType2(value3);
  if (IsNull(value3))
    return NullType(value3);
  if (IsNumber(value3))
    return NumberType(value3);
  if (IsStandardObject(value3))
    return ObjectType2(value3);
  if (IsString(value3))
    return StringType(value3);
  if (IsSymbol(value3))
    return SymbolType(value3);
  if (IsUint8Array(value3))
    return Uint8ArrayType2(value3);
  if (IsUndefined(value3))
    return UndefinedType(value3);
  throw new ValueHashError(value3);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value3) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value3);
  return Accumulator;
}

class ValueHashError extends TypeBoxError {
  constructor(value3) {
    super(`Unable to hash value`);
    this.value = value3;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined(value3) {
  return value3 !== undefined;
}
function Create(errorType, schema, path, value3) {
  return { type: errorType, schema, path, value: value3, message: GetErrorFunction()({ errorType, path, schema, value: value3 }) };
}
function* FromAny(schema, references, path, value3) {
}
function* FromArray3(schema, references, path, value3) {
  if (!IsArray(value3)) {
    return yield Create(ValueErrorType.Array, schema, path, value3);
  }
  if (IsDefined(schema.minItems) && !(value3.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value3);
  }
  if (IsDefined(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value3);
  }
  for (let i = 0;i < value3.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value3[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value3);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4, index) => Visit4(containsSchema, references, `${path}${index}`, value4).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value3);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value3);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value3);
  }
}
function* FromAsyncIterator(schema, references, path, value3) {
  if (!IsAsyncIterator(value3))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value3);
}
function* FromBigInt(schema, references, path, value3) {
  if (!IsBigInt(value3))
    return yield Create(ValueErrorType.BigInt, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value3);
  }
}
function* FromBoolean(schema, references, path, value3) {
  if (!IsBoolean(value3))
    yield Create(ValueErrorType.Boolean, schema, path, value3);
}
function* FromConstructor(schema, references, path, value3) {
  yield* Visit4(schema.returns, references, path, value3.prototype);
}
function* FromDate(schema, references, path, value3) {
  if (!IsDate(value3))
    return yield Create(ValueErrorType.Date, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value3);
  }
}
function* FromFunction(schema, references, path, value3) {
  if (!IsFunction(value3))
    yield Create(ValueErrorType.Function, schema, path, value3);
}
function* FromInteger(schema, references, path, value3) {
  if (!IsInteger(value3))
    return yield Create(ValueErrorType.Integer, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value3);
  }
}
function* FromIntersect3(schema, references, path, value3) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value3).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value3);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value3);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value3[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value3) {
  if (!IsIterator(value3))
    yield Create(ValueErrorType.Iterator, schema, path, value3);
}
function* FromLiteral2(schema, references, path, value3) {
  if (!(value3 === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value3);
}
function* FromNever(schema, references, path, value3) {
  yield Create(ValueErrorType.Never, schema, path, value3);
}
function* FromNot(schema, references, path, value3) {
  if (Visit4(schema.not, references, path, value3).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value3);
}
function* FromNull(schema, references, path, value3) {
  if (!IsNull(value3))
    yield Create(ValueErrorType.Null, schema, path, value3);
}
function* FromNumber(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return yield Create(ValueErrorType.Number, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value3);
  }
}
function* FromObject(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value3);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value3)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value3) {
  if (!IsPromise(value3))
    yield Create(ValueErrorType.Promise, schema, path, value3);
}
function* FromRecord(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value3)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromRegExp(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value3)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value3);
  }
}
function* FromString(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value3);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value3);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value3)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value3);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value3) {
  if (!IsSymbol(value3))
    yield Create(ValueErrorType.Symbol, schema, path, value3);
}
function* FromTemplateLiteral2(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value3)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value3);
  }
}
function* FromThis(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromTuple3(schema, references, path, value3) {
  if (!IsArray(value3))
    return yield Create(ValueErrorType.Tuple, schema, path, value3);
  if (schema.items === undefined && !(value3.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!(value3.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value3[i]);
  }
}
function* FromUndefined(schema, references, path, value3) {
  if (!IsUndefined(value3))
    yield Create(ValueErrorType.Undefined, schema, path, value3);
}
function* FromUnion5(schema, references, path, value3) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors2 = [...Visit4(subschema, references, path, value3)];
    if (errors2.length === 0)
      return;
    count += errors2.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value3);
  }
}
function* FromUint8Array(schema, references, path, value3) {
  if (!IsUint8Array(value3))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value3);
  if (IsDefined(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value3);
  }
  if (IsDefined(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value3);
  }
}
function* FromUnknown(schema, references, path, value3) {
}
function* FromVoid(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsVoidLike(value3))
    yield Create(ValueErrorType.Void, schema, path, value3);
}
function* FromKind(schema, references, path, value3) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value3))
    yield Create(ValueErrorType.Kind, schema, path, value3);
}
function* Visit4(schema, references, path, value3) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value3);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value3);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value3);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value3);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value3);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value3);
    case "Date":
      return yield* FromDate(schema_, references_, path, value3);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value3);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value3);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value3);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value3);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value3);
    case "Never":
      return yield* FromNever(schema_, references_, path, value3);
    case "Not":
      return yield* FromNot(schema_, references_, path, value3);
    case "Null":
      return yield* FromNull(schema_, references_, path, value3);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value3);
    case "Object":
      return yield* FromObject(schema_, references_, path, value3);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value3);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value3);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value3);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value3);
    case "String":
      return yield* FromString(schema_, references_, path, value3);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value3);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value3);
    case "This":
      return yield* FromThis(schema_, references_, path, value3);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value3);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value3);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value3);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value3);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value3);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value3);
  }
}
function Errors(...args) {
  const iterator3 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator3);
}
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator {
  constructor(iterator3) {
    this.iterator = iterator3;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsAny: () => IsAny2
});
function IsPattern(value3) {
  try {
    new RegExp(value3);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value3) {
  if (!IsString2(value3))
    return false;
  for (let i = 0;i < value3.length; i++) {
    const code = value3.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value3) {
  return IsOptionalBoolean(value3) || IsSchema2(value3);
}
function IsOptionalBigInt(value3) {
  return IsUndefined2(value3) || IsBigInt2(value3);
}
function IsOptionalNumber(value3) {
  return IsUndefined2(value3) || IsNumber2(value3);
}
function IsOptionalBoolean(value3) {
  return IsUndefined2(value3) || IsBoolean2(value3);
}
function IsOptionalString(value3) {
  return IsUndefined2(value3) || IsString2(value3);
}
function IsOptionalPattern(value3) {
  return IsUndefined2(value3) || IsString2(value3) && IsControlCharacterFree(value3) && IsPattern(value3);
}
function IsOptionalFormat(value3) {
  return IsUndefined2(value3) || IsString2(value3) && IsControlCharacterFree(value3);
}
function IsOptionalSchema(value3) {
  return IsUndefined2(value3) || IsSchema2(value3);
}
function IsReadonly2(value3) {
  return IsObject2(value3) && value3[ReadonlyKind] === "Readonly";
}
function IsOptional2(value3) {
  return IsObject2(value3) && value3[OptionalKind] === "Optional";
}
function IsAny2(value3) {
  return IsKindOf2(value3, "Any") && IsOptionalString(value3.$id);
}
function IsArray4(value3) {
  return IsKindOf2(value3, "Array") && value3.type === "array" && IsOptionalString(value3.$id) && IsSchema2(value3.items) && IsOptionalNumber(value3.minItems) && IsOptionalNumber(value3.maxItems) && IsOptionalBoolean(value3.uniqueItems) && IsOptionalSchema(value3.contains) && IsOptionalNumber(value3.minContains) && IsOptionalNumber(value3.maxContains);
}
function IsAsyncIterator4(value3) {
  return IsKindOf2(value3, "AsyncIterator") && value3.type === "AsyncIterator" && IsOptionalString(value3.$id) && IsSchema2(value3.items);
}
function IsBigInt4(value3) {
  return IsKindOf2(value3, "BigInt") && value3.type === "bigint" && IsOptionalString(value3.$id) && IsOptionalBigInt(value3.exclusiveMaximum) && IsOptionalBigInt(value3.exclusiveMinimum) && IsOptionalBigInt(value3.maximum) && IsOptionalBigInt(value3.minimum) && IsOptionalBigInt(value3.multipleOf);
}
function IsBoolean4(value3) {
  return IsKindOf2(value3, "Boolean") && value3.type === "boolean" && IsOptionalString(value3.$id);
}
function IsConstructor2(value3) {
  return IsKindOf2(value3, "Constructor") && value3.type === "Constructor" && IsOptionalString(value3.$id) && IsArray2(value3.parameters) && value3.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value3.returns);
}
function IsDate4(value3) {
  return IsKindOf2(value3, "Date") && value3.type === "Date" && IsOptionalString(value3.$id) && IsOptionalNumber(value3.exclusiveMaximumTimestamp) && IsOptionalNumber(value3.exclusiveMinimumTimestamp) && IsOptionalNumber(value3.maximumTimestamp) && IsOptionalNumber(value3.minimumTimestamp) && IsOptionalNumber(value3.multipleOfTimestamp);
}
function IsFunction4(value3) {
  return IsKindOf2(value3, "Function") && value3.type === "Function" && IsOptionalString(value3.$id) && IsArray2(value3.parameters) && value3.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value3.returns);
}
function IsInteger3(value3) {
  return IsKindOf2(value3, "Integer") && value3.type === "integer" && IsOptionalString(value3.$id) && IsOptionalNumber(value3.exclusiveMaximum) && IsOptionalNumber(value3.exclusiveMinimum) && IsOptionalNumber(value3.maximum) && IsOptionalNumber(value3.minimum) && IsOptionalNumber(value3.multipleOf);
}
function IsProperties(value3) {
  return IsObject2(value3) && Object.entries(value3).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value3) {
  return IsKindOf2(value3, "Intersect") && (IsString2(value3.type) && value3.type !== "object" ? false : true) && IsArray2(value3.allOf) && value3.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value3.type) && (IsOptionalBoolean(value3.unevaluatedProperties) || IsOptionalSchema(value3.unevaluatedProperties)) && IsOptionalString(value3.$id);
}
function IsIterator4(value3) {
  return IsKindOf2(value3, "Iterator") && value3.type === "Iterator" && IsOptionalString(value3.$id) && IsSchema2(value3.items);
}
function IsKindOf2(value3, kind14) {
  return IsObject2(value3) && Kind in value3 && value3[Kind] === kind14;
}
function IsLiteralString(value3) {
  return IsLiteral2(value3) && IsString2(value3.const);
}
function IsLiteralNumber(value3) {
  return IsLiteral2(value3) && IsNumber2(value3.const);
}
function IsLiteralBoolean(value3) {
  return IsLiteral2(value3) && IsBoolean2(value3.const);
}
function IsLiteral2(value3) {
  return IsKindOf2(value3, "Literal") && IsOptionalString(value3.$id) && IsLiteralValue(value3.const);
}
function IsLiteralValue(value3) {
  return IsBoolean2(value3) || IsNumber2(value3) || IsString2(value3);
}
function IsMappedKey2(value3) {
  return IsKindOf2(value3, "MappedKey") && IsArray2(value3.keys) && value3.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult2(value3) {
  return IsKindOf2(value3, "MappedResult") && IsProperties(value3.properties);
}
function IsNever2(value3) {
  return IsKindOf2(value3, "Never") && IsObject2(value3.not) && Object.getOwnPropertyNames(value3.not).length === 0;
}
function IsNot2(value3) {
  return IsKindOf2(value3, "Not") && IsSchema2(value3.not);
}
function IsNull4(value3) {
  return IsKindOf2(value3, "Null") && value3.type === "null" && IsOptionalString(value3.$id);
}
function IsNumber4(value3) {
  return IsKindOf2(value3, "Number") && value3.type === "number" && IsOptionalString(value3.$id) && IsOptionalNumber(value3.exclusiveMaximum) && IsOptionalNumber(value3.exclusiveMinimum) && IsOptionalNumber(value3.maximum) && IsOptionalNumber(value3.minimum) && IsOptionalNumber(value3.multipleOf);
}
function IsObject4(value3) {
  return IsKindOf2(value3, "Object") && value3.type === "object" && IsOptionalString(value3.$id) && IsProperties(value3.properties) && IsAdditionalProperties(value3.additionalProperties) && IsOptionalNumber(value3.minProperties) && IsOptionalNumber(value3.maxProperties);
}
function IsPromise3(value3) {
  return IsKindOf2(value3, "Promise") && value3.type === "Promise" && IsOptionalString(value3.$id) && IsSchema2(value3.item);
}
function IsRecord2(value3) {
  return IsKindOf2(value3, "Record") && value3.type === "object" && IsOptionalString(value3.$id) && IsAdditionalProperties(value3.additionalProperties) && IsObject2(value3.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value3);
}
function IsRecursive(value3) {
  return IsObject2(value3) && Hint in value3 && value3[Hint] === "Recursive";
}
function IsRef2(value3) {
  return IsKindOf2(value3, "Ref") && IsOptionalString(value3.$id) && IsString2(value3.$ref);
}
function IsRegExp3(value3) {
  return IsKindOf2(value3, "RegExp") && IsOptionalString(value3.$id) && IsString2(value3.source) && IsString2(value3.flags) && IsOptionalNumber(value3.maxLength) && IsOptionalNumber(value3.minLength);
}
function IsString4(value3) {
  return IsKindOf2(value3, "String") && value3.type === "string" && IsOptionalString(value3.$id) && IsOptionalNumber(value3.minLength) && IsOptionalNumber(value3.maxLength) && IsOptionalPattern(value3.pattern) && IsOptionalFormat(value3.format);
}
function IsSymbol4(value3) {
  return IsKindOf2(value3, "Symbol") && value3.type === "symbol" && IsOptionalString(value3.$id);
}
function IsTemplateLiteral2(value3) {
  return IsKindOf2(value3, "TemplateLiteral") && value3.type === "string" && IsString2(value3.pattern) && value3.pattern[0] === "^" && value3.pattern[value3.pattern.length - 1] === "$";
}
function IsThis2(value3) {
  return IsKindOf2(value3, "This") && IsOptionalString(value3.$id) && IsString2(value3.$ref);
}
function IsTransform2(value3) {
  return IsObject2(value3) && TransformKind in value3;
}
function IsTuple2(value3) {
  return IsKindOf2(value3, "Tuple") && value3.type === "array" && IsOptionalString(value3.$id) && IsNumber2(value3.minItems) && IsNumber2(value3.maxItems) && value3.minItems === value3.maxItems && (IsUndefined2(value3.items) && IsUndefined2(value3.additionalItems) && value3.minItems === 0 || IsArray2(value3.items) && value3.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value3) {
  return IsKindOf2(value3, "Undefined") && value3.type === "undefined" && IsOptionalString(value3.$id);
}
function IsUnionLiteral(value3) {
  return IsUnion2(value3) && value3.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value3) {
  return IsKindOf2(value3, "Union") && IsOptionalString(value3.$id) && IsObject2(value3) && IsArray2(value3.anyOf) && value3.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value3) {
  return IsKindOf2(value3, "Uint8Array") && value3.type === "Uint8Array" && IsOptionalString(value3.$id) && IsOptionalNumber(value3.minByteLength) && IsOptionalNumber(value3.maxByteLength);
}
function IsUnknown2(value3) {
  return IsKindOf2(value3, "Unknown") && IsOptionalString(value3.$id);
}
function IsUnsafe2(value3) {
  return IsKindOf2(value3, "Unsafe");
}
function IsVoid2(value3) {
  return IsKindOf2(value3, "Void") && value3.type === "void" && IsOptionalString(value3.$id);
}
function IsKind2(value3) {
  return IsObject2(value3) && Kind in value3 && IsString2(value3[Kind]) && !KnownTypes.includes(value3[Kind]);
}
function IsSchema2(value3) {
  return IsObject2(value3) && (IsAny2(value3) || IsArray4(value3) || IsBoolean4(value3) || IsBigInt4(value3) || IsAsyncIterator4(value3) || IsConstructor2(value3) || IsDate4(value3) || IsFunction4(value3) || IsInteger3(value3) || IsIntersect2(value3) || IsIterator4(value3) || IsLiteral2(value3) || IsMappedKey2(value3) || IsMappedResult2(value3) || IsNever2(value3) || IsNot2(value3) || IsNull4(value3) || IsNumber4(value3) || IsObject4(value3) || IsPromise3(value3) || IsRecord2(value3) || IsRef2(value3) || IsRegExp3(value3) || IsString4(value3) || IsSymbol4(value3) || IsTemplateLiteral2(value3) || IsThis2(value3) || IsTuple2(value3) || IsUndefined4(value3) || IsUnion2(value3) || IsUint8Array4(value3) || IsUnknown2(value3) || IsUnsafe2(value3) || IsVoid2(value3) || IsKind2(value3));
}

class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type2.IsNever(right) || exports_type2.IsIntersect(right) || exports_type2.IsUnion(right) || exports_type2.IsUnknown(right) || exports_type2.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) && right.anyOf.some((schema) => exports_type2.IsAny(schema) || exports_type2.IsUnknown(schema)) ? ExtendsResult.True : exports_type2.IsUnion(right) ? ExtendsResult.Union : exports_type2.IsUnknown(right) ? ExtendsResult.True : exports_type2.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromAsyncIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromBigInt2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type2.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type2.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromDate2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger2(left, right) {
  return exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromLiteral3(left, right) {
  return exports_type2.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever2(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot2(left, right) {
  return exports_type2.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type2.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type2.IsLiteralNumber(left) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type2.IsString(schema.properties.description.anyOf[0]) && exports_type2.IsUndefined(schema.properties.description.anyOf[1]) || exports_type2.IsString(schema.properties.description.anyOf[1]) && exports_type2.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type2.IsOptional(left) && !exports_type2.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) || exports_type2.IsLiteralString(left) && IsObjectStringLike(right) || exports_type2.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type2.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type2.IsString(left) && IsObjectStringLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsNumber(left) && IsObjectNumberLike(right) || exports_type2.IsInteger(left) && IsObjectNumberLike(right) || exports_type2.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type2.IsDate(left) && IsObjectDateLike(right) || exports_type2.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type2.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type2.IsRecord(left) && exports_type2.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type2.IsRecord(left) && exports_type2.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : !exports_type2.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type2.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type2.IsLiteralString(left) && exports_type2.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type2.IsUint8Array(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsString(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsArray(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
}
function FromRegExp2(left, right) {
  const L = exports_type2.IsRegExp(left) ? String2() : left;
  const R = exports_type2.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
}
function FromStringRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type2.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral3(left, right) {
  return exports_type2.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type2.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type2.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type2.IsNever(left) ? ExtendsResult.True : exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple4(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type2.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type2.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsVoid(right) ? FromVoidRight(left, right) : exports_type2.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown2(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type2.IsArray(right) ? FromArrayRight(left, right) : exports_type2.IsTuple(right) ? FromTupleRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type2.IsUndefined(left) ? ExtendsResult.True : exports_type2.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit5(left, right) {
  return exports_type2.IsTemplateLiteral(left) || exports_type2.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type2.IsRegExp(left) || exports_type2.IsRegExp(right) ? FromRegExp2(left, right) : exports_type2.IsNot(left) || exports_type2.IsNot(right) ? FromNot2(left, right) : exports_type2.IsAny(left) ? FromAny2(left, right) : exports_type2.IsArray(left) ? FromArray4(left, right) : exports_type2.IsBigInt(left) ? FromBigInt2(left, right) : exports_type2.IsBoolean(left) ? FromBoolean2(left, right) : exports_type2.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type2.IsConstructor(left) ? FromConstructor2(left, right) : exports_type2.IsDate(left) ? FromDate2(left, right) : exports_type2.IsFunction(left) ? FromFunction2(left, right) : exports_type2.IsInteger(left) ? FromInteger2(left, right) : exports_type2.IsIntersect(left) ? FromIntersect4(left, right) : exports_type2.IsIterator(left) ? FromIterator2(left, right) : exports_type2.IsLiteral(left) ? FromLiteral3(left, right) : exports_type2.IsNever(left) ? FromNever2(left, right) : exports_type2.IsNull(left) ? FromNull2(left, right) : exports_type2.IsNumber(left) ? FromNumber2(left, right) : exports_type2.IsObject(left) ? FromObject2(left, right) : exports_type2.IsRecord(left) ? FromRecord2(left, right) : exports_type2.IsString(left) ? FromString2(left, right) : exports_type2.IsSymbol(left) ? FromSymbol2(left, right) : exports_type2.IsTuple(left) ? FromTuple4(left, right) : exports_type2.IsPromise(left) ? FromPromise2(left, right) : exports_type2.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type2.IsUndefined(left) ? FromUndefined2(left, right) : exports_type2.IsUnion(left) ? FromUnion6(left, right) : exports_type2.IsUnknown(left) ? FromUnknown2(left, right) : exports_type2.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties7(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined2(value3) {
  return value3 !== undefined;
}
function FromAny3(schema, references, value3) {
  return true;
}
function FromArray5(schema, references, value3) {
  if (!IsArray(value3))
    return false;
  if (IsDefined2(schema.minItems) && !(value3.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    return false;
  }
  if (!value3.every((value4) => Visit6(schema.items, references, value4))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4) => Visit6(containsSchema, references, value4) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator3(schema, references, value3) {
  return IsAsyncIterator(value3);
}
function FromBigInt3(schema, references, value3) {
  if (!IsBigInt(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean3(schema, references, value3) {
  return IsBoolean(value3);
}
function FromConstructor3(schema, references, value3) {
  return Visit6(schema.returns, references, value3.prototype);
}
function FromDate3(schema, references, value3) {
  if (!IsDate(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction3(schema, references, value3) {
  return IsFunction(value3);
}
function FromInteger3(schema, references, value3) {
  if (!IsInteger(value3)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect5(schema, references, value3) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value3));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema2(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value3[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator3(schema, references, value3) {
  return IsIterator(value3);
}
function FromLiteral4(schema, references, value3) {
  return value3 === schema.const;
}
function FromNever3(schema, references, value3) {
  return false;
}
function FromNot3(schema, references, value3) {
  return !Visit6(schema.not, references, value3);
}
function FromNull3(schema, references, value3) {
  return IsNull(value3);
}
function FromNumber3(schema, references, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject3(schema, references, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value3[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value3)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey) && !Visit6(property, references, value3[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value3);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value3);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value3[key]));
  } else {
    return true;
  }
}
function FromPromise3(schema, references, value3) {
  return IsPromise(value3);
}
function FromRecord3(schema, references, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value3).every(([key, value4]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value4) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value3).every(([key, value4]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value4) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value3).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef2(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
}
function FromRegExp3(schema, references, value3) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  return regex.test(value3);
}
function FromString3(schema, references, value3) {
  if (!IsString(value3)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value3);
  }
  return true;
}
function FromSymbol3(schema, references, value3) {
  return IsSymbol(value3);
}
function FromTemplateLiteral4(schema, references, value3) {
  return IsString(value3) && new RegExp(schema.pattern).test(value3);
}
function FromThis2(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
}
function FromTuple5(schema, references, value3) {
  if (!IsArray(value3)) {
    return false;
  }
  if (schema.items === undefined && !(value3.length === 0)) {
    return false;
  }
  if (!(value3.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value3[i]))
      return false;
  }
  return true;
}
function FromUndefined3(schema, references, value3) {
  return IsUndefined(value3);
}
function FromUnion7(schema, references, value3) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value3));
}
function FromUint8Array3(schema, references, value3) {
  if (!IsUint8Array(value3)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown3(schema, references, value3) {
  return true;
}
function FromVoid3(schema, references, value3) {
  return TypeSystemPolicy.IsVoidLike(value3);
}
function FromKind2(schema, references, value3) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value3);
}
function Visit6(schema, references, value3) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value3);
    case "Array":
      return FromArray5(schema_, references_, value3);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value3);
    case "BigInt":
      return FromBigInt3(schema_, references_, value3);
    case "Boolean":
      return FromBoolean3(schema_, references_, value3);
    case "Constructor":
      return FromConstructor3(schema_, references_, value3);
    case "Date":
      return FromDate3(schema_, references_, value3);
    case "Function":
      return FromFunction3(schema_, references_, value3);
    case "Integer":
      return FromInteger3(schema_, references_, value3);
    case "Intersect":
      return FromIntersect5(schema_, references_, value3);
    case "Iterator":
      return FromIterator3(schema_, references_, value3);
    case "Literal":
      return FromLiteral4(schema_, references_, value3);
    case "Never":
      return FromNever3(schema_, references_, value3);
    case "Not":
      return FromNot3(schema_, references_, value3);
    case "Null":
      return FromNull3(schema_, references_, value3);
    case "Number":
      return FromNumber3(schema_, references_, value3);
    case "Object":
      return FromObject3(schema_, references_, value3);
    case "Promise":
      return FromPromise3(schema_, references_, value3);
    case "Record":
      return FromRecord3(schema_, references_, value3);
    case "Ref":
      return FromRef2(schema_, references_, value3);
    case "RegExp":
      return FromRegExp3(schema_, references_, value3);
    case "String":
      return FromString3(schema_, references_, value3);
    case "Symbol":
      return FromSymbol3(schema_, references_, value3);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value3);
    case "This":
      return FromThis2(schema_, references_, value3);
    case "Tuple":
      return FromTuple5(schema_, references_, value3);
    case "Undefined":
      return FromUndefined3(schema_, references_, value3);
    case "Union":
      return FromUnion7(schema_, references_, value3);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value3);
    case "Unknown":
      return FromUnknown3(schema_, references_, value3);
    case "Void":
      return FromVoid3(schema_, references_, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value3);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}

class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function ObjectType3(value3) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value3)) {
    Acc[key] = Clone2(value3[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value3)) {
    Acc[key] = Clone2(value3[key]);
  }
  return Acc;
}
function ArrayType3(value3) {
  return value3.map((element) => Clone2(element));
}
function TypedArrayType(value3) {
  return value3.slice();
}
function DateType3(value3) {
  return new Date(value3.toISOString());
}
function ValueType(value3) {
  return value3;
}
function Clone2(value3) {
  if (IsArray(value3))
    return ArrayType3(value3);
  if (IsDate(value3))
    return DateType3(value3);
  if (IsStandardObject(value3))
    return ObjectType3(value3);
  if (IsTypedArray(value3))
    return TypedArrayType(value3);
  if (IsValueType(value3))
    return ValueType(value3);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
function FromDefault(value3) {
  return typeof value3 === "function" ? value3 : Clone2(value3);
}
function FromAny4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArray6(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = Visit7(schema.returns, references);
    if (typeof value3 === "object" && !Array.isArray(value3)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value3)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromInteger4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value3))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value3;
  }
}
function FromIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord4(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit7(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion8(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
function ScoreUnion(schema, references, value3) {
  if (schema[Kind] === "Object" && typeof value3 === "object" && !IsNull(value3)) {
    const object3 = schema;
    const keys = Object.getOwnPropertyNames(value3);
    const entries = Object.entries(object3.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal7 = schema2[Kind] === "Literal" && schema2.const === value3[key] ? max : 0;
      const checks = Check(schema2, references, value3[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal7 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value3) ? 1 : 0;
  }
}
function SelectUnion(union9, references, value3) {
  const schemas = union9.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value3);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union9, references, value3) {
  if ("default" in union9) {
    return typeof value3 === "function" ? union9.default : Clone2(union9.default);
  } else {
    const schema = SelectUnion(union9, references, value3);
    return Cast(schema, references, value3);
  }
}
function DefaultClone(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : Create2(schema, references);
}
function Default(schema, references, value3) {
  return Check(schema, references, value3) ? value3 : Create2(schema, references);
}
function FromArray7(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  const created = IsArray(value3) ? Clone2(value3) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value4) => Visit8(schema.items, references, value4));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor5(schema, references, value3) {
  if (Check(schema, references, value3))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value3.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value3.prototype[key]);
  }
  return result;
}
function FromIntersect7(schema, references, value3) {
  const created = Create2(schema, references);
  const mapped9 = IsStandardObject(created) && IsStandardObject(value3) ? { ...created, ...value3 } : value3;
  return Check(schema, references, mapped9) ? mapped9 : Create2(schema, references);
}
function FromNever5(schema, references, value3) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject5(schema, references, value3) {
  if (Check(schema, references, value3))
    return value3;
  if (value3 === null || typeof value3 !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value3[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value3[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value3)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value3[propertyName]);
    }
  }
  return result;
}
function FromRecord5(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (value3 === null || typeof value3 !== "object" || Array.isArray(value3) || value3 instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef4(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
}
function FromThis4(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
}
function FromTuple7(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (!IsArray(value3))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value3[index]));
}
function FromUnion9(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : CastUnion(schema, references, value3);
}
function Visit8(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value3);
    case "Constructor":
      return FromConstructor5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect7(schema_, references_, value3);
    case "Never":
      return FromNever5(schema_, references_, value3);
    case "Object":
      return FromObject5(schema_, references_, value3);
    case "Record":
      return FromRecord5(schema_, references_, value3);
    case "Ref":
      return FromRef4(schema_, references_, value3);
    case "This":
      return FromThis4(schema_, references_, value3);
    case "Tuple":
      return FromTuple7(schema_, references_, value3);
    case "Union":
      return FromUnion9(schema_, references_, value3);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value3);
    default:
      return Default(schema_, references_, value3);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}

class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function FromArray8(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  return value3.map((value4) => Visit9(schema.items, references, value4));
}
function FromIntersect8(schema, references, value3) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value3)));
  const composite = intersections.reduce((acc, value4) => IsObject(value4) ? { ...acc, ...value4 } : value4, {});
  if (!IsObject(value3) || !IsObject(composite) || !IsSchema2(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value3[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value3[key]);
    }
  }
  return composite;
}
function FromObject6(schema, references, value3) {
  if (!IsObject(value3) || IsArray(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (key in schema.properties) {
      value3[key] = Visit9(schema.properties[key], references, value3[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
}
function FromRecord6(schema, references, value3) {
  if (!IsObject(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value3);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value3[key] = Visit9(propertySchema, references, value3[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
}
function FromRef5(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
}
function FromThis5(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
}
function FromTuple8(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value3.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value3[i] = Visit9(schema.items[i], references, value3[i]);
  }
  return value3.length > length ? value3.slice(0, length) : value3;
}
function FromUnion10(schema, references, value3) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value3)) {
      return Visit9(inner, references, value3);
    }
  }
  return value3;
}
function Visit9(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value3);
    case "Intersect":
      return FromIntersect8(schema_, references_, value3);
    case "Object":
      return FromObject6(schema_, references_, value3);
    case "Record":
      return FromRecord6(schema_, references_, value3);
    case "Ref":
      return FromRef5(schema_, references_, value3);
    case "This":
      return FromThis5(schema_, references_, value3);
    case "Tuple":
      return FromTuple8(schema_, references_, value3);
    case "Union":
      return FromUnion10(schema_, references_, value3);
    default:
      return value3;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value3) {
  return IsString(value3) && !isNaN(value3) && !isNaN(parseFloat(value3));
}
function IsValueToString(value3) {
  return IsBigInt(value3) || IsBoolean(value3) || IsNumber(value3);
}
function IsValueTrue(value3) {
  return value3 === true || IsNumber(value3) && value3 === 1 || IsBigInt(value3) && value3 === BigInt("1") || IsString(value3) && (value3.toLowerCase() === "true" || value3 === "1");
}
function IsValueFalse(value3) {
  return value3 === false || IsNumber(value3) && (value3 === 0 || Object.is(value3, -0)) || IsBigInt(value3) && value3 === BigInt("0") || IsString(value3) && (value3.toLowerCase() === "false" || value3 === "0" || value3 === "-0");
}
function IsTimeStringWithTimeZone(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
}
function IsTimeStringWithoutTimeZone(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
}
function IsDateTimeStringWithTimeZone(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
}
function IsDateTimeStringWithoutTimeZone(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
}
function IsDateString(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value3);
}
function TryConvertLiteralString(value3, target) {
  const conversion = TryConvertString(value3);
  return conversion === target ? conversion : value3;
}
function TryConvertLiteralNumber(value3, target) {
  const conversion = TryConvertNumber(value3);
  return conversion === target ? conversion : value3;
}
function TryConvertLiteralBoolean(value3, target) {
  const conversion = TryConvertBoolean(value3);
  return conversion === target ? conversion : value3;
}
function TryConvertLiteral(schema, value3) {
  return IsString(schema.const) ? TryConvertLiteralString(value3, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value3, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value3, schema.const) : Clone2(value3);
}
function TryConvertBoolean(value3) {
  return IsValueTrue(value3) ? true : IsValueFalse(value3) ? false : value3;
}
function TryConvertBigInt(value3) {
  return IsStringNumeric(value3) ? BigInt(parseInt(value3)) : IsNumber(value3) ? BigInt(value3 | 0) : IsValueFalse(value3) ? BigInt(0) : IsValueTrue(value3) ? BigInt(1) : value3;
}
function TryConvertString(value3) {
  return IsValueToString(value3) ? value3.toString() : IsSymbol(value3) && value3.description !== undefined ? value3.description.toString() : value3;
}
function TryConvertNumber(value3) {
  return IsStringNumeric(value3) ? parseFloat(value3) : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
}
function TryConvertInteger(value3) {
  return IsStringNumeric(value3) ? parseInt(value3) : IsNumber(value3) ? value3 | 0 : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
}
function TryConvertNull(value3) {
  return IsString(value3) && value3.toLowerCase() === "null" ? null : value3;
}
function TryConvertUndefined(value3) {
  return IsString(value3) && value3 === "undefined" ? undefined : value3;
}
function TryConvertDate(value3) {
  return IsDate(value3) ? value3 : IsNumber(value3) ? new Date(value3) : IsValueTrue(value3) ? new Date(1) : IsValueFalse(value3) ? new Date(0) : IsStringNumeric(value3) ? new Date(parseInt(value3)) : IsTimeStringWithoutTimeZone(value3) ? new Date(`1970-01-01T${value3}.000Z`) : IsTimeStringWithTimeZone(value3) ? new Date(`1970-01-01T${value3}`) : IsDateTimeStringWithoutTimeZone(value3) ? new Date(`${value3}.000Z`) : IsDateTimeStringWithTimeZone(value3) ? new Date(value3) : IsDateString(value3) ? new Date(`${value3}T00:00:00.000Z`) : value3;
}
function Default2(value3) {
  return value3;
}
function FromArray9(schema, references, value3) {
  const elements = IsArray(value3) ? value3 : [value3];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value3) {
  return TryConvertBigInt(value3);
}
function FromBoolean5(schema, references, value3) {
  return TryConvertBoolean(value3);
}
function FromDate5(schema, references, value3) {
  return TryConvertDate(value3);
}
function FromInteger5(schema, references, value3) {
  return TryConvertInteger(value3);
}
function FromIntersect9(schema, references, value3) {
  return schema.allOf.reduce((value4, schema2) => Visit10(schema2, references, value4), value3);
}
function FromLiteral6(schema, references, value3) {
  return TryConvertLiteral(schema, value3);
}
function FromNull5(schema, references, value3) {
  return TryConvertNull(value3);
}
function FromNumber5(schema, references, value3) {
  return TryConvertNumber(value3);
}
function FromObject7(schema, references, value3) {
  const isConvertable = IsObject(value3);
  if (!isConvertable)
    return value3;
  const result = {};
  for (const key of Object.keys(value3)) {
    result[key] = HasPropertyKey(schema.properties, key) ? Visit10(schema.properties[key], references, value3[key]) : value3[key];
  }
  return result;
}
function FromRecord7(schema, references, value3) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
}
function FromRef6(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
}
function FromString5(schema, references, value3) {
  return TryConvertString(value3);
}
function FromSymbol5(schema, references, value3) {
  return IsString(value3) || IsNumber(value3) ? Symbol(value3) : value3;
}
function FromThis6(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
}
function FromTuple9(schema, references, value3) {
  const isConvertable = IsArray(value3) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value3;
  return value3.map((value4, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value4) : value4;
  });
}
function FromUndefined5(schema, references, value3) {
  return TryConvertUndefined(value3);
}
function FromUnion11(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value3);
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value3;
}
function Visit10(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value3);
    case "BigInt":
      return FromBigInt5(schema_, references_, value3);
    case "Boolean":
      return FromBoolean5(schema_, references_, value3);
    case "Date":
      return FromDate5(schema_, references_, value3);
    case "Integer":
      return FromInteger5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect9(schema_, references_, value3);
    case "Literal":
      return FromLiteral6(schema_, references_, value3);
    case "Null":
      return FromNull5(schema_, references_, value3);
    case "Number":
      return FromNumber5(schema_, references_, value3);
    case "Object":
      return FromObject7(schema_, references_, value3);
    case "Record":
      return FromRecord7(schema_, references_, value3);
    case "Ref":
      return FromRef6(schema_, references_, value3);
    case "String":
      return FromString5(schema_, references_, value3);
    case "Symbol":
      return FromSymbol5(schema_, references_, value3);
    case "This":
      return FromThis6(schema_, references_, value3);
    case "Tuple":
      return FromTuple9(schema_, references_, value3);
    case "Undefined":
      return FromUndefined5(schema_, references_, value3);
    case "Union":
      return FromUnion11(schema_, references_, value3);
    default:
      return Default2(value3);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value3) {
  return value3 === undefined && "default" in schema ? Clone2(schema.default) : value3;
}
function IsCheckable2(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function IsDefaultSchema(value3) {
  return IsSchema2(value3) && "default" in value3;
}
function FromArray10(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromIntersect10(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject8(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord8(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef7(schema, references, value3) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value3));
}
function FromThis7(schema, references, value3) {
  return Visit11(Deref(schema, references), references, value3);
}
function FromTuple10(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion12(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit11(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value3);
    case "Intersect":
      return FromIntersect10(schema_, references_, value3);
    case "Object":
      return FromObject8(schema_, references_, value3);
    case "Record":
      return FromRecord8(schema_, references_, value3);
    case "Ref":
      return FromRef7(schema_, references_, value3);
    case "This":
      return FromThis7(schema_, references_, value3);
    case "Tuple":
      return FromTuple10(schema_, references_, value3);
    case "Union":
      return FromUnion12(schema_, references_, value3);
    default:
      return ValueOrDefault(schema_, value3);
  }
}
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value3, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value3, pointer, update);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value3, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value3, pointer);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value3, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value3, pointer) {
  if (pointer === "")
    return value3;
  let current = value3;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}

class ValuePointerRootSetError extends TypeBoxError {
  constructor(value3, path, update) {
    super("Cannot set root value");
    this.value = value3;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value3, path) {
    super("Cannot delete root value");
    this.value = value3;
    this.path = path;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
function CreateUpdate(path, value3) {
  return { type: "update", path, value: value3 };
}
function CreateInsert(path, value3) {
  return { type: "insert", path, value: value3 };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function* ObjectType4(path, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone8 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone8, edit.path);
        break;
      }
    }
  }
  return clone8;
}
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  constructor(value3, message) {
    super(message);
    this.value = value3;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  constructor(value3) {
    super(value3, "Cannot diff objects with symbol keys");
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType5(left, right) {
  if (!IsStandardObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType4(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
}
function ArrayType5(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
}
function TypedArrayType3(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
}
function ValueType3(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsStandardObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function ObjectType6(root, path, current, next) {
  if (!IsStandardObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType6(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType4(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType4(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit13(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
}
function IsNonMutableValue(value3) {
  return IsTypedArray(value3) || IsValueType(value3);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
function Default4(schema, path, value3) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Decode(value3) : value3;
  } catch (error19) {
    throw new TransformDecodeError(schema, path, value3, error19);
  }
}
function FromArray11(schema, references, path, value3) {
  return IsArray(value3) ? Default4(schema, path, value3.map((value4, index) => Visit14(schema.items, references, `${path}/${index}`, value4))) : Default4(schema, path, value3);
}
function FromIntersect11(schema, references, path, value3) {
  if (!IsStandardObject(value3) || IsValueType(value3))
    return Default4(schema, path, value3);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value3 };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit14(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromNot5(schema, references, path, value3) {
  return Default4(schema, path, Visit14(schema.not, references, path, value3));
}
function FromObject9(schema, references, path, value3) {
  if (!IsStandardObject(value3))
    return Default4(schema, path, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value3 };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit14(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRecord9(schema, references, path, value3) {
  if (!IsStandardObject(value3))
    return Default4(schema, path, value3);
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = { ...value3 };
  for (const key of Object.getOwnPropertyNames(value3))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit14(schema.patternProperties[pattern3], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRef8(schema, references, path, value3) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value3));
}
function FromThis8(schema, references, path, value3) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value3));
}
function FromTuple11(schema, references, path, value3) {
  return IsArray(value3) && IsArray(schema.items) ? Default4(schema, path, schema.items.map((schema2, index) => Visit14(schema2, references, `${path}/${index}`, value3[index]))) : Default4(schema, path, value3);
}
function FromUnion13(schema, references, path, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const decoded = Visit14(subschema, references, path, value3);
    return Default4(schema, path, decoded);
  }
  return Default4(schema, path, value3);
}
function Visit14(schema, references, path, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, path, value3);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value3);
    case "Not":
      return FromNot5(schema_, references_, path, value3);
    case "Object":
      return FromObject9(schema_, references_, path, value3);
    case "Record":
      return FromRecord9(schema_, references_, path, value3);
    case "Ref":
      return FromRef8(schema_, references_, path, value3);
    case "Symbol":
      return Default4(schema_, path, value3);
    case "This":
      return FromThis8(schema_, references_, path, value3);
    case "Tuple":
      return FromTuple11(schema_, references_, path, value3);
    case "Union":
      return FromUnion13(schema_, references_, path, value3);
    default:
      return Default4(schema_, path, value3);
  }
}
function TransformDecode(schema, references, value3) {
  return Visit14(schema, references, "", value3);
}

class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value3, error19) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value3;
    this.error = error19;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value3, error19) {
    super(error19 instanceof Error ? error19.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value3;
    this.error = error19;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
function Default5(schema, path, value3) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Encode(value3) : value3;
  } catch (error20) {
    throw new TransformEncodeError(schema, path, value3, error20);
  }
}
function FromArray12(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  return IsArray(defaulted) ? defaulted.map((value4, index) => Visit15(schema.items, references, `${path}/${index}`, value4)) : defaulted;
}
function FromIntersect12(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  if (!IsStandardObject(value3) || IsValueType(value3))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit15(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path, value3) {
  return Default5(schema.not, path, Default5(schema, path, value3));
}
function FromObject10(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  if (!IsStandardObject(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit15(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord10(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  if (!IsStandardObject(value3))
    return defaulted;
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value3))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit15(schema.patternProperties[pattern3], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef9(schema, references, path, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value3);
  return Default5(schema, path, resolved);
}
function FromThis9(schema, references, path, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value3);
  return Default5(schema, path, resolved);
}
function FromTuple12(schema, references, path, value3) {
  const value1 = Default5(schema, path, value3);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const value1 = Visit15(subschema, references, path, value3);
    return Default5(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, path, value3);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, path, value1);
  }
  return Default5(schema, path, value3);
}
function Visit15(schema, references, path, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, path, value3);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value3);
    case "Not":
      return FromNot6(schema_, references_, path, value3);
    case "Object":
      return FromObject10(schema_, references_, path, value3);
    case "Record":
      return FromRecord10(schema_, references_, path, value3);
    case "Ref":
      return FromRef9(schema_, references_, path, value3);
    case "This":
      return FromThis9(schema_, references_, path, value3);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value3);
    case "Union":
      return FromUnion14(schema_, references_, path, value3);
    default:
      return Default5(schema_, path, value3);
  }
}
function TransformEncode(schema, references, value3) {
  return Visit15(schema, references, "", value3);
}

class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value3, error20) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value3;
    this.error = error20;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value3, error20) {
    super(`${error20 instanceof Error ? error20.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value3;
    this.error = error20;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray13(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromAsyncIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromFunction5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform2(schema) || IsTransform2(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
}
function FromIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform2(schema) || Visit16(schema.not, references);
}
function FromObject11(schema, references) {
  return IsTransform2(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema2(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
}
function FromPromise5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.item, references);
}
function FromRecord11(schema, references) {
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern3];
  return IsTransform2(schema) || Visit16(property, references) || IsSchema2(schema.additionalProperties) && IsTransform2(schema.additionalProperties);
}
function FromRef10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromThis10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromTuple13(schema, references) {
  return IsTransform2(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform2(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
}
function Visit16(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform2(schema);
  }
}
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
var visited = new Set;
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => Patch2,
  Mutate: () => Mutate2,
  Hash: () => Hash2,
  Errors: () => Errors2,
  Equal: () => Equal2,
  Encode: () => Encode,
  Diff: () => Diff2,
  Default: () => Default6,
  Decode: () => Decode,
  Create: () => Create3,
  Convert: () => Convert2,
  Clone: () => Clone3,
  Clean: () => Clean2,
  Check: () => Check2,
  Cast: () => Cast2
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value3) {
  return Clone2(value3);
}
function Decode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value3))
    throw new TransformDecodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value3) : value3;
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value3) : value3;
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value3) {
  return Hash(value3);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromRest4(T) {
  return T.map((L) => AwaitedResolve(L));
}
function FromIntersect14(T) {
  return Intersect(FromRest4(T));
}
function FromUnion16(T) {
  return Union(FromRest4(T));
}
function FromPromise6(T) {
  return AwaitedResolve(T);
}
function AwaitedResolve(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
}
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray14(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties8(value5) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value5))
    Acc[K] = Readonly(FromValue(value5[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value5, root) {
  return IsAsyncIterator2(value5) ? ConditionalReadonly(Any(), root) : IsIterator2(value5) ? ConditionalReadonly(Any(), root) : IsArray2(value5) ? Readonly(Tuple(FromArray14(value5))) : IsUint8Array2(value5) ? Uint8Array2() : IsDate2(value5) ? Date2() : IsObject2(value5) ? ConditionalReadonly(Object2(FromProperties8(value5)), root) : IsFunction2(value5) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value5) ? Undefined() : IsNull2(value5) ? Null() : IsSymbol2(value5) ? Symbol2() : IsBigInt2(value5) ? BigInt2() : IsNumber2(value5) ? Literal(value5) : IsBoolean2(value5) ? Literal(value5) : IsString2(value5) ? Literal(value5) : Object2({});
}
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/deref/deref.mjs
function FromRest5(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
}
function FromProperties9(properties, references) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K] = Deref2(properties[K], references);
  }
  return Acc;
}
function FromConstructor7(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromFunction6(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromIntersect15(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
}
function FromUnion17(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
}
function FromTuple14(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
}
function FromArray15(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromObject12(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
}
function FromPromise7(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
}
function FromAsyncIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromRef11(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard8 = Discard(target, ["$id"]);
  return Deref2(discard8, references);
}
function DerefResolve(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
}
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value7) => Literal(value7));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties10(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties10(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties11(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties11(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value7) {
  const [first, rest] = [value7.slice(0, 1), value7.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value7) {
  const [first, rest] = [value7.slice(0, 1), value7.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value7) {
  return value7.toUpperCase();
}
function ApplyLowercase(value7) {
  return value7.toLowerCase();
}
function FromTemplateLiteral6(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite3 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite3)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value7) => Literal(value7));
  const mapped12 = FromRest6(literals, mode);
  const union15 = Union(mapped12);
  return TemplateLiteral([union15], options);
}
function FromLiteralValue(value7, mode) {
  return typeof value7 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value7) : mode === "Capitalize" ? ApplyCapitalize(value7) : mode === "Uppercase" ? ApplyUppercase(value7) : mode === "Lowercase" ? ApplyLowercase(value7) : value7 : value7.toString();
}
function FromRest6(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Omit(P[K2], K, options);
  return Acc;
}
function FromMappedResult9(R, K, options) {
  return FromProperties12(R.properties, K, options);
}
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect16(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromUnion18(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromProperty2(T, K) {
  const { [K]: _, ...R } = T;
  return R;
}
function FromProperties13(T, K) {
  return K.reduce((T2, K2) => FromProperty2(T2, K2), T);
}
function OmitResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
}
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
}
function FromPropertyKeys2(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
}
function FromMappedKey3(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
}
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromRest7(T) {
  return T.map((L) => PartialResolve(L));
}
function FromProperties14(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Optional(T[K]);
  return Acc;
}
function PartialResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
}
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties15(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], options);
  return Acc;
}
function FromMappedResult10(R, options) {
  return FromProperties15(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties16(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Pick(P[K2], K, options);
  return Acc;
}
function FromMappedResult11(R, K, options) {
  return FromProperties16(R.properties, K, options);
}
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect17(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromUnion19(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromProperties17(T, K) {
  const Acc = {};
  for (const K2 of K)
    if (K2 in T)
      Acc[K2] = T[K2];
  return Acc;
}
function PickResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
}
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
}
function FromPropertyKeys3(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
}
function FromMappedKey4(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
}
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern3, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern3]: CloneType(T) }
  };
}
function RecordCreateFromKeys(K, T, options) {
  const Acc = {};
  for (const K2 of K)
    Acc[K2] = CloneType(T);
  return Object2(Acc, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
}
function FromLiteralKey(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
}
function FromRegExpKey(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
}
function FromStringKey(K, T, options) {
  const pattern3 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern3, T, options);
}
function FromIntegerKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function FromNumberKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
var Ordinal = 0;
// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromRest8(T) {
  return T.map((L) => RequiredResolve(L));
}
function FromProperties18(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Discard(T[K], [OptionalKind]);
  return Acc;
}
function RequiredResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
}
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? CloneRest(T.allOf) : IsUnion(T) ? CloneRest(T.anyOf) : IsTuple(T) ? CloneRest(T.items ?? []) : [];
}
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/strict/strict.mjs
function Strict(schema2) {
  return JSON.parse(JSON.stringify(schema2));
}
// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
function Transform(schema2) {
  return new TransformDecodeBuilder(schema2);
}

class TransformDecodeBuilder {
  constructor(schema2) {
    this.schema = schema2;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  constructor(schema2, decode2) {
    this.schema = schema2;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema2) {
    const Encode2 = (value11) => schema2[TransformKind].Encode(encode2(value11));
    const Decode2 = (value11) => this.decode(schema2[TransformKind].Decode(value11));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema2) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema2 = CloneType(this.schema);
    return IsTransform(schema2) ? this.EncodeTransform(encode2, schema2) : this.EncodeSchema(encode2, schema2);
  }
}
// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  Strict: () => Strict,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Deref: () => Deref2,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema3, references, checkFunc, code) {
    this.schema = schema3;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema3, references);
  }
  Code() {
    return this.code;
  }
  Errors(value11) {
    return Errors(this.schema, this.references, value11);
  }
  Check(value11) {
    return this.checkFunc(value11);
  }
  Decode(value11) {
    if (!this.checkFunc(value11))
      throw new TransformDecodeCheckError(this.schema, value11, this.Errors(value11).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value11) : value11;
  }
  Encode(value11) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value11) : value11;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value11, this.Errors(value11).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value11) {
    if (value11.length === 0)
      return false;
    return Character.IsNumeric(value11.charCodeAt(0));
  }
  function IsAccessor(value11) {
    if (IsFirstCharacterNumeric(value11))
      return false;
    for (let i = 0;i < value11.length; i++) {
      const code = value11.charCodeAt(i);
      const check11 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check11)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object13, key) {
    return IsAccessor(key) ? `${object13}.${key}` : `${object13}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema3) {
    super("Unknown type");
    this.schema = schema3;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema3) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema3;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value11, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value11} ? ${expression} : true)` : `(${MemberExpression.Encode(value11, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value11) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value11} === 'object' && ${value11} !== null && !Array.isArray(${value11}))` : `(typeof ${value11} === 'object' && ${value11} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value11) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value11} === 'object' && ${value11} !== null && !Array.isArray(${value11}) && !(${value11} instanceof Date) && !(${value11} instanceof Uint8Array))` : `(typeof ${value11} === 'object' && ${value11} !== null && !(${value11} instanceof Date) && !(${value11} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value11) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value11} === 'number'` : `Number.isFinite(${value11})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value11) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value11} === undefined || ${value11} === null)` : `${value11} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema3) {
    return schema3[Kind] === "Any" || schema3[Kind] === "Unknown";
  }
  function* FromAny5(schema3, references, value11) {
    yield "true";
  }
  function* FromArray16(schema3, references, value11) {
    yield `Array.isArray(${value11})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema3.maxItems))
      yield `${value11}.length <= ${schema3.maxItems}`;
    if (IsNumber(schema3.minItems))
      yield `${value11}.length >= ${schema3.minItems}`;
    const elementExpression = CreateExpression(schema3.items, references, "value");
    yield `${value11}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema3.contains) || IsNumber(schema3.minContains) || IsNumber(schema3.maxContains)) {
      const containsSchema = IsSchema2(schema3.contains) ? schema3.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
      const checkMaxContains = IsNumber(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check11 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check11}})(${value11})`;
    }
    if (schema3.uniqueItems === true) {
      const check11 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check11} }`;
      yield `((${parameter}) => { ${block} )(${value11})`;
    }
  }
  function* FromAsyncIterator7(schema3, references, value11) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value11})`;
  }
  function* FromBigInt6(schema3, references, value11) {
    yield `(typeof ${value11} === 'bigint')`;
    if (IsBigInt(schema3.exclusiveMaximum))
      yield `${value11} < BigInt(${schema3.exclusiveMaximum})`;
    if (IsBigInt(schema3.exclusiveMinimum))
      yield `${value11} > BigInt(${schema3.exclusiveMinimum})`;
    if (IsBigInt(schema3.maximum))
      yield `${value11} <= BigInt(${schema3.maximum})`;
    if (IsBigInt(schema3.minimum))
      yield `${value11} >= BigInt(${schema3.minimum})`;
    if (IsBigInt(schema3.multipleOf))
      yield `(${value11} % BigInt(${schema3.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema3, references, value11) {
    yield `(typeof ${value11} === 'boolean')`;
  }
  function* FromConstructor8(schema3, references, value11) {
    yield* Visit17(schema3.returns, references, `${value11}.prototype`);
  }
  function* FromDate6(schema3, references, value11) {
    yield `(${value11} instanceof Date) && Number.isFinite(${value11}.getTime())`;
    if (IsNumber(schema3.exclusiveMaximumTimestamp))
      yield `${value11}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema3.exclusiveMinimumTimestamp))
      yield `${value11}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema3.maximumTimestamp))
      yield `${value11}.getTime() <= ${schema3.maximumTimestamp}`;
    if (IsNumber(schema3.minimumTimestamp))
      yield `${value11}.getTime() >= ${schema3.minimumTimestamp}`;
    if (IsNumber(schema3.multipleOfTimestamp))
      yield `(${value11}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema3, references, value11) {
    yield `(typeof ${value11} === 'function')`;
  }
  function* FromInteger6(schema3, references, value11) {
    yield `Number.isInteger(${value11})`;
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value11} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value11} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value11} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value11} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value11} % ${schema3.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema3, references, value11) {
    const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value11)).join(" && ");
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value11}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema2(schema3.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value11}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value11}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema3, references, value11) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value11})`;
  }
  function* FromLiteral7(schema3, references, value11) {
    if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
      yield `(${value11} === ${schema3.const})`;
    } else {
      yield `(${value11} === '${LiteralString.Escape(schema3.const)}')`;
    }
  }
  function* FromNever6(schema3, references, value11) {
    yield `false`;
  }
  function* FromNot8(schema3, references, value11) {
    const expression = CreateExpression(schema3.not, references, value11);
    yield `(!${expression})`;
  }
  function* FromNull6(schema3, references, value11) {
    yield `(${value11} === null)`;
  }
  function* FromNumber6(schema3, references, value11) {
    yield Policy.IsNumberLike(value11);
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value11} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value11} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value11} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value11} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value11} % ${schema3.multipleOf}) === 0`;
  }
  function* FromObject13(schema3, references, value11) {
    yield Policy.IsObjectLike(value11);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value11}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value11}).length <= ${schema3.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value11, knownKey);
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value11})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value11, knownKey, expression);
      }
    }
    if (schema3.additionalProperties === false) {
      if (schema3.required && schema3.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value11}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value11}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      const expression = CreateExpression(schema3.additionalProperties, references, `${value11}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value11}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema3, references, value11) {
    yield `(typeof value === 'object' && typeof ${value11}.then === 'function')`;
  }
  function* FromRecord12(schema3, references, value11) {
    yield Policy.IsRecordLike(value11);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value11}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value11}).length <= ${schema3.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema2(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value11) : schema3.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value11}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema3, references, value11) {
    const target = Deref(schema3, references);
    if (state.functions.has(schema3.$ref))
      return yield `${CreateFunctionName(schema3.$ref)}(${value11})`;
    yield* Visit17(target, references, value11);
  }
  function* FromRegExp5(schema3, references, value11) {
    const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
    yield `(typeof ${value11} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value11}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value11}.length >= ${schema3.minLength}`;
    yield `${variable}.test(${value11})`;
  }
  function* FromString6(schema3, references, value11) {
    yield `(typeof ${value11} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value11}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value11}.length >= ${schema3.minLength}`;
    if (schema3.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value11})`;
    }
    if (schema3.format !== undefined) {
      yield `format('${schema3.format}', ${value11})`;
    }
  }
  function* FromSymbol6(schema3, references, value11) {
    yield `(typeof ${value11} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema3, references, value11) {
    yield `(typeof ${value11} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
    yield `${variable}.test(${value11})`;
  }
  function* FromThis11(schema3, references, value11) {
    yield `${CreateFunctionName(schema3.$ref)}(${value11})`;
  }
  function* FromTuple15(schema3, references, value11) {
    yield `Array.isArray(${value11})`;
    if (schema3.items === undefined)
      return yield `${value11}.length === 0`;
    yield `(${value11}.length === ${schema3.maxItems})`;
    for (let i = 0;i < schema3.items.length; i++) {
      const expression = CreateExpression(schema3.items[i], references, `${value11}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema3, references, value11) {
    yield `${value11} === undefined`;
  }
  function* FromUnion20(schema3, references, value11) {
    const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value11));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema3, references, value11) {
    yield `${value11} instanceof Uint8Array`;
    if (IsNumber(schema3.maxByteLength))
      yield `(${value11}.length <= ${schema3.maxByteLength})`;
    if (IsNumber(schema3.minByteLength))
      yield `(${value11}.length >= ${schema3.minByteLength})`;
  }
  function* FromUnknown5(schema3, references, value11) {
    yield "true";
  }
  function* FromVoid5(schema3, references, value11) {
    yield Policy.IsVoidLike(value11);
  }
  function* FromKind4(schema3, references, value11) {
    const instance = state.instances.size;
    state.instances.set(instance, schema3);
    yield `kind('${schema3[Kind]}', ${instance}, ${value11})`;
  }
  function* Visit17(schema3, references, value11, useHoisting = true) {
    const references_ = IsString(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (useHoisting && IsString(schema3.$id)) {
      const functionName = CreateFunctionName(schema3.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value11})`;
      } else {
        const functionCode = CreateFunction(functionName, schema3, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value11})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value11);
      case "Array":
        return yield* FromArray16(schema_, references_, value11);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value11);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value11);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value11);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value11);
      case "Date":
        return yield* FromDate6(schema_, references_, value11);
      case "Function":
        return yield* FromFunction7(schema_, references_, value11);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value11);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value11);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value11);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value11);
      case "Never":
        return yield* FromNever6(schema_, references_, value11);
      case "Not":
        return yield* FromNot8(schema_, references_, value11);
      case "Null":
        return yield* FromNull6(schema_, references_, value11);
      case "Number":
        return yield* FromNumber6(schema_, references_, value11);
      case "Object":
        return yield* FromObject13(schema_, references_, value11);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value11);
      case "Record":
        return yield* FromRecord12(schema_, references_, value11);
      case "Ref":
        return yield* FromRef12(schema_, references_, value11);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value11);
      case "String":
        return yield* FromString6(schema_, references_, value11);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value11);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value11);
      case "This":
        return yield* FromThis11(schema_, references_, value11);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value11);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value11);
      case "Union":
        return yield* FromUnion20(schema_, references_, value11);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value11);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value11);
      case "Void":
        return yield* FromVoid5(schema_, references_, value11);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema3);
        return yield* FromKind4(schema_, references_, value11);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema3, references, value11, useHoisting = true) {
    return `(${[...Visit17(schema3, references, value11, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema3, references, value11, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema3, references, value11, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type47) {
    const annotation = state.language === "typescript" ? `: ${type47}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type47) {
    return state.language === "typescript" ? `: ${type47}` : "";
  }
  function Build(schema3, references, options) {
    const functionCode = CreateFunction("check", schema3, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema3.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema3.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema3, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema3))
      throw new TypeCompilerTypeGuardError(schema3);
    for (const schema4 of references)
      if (!IsSchema2(schema4))
        throw new TypeCompilerTypeGuardError(schema4);
    return Build(schema3, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema3, references = []) {
    const generatedCode = Code(schema3, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind28, instance, value11) {
      if (!exports_type.Has(kind28) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind28);
      const schema4 = instances.get(instance);
      return checkFunc(schema4, value11);
    }
    function formatRegistryFunction(format, value11) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value11);
    }
    function hashFunction(value11) {
      return Hash(value11);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema3, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/elysia/dist/bun/index.js
function k2($) {
  return $ % 4 === 0 && ($ % 100 !== 0 || $ % 400 === 0);
}
function c1($) {
  const W = v2.exec($);
  if (!W)
    return false;
  const X = +W[1], Z = +W[2], J = +W[3];
  return Z >= 1 && Z <= 12 && J >= 1 && J <= (Z === 2 && k2(X) ? 29 : u2[Z]);
}
function F1($) {
  return function W(X) {
    const Z = h2.exec(X);
    if (!Z)
      return false;
    const J = +Z[1], j = +Z[2], Q = +Z[3], Y = Z[4], K = Z[5] === "-" ? -1 : 1, B = +(Z[6] || 0), U = +(Z[7] || 0);
    if (B > 23 || U > 59 || $ && !Y)
      return false;
    if (J <= 23 && j <= 59 && Q < 60)
      return true;
    const w = j - U * K, F = J - B * K - (w < 0 ? 1 : 0);
    return (F === 23 || F === -1) && (w === 59 || w === -1) && Q < 61;
  };
}
function h1($) {
  const W = F1($);
  return function X(Z) {
    const J = Z.split(m2);
    return J.length === 2 && c1(J[0]) && W(J[1]);
  };
}
function l2($) {
  return d2.test($) && c2.test($);
}
function p2($) {
  return m1.lastIndex = 0, m1.test($);
}
function t2($) {
  return Number.isInteger($) && $ <= n2 && $ >= i2;
}
function s2($) {
  return Number.isInteger($);
}
function d1() {
  return true;
}
function a2($) {
  if (r2.test($))
    return false;
  try {
    return new RegExp($), true;
  } catch (W) {
    return false;
  }
}
function Z3($, W) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var X = {}, Z = W || {}, J = Z.decode || j3, j = 0;
  while (j < $.length) {
    var Q = $.indexOf("=", j);
    if (Q === -1)
      break;
    var Y = $.indexOf(";", j);
    if (Y === -1)
      Y = $.length;
    else if (Y < Q) {
      j = $.lastIndexOf(";", Q - 1) + 1;
      continue;
    }
    var K = $.slice(j, Q).trim();
    if (X[K] === undefined) {
      var B = $.slice(Q + 1, Y).trim();
      if (B.charCodeAt(0) === 34)
        B = B.slice(1, -1);
      X[K] = Y3(B, J);
    }
    j = Y + 1;
  }
  return X;
}
function J3($, W, X) {
  var Z = X || {}, J = Z.encode || Q3;
  if (typeof J !== "function")
    throw new TypeError("option encode is invalid");
  if (!o0.test($))
    throw new TypeError("argument name is invalid");
  var j = J(W);
  if (j && !o0.test(j))
    throw new TypeError("argument val is invalid");
  var Q = $ + "=" + j;
  if (Z.maxAge != null) {
    var Y = Z.maxAge - 0;
    if (isNaN(Y) || !isFinite(Y))
      throw new TypeError("option maxAge is invalid");
    Q += "; Max-Age=" + Math.floor(Y);
  }
  if (Z.domain) {
    if (!o0.test(Z.domain))
      throw new TypeError("option domain is invalid");
    Q += "; Domain=" + Z.domain;
  }
  if (Z.path) {
    if (!o0.test(Z.path))
      throw new TypeError("option path is invalid");
    Q += "; Path=" + Z.path;
  }
  if (Z.expires) {
    var K = Z.expires;
    if (!G3(K) || isNaN(K.valueOf()))
      throw new TypeError("option expires is invalid");
    Q += "; Expires=" + K.toUTCString();
  }
  if (Z.httpOnly)
    Q += "; HttpOnly";
  if (Z.secure)
    Q += "; Secure";
  if (Z.partitioned)
    Q += "; Partitioned";
  if (Z.priority) {
    var B = typeof Z.priority === "string" ? Z.priority.toLowerCase() : Z.priority;
    switch (B) {
      case "low":
        Q += "; Priority=Low";
        break;
      case "medium":
        Q += "; Priority=Medium";
        break;
      case "high":
        Q += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (Z.sameSite) {
    var U = typeof Z.sameSite === "string" ? Z.sameSite.toLowerCase() : Z.sameSite;
    switch (U) {
      case true:
        Q += "; SameSite=Strict";
        break;
      case "lax":
        Q += "; SameSite=Lax";
        break;
      case "strict":
        Q += "; SameSite=Strict";
        break;
      case "none":
        Q += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return Q;
}
function j3($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
}
function Q3($) {
  return encodeURIComponent($);
}
function G3($) {
  return X3.call($) === "[object Date]" || $ instanceof Date;
}
function Y3($, W) {
  try {
    return W($);
  } catch (X) {
    return $;
  }
}
async function* m0($) {
  const W = $.body;
  if (!W)
    return;
  const X = W.getReader(), Z = new TextDecoder;
  try {
    while (true) {
      const { done: J, value: j } = await X.read();
      if (J)
        break;
      yield Z.decode(j);
    }
  } finally {
    X.releaseLock();
  }
}
function N3($) {
  let W = $;
  while (W.endsWith("="))
    W = W.slice(0, -1);
  return W;
}
function B1($) {
  const W = {};
  if (typeof $ !== "string")
    return W;
  let X = "", Z = "", J = -1, j = -1, Q = 0;
  const Y = $.length;
  for (let K = 0;K < Y; K++)
    switch ($.charCodeAt(K)) {
      case 38:
        const B = j > J;
        if (!B)
          j = K;
        if (X = $.slice(J + 1, j), B || X.length > 0) {
          if (Q & 1)
            X = X.replace(y0, " ");
          if (Q & 2)
            X = V0.default(X) || X;
          if (!W[X]) {
            if (B) {
              if (Z = $.slice(j + 1, K), Q & 4)
                Z = Z.replace(y0, " ");
              if (Q & 8)
                Z = V0.default(Z) || Z;
            }
            W[X] = Z;
          }
        }
        X = "", Z = "", J = K, j = K, Q = 0;
        break;
      case 61:
        if (j <= J)
          j = K;
        else
          Q |= 8;
        break;
      case 43:
        if (j > J)
          Q |= 4;
        else
          Q |= 1;
        break;
      case 37:
        if (j > J)
          Q |= 8;
        else
          Q |= 2;
        break;
    }
  if (J < Y) {
    const K = j > J;
    if (X = $.slice(J + 1, K ? j : Y), K || X.length > 0) {
      if (Q & 1)
        X = X.replace(y0, " ");
      if (Q & 2)
        X = V0.default(X) || X;
      if (!W[X]) {
        if (K) {
          if (Z = $.slice(j + 1, Y), Q & 4)
            Z = Z.replace(y0, " ");
          if (Q & 8)
            Z = V0.default(Z) || Z;
        }
        W[X] = Z;
      }
    }
  }
  return W;
}
var C2 = Object.create;
var { getPrototypeOf: S2, defineProperty: g1, getOwnPropertyNames: L2 } = Object;
var T2 = Object.prototype.hasOwnProperty;
var w1 = ($, W, X) => {
  X = $ != null ? C2(S2($)) : {};
  const Z = W || !$ || !$.__esModule ? g1(X, "default", { value: $, enumerable: true }) : X;
  for (let J of L2($))
    if (!T2.call(Z, J))
      g1(Z, J, { get: () => $[J], enumerable: true });
  return Z;
};
var q2 = ($, W) => () => (W || $((W = { exports: {} }).exports, W), W.exports);
var e0 = q2((Z8, o1) => {
  function K3($) {
    var W = $.indexOf("%");
    if (W === -1)
      return $;
    var X = $.length, Z = "", J = 0, j = 0, Q = W, Y = r1;
    while (W > -1 && W < X) {
      var K = a1($[W + 1], 4), B = a1($[W + 2], 0), U = K | B, w = N1[U];
      if (Y = N1[256 + Y + w], j = j << 6 | U & N1[364 + w], Y === r1)
        Z += $.slice(J, Q), Z += j <= 65535 ? String.fromCharCode(j) : String.fromCharCode(55232 + (j >> 10), 56320 + (j & 1023)), j = 0, J = W + 3, W = Q = $.indexOf("%", J);
      else if (Y === B3)
        return null;
      else {
        if (W += 3, W < X && $.charCodeAt(W) === 37)
          continue;
        return null;
      }
    }
    return Z + $.slice(J);
  }
  function a1($, W) {
    var X = U3[$];
    return X === undefined ? 255 : X << W;
  }
  var r1 = 12, B3 = 0, N1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], U3 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  o1.exports = K3;
});
var q0 = ($, W) => {
  const X = W?.length ? {} : null;
  if (X)
    for (let Z of W)
      X[Z.part.charCodeAt(0)] = Z;
  return { part: $, store: null, inert: X, params: null, wildcardStore: null };
};
var f1 = ($, W) => ({ ...$, part: W });
var y1 = ($) => ({ name: $, store: null, inert: null });

class M0 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /:.+?\?(?=\/|$)/g };
  add($, W, X, { ignoreError: Z = false, ignoreHistory: J = false } = {}) {
    if (typeof W !== "string")
      throw new TypeError("Route path must be a string");
    if (W === "")
      W = "/";
    else if (W[0] !== "/")
      W = `/${W}`;
    const j = W[W.length - 1] === "*", Q = W.match(M0.regex.optionalParams);
    if (Q) {
      const w = W.replaceAll("?", "");
      this.add($, w, X, { ignoreError: Z });
      for (let F = 0;F < Q.length; F++) {
        let G = W.replace("/" + Q[F], "");
        this.add($, G, X, { ignoreError: true });
      }
      return X;
    }
    if (Q)
      W = W.replaceAll("?", "");
    if (this.history.find(([w, F, G]) => w === $ && F === W))
      return X;
    if (j || Q && W.charCodeAt(W.length - 1) === 63)
      W = W.slice(0, -1);
    if (!J)
      this.history.push([$, W, X]);
    const Y = W.split(M0.regex.static), K = W.match(M0.regex.params) || [];
    if (Y[Y.length - 1] === "")
      Y.pop();
    let B;
    if (!this.root[$])
      B = this.root[$] = q0("/");
    else
      B = this.root[$];
    let U = 0;
    for (let w = 0;w < Y.length; ++w) {
      let F = Y[w];
      if (w > 0) {
        const G = K[U++].slice(1);
        if (B.params === null)
          B.params = y1(G);
        else if (B.params.name !== G)
          if (Z)
            return X;
          else
            throw new Error(`Cannot create route "${W}" with parameter "${G}" because a route already exists with a different parameter name ("${B.params.name}") in the same location`);
        const z = B.params;
        if (z.inert === null) {
          B = z.inert = q0(F);
          continue;
        }
        B = z.inert;
      }
      for (let G = 0;; ) {
        if (G === F.length) {
          if (G < B.part.length) {
            const z = f1(B, B.part.slice(G));
            Object.assign(B, q0(F, [z]));
          }
          break;
        }
        if (G === B.part.length) {
          if (B.inert === null)
            B.inert = {};
          const z = B.inert[F.charCodeAt(G)];
          if (z) {
            B = z, F = F.slice(G), G = 0;
            continue;
          }
          const D = q0(F.slice(G));
          B.inert[F.charCodeAt(G)] = D, B = D;
          break;
        }
        if (F[G] !== B.part[G]) {
          const z = f1(B, B.part.slice(G)), D = q0(F.slice(G));
          Object.assign(B, q0(B.part.slice(0, G), [z, D])), B = D;
          break;
        }
        ++G;
      }
    }
    if (U < K.length) {
      const w = K[U].slice(1);
      if (B.params === null)
        B.params = y1(w);
      else if (B.params.name !== w)
        if (Z)
          return X;
        else
          throw new Error(`Cannot create route "${W}" with parameter "${w}" because a route already exists with a different parameter name ("${B.params.name}") in the same location`);
      if (B.params.store === null)
        B.params.store = X;
      return B.params.store;
    }
    if (j) {
      if (B.wildcardStore === null)
        B.wildcardStore = X;
      return B.wildcardStore;
    }
    if (B.store === null)
      B.store = X;
    return B.store;
  }
  find($, W) {
    const X = this.root[$];
    if (!X)
      return null;
    return _1(W, W.length, X, 0);
  }
}
var _1 = ($, W, X, Z) => {
  const J = X.part, j = J.length, Q = Z + j;
  if (j > 1) {
    if (Q > W)
      return null;
    if (j < 15) {
      for (let Y = 1, K = Z + 1;Y < j; ++Y, ++K)
        if (J.charCodeAt(Y) !== $.charCodeAt(K))
          return null;
    } else if ($.slice(Z, Q) !== J)
      return null;
  }
  if (Q === W) {
    if (X.store !== null)
      return { store: X.store, params: {} };
    if (X.wildcardStore !== null)
      return { store: X.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (X.inert !== null) {
    const Y = X.inert[$.charCodeAt(Q)];
    if (Y !== undefined) {
      const K = _1($, W, Y, Q);
      if (K !== null)
        return K;
    }
  }
  if (X.params !== null) {
    const { store: Y, name: K, inert: B } = X.params, U = $.indexOf("/", Q);
    if (U !== Q) {
      if (U === -1 || U >= W) {
        if (Y !== null) {
          const w = {};
          return w[K] = $.substring(Q, W), { store: Y, params: w };
        }
      } else if (B !== null) {
        const w = _1($, W, B, U);
        if (w !== null)
          return w.params[K] = $.substring(Q, U), w;
      }
    }
  }
  if (X.wildcardStore !== null)
    return { store: X.wildcardStore, params: { "*": $.substring(Q, W) } };
  return null;
};
var E0 = ($) => {
  const W = typeof $ === "object" ? $.fn.toString() : typeof $ === "string" ? $.toString() : $, X = W.indexOf(")");
  if (W.charCodeAt(X + 2) === 61 && W.charCodeAt(X + 5) !== 123)
    return true;
  return W.includes("return");
};
var E2 = ($) => {
  if ($.startsWith("async"))
    $ = $.slice(5);
  $ = $.trimStart();
  let W = -1;
  if ($.charCodeAt(0) === 40) {
    if (W = $.indexOf("=>", $.indexOf(")")), W !== -1) {
      let J = W;
      while (J > 0)
        if ($.charCodeAt(--J) === 41)
          break;
      let j = $.slice(W + 2);
      if (j.charCodeAt(0) === 32)
        j = j.trimStart();
      return [$.slice(1, J), j, { isArrowReturn: j.charCodeAt(0) !== 123 }];
    }
  }
  if ($.startsWith("function")) {
    W = $.indexOf("(");
    const J = $.indexOf(")");
    return [$.slice(W + 1, J), $.slice(J + 2), { isArrowReturn: false }];
  }
  const X = $.indexOf("(");
  if (X !== -1) {
    const J = $.indexOf("\n", 2), j = $.slice(0, J), Q = j.lastIndexOf(")") + 1, Y = $.slice(J + 1);
    return [j.slice(X, Q), "{" + Y, { isArrowReturn: false }];
  }
  const Z = $.split("\n", 2);
  return [Z[0], Z[1], { isArrowReturn: false }];
};
var H2 = ($) => {
  const W = $.indexOf("{");
  if (W === -1)
    return [-1, 0];
  let X = W + 1, Z = 1;
  for (;X < $.length; X++) {
    const J = $.charCodeAt(X);
    if (J === 123)
      Z++;
    else if (J === 125)
      Z--;
    if (Z === 0)
      break;
  }
  if (Z !== 0)
    return [0, $.length];
  return [W, X + 1];
};
var R2 = ($) => {
  const W = $.lastIndexOf("}");
  if (W === -1)
    return [-1, 0];
  let X = W - 1, Z = 1;
  for (;X >= 0; X--) {
    const J = $.charCodeAt(X);
    if (J === 125)
      Z++;
    else if (J === 123)
      Z--;
    if (Z === 0)
      break;
  }
  if (Z !== 0)
    return [-1, 0];
  return [X, W + 1];
};
var k1 = ($) => {
  while (true) {
    const W = $.indexOf(":");
    if (W === -1)
      break;
    let X = $.indexOf(",", W);
    if (X === -1)
      X = $.indexOf("}", W) - 1;
    if (X === -2)
      X = $.length;
    $ = $.slice(0, W) + $.slice(X);
  }
  return $;
};
var v1 = ($) => {
  let W = false;
  if ($.charCodeAt(0) === 40)
    $ = $.slice(1, -1);
  if ($.charCodeAt(0) === 123)
    W = true, $ = $.slice(1, -1);
  $ = $.replace(/( |\t|\n)/g, "").trim();
  let X = [];
  while (true) {
    let [J, j] = H2($);
    if (J === -1)
      break;
    if (X.push($.slice(0, J - 1)), $.charCodeAt(j) === 44)
      j++;
    $ = $.slice(j);
  }
  if ($ = k1($), $)
    X = X.concat($.split(","));
  const Z = [];
  for (let J of X) {
    if (J.indexOf(",") === -1) {
      Z.push(J);
      continue;
    }
    for (let j of J.split(","))
      Z.push(j.trim());
  }
  return X = Z, { hasParenthesis: W, parameters: X };
};
var b2 = ($, W) => {
  const { parameters: X, hasParenthesis: Z } = v1($);
  if (!W.query && X.includes("query"))
    W.query = true;
  if (!W.headers && X.includes("headers"))
    W.headers = true;
  if (!W.body && X.includes("body"))
    W.body = true;
  if (!W.cookie && X.includes("cookie"))
    W.cookie = true;
  if (!W.set && X.includes("set"))
    W.set = true;
  if (!W.server && X.includes("server"))
    W.server = true;
  if (Z)
    return `{ ${X.join(", ")} }`;
  return X.join(", ");
};
var x2 = ($, W, X) => {
  const Z = W.indexOf($ + "\n", X), J = W.indexOf($ + "\t", X), j = W.indexOf($ + ",", X), Q = W.indexOf($ + ";", X), Y = W.indexOf($ + " ", X);
  return [Z, J, j, Q, Y].filter((K) => K > 0).sort((K, B) => K - B)[0] || -1;
};
var u1 = ($, W, X = 0) => {
  if (X > 5)
    return [];
  const Z = [];
  let J = W;
  while (true) {
    let j = x2(" = " + $, J);
    if (j === -1) {
      const K = J.indexOf(" = " + $);
      if (K + 3 + $.length !== J.length)
        break;
      j = K;
    }
    const Q = J.slice(0, j);
    let Y = Q.slice(Q.lastIndexOf(" ") + 1);
    if (Y === "}") {
      const [K, B] = R2(Q);
      Z.push(k1(J.slice(K, B))), J = J.slice(j + 3 + $.length);
      continue;
    }
    while (Y.charCodeAt(0) === 44)
      Y = Y.slice(1);
    while (Y.charCodeAt(0) === 9)
      Y = Y.slice(1);
    if (!Y.includes("("))
      Z.push(Y);
    J = J.slice(j + 3 + $.length);
  }
  for (let j of Z) {
    if (j.charCodeAt(0) === 123)
      continue;
    const Q = u1(j, W);
    if (Q.length > 0)
      Z.push(...Q);
  }
  return Z;
};
var g2 = ($) => {
  if (!$)
    return;
  if ($.charCodeAt(0) !== 123)
    return $;
  if ($ = $.slice(2, -2), !$.includes(",")) {
    if ($.includes("..."))
      return $.slice($.indexOf("...") + 3);
    return;
  }
  const X = $.indexOf("...");
  if (X === -1)
    return;
  return $.slice(X + 3).trimEnd();
};
var f2 = ($, W, X) => {
  const Z = (J, j) => $.includes(j + "." + J) || $.includes(j + '["' + J + '"]') || $.includes(j + "['" + J + "']");
  for (let J of W) {
    if (!J)
      continue;
    if (J.charCodeAt(0) === 123) {
      const j = v1(J).parameters;
      if (!X.query && j.includes("query"))
        X.query = true;
      if (!X.headers && j.includes("headers"))
        X.headers = true;
      if (!X.body && j.includes("body"))
        X.body = true;
      if (!X.cookie && j.includes("cookie"))
        X.cookie = true;
      if (!X.set && j.includes("set"))
        X.set = true;
      if (!X.query && j.includes("server"))
        X.server = true;
      continue;
    }
    if (!X.query && Z("query", J))
      X.query = true;
    if ($.includes("return " + J) || $.includes("return " + J + ".query"))
      X.query = true;
    if (!X.headers && Z("headers", J))
      X.headers = true;
    if (!X.body && Z("body", J))
      X.body = true;
    if (!X.cookie && Z("cookie", J))
      X.cookie = true;
    if (!X.set && Z("set", J))
      X.set = true;
    if (!X.server && Z("server", J))
      X.server = true;
    if (X.query && X.headers && X.body && X.cookie && X.set && X.server)
      break;
  }
  return W;
};
var y2 = ($, W, X) => {
  try {
    const Z = new RegExp(`(?:\\w)\\((?:.*)?${$}`, "gs");
    Z.test(W);
    const J = W.charCodeAt(Z.lastIndex);
    if (J === 41 || J === 44)
      return X.query = true, X.headers = true, X.body = true, X.cookie = true, X.set = true, X.server = true, true;
    return false;
  } catch (Z) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(W), console.log("--- context ---"), console.log($), true;
  }
};
var r0 = ($, W = { query: false, headers: false, body: false, cookie: false, set: false, server: false }) => {
  const X = [];
  if ($.handler && typeof $.handler === "function")
    X.push($.handler);
  if ($.request?.length)
    X.push(...$.request);
  if ($.beforeHandle?.length)
    X.push(...$.beforeHandle);
  if ($.parse?.length)
    X.push(...$.parse);
  if ($.error?.length)
    X.push(...$.error);
  if ($.transform?.length)
    X.push(...$.transform);
  if ($.afterHandle?.length)
    X.push(...$.afterHandle);
  if ($.mapResponse?.length)
    X.push(...$.mapResponse);
  if ($.afterResponse?.length)
    X.push(...$.afterResponse);
  for (let Z of X) {
    if (!Z)
      continue;
    const J = "fn" in Z ? Z.fn : Z, [j, Q, { isArrowReturn: Y }] = E2(J.toString()), K = b2(j, W), B = g2(K);
    if (B) {
      const U = u1(B, Q);
      if (U.splice(0, -1, B), !y2(B, Q, W))
        f2(Q, U, W);
      if (!W.query && Q.includes("return " + B + ".query"))
        W.query = true;
    }
    if (W.query && W.headers && W.body && W.cookie && W.set && W.server)
      break;
  }
  return W;
};
var a0 = { date: c1, time: F1(true), "date-time": h1(true), "iso-time": F1(false), "iso-date-time": h1(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri: l2, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex: a2, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte: p2, int32: { type: "number", validate: t2 }, int64: { type: "number", validate: s2 }, float: { type: "number", validate: d1 }, double: { type: "number", validate: d1 }, password: true, binary: true };
var v2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var u2 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var h2 = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
var m2 = /t|\s/i;
var d2 = /\/|:/;
var c2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var m1 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
var i2 = -2147483648;
var n2 = 2147483647;
var r2 = /[^\\]\\Z/;
var n1 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var t1 = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var s1 = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var o2 = a0.date;
var e2 = a0["date-time"];
if (!exports_format.Has("date"))
  TypeSystem.Format("date", ($) => {
    const W = $.replace(/"/g, "");
    if (n1.test(W) || t1.test(W) || s1.test(W) || o2(W)) {
      const X = new Date(W);
      if (!Number.isNaN(X.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  TypeSystem.Format("date-time", ($) => {
    const W = $.replace(/"/g, "");
    if (n1.test(W) || t1.test(W) || s1.test(W) || e2(W)) {
      const X = new Date(W);
      if (!Number.isNaN(X.getTime()))
        return true;
    }
    return false;
  });
Object.entries(a0).forEach(($) => {
  const [W, X] = $;
  if (!exports_format.Has(W)) {
    if (X instanceof RegExp)
      TypeSystem.Format(W, (Z) => X.test(Z));
    else if (typeof X === "function")
      TypeSystem.Format(W, X);
  }
});
var C = Object.assign({}, Type);
var p1 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var M1 = ($, W) => {
  if (!(W instanceof Blob))
    return false;
  if ($.minSize && W.size < p1($.minSize))
    return false;
  if ($.maxSize && W.size > p1($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!W.type.startsWith($.extension))
        return false;
    } else {
      for (let X = 0;X < $.extension.length; X++)
        if (W.type.startsWith($.extension[X]))
          return true;
      return false;
    }
  return true;
};
var $3 = exports_type.Get("Files") ?? TypeSystem.Type("File", M1);
var W3 = exports_type.Get("Files") ?? TypeSystem.Type("Files", ($, W) => {
  if (!Array.isArray(W))
    return M1($, W);
  if ($.minItems && W.length < $.minItems)
    return false;
  if ($.maxItems && W.length > $.maxItems)
    return false;
  for (let X = 0;X < W.length; X++)
    if (!M1($, W[X]))
      return false;
  return true;
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", ($) => !!$ && !isNaN(+$));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", ($) => $ === "true" || $ === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", ($) => {
    let W = $.charCodeAt(0);
    if (W === 9 || W === 10 || W === 32)
      W = $.trimStart().charCodeAt(0);
    if (W !== 123 && W !== 91)
      return false;
    try {
      return JSON.parse($), true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", ($) => {
    let W = $.charCodeAt(0);
    if (W === 9 || W === 10 || W === 32)
      W = $.trimStart().charCodeAt(0);
    if (W !== 123 && W !== 91)
      return false;
    try {
      return JSON.parse($), true;
    } catch {
      return false;
    }
  });
var Y0 = { Numeric: ($) => {
  const W = Type.Number($);
  return C.Transform(C.Union([C.String({ format: "numeric", default: 0 }), C.Number($)], $)).Decode((X) => {
    const Z = +X;
    if (isNaN(Z))
      return X;
    if ($ && !exports_value2.Check(W, Z))
      throw new T("property", W, Z);
    return Z;
  }).Encode((X) => X);
}, Date: ($) => {
  const W = Type.Date($);
  return C.Transform(C.Union([Type.Date($), C.String({ format: "date", default: new Date().toISOString() }), C.String({ format: "date-time", default: new Date().toISOString() })], $)).Decode((X) => {
    if (X instanceof Date)
      return X;
    const Z = new Date(X);
    if (!exports_value2.Check(W, Z))
      throw new T("property", W, Z);
    return Z;
  }).Encode((X) => {
    if (typeof X === "string")
      return new Date(X);
    return X;
  });
}, BooleanString: ($) => {
  const W = Type.Boolean($);
  return C.Transform(C.Union([C.String({ format: "boolean", default: false }), C.Boolean($)], $)).Decode((X) => {
    if (typeof X === "string")
      return X === "true";
    if ($ && !exports_value2.Check(W, X))
      throw new T("property", W, X);
    return X;
  }).Encode((X) => X);
}, ObjectString: ($, W) => {
  const X = C.Object($, W), Z = JSON.stringify(exports_value2.Create(X));
  let J;
  try {
    J = TypeCompiler.Compile(X);
  } catch {
  }
  return C.Transform(C.Union([C.String({ format: "ObjectString", default: Z }), X])).Decode((j) => {
    if (typeof j === "string") {
      if (j.charCodeAt(0) !== 123)
        throw new T("property", X, j);
      try {
        j = JSON.parse(j);
      } catch {
        throw new T("property", X, j);
      }
      if (J) {
        if (!J.Check(j))
          throw new T("property", X, j);
        return J.Decode(j);
      }
      if (!exports_value2.Check(X, j))
        throw new T("property", X, j);
      return exports_value2.Decode(X, j);
    }
    return j;
  }).Encode((j) => {
    if (typeof j === "string")
      try {
        j = JSON.parse(j);
      } catch {
        throw new T("property", X, j);
      }
    if (!exports_value2.Check(X, j))
      throw new T("property", X, j);
    return JSON.stringify(j);
  });
}, ArrayString: ($ = {}, W) => {
  const X = C.Array($, W), Z = JSON.stringify(exports_value2.Create(X));
  let J;
  try {
    J = TypeCompiler.Compile(X);
  } catch {
  }
  return C.Transform(C.Union([C.String({ format: "ArrayString", default: Z }), X])).Decode((j) => {
    if (typeof j === "string") {
      if (j.charCodeAt(0) !== 91)
        throw new T("property", X, j);
      try {
        j = JSON.parse(j);
      } catch {
        throw new T("property", X, j);
      }
      if (J) {
        if (!J.Check(j))
          throw new T("property", X, j);
        return J.Decode(j);
      }
      if (!exports_value2.Check(X, j))
        throw new T("property", X, j);
      return exports_value2.Decode(X, j);
    }
    return j;
  }).Encode((j) => {
    if (typeof j === "string")
      try {
        j = JSON.parse(j);
      } catch {
        throw new T("property", X, j);
      }
    if (!exports_value2.Check(X, j))
      throw new T("property", X, j);
    return JSON.stringify(j);
  });
}, File: $3, Files: ($ = {}) => C.Transform(W3($)).Decode((W) => {
  if (Array.isArray(W))
    return W;
  return [W];
}).Encode((W) => W), Nullable: ($) => C.Union([$, C.Null()]), MaybeEmpty: ($) => C.Union([$, C.Null(), C.Undefined()]), Cookie: ($, { domain: W, expires: X, httpOnly: Z, maxAge: J, path: j, priority: Q, sameSite: Y, secure: K, secrets: B, sign: U, ...w } = {}) => {
  const F = C.Object($, w);
  return F.config = { domain: W, expires: X, httpOnly: Z, maxAge: J, path: j, priority: Q, sameSite: Y, secure: K, secrets: B, sign: U }, F;
} };
C.BooleanString = Y0.BooleanString;
C.ObjectString = Y0.ObjectString;
C.ArrayString = Y0.ArrayString;
C.Numeric = Y0.Numeric;
C.File = ($ = {}) => Y0.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
C.Files = ($ = {}) => Y0.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
C.Nullable = ($) => Y0.Nullable($);
C.MaybeEmpty = Y0.MaybeEmpty;
C.Cookie = Y0.Cookie;
C.Date = Y0.Date;
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var z1 = Z3;
var D1 = J3;
var X3 = Object.prototype.toString;
var o0 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var $2 = w1(e0(), 1);

class w0 {
  $;
  W;
  X;
  constructor($, W, X = {}) {
    this.name = $;
    this.jar = W;
    this.initial = X;
  }
  get cookie() {
    if (!(this.name in this.jar))
      return this.initial;
    return this.jar[this.name];
  }
  set cookie($) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = $;
  }
  get value() {
    return this.cookie.value;
  }
  set value($) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name].value = $;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires($) {
    this.cookie.expires = $;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge($) {
    this.cookie.maxAge = $;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain($) {
    this.cookie.domain = $;
  }
  get path() {
    return this.cookie.path;
  }
  set path($) {
    this.cookie.path = $;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure($) {
    this.cookie.secure = $;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly($) {
    this.cookie.httpOnly = $;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite($) {
    this.cookie.sameSite = $;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority($) {
    this.cookie.priority = $;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned($) {
    this.cookie.partitioned = $;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets($) {
    this.cookie.secrets = $;
  }
  update($) {
    return this.cookie = Object.assign(this.cookie, typeof $ === "function" ? $(this.cookie) : $), this;
  }
  set($) {
    return this.cookie = Object.assign({ ...this.initial, value: this.value }, typeof $ === "function" ? $(this.cookie) : $), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var e1 = ($, W, X) => {
  if (!$.cookie)
    $.cookie = {};
  return new Proxy(W, { get(Z, J) {
    if (J in W)
      return new w0(J, $.cookie, Object.assign({}, X ?? {}, W[J]));
    return new w0(J, $.cookie, Object.assign({}, X));
  } });
};
var $1 = async ($, W, { secrets: X, sign: Z, ...J } = {}) => {
  if (!W)
    return e1($, {}, J);
  const j = typeof X === "string";
  if (Z && Z !== true && !Array.isArray(Z))
    Z = [Z];
  const Q = {}, Y = z1(W);
  for (let [K, B] of Object.entries(Y)) {
    let U = $2.default(B);
    if (Z === true || Z?.includes(K)) {
      if (!X)
        throw new Error("No secret is provided to cookie plugin");
      if (j) {
        const w = await P1(U, X);
        if (w === false)
          throw new u0(K);
        U = w;
      } else {
        let w = true;
        for (let F = 0;F < X.length; F++) {
          const G = await P1(U, X[F]);
          if (G !== false) {
            w = true, U = G;
            break;
          }
        }
        if (!w)
          throw new u0(K);
      }
    }
    Q[K] = { value: U };
  }
  return e1($, Q, J);
};
var W2 = "toJSON" in new Headers;
var n = ($) => {
  if (!$)
    return false;
  for (let W in $)
    return true;
  return false;
};
var h0 = ($, W) => {
  const X = $.size;
  if (!W && X || X && W && W.status !== 206 && W.status !== 304 && W.status !== 412 && W.status !== 416) {
    if (W) {
      if (W.headers instanceof Headers) {
        if (W2)
          W.headers = W.headers.toJSON();
        else
          for (let [Z, J] of W.headers.entries())
            if (Z in W.headers)
              W.headers[Z] = J;
      }
      return new Response($, { status: W.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` }, W.headers) });
    }
    return new Response($, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` } });
  }
  return new Response($);
};
var X2 = ($, W) => {
  if (!$)
    return $;
  $.delete("set-cookie");
  for (let X = 0;X < W.length; X++) {
    const Z = W[X].indexOf("=");
    $.append("set-cookie", `${W[X].slice(0, Z)}=${W[X].slice(Z + 1) || ""}`);
  }
  return $;
};
var Z2 = ($) => {
  if (!$ || !n($))
    return;
  const W = [];
  for (let [X, Z] of Object.entries($)) {
    if (!X || !Z)
      continue;
    const J = Z.value;
    if (J === undefined || J === null)
      continue;
    W.push(D1(X, typeof J === "object" ? JSON.stringify(J) : J + "", Z));
  }
  if (W.length === 0)
    return;
  if (W.length === 1)
    return W[0];
  return W;
};
var B0 = async ($, W, X) => {
  let Z = $.next();
  if (Z instanceof Promise)
    Z = await Z;
  if (Z.done) {
    if (W)
      return f(Z.value, W, X);
    return X0(Z.value, X);
  }
  return new Response(new ReadableStream({ async start(J) {
    let j = false;
    if (X?.signal.addEventListener("abort", () => {
      j = true;
      try {
        J.close();
      } catch {
      }
    }), Z.value !== undefined && Z.value !== null)
      if (typeof Z.value === "object")
        try {
          J.enqueue(Buffer.from(JSON.stringify(Z.value)));
        } catch {
          J.enqueue(Buffer.from(Z.value.toString()));
        }
      else
        J.enqueue(Buffer.from(Z.value.toString()));
    for await (let Q of $) {
      if (j)
        break;
      if (Q === undefined || Q === null)
        continue;
      if (typeof Q === "object")
        try {
          J.enqueue(Buffer.from(JSON.stringify(Q)));
        } catch {
          J.enqueue(Buffer.from(Q.toString()));
        }
      else
        J.enqueue(Buffer.from(Q.toString()));
      await new Promise((Y) => setTimeout(() => Y(), 0));
    }
    try {
      J.close();
    } catch {
    }
  } }), { ...W, headers: { "transfer-encoding": "chunked", "content-type": "text/event-stream; charset=utf-8", ...W?.headers } });
};
var f = ($, W, X) => {
  if (n(W.headers) || W.status !== 200 || W.redirect || W.cookie) {
    if (typeof W.status === "string")
      W.status = _0[W.status];
    if (W.redirect) {
      if (W.headers.Location = W.redirect, !W.status || W.status < 300 || W.status >= 400)
        W.status = 302;
    }
    if (W.cookie && n(W.cookie)) {
      const Z = Z2(W.cookie);
      if (Z)
        W.headers["set-cookie"] = Z;
    }
    if (W.headers["set-cookie"] && Array.isArray(W.headers["set-cookie"]))
      W.headers = X2(new Headers(W.headers), W.headers["set-cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, W);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($, W);
      case "Object":
        const Z = $[c];
        if (Z)
          return W.status = Z, f($.response, W, X);
        for (let j in Object.values($))
          switch (j?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(N0($));
            default:
              break;
          }
        return Response.json($, W);
      case "ReadableStream":
        if (!W.headers["content-type"]?.startsWith("text/event-stream"))
          W.headers["content-type"] = "text/event-stream; charset=utf-8";
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, W);
      case undefined:
        if (!$)
          return new Response("", W);
        return Response.json($, W);
      case "Response":
        let J = false;
        if (W.headers instanceof Headers)
          for (let j of W.headers.keys())
            if (j === "set-cookie") {
              if (J)
                continue;
              J = true;
              for (let Q of W.headers.getSetCookie())
                $.headers.append("set-cookie", Q);
            } else
              $.headers.append(j, W.headers?.get(j) ?? "");
        else
          for (let j in W.headers)
            $.headers.append(j, W.headers[j]);
        if ($.status !== W.status)
          W.status = $.status;
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($), W, X);
        return $;
      case "Error":
        return K0($, W);
      case "Promise":
        return $.then((j) => f(j, W));
      case "Function":
        return f($(), W);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W);
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($, W);
      default:
        if ($ instanceof Response) {
          let j = false;
          if (W.headers instanceof Headers)
            for (let Q of W.headers.keys())
              if (Q === "set-cookie") {
                if (j)
                  continue;
                j = true;
                for (let Y of W.headers.getSetCookie())
                  $.headers.append("set-cookie", Y);
              } else
                $.headers.append(Q, W.headers?.get(Q) ?? "");
          else
            for (let Q in W.headers)
              $.headers.append(Q, W.headers[Q]);
          if (W2)
            W.headers = $.headers.toJSON();
          else
            for (let [Q, Y] of $.headers.entries())
              if (Q in W.headers)
                W.headers[Q] = Y;
          return $;
        }
        if ($ instanceof Promise)
          return $.then((j) => f(j, W));
        if ($ instanceof Error)
          return K0($, W);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return f($.toResponse(), W);
        if ("charCodeAt" in $) {
          const j = $.charCodeAt(0);
          if (j === 123 || j === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($, W);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($);
      case "Object":
        const Z = $[c];
        if (Z)
          return W.status = Z, f($.response, W, X);
        for (let J in Object.values($))
          switch (J?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(N0($), W);
            default:
              break;
          }
        return Response.json($, W);
      case "ReadableStream":
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($), W, X);
        return $;
      case "Error":
        return K0($, W);
      case "Promise":
        return $.then((J) => {
          const j = X0(J, X);
          if (j !== undefined)
            return j;
          return new Response("");
        });
      case "Function":
        return X0($(), X);
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($, W);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((J) => f(J, W));
        if ($ instanceof Error)
          return K0($, W);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return f($.toResponse(), W);
        if ("charCodeAt" in $) {
          const J = $.charCodeAt(0);
          if (J === 123 || J === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($);
    }
};
var v = ($, W, X) => {
  if ($ === undefined || $ === null)
    return;
  if (n(W.headers) || W.status !== 200 || W.redirect || W.cookie) {
    if (typeof W.status === "string")
      W.status = _0[W.status];
    if (W.redirect) {
      if (W.headers.Location = W.redirect, !W.status || W.status < 300 || W.status >= 400)
        W.status = 302;
    }
    if (W.cookie && n(W.cookie)) {
      const Z = Z2(W.cookie);
      if (Z)
        W.headers["set-cookie"] = Z;
    }
    if (W.headers["set-cookie"] && Array.isArray(W.headers["set-cookie"]))
      W.headers = X2(new Headers(W.headers), W.headers["set-cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, W);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($, W);
      case "Object":
        const Z = $[c];
        if (Z)
          return W.status = Z, v($.response, W, X);
        for (let j in Object.values($))
          switch (j?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(N0($), W);
            default:
              break;
          }
        return Response.json($, W);
      case "ReadableStream":
        if (!W.headers["content-type"]?.startsWith("text/event-stream"))
          W.headers["content-type"] = "text/event-stream; charset=utf-8";
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, W);
      case undefined:
        if (!$)
          return;
        return Response.json($, W);
      case "Response":
        let J = false;
        if (W.headers instanceof Headers)
          for (let j of W.headers.keys())
            if (j === "set-cookie") {
              if (J)
                continue;
              J = true;
              for (let Q of W.headers.getSetCookie())
                $.headers.append("set-cookie", Q);
            } else
              $.headers.append(j, W.headers?.get(j) ?? "");
        else
          for (let j in W.headers)
            $.headers.append(j, W.headers[j]);
        if ($.status !== W.status)
          W.status = $.status;
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($), W, X);
        return $;
      case "Promise":
        return $.then((j) => {
          const Q = v(j, W);
          if (Q !== undefined)
            return Q;
        });
      case "Error":
        return K0($, W);
      case "Function":
        return v($(), W);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W);
      case "FormData":
        return new Response($);
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      default:
        if ($ instanceof Response) {
          let j = false;
          if (W.headers instanceof Headers)
            for (let Q of W.headers.keys())
              if (Q === "set-cookie") {
                if (j)
                  continue;
                j = true;
                for (let Y of W.headers.getSetCookie())
                  $.headers.append("set-cookie", Y);
              } else
                $.headers.append(Q, W.headers?.get(Q) ?? "");
          else
            for (let Q in W.headers)
              $.headers.append(Q, W.headers[Q]);
          if ($.status !== W.status)
            W.status = $.status;
          return $;
        }
        if ($ instanceof Promise)
          return $.then((j) => v(j, W));
        if ($ instanceof Error)
          return K0($, W);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return v($.toResponse(), W);
        if ("charCodeAt" in $) {
          const j = $.charCodeAt(0);
          if (j === 123 || j === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($, W);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return h0($, W);
      case "Array":
        return Response.json($);
      case "Object":
        const Z = $[c];
        if (Z)
          return W.status = Z, v($.response, W, X);
        for (let J in Object.values($))
          switch (J?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(N0($), W);
            default:
              break;
          }
        return Response.json($, W);
      case "ReadableStream":
        return X?.signal.addEventListener("abort", { handleEvent() {
          if (!X?.signal.aborted)
            $.cancel(X);
        } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        if ($.headers.get("transfer-encoding") === "chunked")
          return B0(m0($));
        return $;
      case "Promise":
        return $.then((J) => {
          const j = v(J, W);
          if (j !== undefined)
            return j;
        });
      case "Error":
        return K0($, W);
      case "Function":
        return X0($(), X);
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof w0)
          return new Response($.value, W);
        return new Response($?.toString(), W);
      case "FormData":
        return new Response($);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((J) => v(J, W));
        if ($ instanceof Error)
          return K0($, W);
        if (typeof $?.next === "function")
          return B0($, W, X);
        if ("toResponse" in $)
          return v($.toResponse(), W);
        if ("charCodeAt" in $) {
          const J = $.charCodeAt(0);
          if (J === 123 || J === 91) {
            if (!W.headers["Content-Type"])
              W.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify($), W);
          }
        }
        return new Response($);
    }
};
var X0 = ($, W) => {
  switch ($?.constructor?.name) {
    case "String":
      return new Response($);
    case "Blob":
      return h0($);
    case "Array":
      return Response.json($);
    case "Object":
      if ($[c])
        return f($.response, { status: $[c], headers: {} });
      $:
        for (let X of Object.values($))
          switch (X?.constructor?.name) {
            case "Blob":
            case "File":
            case "ArrayBuffer":
            case "FileRef":
              return new Response(N0($));
            case "Object":
              break $;
            default:
              break;
          }
      return Response.json($);
    case "ReadableStream":
      return W?.signal.addEventListener("abort", { handleEvent() {
        if (!W?.signal.aborted)
          $.cancel(W);
      } }, { once: true }), new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      if ($.headers.get("transfer-encoding") === "chunked")
        return B0(m0($));
      return $;
    case "Error":
      return K0($);
    case "Promise":
      return $.then((X) => X0(X, W));
    case "Function":
      return X0($(), W);
    case "Number":
    case "Boolean":
      return new Response($.toString());
    case "FormData":
      return new Response($);
    default:
      if ($ instanceof Response)
        return new Response($.body, { headers: { "Content-Type": "application/json" } });
      if ($ instanceof Promise)
        return $.then((X) => X0(X, W));
      if ($ instanceof Error)
        return K0($);
      if (typeof $?.next === "function")
        return B0($, undefined, W);
      if ("toResponse" in $)
        return X0($.toResponse());
      if ("charCodeAt" in $) {
        const X = $.charCodeAt(0);
        if (X === 123 || X === 91)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      }
      return new Response($);
  }
};
var K0 = ($, W) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: W?.status !== 200 ? W?.status ?? 500 : 500, headers: W?.headers });
var J2 = ($, W, X = {}) => {
  if (typeof $ === "function")
    return;
  const Z = f($, { headers: X });
  if (W.parse.length === 0 && W.transform.length === 0 && W.beforeHandle.length === 0 && W.afterHandle.length === 0)
    return Z.clone.bind(Z);
};
var b0 = ($, W) => {
  const X = new URL($);
  return X.pathname = W, X.toString();
};
var w3 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") && $.toString() !== "[object Object]" || n(Object.getPrototypeOf($));
var I1 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var l = ($, W, { skipKeys: X, override: Z = true } = {}) => {
  if (!I1($) || !I1(W))
    return $;
  for (let [J, j] of Object.entries(W)) {
    if (X?.includes(J))
      continue;
    if (!I1(j) || !(J in $) || w3(j)) {
      if (Z || !(J in $))
        $[J] = j;
      continue;
    }
    $[J] = l($[J], j, { skipKeys: X, override: Z });
  }
  return $;
};
var _3 = ($, W) => {
  const { properties: X, ...Z } = $ ?? {}, { properties: J, ...j } = W ?? {};
  return l(Z, j);
};
var x = ($ = [], W = []) => {
  if (!$)
    return [];
  if (!W)
    return $;
  const X = [], Z = [];
  if (!Array.isArray($))
    $ = [$];
  if (!Array.isArray(W))
    W = [W];
  for (let J of $)
    if (X.push(J), J.checksum)
      Z.push(J.checksum);
  for (let J of W)
    if (!Z.includes(J.checksum))
      X.push(J);
  return X;
};
var F3 = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var M3 = F3.reduce(($, W) => ($[W] = true, $), {});
var Y2 = ($, W) => {
  const X = (Z) => typeof Z === "object" && Object.keys(Z).every(J1);
  if (X($) && X(W))
    return { ...$, ...W };
  return W ?? $;
};
var x0 = ($, W) => {
  return { body: W?.body ?? $?.body, headers: W?.headers ?? $?.headers, params: W?.params ?? $?.params, query: W?.query ?? $?.query, cookie: W?.cookie ?? $?.cookie, response: Y2($?.response, W?.response) };
};
var i = ($, W) => {
  return { ...$, ...W, body: W?.body ?? $?.body, headers: W?.headers ?? $?.headers, params: W?.params ?? $?.params, query: W?.query ?? $?.query, cookie: W?.cookie ?? $?.cookie, response: Y2($?.response, W?.response), type: $?.type || W?.type, detail: l(W?.detail ?? {}, $?.detail ?? {}), parse: x($?.parse, W?.parse), transform: x($?.transform, W?.transform), beforeHandle: x($?.beforeHandle, W?.beforeHandle), afterHandle: x($?.afterHandle, W?.afterHandle), mapResponse: x($?.mapResponse, W?.mapResponse), afterResponse: x($?.afterResponse, W?.afterResponse), trace: x($?.trace, W?.trace), error: x($?.error, W?.error) };
};
var B2 = ($, W, X = true) => {
  if (!Array.isArray(W))
    return m($, W, X);
  for (let Z of W)
    $ = m($, Z, X);
  return $;
};
var m = ($, W, X = true) => {
  if (!$)
    return $;
  if (W.untilObjectFound && !X && $.type === "object")
    return $;
  const Z = W.from[Kind];
  if ($.oneOf) {
    for (let Q = 0;Q < $.oneOf.length; Q++)
      $.oneOf[Q] = m($.oneOf[Q], W, X);
    return $;
  }
  if ($.anyOf) {
    for (let Q = 0;Q < $.anyOf.length; Q++)
      $.anyOf[Q] = m($.anyOf[Q], W, X);
    return $;
  }
  if ($.allOf) {
    for (let Q = 0;Q < $.allOf.length; Q++)
      $.allOf[Q] = m($.allOf[Q], W, X);
    return $;
  }
  if ($.not) {
    for (let Q = 0;Q < $.not.length; Q++)
      $.not[Q] = m($.not[Q], W, X);
    return $;
  }
  const J = X && !!W.excludeRoot;
  if ($[Kind] === Z) {
    const { anyOf: Q, oneOf: Y, allOf: K, not: B, properties: U, items: w, ...F } = $, G = W.to();
    let z;
    const D = (M) => {
      if (U && M.type === "object") {
        const I = {};
        for (let [O, H] of Object.entries(U))
          I[O] = m(H, W, false);
        return { ...F, ...M, properties: I };
      }
      if (w && M.type === "array")
        return { ...F, ...M, items: m(w, W, false) };
      const P = { ...F, ...M };
      if (delete P.required, U && M.type === "string" && M.format === "ObjectString" && M.default === "{}")
        z = C.ObjectString(U, F), P.default = JSON.stringify(exports_value2.Create(C.Object(U))), P.properties = U;
      if (w && M.type === "string" && M.format === "ArrayString" && M.default === "[]")
        z = C.ArrayString(w, F), P.default = JSON.stringify(exports_value2.Create(C.Array(w))), P.items = w;
      return P;
    };
    if (J) {
      if (U) {
        const M = {};
        for (let [P, I] of Object.entries(U))
          M[P] = m(I, W, false);
        return { ...F, properties: M };
      } else if (w?.map)
        return { ...F, items: w.map((M) => m(M, W, false)) };
      return F;
    }
    if (G.anyOf)
      for (let M = 0;M < G.anyOf.length; M++)
        G.anyOf[M] = D(G.anyOf[M]);
    else if (G.oneOf)
      for (let M = 0;M < G.oneOf.length; M++)
        G.oneOf[M] = D(G.oneOf[M]);
    else if (G.allOf)
      for (let M = 0;M < G.allOf.length; M++)
        G.allOf[M] = D(G.allOf[M]);
    else if (G.not)
      for (let M = 0;M < G.not.length; M++)
        G.not[M] = D(G.not[M]);
    if (z)
      G[TransformKind] = z[TransformKind];
    if (G.anyOf || G.oneOf || G.allOf || G.not)
      return G;
    if (U) {
      const M = {};
      for (let [P, I] of Object.entries(U))
        M[P] = m(I, W, false);
      return { ...F, ...G, properties: M };
    } else if (w?.map)
      return { ...F, ...G, items: w.map((M) => m(M, W, false)) };
    return { ...F, ...G };
  }
  const j = $?.properties;
  if (j)
    for (let [Q, Y] of Object.entries(j))
      switch (Y[Kind]) {
        case Z:
          const { anyOf: K, oneOf: B, allOf: U, not: w, type: F, ...G } = Y, z = W.to();
          if (z.anyOf)
            for (let D = 0;D < z.anyOf.length; D++)
              z.anyOf[D] = { ...G, ...z.anyOf[D] };
          else if (z.oneOf)
            for (let D = 0;D < z.oneOf.length; D++)
              z.oneOf[D] = { ...G, ...z.oneOf[D] };
          else if (z.allOf)
            for (let D = 0;D < z.allOf.length; D++)
              z.allOf[D] = { ...G, ...z.allOf[D] };
          else if (z.not)
            for (let D = 0;D < z.not.length; D++)
              z.not[D] = { ...G, ...z.not[D] };
          j[Q] = { ...G, ...m(G, W, false) };
          break;
        case "Object":
        case "Union":
          j[Q] = m(Y, W, false);
          break;
        default:
          if (Y.items)
            for (let D = 0;D < Y.items.length; D++)
              Y.items[D] = m(Y.items[D], W, false);
          else if (Y.anyOf || Y.oneOf || Y.allOf || Y.not)
            j[Q] = m(Y, W, false);
          break;
      }
  return $;
};
var d = ($, { models: W = {}, dynamic: X = false, normalize: Z = false, additionalProperties: J = false, coerce: j = false, additionalCoerce: Q = [] } = {}) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W))
    return;
  let Y = typeof $ === "string" ? W[$] : $;
  if (j)
    Y = B2(Y, [{ from: C.Number(), to: () => C.Numeric(), untilObjectFound: true }, { from: C.Boolean(), to: () => C.BooleanString(), untilObjectFound: true }, ...Array.isArray(Q) ? Q : [Q]]);
  if (Y.type === "object" && "additionalProperties" in Y === false)
    Y.additionalProperties = J;
  const K = (U) => exports_value2.Clean(Y, U);
  if (X) {
    const U = { schema: Y, references: "", checkFunc: () => {
    }, code: "", Check: (w) => exports_value2.Check(Y, w), Errors: (w) => exports_value2.Errors(Y, w), Code: () => "", Clean: K, Decode: (w) => exports_value2.Decode(Y, w), Encode: (w) => exports_value2.Encode(Y, w) };
    if (Z && Y.additionalProperties === false)
      U.Clean = K;
    if (Y.config) {
      if (U.config = Y.config, U?.schema?.config)
        delete U.schema.config;
    }
    return U.parse = (w) => {
      try {
        return U.Decode(w);
      } catch (F) {
        throw [...U.Errors(w)].map(o);
      }
    }, U.safeParse = (w) => {
      try {
        return { success: true, data: U.Decode(w), error: null };
      } catch (F) {
        const G = [...B.Errors(w)].map(o);
        return { success: false, data: null, error: G[0]?.summary, errors: G };
      }
    }, U;
  }
  const B = TypeCompiler.Compile(Y, Object.values(W));
  if (B.Clean = K, Y.config) {
    if (B.config = Y.config, B?.schema?.config)
      delete B.schema.config;
  }
  return B.parse = (U) => {
    try {
      return B.Decode(U);
    } catch (w) {
      throw [...B.Errors(U)].map(o);
    }
  }, B.safeParse = (U) => {
    try {
      return { success: true, data: B.Decode(U), error: null };
    } catch (w) {
      const F = [...B.Errors(U)].map(o);
      return { success: false, data: null, error: F[0]?.summary, errors: F };
    }
  }, B;
};
var W1 = ($, { models: W = {}, dynamic: X = false, normalize: Z = false, additionalProperties: J = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W))
    return;
  const j = typeof $ === "string" ? W[$] : $, Q = (K, B) => {
    const U = (F) => {
      if (!F || typeof F !== "object")
        return exports_value2.Clean(K, F);
      if (Array.isArray(F))
        F = exports_value2.Clean(K, F);
      else
        F = exports_value2.Clean(K, F);
      return F;
    };
    if (X)
      return { schema: K, references: "", checkFunc: () => {
      }, code: "", Check: (F) => exports_value2.Check(K, F), Errors: (F) => exports_value2.Errors(K, F), Code: () => "", Decode: (F) => exports_value2.Decode(K, F), Encode: (F) => exports_value2.Encode(K, F) };
    const w = TypeCompiler.Compile(K, B);
    if (Z && K.additionalProperties === false)
      w.Clean = U;
    return w;
  };
  if (Kind in j) {
    if ("additionalProperties" in j === false)
      j.additionalProperties = J;
    return { 200: Q(j, Object.values(W)) };
  }
  const Y = {};
  return Object.keys(j).forEach((K) => {
    const B = j[+K];
    if (typeof B === "string") {
      if (B in W) {
        const U = W[B];
        U.type === "object" && "additionalProperties" in U, Y[+K] = Kind in U ? Q(U, Object.values(W)) : U;
      }
      return;
    }
    if (B.type === "object" && "additionalProperties" in B === false)
      B.additionalProperties = J;
    Y[+K] = Kind in B ? Q(B, Object.values(W)) : B;
  }), Y;
};
var z3 = typeof Bun !== "undefined";
var D3 = z3 && typeof Bun.hash === "function";
var P0 = ($) => {
  if (D3)
    return Bun.hash($);
  let W = 9;
  for (let X = 0;X < $.length; )
    W = Math.imul(W ^ $.charCodeAt(X++), 387420489);
  return W = W ^ W >>> 9;
};
var A1;
var D0 = () => {
  if (!A1)
    A1 = [{ from: C.Object({}), to: () => C.ObjectString({}), excludeRoot: true }, { from: C.Array(C.Any()), to: () => C.ArrayString(C.Any()) }];
  return A1;
};
var X1 = ({ validator: $, defaultConfig: W = {}, config: X, dynamic: Z, models: J }) => {
  let j = d($, { dynamic: Z, models: J, additionalProperties: true, coerce: true, additionalCoerce: D0() });
  if (n(W))
    if (j)
      j.config = _3(j.config, X);
    else
      j = d(C.Cookie({}), { dynamic: Z, models: J, additionalProperties: true }), j.config = W;
  return j;
};
var Z0 = ($, W) => {
  if (!W)
    return;
  if (!Array.isArray(W)) {
    const Z = W;
    if ($ && !Z.checksum)
      Z.checksum = $;
    if (Z.scope === "scoped")
      Z.scope = "local";
    return Z;
  }
  const X = [...W];
  for (let Z of X) {
    if ($ && !Z.checksum)
      Z.checksum = $;
    if (Z.scope === "scoped")
      Z.scope = "local";
  }
  return X;
};
var O1 = ($, W, X) => {
  return { start: x($.start, Z0(X, W?.start)), request: x($.request, Z0(X, W?.request)), parse: x($.parse, Z0(X, W?.parse)), transform: x($.transform, Z0(X, W?.transform)), beforeHandle: x($.beforeHandle, Z0(X, W?.beforeHandle)), afterHandle: x($.afterHandle, Z0(X, W?.afterHandle)), mapResponse: x($.mapResponse, Z0(X, W?.mapResponse)), afterResponse: x($.afterResponse, Z0(X, W?.afterResponse)), trace: x($.trace, Z0(X, W?.trace)), error: x($.error, Z0(X, W?.error)), stop: x($.stop, Z0(X, W?.stop)) };
};
var K2 = ($, W, { skipIfHasType: X = false } = {}) => {
  if (!$)
    return $;
  if (!Array.isArray($)) {
    if (X)
      $.scope ??= W;
    else
      $.scope = W;
    return $;
  }
  for (let Z of $)
    if (X)
      Z.scope ??= W;
    else
      Z.scope = W;
  return $;
};
var z0 = ($) => {
  if (!$)
    return $;
  if (!Array.isArray($))
    switch ($.scope) {
      case "global":
      case "scoped":
        return { ...$ };
      default:
        return { fn: $ };
    }
  const W = [];
  for (let X of $)
    switch (X.scope) {
      case "global":
      case "scoped":
        W.push({ ...X });
        break;
    }
  return W;
};
var V1 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: z0($?.parse), transform: z0($?.transform), beforeHandle: z0($?.beforeHandle), afterHandle: z0($?.afterHandle), mapResponse: z0($?.mapResponse), afterResponse: z0($?.afterResponse), error: z0($?.error), trace: z0($?.trace) };
};
var _0 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var Z1 = Object.fromEntries(Object.entries(_0).map(([$, W]) => [W, $]));
var Q2 = new TextEncoder;
var g0 = async ($, W) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (W === null)
    throw new TypeError("Secret key must be provided.");
  const X = await crypto.subtle.importKey("raw", Q2.encode(W), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), Z = await crypto.subtle.sign("HMAC", X, Q2.encode($));
  return $ + "." + N3(Buffer.from(Z).toString("base64"));
};
var P1 = async ($, W) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (W === null)
    throw new TypeError("Secret key must be provided.");
  const X = $.slice(0, $.lastIndexOf("."));
  return await g0(X, W) === $ ? X : false;
};
var U2 = ($, W) => {
  if (!$ || typeof $ !== "object" || !W)
    return;
  for (let [X, Z] of Object.entries(W)) {
    if (X in M3 || !(X in $))
      continue;
    const J = $[X];
    if (typeof J === "function")
      J(Z), delete W[X];
  }
};
var w2 = ({ globalHook: $, localHook: W }) => (X) => (Z, J) => {
  if (typeof Z === "function")
    Z = { fn: Z };
  if ("fn" in Z || Array.isArray(Z)) {
    if (!W[X])
      W[X] = [];
    if (typeof W[X] === "function")
      W[X] = [W[X]];
    if (Array.isArray(Z))
      W[X] = W[X].concat(Z);
    else
      W[X].push(Z);
    return;
  }
  const { insert: j = "after", stack: Q = "local" } = Z;
  if (typeof J === "function")
    J = { fn: J };
  if (Q === "global")
    if (!Array.isArray(J))
      if (j === "before")
        $[X].unshift(J);
      else
        $[X].push(J);
    else if (j === "before")
      $[X] = J.concat($[X]);
    else
      $[X] = $[X].concat(J);
  else {
    if (!W[X])
      W[X] = [];
    if (typeof W[X] === "function")
      W[X] = [W[X]];
    if (!Array.isArray(J))
      if (j === "before")
        W[X].unshift(J);
      else
        W[X].push(J);
    else if (j === "before")
      W[X] = J.concat(W[X]);
    else
      W[X] = W[X].concat(J);
  }
};
var P3 = ($) => {
  if (typeof $ === "number")
    return $;
  if ($.length < 16) {
    if ($.trim().length === 0)
      return null;
    const W = Number($);
    if (Number.isNaN(W))
      return null;
    return W;
  }
  if ($.length === 16) {
    if ($.trim().length === 0)
      return null;
    const W = Number($);
    if (Number.isNaN(W) || W.toString() !== $)
      return null;
    return W;
  }
  return null;
};
var J1 = ($) => P3($) !== null;

class C1 {
  $;
  root = null;
  promises = [];
  constructor($ = console.error) {
    this.onError = $;
  }
  get size() {
    return this.promises.length;
  }
  add($) {
    return this.promises.push($), this.root ||= this.drain(), $;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch ($) {
        this.onError($);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then($, W) {
    return (this.root ?? Promise.resolve()).then($, W);
  }
}
var t = ($) => {
  if (!$)
    return $;
  if (!Array.isArray($)) {
    if (typeof $ === "function")
      return { fn: $ };
    else if ("fn" in $)
      return $;
  }
  const W = [];
  for (let X of $)
    if (typeof X === "function")
      W.push({ fn: X });
    else if ("fn" in X)
      W.push(X);
  return W;
};
var _2 = ($) => {
  return { ...$, start: t($?.start), request: t($?.request), parse: t($?.parse), transform: t($?.transform), beforeHandle: t($?.beforeHandle), afterHandle: t($?.afterHandle), mapResponse: t($?.mapResponse), afterResponse: t($?.afterResponse), trace: t($?.trace), error: t($?.error), stop: t($?.stop) };
};
var S1 = ($) => {
  return { ...$, start: $.start?.map((W) => W.fn), request: $.request?.map((W) => W.fn), parse: $.parse?.map((W) => W.fn), transform: $.transform?.map((W) => W.fn), beforeHandle: $.beforeHandle?.map((W) => W.fn), afterHandle: $.afterHandle?.map((W) => W.fn), afterResponse: $.afterResponse?.map((W) => W.fn), mapResponse: $.mapResponse?.map((W) => W.fn), trace: $.trace?.map((W) => W.fn), error: $.error?.map((W) => W.fn), stop: $.stop?.map((W) => W.fn) };
};
var d0 = ($) => ({ body: $.body, cookie: $.cookie, headers: $.headers, query: $.query, set: $.set, server: $.server });
var c0 = ($, W = 302) => Response.redirect($, W);
var I3 = Symbol("ElysiaFormData");
var I0 = Symbol("ElysiaRequestId");
var N0 = ($) => {
  const W = new FormData;
  for (let [X, Z] of Object.entries($)) {
    if (Array.isArray(Z)) {
      for (let J of Z) {
        if (Z instanceof File)
          W.append(X, Z, Z.name);
        W.append(X, J);
      }
      continue;
    }
    if (Z instanceof File)
      W.append(X, Z, Z.name);
    W.append(X, Z);
  }
  return W;
};
var j1 = () => crypto.getRandomValues(new Uint32Array(1))[0];
var Q1 = ($) => {
  const W = [];
  for (let X = 0;X < $.length; X++) {
    const Z = $[X];
    if (Z.checksum) {
      if (W.includes(Z.checksum))
        $.splice(X, 1), X--;
      W.push(Z.checksum);
    }
  }
  return $;
};
var u = ($, W = "scoped") => {
  if (W === "scoped") {
    for (let X of $)
      if ("scope" in X && X.scope === "local")
        X.scope = "scoped";
    return;
  }
  for (let X of $)
    if ("scope" in X)
      X.scope = "global";
};
var F2 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var A0 = Symbol("ElysiaErrorCode");
var c = Symbol("ElysiaResponse");
var p0 = (F2?.NODE_ENV ?? F2?.ENV) === "production";
var L1 = ($, W) => {
  const X = W ?? ($ in Z1 ? Z1[$] : $);
  return { [c]: _0[$] ?? $, response: X, _type: undefined, error: new Error(X) };
};

class G1 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class O0 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}

class Y1 extends Error {
  code = "PARSE";
  status = 400;
  constructor() {
    super("Failed to parse body");
  }
}

class u0 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, W) {
    super(W ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}
var o = ($) => {
  if (!$)
    return { summary: undefined };
  const { message: W, path: X, value: Z, type: J } = $, j = X.slice(1).replaceAll("/", "."), Q = X === "";
  switch (J) {
    case 42:
      return { ...$, summary: Q ? "Value should not be provided" : `Property '${j}' should not be provided` };
    case 45:
      return { ...$, summary: Q ? "Value is missing" : `Property '${j}' is missing` };
    case 50:
      const Y = W.indexOf("'"), K = W.slice(Y + 1, W.indexOf("'", Y + 1));
      return { ...$, summary: Q ? "Value should be an email" : `Property '${j}' should be ${K}` };
    case 54:
      return { ...$, summary: `${W.slice(0, 9)} property '${j}' to be ${W.slice(8)} but found: ${Z}` };
    case 62:
      const B = $.schema.anyOf.map((U) => `'${U?.format ?? U.type}'`).join(", ");
      return { ...$, summary: Q ? `Value should be one of ${B}` : `Property '${j}' should be one of: ${B}` };
    default:
      return { summary: W, ...$ };
  }
};

class T extends Error {
  $;
  W;
  X;
  code = "VALIDATION";
  status = 422;
  constructor($, W, X) {
    if (X && typeof X === "object" && c in X)
      X = X.response;
    const Z = p0 ? undefined : ("Errors" in W) ? W.Errors(X).First() : exports_value2.Errors(W, X).First(), J = Z?.schema.error !== undefined ? typeof Z.schema.error === "function" ? Z.schema.error({ type: $, validator: W, value: X, get errors() {
      return [...W.Errors(X)].map(o);
    } }) : Z.schema.error : undefined, j = Z?.path || "root";
    let Q = "";
    if (J !== undefined)
      Q = typeof J === "object" ? JSON.stringify(J) : J + "";
    else if (p0)
      Q = JSON.stringify({ type: "validation", on: $, summary: o(Z).summary, message: Z?.message, found: X });
    else {
      const Y = W?.schema ?? W, K = "Errors" in W ? [...W.Errors(X)].map(o) : [...exports_value2.Errors(W, X)].map(o);
      let B;
      try {
        B = exports_value2.Create(Y);
      } catch (U) {
        B = { type: "Could not create expected value", message: U?.message, error: U };
      }
      Q = JSON.stringify({ type: "validation", on: $, summary: K[0]?.summary, property: j, message: Z?.message, expected: B, found: X, errors: K }, null, 2);
    }
    super(Q);
    this.type = $;
    this.validator = W;
    this.value = X;
    Object.setPrototypeOf(this, T.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(o) : [...exports_value2.Errors(this.validator, this.value)].map(o);
  }
  static simplifyModel($) {
    const W = "schema" in $ ? $.schema : $;
    try {
      return exports_value2.Create(W);
    } catch {
      return W;
    }
  }
  get model() {
    return T.simplifyModel(this.validator);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: { ...$, "content-type": "application/json" } });
  }
}
var T1 = { open($) {
  $.data.open?.($);
}, message($, W) {
  $.data.message?.($, W);
}, drain($) {
  $.data.drain?.($);
}, close($, W, X) {
  $.data.close?.($, W, X);
} };

class f0 {
  $;
  W;
  validator;
  _validator;
  constructor($, W) {
    this.raw = $;
    this.data = W;
    if (this.validator = $.data.validator, $.data.id)
      this.id = $.data.id;
    else
      this.id = j1().toString();
  }
  get id() {
    return this.raw.data.id;
  }
  set id($) {
    this.raw.data.id = $;
  }
  get publish() {
    return ($, W = undefined, X) => {
      if (this.validator?.Check(W) === false)
        throw new T("message", this.validator, W);
      if (typeof W === "object")
        W = JSON.stringify(W);
      return this.raw.publish($, W, X), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new T("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var q1 = "1.1.11";
var V0 = w1(e0(), 1);
var y0 = /\+/g;
var i0 = ($) => {
  const W = {};
  if (typeof $ !== "string")
    return W;
  const X = $.length;
  let Z = "", J = "", j = -1, Q = -1, Y = false, K = false, B = false, U = false, w = false, F = 0;
  for (let G = 0;G < X + 1; G++) {
    if (G !== X)
      F = $.charCodeAt(G);
    else
      F = 38;
    switch (F) {
      case 38: {
        if (w = Q > j, !w)
          Q = G;
        if (Z = $.slice(j + 1, Q), w || Z.length > 0) {
          if (B)
            Z = Z.replace(y0, " ");
          if (Y)
            Z = V0.default(Z) || Z;
          if (w) {
            if (J = $.slice(Q + 1, G), U)
              J = J.replace(y0, " ");
            if (K)
              J = V0.default(J) || J;
          }
          const z = W[Z];
          if (z === undefined)
            W[Z] = J;
          else if (z.pop)
            z.push(J);
          else
            W[Z] = [z, J];
        }
        J = "", j = G, Q = G, Y = false, K = false, B = false, U = false;
        break;
      }
      case 61:
        if (Q <= j)
          Q = G;
        else
          K = true;
        break;
      case 43:
        if (Q > j)
          U = true;
        else
          B = true;
        break;
      case 37:
        if (Q > j)
          K = true;
        else
          Y = true;
        break;
    }
  }
  return W;
};
var z2 = w1(e0(), 1);
var n0 = Symbol("ElysiaTrace");
var F0 = () => {
  const { promise: $, resolve: W } = Promise.withResolvers(), { promise: X, resolve: Z } = Promise.withResolvers(), { promise: J, resolve: j } = Promise.withResolvers(), Q = [], Y = [];
  return [(K) => {
    if (K)
      Q.push(K);
    return $;
  }, (K) => {
    const B = [], U = [];
    let w = null;
    for (let G = 0;G < (K.total ?? 0); G++) {
      const { promise: z, resolve: D } = Promise.withResolvers(), { promise: M, resolve: P } = Promise.withResolvers(), { promise: I, resolve: O } = Promise.withResolvers(), H = [], V = [];
      B.push((g) => {
        if (g)
          H.push(g);
        return z;
      }), U.push((g) => {
        const R = { ...g, end: M, error: I, index: G, onStop(E) {
          if (E)
            V.push(E);
          return M;
        } };
        D(R);
        for (let E = 0;E < H.length; E++)
          H[E](R);
        return (E = null) => {
          const k = performance.now();
          if (E)
            w = E;
          const b = { end: k, error: E, get elapsed() {
            return k - g.begin;
          } };
          for (let Q0 = 0;Q0 < V.length; Q0++)
            V[Q0](b);
          P(k), O(E);
        };
      });
    }
    const F = { ...K, end: X, error: J, onEvent(G) {
      for (let z = 0;z < B.length; z++)
        B[z](G);
    }, onStop(G) {
      if (G)
        Y.push(G);
      return X;
    } };
    W(F);
    for (let G = 0;G < Q.length; G++)
      Q[G](F);
    return { resolveChild: U, resolve(G = null) {
      const z = performance.now();
      if (!G && w)
        G = w;
      const D = { end: z, error: G, get elapsed() {
        return z - K.begin;
      } };
      for (let M = 0;M < Y.length; M++)
        Y[M](D);
      Z(z), j(G);
    } };
  }];
};
var M2 = ($) => {
  return (W) => {
    const [X, Z] = F0(), [J, j] = F0(), [Q, Y] = F0(), [K, B] = F0(), [U, w] = F0(), [F, G] = F0(), [z, D] = F0(), [M, P] = F0(), [I, O] = F0();
    return $({ id: W[I0], context: W, set: W.set, onRequest: X, onParse: J, onTransform: Q, onBeforeHandle: K, onHandle: U, onAfterHandle: F, onMapResponse: M, onAfterResponse: I, onError: z }), { request: Z, parse: j, transform: Y, beforeHandle: B, handle: w, afterHandle: G, error: D, mapResponse: P, afterResponse: O };
  };
};
var O3 = new Headers().toJSON;
var D2 = { optional: Symbol.for("TypeBox.Optional"), kind: Symbol.for("TypeBox.Kind") };
var s = ($) => {
  if (!$)
    return false;
  const W = $?.schema;
  return !!W && D2.optional in W;
};
var J0 = ($) => {
  if (!$)
    return false;
  const W = $?.schema ?? $;
  if (W.anyOf)
    return W.anyOf.some(J0);
  if (W.someOf)
    return W.someOf.some(J0);
  if (W.allOf)
    return W.allOf.some(J0);
  if (W.not)
    return W.not.some(J0);
  if (W.type === "object") {
    const X = W.properties;
    if ("additionalProperties" in W)
      return W.additionalProperties;
    for (let Z of Object.keys(X)) {
      const J = X[Z];
      if (J.type === "object") {
        if (J0(J))
          return true;
      } else if (J.anyOf) {
        for (let j = 0;j < J.anyOf.length; j++)
          if (J0(J.anyOf[j]))
            return true;
      }
      return J.additionalProperties;
    }
    return false;
  }
  return false;
};
var H1 = ({ context: $ = "c", trace: W, addFn: X }) => {
  if (!W.length)
    return () => {
      return { resolveChild() {
        return () => {
        };
      }, resolve() {
      } };
    };
  for (let Z = 0;Z < W.length; Z++)
    X(`let report${Z}, reportChild${Z}, reportErr${Z}, reportErrChild${Z}; let trace${Z} = ${$}[ELYSIA_TRACE]?.[${Z}] ?? trace[${Z}](${$});\n`);
  return (Z, { name: J, total: j = 0 } = {}) => {
    if (!J)
      J = "anonymous";
    const Q = Z === "error" ? "reportErr" : "report";
    for (let Y = 0;Y < W.length; Y++)
      X(`\n${Q}${Y} = trace${Y}.${Z}({id,event: '${Z}',name: '${J}',begin: performance.now(),total: ${j}})\n`);
    return { resolve() {
      for (let Y = 0;Y < W.length; Y++)
        X(`\n${Q}${Y}.resolve()\n`);
    }, resolveChild(Y) {
      for (let K = 0;K < W.length; K++)
        X(`${Q}Child${K} = ${Q}${K}.resolveChild?.shift()?.({id,event: '${Z}',name: '${Y}',begin: performance.now()})\n`);
      return (K) => {
        for (let B = 0;B < W.length; B++)
          if (K)
            X(`
                             	if (${K} instanceof Error)
                    				${Q}Child${B}?.(${K})
                           		else
                             		${Q}Child${B}?.()\n`);
          else
            X(`${Q}Child${B}?.()\n`);
      };
    } };
  };
};
var V3 = ({ injectResponse: $ = "", normalize: W = false, validator: X }) => ({ composeValidation: (Z, J = `c.${Z}`) => `c.set.status = 422; throw new ValidationError('${Z}', validator.${Z}, ${J})`, composeResponseValidation: (Z = "r") => {
  let J = "\n" + $ + "\n";
  J += `if(typeof ${Z} === "object" && ${Z} && ELYSIA_RESPONSE in ${Z}) {
			c.set.status = ${Z}[ELYSIA_RESPONSE]
			${Z} = ${Z}.response
		}

		const isResponse = ${Z} instanceof Response\n\n`, J += "switch(c.set.status) {\n";
  for (let [j, Q] of Object.entries(X.response)) {
    if (J += `\tcase ${j}:
				if (!isResponse) {\n`, W && "Clean" in Q && !J0(Q))
      J += `${Z} = validator.response['${j}'].Clean(${Z})\n`;
    J += `if(validator.response['${j}'].Check(${Z}) === false) {
					c.set.status = 422

					throw new ValidationError('response', validator.response['${j}'], ${Z})
				}

				c.set.status = ${j}
			}

			break\n\n`;
  }
  return J += "\n}\n", J;
} });
var m8 = Symbol.for("TypeBox.Kind");
var C0 = ($, W) => {
  if (!W)
    return;
  if (W.type === "object") {
    const X = W.properties;
    if (!X)
      return false;
    for (let Z of Object.keys(X)) {
      const J = X[Z];
      if ($ in J)
        return true;
      if (J.type === "object") {
        if (C0($, J))
          return true;
      } else if (J.anyOf) {
        for (let j = 0;j < J.anyOf.length; j++)
          if (C0($, J.anyOf[j]))
            return true;
      }
    }
    return false;
  }
  return $ in W;
};
var E1 = Symbol.for("TypeBox.Transform");
var S0 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    const W = $.properties;
    for (let X of Object.keys(W)) {
      const Z = W[X];
      if (Z.type === "object") {
        if (S0(Z))
          return true;
      } else if (Z.anyOf) {
        for (let j = 0;j < Z.anyOf.length; j++)
          if (S0(Z.anyOf[j]))
            return true;
      }
      if (E1 in Z)
        return true;
    }
    return false;
  }
  return E1 in $ || $.properties && E1 in $.properties;
};
var C3 = /(?:return|=>) \S+\(/g;
var L0 = ($) => {
  return ($?.fn ?? $).constructor.name === "AsyncFunction";
};
var y = ($) => {
  const W = $?.fn ?? $;
  if (W.constructor.name === "AsyncFunction")
    return true;
  const X = W.toString();
  if (X.includes("=> response.clone("))
    return false;
  if (X.includes("await"))
    return true;
  if (X.includes("async"))
    return true;
  return !!X.match(C3);
};
var K1 = ($) => {
  const W = $?.fn ?? $;
  return W.constructor.name === "AsyncGeneratorFunction" || W.constructor.name === "GeneratorFunction";
};
var N2 = ({ app: $, path: W, method: X, localHook: Z, hooks: J, validator: j, handler: Q, allowMeta: Y = false, inference: K }) => {
  const B = typeof Q === "function";
  if (!B) {
    if (Q = f(Q, { headers: $.setHeaders ?? {} }), J.parse.length === 0 && J.transform.length === 0 && J.beforeHandle.length === 0 && J.afterHandle.length === 0)
      return Function("a", "return function () { return a.clone() }")(Q);
  }
  const U = B ? "handler(c)" : "handler", w = J.afterResponse.length > 0, F = J.trace.length > 0;
  let G = "";
  if (K = r0(Object.assign(Z, { handler: Q }), K), K.server)
    G += `\nObject.defineProperty(c, 'server', {
			get: function() { return getServer() }
		})\n`;
  if (K.body)
    G += "let isParsing = false\n";
  j.createBody?.(), j.createQuery?.(), j.createHeaders?.(), j.createParams?.(), j.createCookie?.(), j.createResponse?.();
  const z = K.query || !!j.query, D = X !== "$INTERNALWS" && X !== "GET" && X !== "HEAD" && (K.body || !!j.body || J.parse.length), M = $.setHeaders, P = M && !!Object.keys(M).length, I = K.headers || j.headers, O = K.cookie || !!j.cookie, H = O ? X1({ validator: j.cookie, defaultConfig: $.config.cookie, dynamic: !!$.config.aot, config: j.cookie?.config ?? {}, models: $.definitions.type }) : undefined, V = H?.config;
  let g = "";
  if (V?.sign) {
    if (!V.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${X}) ${W}.`);
    const N = !V.secrets ? undefined : typeof V.secrets === "string" ? V.secrets : V.secrets[0];
    if (g += `const _setCookie = c.set.cookie
		if(_setCookie) {`, V.sign === true)
      g += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${N}')
			}`;
    else
      for (let _ of V.sign)
        g += `if(_setCookie['${_}']?.value) { c.set.cookie['${_}'].value = await signCookie(_setCookie['${_}'].value, '${N}') }\n`;
    g += "}\n";
  }
  const R = $.config.normalize, { composeValidation: E, composeResponseValidation: k } = V3({ normalize: R, validator: j });
  if (I)
    G += O3 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (O) {
    const N = (A, S) => {
      const L = V?.[A] ?? S;
      if (!L)
        return typeof S === "string" ? `${A}: "${S}",` : `${A}: ${S},`;
      if (typeof L === "string")
        return `${A}: '${L}',`;
      if (L instanceof Date)
        return `${A}: new Date(${L.getTime()}),`;
      return `${A}: ${L},`;
    }, _ = V ? `{
			secrets: ${V.secrets !== undefined ? typeof V.secrets === "string" ? `'${V.secrets}'` : "[" + V.secrets.reduce((A, S) => A + `'${S}',`, "") + "]" : "undefined"},
			sign: ${V.sign === true ? true : V.sign !== undefined ? "[" + V.sign.reduce((A, S) => A + `'${S}',`, "") + "]" : "undefined"},
			${N("domain")}
			${N("expires")}
			${N("httpOnly")}
			${N("maxAge")}
			${N("path", "/")}
			${N("priority")}
			${N("sameSite")}
			${N("secure")}
		}` : "undefined";
    if (I)
      G += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${_})\n`;
    else
      G += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${_})\n`;
  }
  if (z) {
    const N = [];
    if (j.query && j.query.schema.type === "object") {
      const _ = j.query.schema.properties;
      if (!J0(j.query))
        for (let [A, S] of Object.entries(_)) {
          let L = S;
          if (L && D2.optional in L && L.type === "array" && L.items)
            L = L.items;
          const { type: a, anyOf: q } = L, U0 = a === "array" || q?.some((h) => h.type === "string" && h.format === "ArrayString");
          N.push({ key: A, isArray: U0, isNestedObjectArray: U0 && L.items?.type === "object" || !!L.items?.anyOf?.some((h) => h.type === "object" || h.type === "array"), isObject: a === "object" || q?.some((h) => h.type === "string" && h.format === "ArrayString"), anyOf: !!q });
        }
    }
    if (!N.length)
      G += `if(c.qi === -1) {
				c.query = {}
			} else {
				c.query = parseQueryFromURL(c.url.slice(c.qi + 1))
			}`;
    else
      G += `if(c.qi !== -1) {
				let url = '&' + c.url.slice(c.qi + 1)

				${N.map(({ key: _, isArray: A, isObject: S, isNestedObjectArray: L, anyOf: a }, q) => {
        const U0 = `${q === 0 ? "let" : ""} memory = url.indexOf('&${_}=')
							let a${q}\n`;
        if (A)
          return U0 + (L ? `while (memory !== -1) {
											const start = memory + ${_.length + 2}
											memory = url.indexOf('&', start)

											if(a${q} === undefined)
												a${q} = ''
											else
												a${q} += ','

											let temp

											if(memory === -1) temp = decodeURIComponent(url.slice(start))
											else temp = decodeURIComponent(url.slice(start, memory))

											const charCode = temp.charCodeAt(0)
											if(charCode !== 91 && charCode !== 123)
												temp = '"' + temp + '"'

											a${q} += temp

											if(memory === -1) break

											memory = url.indexOf('&${_}=', memory)
											if(memory === -1) break
										}

										try {
										    if(a${q}.charCodeAt(0) === 91)
												a${q} = JSON.parse(a${q})
											else
												a${q} = JSON.parse('[' + a${q} + ']')
										} catch {}\n` : `while (memory !== -1) {
											const start = memory + ${_.length + 2}
											memory = url.indexOf('&', start)

											if(a${q} === undefined)
												a${q} = []

											if(memory === -1) {
												a${q}.push(decodeURIComponent(url.slice(start)))
												break
											}
											else a${q}.push(decodeURIComponent(url.slice(start, memory)))

											memory = url.indexOf('&${_}=', memory)
											if(memory === -1) break
										}\n`);
        if (S)
          return U0 + `if (memory !== -1) {
										const start = memory + ${_.length + 2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${q} = decodeURIComponent(url.slice(start))
										else a${q} = decodeURIComponent(url.slice(start, memory))

										if (a${q} !== undefined) {
											try {
												a${q} = JSON.parse(a${q})
											} catch {}
										}
									}`;
        return U0 + `if (memory !== -1) {
										const start = memory + ${_.length + 2}
										memory = url.indexOf('&', start)

										if(memory === -1) a${q} = decodeURIComponent(url.slice(start))
										else {
											a${q} = decodeURIComponent(url.slice(start, memory))

											${a ? `
											let deepMemory = url.indexOf('&${_}=', memory)

											if(deepMemory !== -1) {
												a${q} = [a${q}]
												let first = true

												while(true) {
													const start = deepMemory + ${_.length + 2}
													if(first)
														first = false
													else
														deepMemory = url.indexOf('&', start)

													let value
													if(deepMemory === -1) value = decodeURIComponent(url.slice(start))
													else value = decodeURIComponent(url.slice(start, deepMemory))

													const vStart = value.charCodeAt(0)
													const vEnd = value.charCodeAt(value.length - 1)

													if((vStart === 91 && vEnd === 93) || (vStart === 123 && vEnd === 125))
														try {
															a${q}.push(JSON.parse(value))
														} catch {
														 	a${q}.push(value)
														}

													if(deepMemory === -1) break
												}
											}
												` : ""}
										}
									}`;
      }).join("\n")}

				c.query = {
					${N.map(({ key: _ }, A) => `'${_}': a${A}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
  }
  if (F)
    G += "\nconst id = c[ELYSIA_REQUEST_ID]\n";
  const b = H1({ trace: J.trace, addFn: (N) => {
    G += N;
  } });
  G += "\ntry {\n";
  const Q0 = typeof Q === "function" && y(Q), e = F || J.afterResponse.length > 0 ? "c.response = " : "", k0 = O || D || Q0 || J.parse.length > 0 || J.afterHandle.some(y) || J.beforeHandle.some(y) || J.transform.some(y) || J.mapResponse.some(y), I2 = (typeof Q === "function" ? K1(Q) : false) || J.beforeHandle.some(K1) || J.afterHandle.some(K1) || J.transform.some(K1), s0 = K.cookie || K.set || I || F || j.response || B && P || I2, r = ", c.request";
  G += `c.route = \`${W}\`\n`;
  const A2 = b("parse", { total: J.parse.length });
  if (D) {
    const N = J.parse.length || K.body || j.body;
    if (G += "isParsing = true\n", J.type && !J.parse.length)
      switch (J.type) {
        case "json":
        case "application/json":
          if (s(j.body))
            G += "try { c.body = await c.request.json() } catch {}";
          else
            G += "c.body = await c.request.json()";
          break;
        case "text":
        case "text/plain":
          G += "c.body = await c.request.text()\n";
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          G += "c.body = parseQuery(await c.request.text())\n";
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          G += "c.body = await c.request.arrayBuffer()\n";
          break;
        case "formdata":
        case "multipart/form-data":
          if (G += "c.body = {}\n", s(j.body))
            G += "let form; try { form = await c.request.formData() } catch {}";
          else
            G += "const form = await c.request.formData()";
          G += `\nif(form)
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						} else form = {}\n`;
          break;
      }
    else if (N) {
      if (G += "\n", G += I ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", G += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n
					c.contentType = contentType\n`, J.parse.length) {
        G += "let used = false\n";
        const _ = b("parse", { total: J.parse.length });
        for (let A = 0;A < J.parse.length; A++) {
          const S = _.resolveChild(J.parse[A].fn.name), L = `bo${A}`;
          if (A !== 0)
            G += "if(!used) {\n";
          if (G += `let ${L} = parse[${A}](c, contentType)\n`, G += `if(${L} instanceof Promise) ${L} = await ${L}\n`, G += `if(${L} !== undefined) { c.body = ${L}; used = true }\n`, S(), A !== 0)
            G += "}";
        }
        _.resolve();
      }
      if (G += "\ndelete c.contentType\n", J.parse.length)
        G += "if (!used) {";
      if (J.type && !Array.isArray(J.type))
        switch (J.type) {
          case "json":
          case "application/json":
            if (s(j.body))
              G += "try { c.body = await c.request.json() } catch {}";
            else
              G += "c.body = await c.request.json()";
            break;
          case "text":
          case "text/plain":
            G += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            G += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            G += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            G += `c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}\n`;
            break;
        }
      else
        G += `
					switch (contentType) {
						case 'application/json':
							${s(j.body) ? "try { c.body = await c.request.json() } catch {}" : "c.body = await c.request.json()"}
							break

						case 'text/plain':
							c.body = await c.request.text()
							break

						case 'application/x-www-form-urlencoded':
							c.body = parseQuery(await c.request.text())
							break

						case 'application/octet-stream':
							c.body = await c.request.arrayBuffer();
							break

						case 'multipart/form-data':
							c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}

							break
					}`;
      if (J.parse.length)
        G += "}";
      G += "}\n";
    }
    G += "\nisParsing = false\n";
  }
  if (A2.resolve(), J?.transform) {
    const N = b("transform", { total: J.transform.length });
    if (J.transform.length)
      G += "\nlet transformed\n";
    for (let _ = 0;_ < J.transform.length; _++) {
      const A = J.transform[_], S = N.resolveChild(A.fn.name);
      if (G += y(A) ? `transformed = await transform[${_}](c)\n` : `transformed = transform[${_}](c)\n`, A.subType === "mapDerive")
        G += `if(transformed?.[ELYSIA_RESPONSE])
					throw transformed
				else {
					transformed.request = c.request
					transformed.store = c.store
					transformed.qi = c.qi
					transformed.path = c.path
					transformed.url = c.url
					transformed.redirect = c.redirect
					transformed.set = c.set
					transformed.error = c.error

					c = transformed
			}`;
      else
        G += `if(transformed?.[ELYSIA_RESPONSE])
					throw transformed
				else
					Object.assign(c, transformed)\n`;
      S();
    }
    N.resolve();
  }
  if (j) {
    if (G += "\n", j.headers) {
      if (R && "Clean" in j.headers && !J0(j.headers))
        G += "c.headers = validator.headers.Clean(c.headers);\n";
      if (C0("default", j.headers.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(j.headers.schema, {}))) {
          const A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            G += `c.headers['${N}'] ??= ${A}\n`;
        }
      if (s(j.headers))
        G += "if(isNotEmpty(c.headers)) {";
      if (G += `if(validator.headers.Check(c.headers) === false) {
				${E("headers")}
			}`, S0(j.headers.schema))
        G += "c.headers = validator.headers.Decode(c.headers)\n";
      if (s(j.headers))
        G += "}";
    }
    if (j.params) {
      if (C0("default", j.params.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(j.params.schema, {}))) {
          const A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            G += `c.params['${N}'] ??= ${A}\n`;
        }
      if (G += `if(validator.params.Check(c.params) === false) {
				${E("params")}
			}`, S0(j.params.schema))
        G += "\nc.params = validator.params.Decode(c.params)\n";
    }
    if (j.query) {
      if (R && "Clean" in j.query && !J0(j.query))
        G += "c.query = validator.query.Clean(c.query);\n";
      if (C0("default", j.query.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(j.query.schema, {}))) {
          const A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
          if (A !== undefined)
            G += `if(c.query['${N}'] === undefined) c.query['${N}'] = ${A}\n`;
        }
      if (s(j.query))
        G += "if(isNotEmpty(c.query)) {";
      if (G += `if(validator.query.Check(c.query) === false) {
          		${E("query")}
			}`, S0(j.query.schema))
        G += "\nc.query = validator.query.Decode(Object.assign({}, c.query))\n";
      if (s(j.query))
        G += "}";
    }
    if (j.body) {
      if (R && "Clean" in j.body && !J0(j.body))
        G += "c.body = validator.body.Clean(c.body);\n";
      const N = S0(j.body.schema);
      if (N || s(j.body))
        G += '\nconst isNotEmptyObject = c.body && (typeof c.body === "object" && isNotEmpty(c.body))\n';
      if (C0("default", j.body.schema)) {
        const _ = exports_value2.Default(j.body.schema, j.body.schema.type === "object" ? {} : undefined), A = typeof _ === "object" ? JSON.stringify(_) : typeof _ === "string" ? `'${_}'` : _;
        if (G += `if(validator.body.Check(c.body) === false) {
					if (typeof c.body === 'object') {
						c.body = Object.assign(${A}, c.body)
					} else { c.body = ${A} }`, s(j.body))
          G += `
					    if(isNotEmptyObject && validator.body.Check(c.body) === false) {
            				${E("body")}
             			}
                    }`;
        else
          G += `
    				if(validator.body.Check(c.body) === false) {
        				${E("body")}
         			}
                }`;
      } else if (s(j.body))
        G += `if(isNotEmptyObject && validator.body.Check(c.body) === false) {
         			${E("body")}
          		}`;
      else
        G += `if(validator.body.Check(c.body) === false) {
         			${E("body")}
          		}`;
      if (N)
        G += "\nif(isNotEmptyObject) c.body = validator.body.Decode(c.body)\n";
    }
    if (n(H?.schema?.properties ?? H?.schema?.schema ?? {})) {
      if (G += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value\n`, C0("default", H.schema))
        for (let [N, _] of Object.entries(exports_value2.Default(H.schema, {})))
          G += `cookieValue['${N}'] = ${typeof _ === "object" ? JSON.stringify(_) : _}\n`;
      if (s(j.cookie))
        G += "if(isNotEmpty(c.cookie)) {";
      if (G += `if(validator.cookie.Check(cookieValue) === false) {
				${E("cookie", "cookieValue")}
			}`, S0(j.cookie.schema))
        G += `\nfor(const [key, value] of Object.entries(validator.cookie.Decode(cookieValue)))
					c.cookie[key].value = value\n`;
      if (s(j.cookie))
        G += "}";
    }
  }
  if (J?.beforeHandle) {
    const N = b("beforeHandle", { total: J.beforeHandle.length });
    let _ = false;
    for (let A = 0;A < J.beforeHandle.length; A++) {
      const S = J.beforeHandle[A], L = N.resolveChild(S.fn.name), a = E0(S);
      if (S.subType === "resolve" || S.subType === "mapResolve") {
        if (!_)
          _ = true, G += "\nlet resolved\n";
        if (G += y(S) ? `resolved = await beforeHandle[${A}](c);\n` : `resolved = beforeHandle[${A}](c);\n`, S.subType === "mapResolve")
          G += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else {
						resolved.request = c.request
						resolved.store = c.store
						resolved.qi = c.qi
						resolved.path = c.path
						resolved.url = c.url
						resolved.redirect = c.redirect
						resolved.set = c.set
						resolved.error = c.error

						c = resolved
					}`;
        else
          G += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else
						Object.assign(c, resolved)\n`;
      } else if (!a)
        G += y(S) ? `await beforeHandle[${A}](c);\n` : `beforeHandle[${A}](c);\n`, L();
      else {
        if (G += y(S) ? `be = await beforeHandle[${A}](c);\n` : `be = beforeHandle[${A}](c);\n`, L("be"), G += "if(be !== undefined) {\n", N.resolve(), J.afterHandle?.length) {
          b("handle", { name: B ? Q.name : undefined }).resolve();
          const h = b("afterHandle", { total: J.afterHandle.length });
          for (let G0 = 0;G0 < J.afterHandle.length; G0++) {
            const T0 = J.afterHandle[G0], O2 = E0(T0), V2 = h.resolveChild(T0.fn.name);
            if (G += "c.response = be\n", !O2)
              G += y(T0.fn) ? `await afterHandle[${G0}](c, be)\n` : `afterHandle[${G0}](c, be)\n`;
            else
              G += y(T0.fn) ? `af = await afterHandle[${G0}](c)\n` : `af = afterHandle[${G0}](c)\n`, G += "if(af !== undefined) { c.response = be = af }\n";
            V2("af");
          }
          h.resolve();
        }
        if (j.response)
          G += k("be");
        const U0 = b("mapResponse", { total: J.mapResponse.length });
        if (J.mapResponse.length) {
          G += "\nc.response = be\n";
          for (let h = 0;h < J.mapResponse.length; h++) {
            const G0 = J.mapResponse[h], T0 = U0.resolveChild(G0.fn.name);
            G += `\nif(mr === undefined) {
							mr = ${L0(G0) ? "await" : ""} onMapResponse[${h}](c)
							if(mr !== undefined) be = c.response = mr
						}\n`, T0();
          }
        }
        U0.resolve(), G += g, G += `return mapEarlyResponse(${e} be, c.set ${r})}\n`;
      }
    }
    N.resolve();
  }
  if (J?.afterHandle.length) {
    const N = b("handle", { name: B ? Q.name : undefined });
    if (J.afterHandle.length)
      G += Q0 ? `let r = c.response = await ${U};\n` : `let r = c.response = ${U};\n`;
    else
      G += Q0 ? `let r = await ${U};\n` : `let r = ${U};\n`;
    N.resolve();
    const _ = b("afterHandle", { total: J.afterHandle.length });
    for (let S = 0;S < J.afterHandle.length; S++) {
      const L = J.afterHandle[S], a = E0(L), q = _.resolveChild(L.fn.name);
      if (!a)
        G += y(L.fn) ? `await afterHandle[${S}](c)\n` : `afterHandle[${S}](c)\n`, q();
      else if (G += y(L.fn) ? `af = await afterHandle[${S}](c)\n` : `af = afterHandle[${S}](c)\n`, q("af"), j.response)
        G += "if(af !== undefined) {", _.resolve(), G += k("af"), G += "c.response = af }";
      else
        G += "if(af !== undefined) {", _.resolve(), G += "c.response = af}\n";
    }
    if (_.resolve(), G += "r = c.response\n", j.response)
      G += k();
    G += g;
    const A = b("mapResponse", { total: J.mapResponse.length });
    if (J.mapResponse.length)
      for (let S = 0;S < J.mapResponse.length; S++) {
        const L = J.mapResponse[S], a = A.resolveChild(L.fn.name);
        G += `\nmr = ${L0(L) ? "await" : ""} onMapResponse[${S}](c)
				if(mr !== undefined) r = c.response = mr\n`, a();
      }
    if (A.resolve(), s0)
      G += `return mapResponse(${e} r, c.set ${r})\n`;
    else
      G += `return mapCompactResponse(${e} r ${r})\n`;
  } else {
    const N = b("handle", { name: B ? Q.name : undefined });
    if (j.response || J.mapResponse.length) {
      if (G += Q0 ? `let r = await ${U};\n` : `let r = ${U};\n`, N.resolve(), j.response)
        G += k();
      b("afterHandle").resolve();
      const _ = b("mapResponse", { total: J.mapResponse.length });
      if (J.mapResponse.length) {
        G += "\nc.response = r\n";
        for (let A = 0;A < J.mapResponse.length; A++) {
          const S = J.mapResponse[A], L = _.resolveChild(S.fn.name);
          G += `\nif(mr === undefined) {
						mr = ${L0(S) ? "await" : ""} onMapResponse[${A}](c)
    					if(mr !== undefined) r = c.response = mr
					}\n`, L();
        }
      }
      if (_.resolve(), G += g, Q instanceof Response)
        G += K.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${e} ${U}.clone(), c.set ${r})
				else
					return ${U}.clone()` : `return ${U}.clone()`, G += "\n";
      else if (s0)
        G += `return mapResponse(${e} r, c.set ${r})\n`;
      else
        G += `return mapCompactResponse(${e} r ${r})\n`;
    } else if (O || F) {
      G += Q0 ? `let r = await ${U};\n` : `let r = ${U};\n`, N.resolve(), b("afterHandle").resolve();
      const _ = b("mapResponse", { total: J.mapResponse.length });
      if (J.mapResponse.length) {
        G += "\nc.response = r\n";
        for (let A = 0;A < J.mapResponse.length; A++) {
          const S = J.mapResponse[A], L = _.resolveChild(S.fn.name);
          G += `\nif(mr === undefined) {
							mr = ${L0(S) ? "await" : ""} onMapResponse[${A}](c)
    						if(mr !== undefined) r = c.response = mr
						}\n`, L();
        }
      }
      if (_.resolve(), G += g, s0)
        G += `return mapResponse(${e} r, c.set ${r})\n`;
      else
        G += `return mapCompactResponse(${e} r ${r})\n`;
    } else {
      N.resolve();
      const _ = Q0 ? `await ${U}` : U;
      if (b("afterHandle").resolve(), Q instanceof Response)
        G += K.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${e} ${U}.clone(), c.set ${r})
				else
					return ${U}.clone()` : `return ${U}.clone()`, G += "\n";
      else if (s0)
        G += `return mapResponse(${e} ${_}, c.set ${r})\n`;
      else
        G += `return mapCompactResponse(${e} ${_} ${r})\n`;
    }
  }
  if (G += "\n} catch(error) {", D)
    G += "\nif(isParsing) error = new ParseError()\n";
  if (!k0)
    G += "\nreturn (async () => {\n";
  if (G += "\nconst set = c.set\nif (!set.status || set.status < 300) set.status = error?.status || 500\n", F)
    for (let N = 0;N < J.trace.length; N++)
      G += `report${N}?.resolve(error);reportChild${N}?.(error);\n`;
  const U1 = b("error", { total: J.error.length });
  if (J.error.length) {
    G += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
				let er
			`;
    for (let N = 0;N < J.error.length; N++) {
      const _ = U1.resolveChild(J.error[N].fn.name);
      if (y(J.error[N]))
        G += `\ner = await handleErrors[${N}](c)\n`;
      else
        G += `\ner = handleErrors[${N}](c)\nif (er instanceof Promise) er = await er\n`;
      _();
      const A = b("mapResponse", { total: J.mapResponse.length });
      if (J.mapResponse.length)
        for (let S = 0;S < J.mapResponse.length; S++) {
          const L = J.mapResponse[S], a = A.resolveChild(L.fn.name);
          G += `\nc.response = er\n
							er = ${L0(L) ? "await" : ""} onMapResponse[${S}](c)
							if(er instanceof Promise) er = await er\n`, a();
        }
      if (A.resolve(), G += `er = mapEarlyResponse(er, set ${r})\n`, G += "if (er) {", F) {
        for (let S = 0;S < J.trace.length; S++)
          G += `\nreport${S}.resolve()\n`;
        U1.resolve();
      }
      G += "return er\n}\n";
    }
  }
  if (U1.resolve(), G += "return handleError(c, error, true)\n", !k0)
    G += "})()";
  if (G += "}", w || F) {
    if (G += " finally { ", !k0)
      G += ";(async () => {";
    const N = b("afterResponse", { total: J.afterResponse.length });
    if (w)
      for (let _ = 0;_ < J.afterResponse.length; _++) {
        const A = N.resolveChild(J.afterResponse[_].fn.name);
        G += `\nawait afterResponse[${_}](c);\n`, A();
      }
    if (N.resolve(), !k0)
      G += "})();";
    G += "}";
  }
  G = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			afterResponse,
			trace: _trace
		},
		validator,
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery,
			parseQueryFromURL,
			isNotEmpty
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError,
			ParseError
		},
		schema,
		definitions,
		ERROR_CODE,
		parseCookie,
		signCookie,
		decodeURIComponent,
		ELYSIA_RESPONSE,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer
	} = hooks

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)

	return ${k0 ? "async" : ""} function handle(c) {
		${J.beforeHandle.length ? "let be" : ""}
		${J.afterHandle.length ? "let af" : ""}
		${J.mapResponse.length ? "let mr" : ""}

		${Y ? "c.schema = schema; c.defs = definitions" : ""}
		${G}
	}`;
  try {
    return Function("hooks", G)({ handler: Q, hooks: S1(J), validator: j, handleError: $.handleError, utils: { mapResponse: f, mapCompactResponse: X0, mapEarlyResponse: v, parseQuery: i0, parseQueryFromURL: B1, isNotEmpty: n }, error: { NotFoundError: O0, ValidationError: T, InternalServerError: G1, ParseError: Y1 }, schema: $.router.history, definitions: $.definitions.type, ERROR_CODE: A0, parseCookie: $1, signCookie: g0, decodeURIComponent: z2.default, ELYSIA_RESPONSE: c, ELYSIA_TRACE: n0, ELYSIA_REQUEST_ID: I0, getServer: () => $.getServer() });
  } catch {
    const N = S1(J);
    console.log("[Composer] failed to generate optimized handler"), console.log("Please report the following to SaltyAom privately as it may include sensitive information about your codebase:"), console.log("---"), console.log({ handler: typeof Q === "function" ? Q.toString() : Q, hooks: { ...N, transform: N?.transform?.map?.((_) => _.toString()), resolve: N?.resolve?.map?.((_) => _.toString()), beforeHandle: N?.beforeHandle?.map?.((_) => _.toString()), afterHandle: N?.afterHandle?.map?.((_) => _.toString()), mapResponse: N?.mapResponse?.map?.((_) => _.toString()), parse: N?.parse?.map?.((_) => _.toString()), error: N?.error?.map?.((_) => _.toString()), afterResponse: N?.afterResponse?.map?.((_) => _.toString()), stop: N?.stop?.map?.((_) => _.toString()) }, validator: j, definitions: $.definitions.type }), console.log("---"), process.exit(1);
  }
};
var R1 = ($) => {
  const W = $.config.handler?.standardHostname ?? true;
  let X = "", Z = "";
  const J = $.setHeaders;
  for (let D of Object.keys($.singleton.decorator))
    X += `,${D}: app.singleton.decorator.${D}`;
  const j = $.router, Q = $.event.trace.length > 0;
  let Y = `
	const route = router.find(request.method, path) ${j.http.root.ALL ? '?? router.find("ALL", path)' : ""}

	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : $.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : "error404.clone()"}

	ctx.params = route.params\n`;
  Y += `if(route.store.handler) return route.store.handler(ctx)
	return (route.store.handler = route.store.compile())(ctx)\n`;
  let K = "";
  for (let [D, { code: M, all: P, static: I }] of Object.entries(j.static.http.map)) {
    if (I)
      K += `case '${D}':\nswitch(request.method) {\n${M}\n${P ?? "default: break map"}}\n\n`;
    K += `case '${D}':\nswitch(request.method) {\n${M}\n${P ?? "default: break map"}}\n\n`;
  }
  const B = $.event.request.some(y);
  if (Z += `const {
		app,
		mapEarlyResponse,
		NotFoundError,
		randomId,
		handleError,
		error,
		redirect,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID,
		getServer
	} = data

	const store = app.singleton.store
	const staticRouter = app.router.static.http
	const st = staticRouter.handlers
	const wsRouter = app.router.ws
	const router = app.router.http
	const trace = app.event.trace.map(x => typeof x === 'function' ? x : x.fn)

	const notFound = new NotFoundError()
	const hoc = app.extender.higherOrderFunctions.map(x => x.fn)

	${$.event.request.length ? "const onRequest = app.event.request.map(x => x.fn)" : ""}
	${$.event.error.length ? "" : `\nconst error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });\n`}

	${$.event.trace.length ? `const ${$.event.trace.map((D, M) => `tr${M} = app.event.trace[${M}].fn`).join(",")}` : ""}

	${B ? "async" : ""} function map(request) {\n`, $.event.request.length)
    Z += "let re";
  if (Z += `\nconst url = request.url
		const s = url.indexOf('/', ${W ? 11 : 7})
		const qi = url.indexOf('?', s + 1)
		let path
		if(qi === -1)
			path = url.substring(s)
		else
			path = url.substring(s, qi)\n`, Z += `${Q ? "const id = randomId()" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			url,
			redirect,
			set: {
				headers: ${Object.keys(J ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			},
			error
			${$.inference.server ? `, get server() {
							return getServer()
						}` : ""}
			${Q ? ",[ELYSIA_REQUEST_ID]: id" : ""}
			${X}
		}\n`, $.event.trace.length)
    Z += `\nctx[ELYSIA_TRACE] = [${$.event.trace.map((D, M) => `tr${M}(ctx)`).join(",")}]\n`;
  const w = H1({ context: "ctx", trace: $.event.trace, addFn(D) {
    Z += D;
  } })("request", { attribute: "ctx", total: $.event.request.length });
  if ($.event.request.length) {
    Z += "\n try {\n";
    for (let D = 0;D < $.event.request.length; D++) {
      const M = $.event.request[D], P = E0(M), I = y(M), O = w.resolveChild($.event.request[D].fn.name);
      if (P)
        Z += `re = mapEarlyResponse(
					${I ? "await" : ""} onRequest[${D}](ctx),
					ctx.set,
					request
				)\n`, O("re"), Z += "if(re !== undefined) return re\n";
      else
        Z += `${I ? "await" : ""} onRequest[${D}](ctx)\n`, O();
    }
    Z += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
  }
  w.resolve();
  const F = $.router.static.ws, G = $.router.ws;
  if (Object.keys(F).length || G.history.length) {
    Z += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (let [D, M] of Object.entries(F))
      Z += `
					case '${D}':
						if(request.headers.get('upgrade') === 'websocket')
							return st[${M}](ctx)

						break`;
    Z += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							if(route.store.handler)
							    return route.store.handler(ctx)

							return (route.store.handler = route.store.compile())(ctx)
						}
					}

					break
			}
		}\n`;
  }
  if (Z += `
		map: switch(path) {
			${K}

			default:
				break
		}

		${Y}
	}\n`, $.extender.higherOrderFunctions.length) {
    let D = "map";
    for (let M = 0;M < $.extender.higherOrderFunctions.length; M++)
      D = `hoc[${M}](${D}, request)`;
    Z += `return function hocMap(request) { return ${D}(request) }`;
  } else
    Z += "return map";
  const z = b1($);
  return $.handleError = z, Function("data", Z)({ app: $, mapEarlyResponse: v, NotFoundError: O0, randomId: j1, handleError: z, error: L1, redirect: c0, ELYSIA_TRACE: n0, ELYSIA_REQUEST_ID: I0, getServer: () => $.getServer() });
};
var b1 = ($) => {
  const W = $.event;
  let X = "";
  X += `const {
		app: { event: { error: onErrorContainer, afterResponse: resContainer, mapResponse: _onMapResponse, trace: _trace } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE,
		ELYSIA_TRACE,
		ELYSIA_REQUEST_ID
	} = inject

	const trace = _trace.map(x => typeof x === 'function' ? x : x.fn)
	const onMapResponse = []

	for(let i = 0; i < _onMapResponse.length; i++)
		onMapResponse.push(_onMapResponse[i].fn ?? _onMapResponse[i])

	delete _onMapResponse

	const onError = onErrorContainer.map(x => x.fn)
	const res = resContainer.map(x => x.fn)

	return ${$.event.error.find(y) || $.event.mapResponse.find(y) ? "async" : ""} function(context, error, skipGlobal) {`;
  const Z = $.event.trace.length > 0;
  if (Z)
    X += "\nconst id = context[ELYSIA_REQUEST_ID]\n";
  const J = H1({ context: "context", trace: W.trace, addFn: (Y) => {
    X += Y;
  } });
  X += `
		const set = context.set
		let r

		if(!context.code)
			context.code = error.code ?? error[ERROR_CODE]

		if(!(context.error instanceof Error))
			context.error = error

		if(typeof error === "object" && error && ELYSIA_RESPONSE in error) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}\n`;
  const j = Z || W.afterResponse.length > 0 || W.afterResponse.length > 0 ? "context.response = " : "";
  for (let Y = 0;Y < $.event.error.length; Y++) {
    const K = $.event.error[Y], B = `${y(K) ? "await " : ""}onError[${Y}](context)`;
    if (X += "\nif(skipGlobal !== true) {\n", E0(K)) {
      X += `r = ${B}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}

				if(set.status === 200) set.status = error.status\n`;
      const U = J("mapResponse", { total: W.mapResponse.length, name: "context" });
      if (W.mapResponse.length)
        for (let w = 0;w < W.mapResponse.length; w++) {
          const F = W.mapResponse[w], G = U.resolveChild(F.fn.name);
          X += `\ncontext.response = r
						r = ${L0(F) ? "await" : ""} onMapResponse[${w}](context)\n`, G();
        }
      U.resolve(), X += `return mapResponse(${j} r, set, context.request)}\n`;
    } else
      X += B + "\n";
    X += "\n}\n";
  }
  X += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 422
		return new Response(
			error.message,
			{
				headers: Object.assign(
					{ 'content-type': 'application/json'},
					set.headers
				),
				status: set.status
			}
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)\n`;
  const Q = J("mapResponse", { total: W.mapResponse.length, name: "context" });
  if (W.mapResponse.length)
    for (let Y = 0;Y < W.mapResponse.length; Y++) {
      const K = W.mapResponse[Y], B = Q.resolveChild(K.fn.name);
      X += `\ncontext.response = error
			error = ${L0(K) ? "await" : ""} onMapResponse[${Y}](context)\n`, B();
    }
  return Q.resolve(), X += `\nreturn mapResponse(${j} error, set, context.request)\n}\n}`, Function("inject", X)({ app: $, mapResponse: f, ERROR_CODE: A0, ELYSIA_RESPONSE: c, ELYSIA_TRACE: n0, ELYSIA_REQUEST_ID: I0 });
};
var x1 = ($) => async (W) => {
  const X = W.url, Z = X.indexOf("/", 11), J = X.indexOf("?", Z + 1), j = J === -1 ? X.substring(Z) : X.substring(Z, J), Q = { cookie: {}, status: 200, headers: {} }, Y = Object.assign({}, $.singleton.decorator, { set: Q, store: $.singleton.store, request: W, path: j, qi: J, redirect: c0 });
  try {
    for (let P = 0;P < $.event.request.length; P++) {
      const I = $.event.request[P].fn;
      let O = I(Y);
      if (O instanceof Promise)
        O = await O;
      if (O = v(O, Q), O)
        return Y.response = O;
    }
    const K = $.router.dynamic.find(W.method, j) ?? $.router.dynamic.find("ALL", j);
    if (!K)
      throw new O0;
    const { handle: B, hooks: U, validator: w, content: F } = K.store;
    let G;
    if (W.method !== "GET" && W.method !== "HEAD")
      if (F)
        switch (F) {
          case "application/json":
            G = await W.json();
            break;
          case "text/plain":
            G = await W.text();
            break;
          case "application/x-www-form-urlencoded":
            G = i0(await W.text());
            break;
          case "application/octet-stream":
            G = await W.arrayBuffer();
            break;
          case "multipart/form-data":
            G = {};
            const P = await W.formData();
            for (let I of P.keys()) {
              if (G[I])
                continue;
              const O = P.getAll(I);
              if (O.length === 1)
                G[I] = O[0];
              else
                G[I] = O;
            }
            break;
        }
      else {
        let P = W.headers.get("content-type");
        if (P) {
          const I = P.indexOf(";");
          if (I !== -1)
            P = P.slice(0, I);
          Y.contentType = P;
          for (let O = 0;O < U.parse.length; O++) {
            const H = U.parse[O].fn;
            let V = H(Y, P);
            if (V instanceof Promise)
              V = await V;
            if (V) {
              G = V;
              break;
            }
          }
          if (delete Y.contentType, G === undefined)
            switch (P) {
              case "application/json":
                G = await W.json();
                break;
              case "text/plain":
                G = await W.text();
                break;
              case "application/x-www-form-urlencoded":
                G = i0(await W.text());
                break;
              case "application/octet-stream":
                G = await W.arrayBuffer();
                break;
              case "multipart/form-data":
                G = {};
                const O = await W.formData();
                for (let H of O.keys()) {
                  if (G[H])
                    continue;
                  const V = O.getAll(H);
                  if (V.length === 1)
                    G[H] = V[0];
                  else
                    G[H] = V;
                }
                break;
            }
        }
      }
    Y.body = G, Y.params = K?.params || undefined, Y.query = J === -1 ? {} : B1(X.substring(J + 1)), Y.headers = {};
    for (let [P, I] of W.headers.entries())
      Y.headers[P] = I;
    const z = Object.assign({}, $.config?.cookie, w?.cookie?.config), D = W.headers.get("cookie");
    Y.cookie = await $1(Y.set, D, z ? { secrets: z.secrets !== undefined ? typeof z.secrets === "string" ? z.secrets : z.secrets.join(",") : undefined, sign: z.sign === true ? true : z.sign !== undefined ? typeof z.sign === "string" ? z.sign : z.sign.join(",") : undefined } : undefined);
    for (let P = 0;P < U.transform.length; P++) {
      const I = U.transform[P], O = I.fn(Y);
      if (I.subType === "derive")
        if (O instanceof Promise)
          Object.assign(Y, await O);
        else
          Object.assign(Y, O);
      else if (O instanceof Promise)
        await O;
    }
    if (w) {
      if (w.createHeaders?.()) {
        const P = {};
        for (let I in W.headers)
          P[I] = W.headers.get(I);
        if (w.headers.Check(P) === false)
          throw new T("header", w.headers, P);
      } else if (w.headers?.Decode)
        Y.headers = w.headers.Decode(Y.headers);
      if (w.createParams?.()?.Check(Y.params) === false)
        throw new T("params", w.params, Y.params);
      else if (w.params?.Decode)
        Y.params = w.params.Decode(Y.params);
      if (w.createQuery?.()?.Check(Y.query) === false)
        throw new T("query", w.query, Y.query);
      else if (w.query?.Decode)
        Y.query = w.query.Decode(Y.query);
      if (w.createCookie?.()) {
        let P = {};
        for (let [I, O] of Object.entries(Y.cookie))
          P[I] = O.value;
        if (w.cookie.Check(P) === false)
          throw new T("cookie", w.cookie, P);
        else if (w.cookie?.Decode)
          P = w.cookie.Decode(P);
      }
      if (w.createBody?.()?.Check(G) === false)
        throw new T("body", w.body, G);
      else if (w.body?.Decode)
        Y.body = w.body.Decode(G);
    }
    for (let P = 0;P < U.beforeHandle.length; P++) {
      let I = U.beforeHandle[P].fn(Y);
      if (I instanceof Promise)
        I = await I;
      if (I !== undefined) {
        Y.response = I;
        for (let H = 0;H < U.afterHandle.length; H++) {
          let V = U.afterHandle[H].fn(Y);
          if (V instanceof Promise)
            V = await V;
          if (V)
            I = V;
        }
        const O = v(I, Y.set);
        if (O)
          return Y.response = O;
      }
    }
    let M = B(Y);
    if (M instanceof Promise)
      M = await M;
    if (!U.afterHandle.length) {
      const P = M?.[c] ?? (Q.status ? typeof Q.status === "string" ? _0[Q.status] : Q.status : 200), I = w?.createResponse?.()?.[P];
      if (I?.Check(M) === false)
        throw new T("response", I, M);
      else if (I?.Decode)
        M = I.Decode(M);
    } else {
      Y.response = M;
      for (let P = 0;P < U.afterHandle.length; P++) {
        let I = U.afterHandle[P].fn(Y);
        if (I instanceof Promise)
          I = await I;
        const O = v(I, Y.set);
        if (O !== undefined) {
          const H = w?.response?.[O.status];
          if (H?.Check(O) === false)
            throw new T("response", H, O);
          else if (H?.Decode)
            M = H.Decode(M);
          return Y.response = O;
        }
      }
    }
    if (Y.set.cookie && z?.sign) {
      const P = !z.secrets ? undefined : typeof z.secrets === "string" ? z.secrets : z.secrets[0];
      if (z.sign === true)
        for (let [I, O] of Object.entries(Y.set.cookie))
          Y.set.cookie[I].value = await g0(O.value, "${secret}");
      else {
        const I = w?.cookie?.schema?.properties;
        for (let O of z.sign) {
          if (!(O in I))
            continue;
          if (Y.set.cookie[O]?.value)
            Y.set.cookie[O].value = await g0(Y.set.cookie[O].value, P);
        }
      }
    }
    return Y.response = f(M, Y.set);
  } catch (K) {
    if (K.status)
      Q.status = K.status;
    return $.handleError(Y, K);
  } finally {
    for (let K of $.event.afterResponse)
      await K.fn(Y);
  }
};
var P2 = ($) => async (W, X) => {
  const Z = Object.assign(W, { error: X, code: X.code });
  Z.set = W.set;
  for (let J = 0;J < $.event.error.length; J++) {
    let Q = $.event.error[J].fn(Z);
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return W.response = f(Q, W.set);
  }
  return new Response(typeof X.cause === "string" ? X.cause : X.message, { headers: W.set.headers, status: X.status ?? 500 });
};

class j0 {
  config;
  server = null;
  dependencies = {};
  _routes = {};
  _types = { Prefix: "", Scoped: false, Singleton: {}, Definitions: {}, Metadata: {} };
  _ephemeral = {};
  _volatile = {};
  static version = q1;
  version = q1;
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  get _scoped() {
    return this.config.scoped;
  }
  definitions = { type: {}, error: {} };
  extender = { macros: [], higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    return x0(x0(this.global, this.scoped), this.local);
  } };
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], afterResponse: [], trace: [], error: [], stop: [] };
  telemetry = { stack: undefined };
  router = { http: new M0, ws: new M0, dynamic: new M0, static: { http: { static: {}, handlers: [], map: {}, all: "" }, ws: {} }, history: [] };
  routeTree = new Map;
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false };
  getServer() {
    return this.server;
  }
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new C1;
    return this._promisedModules;
  }
  constructor($) {
    if ($?.tags)
      if (!$.detail)
        $.detail = { tags: $.tags };
      else
        $.detail.tags = $.tags;
    if (this.config = { nativeStaticResponse: true }, this.applyConfig($ ?? {}), $?.analytic && ($?.name || $?.seed !== undefined))
      this.telemetry.stack = new Error().stack;
  }
  env($, W = Bun?.env ?? process.env) {
    if (d($, { dynamic: true, additionalProperties: true, coerce: true }).Check(W) === false) {
      const Z = new T("env", $, W);
      throw new Error(Z.all.map((J) => J.summary).join("\n"));
    }
    return this;
  }
  wrap($) {
    return this.extender.higherOrderFunctions.push({ checksum: P0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), fn: $ }), this;
  }
  applyMacro($) {
    if (this.extender.macros.length) {
      const W = w2({ globalHook: this.event, localHook: $ }), X = { events: { global: this.event, local: $ }, onParse: W("parse"), onTransform: W("transform"), onBeforeHandle: W("beforeHandle"), onAfterHandle: W("afterHandle"), mapResponse: W("mapResponse"), onAfterResponse: W("afterResponse"), onError: W("error") };
      for (let Z of this.extender.macros)
        U2(Z.fn(X), $);
    }
  }
  applyConfig($) {
    return this.config = { prefix: "", aot: true, strictPath: false, global: false, analytic: false, normalize: true, ...$, cookie: { path: "/", ...$?.cookie }, experimental: $?.experimental ?? {}, seed: $?.seed === undefined ? "" : $?.seed }, this;
  }
  get models() {
    const $ = {};
    for (let [W, X] of Object.entries(this.definitions.type))
      $[W] = d(X);
    return $;
  }
  add($, W, X, Z, { allowMeta: J = false, skipPrefix: j = false } = { allowMeta: false, skipPrefix: false }) {
    if (Z = _2(Z), W !== "" && W.charCodeAt(0) !== 47)
      W = "/" + W;
    if (this.config.prefix && !j && !this.config.scoped)
      W = this.config.prefix + W;
    if (Z?.type)
      switch (Z.type) {
        case "text":
          Z.type = "text/plain";
          break;
        case "json":
          Z.type = "application/json";
          break;
        case "formdata":
          Z.type = "multipart/form-data";
          break;
        case "urlencoded":
          Z.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          Z.type = "application/octet-stream";
          break;
        default:
          break;
      }
    const Q = this.definitions.type, Y = !this.config.aot, K = { ...this.validator.getCandidate() }, B = { body: Z?.body ?? K?.body, headers: Z?.headers ?? K?.headers, params: Z?.params ?? K?.params, query: Z?.query ?? K?.query, cookie: Z?.cookie ?? K?.cookie, response: Z?.response ?? K?.response }, U = () => B.cookie ? X1({ validator: B.cookie, defaultConfig: this.config.cookie, config: B.cookie?.config ?? {}, dynamic: Y, models: Q }) : undefined, w = this.config.normalize, F = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? { body: d(B.body, { dynamic: Y, models: Q, normalize: w }), headers: d(B.headers, { dynamic: Y, models: Q, additionalProperties: !this.config.normalize, coerce: true, additionalCoerce: D0() }), params: d(B.params, { dynamic: Y, models: Q, coerce: true, additionalCoerce: D0() }), query: d(B.query, { dynamic: Y, models: Q, normalize: w, coerce: true, additionalCoerce: D0() }), cookie: U(), response: W1(B.response, { dynamic: Y, models: Q, normalize: w }) } : { createBody() {
      if (this.body)
        return this.body;
      return this.body = d(B.body, { dynamic: Y, models: Q, normalize: w });
    }, createHeaders() {
      if (this.headers)
        return this.headers;
      return this.headers = d(B.headers, { dynamic: Y, models: Q, additionalProperties: !w, coerce: true, additionalCoerce: D0() });
    }, createParams() {
      if (this.params)
        return this.params;
      return this.params = d(B.params, { dynamic: Y, models: Q, coerce: true, additionalCoerce: D0() });
    }, createQuery() {
      if (this.query)
        return this.query;
      return this.query = d(B.query, { dynamic: Y, models: Q, coerce: true, additionalCoerce: D0() });
    }, createCookie() {
      if (this.cookie)
        return this.cookie;
      return this.cookie = U();
    }, createResponse() {
      if (this.response)
        return this.response;
      return this.response = W1(B.response, { dynamic: Y, models: Q, normalize: w });
    } }, G = W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
    if (Z = i(Z, K), Z.tags)
      if (!Z.detail)
        Z.detail = { tags: Z.tags };
      else
        Z.detail.tags = Z.tags;
    if (n(this.config.detail))
      Z.detail = l(Object.assign({}, this.config.detail), Z.detail);
    this.applyMacro(Z);
    const z = i(this.event, Z);
    if (this.config.aot === false) {
      if (this.router.dynamic.add($, W, { validator: F, hooks: z, content: Z?.type, handle: X }), this.config.strictPath === false)
        this.router.dynamic.add($, G, { validator: F, hooks: z, content: Z?.type, handle: X });
      this.router.history.push({ method: $, path: W, composed: null, handler: X, hooks: z });
      return;
    }
    const D = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, M = d0(this.inference), P = typeof X !== "function" ? J2(X, z, this.setHeaders) : undefined;
    if (this.config.nativeStaticResponse === true && P && ($ === "GET" || $ === "ALL"))
      this.router.static.http.static[W] = P();
    const I = () => N2({ app: this, path: W, method: $, localHook: i(Z), hooks: z, validator: F, handler: X, allowMeta: J, inference: M }), O = D ? I() : (R) => {
      return I()(R);
    }, H = this.router.history.length;
    if (this.routeTree.has($ + W))
      for (let R = 0;R < this.router.history.length; R++) {
        const E = this.router.history[R];
        if (E.path === W && E.method === $) {
          const k = this.router.history.splice(R, 1)[0];
          if (k && this.routeTree.has(k?.method + k?.path))
            this.routeTree.delete(k.method + k.path);
        }
      }
    else
      this.routeTree.set($ + W, H);
    this.router.history.push({ method: $, path: W, composed: O, handler: X, hooks: z });
    const V = this.router.static.http, g = { handler: D ? O : undefined, compile: I };
    if ($ === "$INTERNALWS") {
      const R = this.config.strictPath ? undefined : W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/";
      if (W.indexOf(":") === -1 && W.indexOf("*") === -1) {
        const E = V.handlers.length;
        if (V.handlers.push((k) => (V.handlers[E] = I())(k)), this.router.static.ws[W] = E, R)
          this.router.static.ws[R] = E;
      } else if (this.router.ws.add("ws", W, g), R)
        this.router.ws.add("ws", R, g);
      return;
    }
    if (W.indexOf(":") === -1 && W.indexOf("*") === -1) {
      const R = V.handlers.length;
      if (V.handlers.push(P ?? ((k) => (V.handlers[R] = I())(k))), !V.map[W])
        V.map[W] = { code: "" };
      const E = P ? "" : "ctx";
      if ($ === "ALL")
        V.map[W].all = `default: return st[${R}](${E})\n`;
      else
        V.map[W].code = `case '${$}': return st[${R}](${E})\n${V.map[W].code}`;
      if (!this.config.strictPath) {
        if (!V.map[G])
          V.map[G] = { code: "" };
        if ($ === "ALL")
          V.map[G].all = `default: return st[${R}](${E})\n`;
        else
          V.map[G].code = `case '${$}': return st[${R}](${E})\n${V.map[G].code}`;
      }
    } else if (this.router.http.add($, W, g), !this.config.strictPath)
      this.router.http.add($, W.endsWith("/") ? W.slice(0, W.length - 1) : W + "/", g);
  }
  setHeaders;
  headers($) {
    if (!$)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = l(this.setHeaders, $), this;
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($, W) {
    if (!W)
      return this.on("parse", $);
    return this.on($, "parse", W);
  }
  onTransform($, W) {
    if (!W)
      return this.on("transform", $);
    return this.on($, "transform", W);
  }
  resolve($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "resolve", fn: W };
    return this.onBeforeHandle($, X);
  }
  mapResolve($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "mapResolve", fn: W };
    return this.onBeforeHandle($, X);
  }
  onBeforeHandle($, W) {
    if (!W)
      return this.on("beforeHandle", $);
    return this.on($, "beforeHandle", W);
  }
  onAfterHandle($, W) {
    if (!W)
      return this.on("afterHandle", $);
    return this.on($, "afterHandle", W);
  }
  mapResponse($, W) {
    if (!W)
      return this.on("mapResponse", $);
    return this.on($, "mapResponse", W);
  }
  onAfterResponse($, W) {
    if (!W)
      return this.on("afterResponse", $);
    return this.on($, "afterResponse", W);
  }
  trace($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    if (!Array.isArray(W))
      W = [W];
    for (let X of W)
      this.on($, "trace", M2(X));
    return this;
  }
  error($, W) {
    switch (typeof $) {
      case "string":
        return W.prototype[A0] = $, this.definitions.error[$] = W, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [X, Z] of Object.entries($))
      Z.prototype[A0] = X, this.definitions.error[X] = Z;
    return this;
  }
  onError($, W) {
    if (!W)
      return this.on("error", $);
    return this.on($, "error", W);
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, W, X) {
    let Z;
    switch (typeof $) {
      case "string":
        Z = $, X = W;
        break;
      case "object":
        if (Z = W, !Array.isArray(W) && typeof W === "object")
          X = W;
        break;
    }
    if (Array.isArray(X))
      X = t(X);
    else if (typeof X === "function")
      X = [{ fn: X }];
    else
      X = [X];
    const J = X;
    for (let j of J)
      j.scope = typeof $ === "string" ? "local" : $?.as ?? "local";
    if (Z !== "trace")
      r0({ [Z]: J.map((j) => j.fn) }, this.inference);
    for (let j of J) {
      const Q = K2(j, "global", { skipIfHasType: true });
      switch (Z) {
        case "start":
          this.event.start.push(Q);
          break;
        case "request":
          this.event.request.push(Q);
          break;
        case "parse":
          this.event.parse.push(Q);
          break;
        case "transform":
          this.event.transform.push(Q);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(Q);
          break;
        case "afterHandle":
          this.event.afterHandle.push(Q);
          break;
        case "mapResponse":
          this.event.mapResponse.push(Q);
          break;
        case "afterResponse":
          this.event.afterResponse.push(Q);
          break;
        case "trace":
          this.event.trace.push(Q);
          break;
        case "error":
          this.event.error.push(Q);
          break;
        case "stop":
          this.event.stop.push(Q);
          break;
      }
    }
    return this;
  }
  propagate() {
    return u(this.event.parse), u(this.event.transform), u(this.event.beforeHandle), u(this.event.afterHandle), u(this.event.mapResponse), u(this.event.afterResponse), u(this.event.trace), u(this.event.error), this;
  }
  as($) {
    const W = { plugin: "scoped", global: "global" }[$];
    if (u(this.event.parse, W), u(this.event.transform, W), u(this.event.beforeHandle, W), u(this.event.afterHandle, W), u(this.event.mapResponse, W), u(this.event.afterResponse, W), u(this.event.trace, W), u(this.event.error, W), $ === "plugin")
      this.validator.scoped = x0(this.validator.scoped, this.validator.local), this.validator.local = null;
    else if ($ === "global")
      this.validator.global = x0(this.validator.global, x0(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null;
    return this;
  }
  group($, W, X) {
    const Z = new j0({ ...this.config, prefix: "" });
    Z.singleton = { ...this.singleton }, Z.definitions = { ...this.definitions }, Z.getServer = () => this.getServer(), Z.inference = d0(this.inference), Z.extender = { ...this.extender };
    const J = typeof W === "object", j = (J ? X : W)(Z);
    if (this.singleton = l(this.singleton, Z.singleton), this.definitions = l(this.definitions, Z.definitions), j.event.request.length)
      this.event.request = [...this.event.request || [], ...j.event.request || []];
    if (j.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...j.event.mapResponse || []];
    return this.model(j.definitions.type), Object.values(Z.router.history).forEach(({ method: Q, path: Y, handler: K, hooks: B }) => {
      if (Y = (J ? "" : this.config.prefix) + $ + Y, J) {
        const U = W, w = B;
        this.add(Q, Y, K, i(U, { ...w || {}, error: !w.error ? j.event.error : Array.isArray(w.error) ? [...w.error || {}, ...j.event.error || {}] : [w.error, ...j.event.error || {}] }));
      } else
        this.add(Q, Y, K, i(B, { error: j.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, W) {
    if (!W) {
      if (typeof $ === "object") {
        this.applyMacro($);
        const J = $.as ?? "local";
        if (this.validator[J] = { body: $.body ?? this.validator[J]?.body, headers: $.headers ?? this.validator[J]?.headers, params: $.params ?? this.validator[J]?.params, query: $.query ?? this.validator[J]?.query, response: $.response ?? this.validator[J]?.response, cookie: $.cookie ?? this.validator[J]?.cookie }, $.parse)
          this.on({ as: J }, "parse", $.parse);
        if ($.transform)
          this.on({ as: J }, "transform", $.transform);
        if ($.beforeHandle)
          this.on({ as: J }, "beforeHandle", $.beforeHandle);
        if ($.afterHandle)
          this.on({ as: J }, "afterHandle", $.afterHandle);
        if ($.mapResponse)
          this.on({ as: J }, "mapResponse", $.mapResponse);
        if ($.afterResponse)
          this.on({ as: J }, "afterResponse", $.afterResponse);
        if ($.error)
          this.on({ as: J }, "error", $.error);
        if ($.detail)
          if (this.config.detail)
            this.config.detail = l(Object.assign({}, this.config.detail), $.detail);
          else
            this.config.detail = $.detail;
        if ($?.tags)
          if (!this.config.detail)
            this.config.detail = { tags: $.tags };
          else
            this.config.detail.tags = $.tags;
        return this;
      }
      return this.guard({}, $);
    }
    const X = new j0({ ...this.config, prefix: "" });
    X.singleton = { ...this.singleton }, X.definitions = { ...this.definitions }, X.inference = d0(this.inference), X.extender = { ...this.extender };
    const Z = W(X);
    if (this.singleton = l(this.singleton, X.singleton), this.definitions = l(this.definitions, X.definitions), Z.getServer = () => this.server, Z.event.request.length)
      this.event.request = [...this.event.request || [], ...Z.event.request || []];
    if (Z.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...Z.event.mapResponse || []];
    return this.model(Z.definitions.type), Object.values(X.router.history).forEach(({ method: J, path: j, handler: Q, hooks: Y }) => {
      this.add(J, j, Q, i($, { ...Y || {}, error: !Y.error ? Z.event.error : Array.isArray(Y.error) ? [...Y.error || {}, ...Z.event.error || []] : [Y.error, ...Z.event.error || []] }));
    }), this;
  }
  use($, W) {
    if (W?.scoped)
      return this.guard({}, (X) => X.use($));
    if (Array.isArray($)) {
      let X = this;
      for (let Z of $)
        X = this.use(Z);
      return X;
    }
    if ($ instanceof Promise)
      return this.promisedModules.add($.then((X) => {
        if (typeof X === "function")
          return X(this);
        if (X instanceof j0)
          return this._use(X).compile();
        if (typeof X.default === "function")
          return X.default(this);
        if (X.default instanceof j0)
          return this._use(X.default);
        throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
      }).then((X) => X.compile())), this;
    return this._use($);
  }
  _use($) {
    if (typeof $ === "function") {
      const J = $(this);
      if (J instanceof Promise)
        return this.promisedModules.add(J.then((j) => {
          if (j instanceof j0) {
            j.getServer = () => this.getServer(), j.getGlobalRoutes = () => this.getGlobalRoutes(), j.model(this.definitions.type), j.error(this.definitions.error);
            for (let { method: Q, path: Y, handler: K, hooks: B } of Object.values(j.router.history))
              this.add(Q, Y, K, i(B, { error: j.event.error }));
            return j.compile(), j;
          }
          if (typeof j === "function")
            return j(this);
          if (typeof j.default === "function")
            return j.default(this);
          return this._use(j);
        }).then((j) => j.compile())), this;
      return J;
    }
    const { name: W, seed: X } = $.config;
    $.getServer = () => this.getServer(), $.getGlobalRoutes = () => this.getGlobalRoutes(), $.model(this.definitions.type), $.error(this.definitions.error);
    const Z = $.config.scoped;
    if (Z) {
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const j = X !== undefined ? P0(W + JSON.stringify(X)) : 0;
        if (this.dependencies[W].some(({ checksum: Q }) => j === Q))
          return this;
        this.dependencies[W].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: j, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: j, dependencies: $.dependencies, stack: $.telemetry.stack, routes: $.router.history, decorators: $.singleton.decorator, store: $.singleton.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Q) => Q.subType === "derive").map((Q) => ({ fn: Q.fn.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Q) => Q.subType === "derive").map((Q) => ({ fn: Q.fn.toString(), stack: new Error().stack ?? "" })) });
      }
      $.extender.macros = this.extender.macros.concat($.extender.macros);
      const J = [];
      for (let j = 0;j < $.extender.macros.length; j++) {
        const Q = this.extender.macros[j];
        if (J.includes(Q.checksum))
          $.extender.macros.splice(j, 1), j--;
        J.push(Q.checksum);
      }
      if ($.onRequest((j) => {
        Object.assign(j, this.singleton.decorator), Object.assign(j.store, this.singleton.store);
      }), $.event.trace.length)
        $.event.trace.push(...$.event.trace);
      if (!$.config.prefix)
        console.warn("It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.");
      if ($.event.error.length)
        $.event.error.push(...this.event.error);
      if ($.config.aot)
        $.compile();
      if (Z === true && $.config.prefix) {
        this.mount($.config.prefix + "/", $.fetch);
        for (let j of $.router.history)
          this.routeTree.set(j.method + `${$.config.prefix}${j.path}`, this.router.history.length), this.router.history.push({ ...j, path: `${$.config.prefix}${j.path}`, hooks: i(j.hooks, { error: this.event.error }) });
      } else {
        this.mount($.fetch);
        for (let j of $.router.history)
          this.routeTree.set(j.method + `${$.config.prefix}${j.path}`, this.router.history.length), this.router.history.push({ ...j, path: `${$.config.prefix}${j.path}`, hooks: i(j.hooks, { error: this.event.error }) });
      }
      return this;
    } else {
      if (this.headers($.setHeaders), W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const j = X !== undefined ? P0(W + JSON.stringify(X)) : 0;
        if (!this.dependencies[W].some(({ checksum: Q }) => j === Q))
          this.extender.macros = this.extender.macros.concat($.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat($.extender.higherOrderFunctions);
      } else
        this.extender.macros = this.extender.macros.concat($.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat($.extender.higherOrderFunctions);
      Q1(this.extender.macros), Q1(this.extender.higherOrderFunctions);
      const J = [];
      for (let j = 0;j < this.extender.higherOrderFunctions.length; j++) {
        const Q = this.extender.higherOrderFunctions[j];
        if (Q.checksum) {
          if (J.includes(Q.checksum))
            this.extender.higherOrderFunctions.splice(j, 1), j--;
          J.push(Q.checksum);
        }
      }
      this.inference = { body: this.inference.body || $.inference.body, cookie: this.inference.cookie || $.inference.cookie, headers: this.inference.headers || $.inference.headers, query: this.inference.query || $.inference.query, set: this.inference.set || $.inference.set, server: this.inference.server || $.inference.server };
    }
    this.decorate($.singleton.decorator), this.state($.singleton.store), this.model($.definitions.type), this.error($.definitions.error), $.extender.macros = this.extender.macros.concat($.extender.macros);
    for (let { method: J, path: j, handler: Q, hooks: Y } of Object.values($.router.history))
      this.add(J, j, Q, i(Y, { error: $.event.error }));
    if (!Z)
      if (W) {
        if (!(W in this.dependencies))
          this.dependencies[W] = [];
        const J = X !== undefined ? P0(W + JSON.stringify(X)) : 0;
        if (this.dependencies[W].some(({ checksum: j }) => J === j))
          return this;
        this.dependencies[W].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies, stack: $.telemetry.stack, routes: $.router.history, decorators: $.singleton, store: $.singleton.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((j) => j?.subType === "derive").map((j) => ({ fn: j.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((j) => j?.subType === "resolve").map((j) => ({ fn: j.toString(), stack: new Error().stack ?? "" })) }), this.event = O1(this.event, V1($.event), J);
      } else
        this.event = O1(this.event, V1($.event));
    return this.validator.global = i(this.validator.global, { ...$.validator.global }), this.validator.local = i(this.validator.local, { ...$.validator.scoped }), this;
  }
  macro($) {
    const W = { checksum: P0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), fn: $ };
    return this.extender.macros.push(W), this;
  }
  mount($, W) {
    if ($ instanceof j0 || typeof $ === "function" || $.length === 0 || $ === "/") {
      const J = typeof $ === "function" ? $ : $ instanceof j0 ? $.compile().fetch : W instanceof j0 ? W.compile().fetch : W, j = async ({ request: Q, path: Y }) => {
        if (Q.method === "GET" || Q.method === "HEAD" || !Q.headers.get("content-type"))
          return J(new Request(b0(Q.url, Y || "/"), Q));
        return J(new Request(b0(Q.url, Y || "/"), { ...Q, body: await Q.arrayBuffer() }));
      };
      return this.all("/*", j, { type: "none" }), this;
    }
    const X = $.length;
    if (W instanceof j0)
      W = W.compile().fetch;
    const Z = async ({ request: J, path: j }) => {
      if (J.method === "GET" || J.method === "HEAD" || !J.headers.get("content-type"))
        return W(new Request(b0(J.url, j.slice(X) || "/"), J));
      return W(new Request(b0(J.url, j.slice(X) || "/"), { ...J, body: await J.arrayBuffer() }));
    };
    return this.all($, Z, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), Z, { type: "none" }), this;
  }
  get($, W, X) {
    return this.add("GET", $, W, X), this;
  }
  post($, W, X) {
    return this.add("POST", $, W, X), this;
  }
  put($, W, X) {
    return this.add("PUT", $, W, X), this;
  }
  patch($, W, X) {
    return this.add("PATCH", $, W, X), this;
  }
  delete($, W, X) {
    return this.add("DELETE", $, W, X), this;
  }
  options($, W, X) {
    return this.add("OPTIONS", $, W, X), this;
  }
  all($, W, X) {
    return this.add("ALL", $, W, X), this;
  }
  head($, W, X) {
    return this.add("HEAD", $, W, X), this;
  }
  connect($, W, X) {
    return this.add("CONNECT", $, W, X), this;
  }
  route($, W, X, Z) {
    return this.add($.toUpperCase(), W, X, Z, Z?.config), this;
  }
  ws($, W) {
    const X = W.transformMessage ? Array.isArray(W.transformMessage) ? W.transformMessage : [W.transformMessage] : undefined;
    let Z = null;
    const J = d(W?.body, { models: this.definitions.type, normalize: this.config.normalize }), j = d(W?.response, { models: this.definitions.type, normalize: this.config.normalize }), Q = (Y) => {
      if (typeof Y === "string") {
        const K = Y?.charCodeAt(0);
        if (K === 47 || K === 123)
          try {
            Y = JSON.parse(Y);
          } catch {
          }
        else if (J1(Y))
          Y = +Y;
      }
      if (X?.length)
        for (let K = 0;K < X.length; K++) {
          const B = X[K](Y);
          if (B !== undefined)
            Y = B;
        }
      return Y;
    };
    return this.route("$INTERNALWS", $, (Y) => {
      const { set: K, path: B, qi: U, headers: w, query: F, params: G } = Y;
      if (Z === null)
        Z = this.getServer();
      if (Z?.upgrade(Y.request, { headers: typeof W.upgrade === "function" ? W.upgrade(Y) : W.upgrade, data: { validator: j, open(z) {
        W.open?.(new f0(z, Y));
      }, message: (z, D) => {
        const M = Q(D);
        if (J?.Check(M) === false)
          return void z.send(new T("message", J, M).message);
        W.message?.(new f0(z, Y), M);
      }, drain(z) {
        W.drain?.(new f0(z, Y));
      }, close(z, D, M) {
        W.close?.(new f0(z, Y), D, M);
      } } }))
        return;
      return K.status = 400, "Expected a websocket connection";
    }, { beforeHandle: W.beforeHandle, transform: W.transform, headers: W.headers, params: W.params, query: W.query }), this;
  }
  state($, W, X) {
    if (W === undefined)
      X = $, $ = { as: "append" }, W = "";
    else if (X === undefined) {
      if (typeof $ === "string")
        X = W, W = $, $ = { as: "append" };
      else if (typeof $ === "object")
        X = W, W = "";
    }
    const { as: Z } = $;
    if (typeof W !== "string")
      return this;
    switch (typeof X) {
      case "object":
        if (W) {
          if (W in this.singleton.store)
            this.singleton.store[W] = l(this.singleton.store[W], X, { override: Z === "override" });
          else
            this.singleton.store[W] = X;
          return this;
        }
        if (X === null)
          return this;
        return this.singleton.store = l(this.singleton.store, X, { override: Z === "override" }), this;
      case "function":
        if (W) {
          if (Z === "override" || !(W in this.singleton.store))
            this.singleton.store[W] = X;
        } else
          this.singleton.store = X(this.singleton.store);
        return this;
      default:
        if (Z === "override" || !(W in this.singleton.store))
          this.singleton.store[W] = X;
        return this;
    }
  }
  decorate($, W, X) {
    if (W === undefined)
      X = $, $ = { as: "append" }, W = "";
    else if (X === undefined) {
      if (typeof $ === "string")
        X = W, W = $, $ = { as: "append" };
      else if (typeof $ === "object")
        X = W, W = "";
    }
    const { as: Z } = $;
    if (typeof W !== "string")
      return this;
    switch (typeof X) {
      case "object":
        if (W) {
          if (W in this.singleton.decorator)
            this.singleton.decorator[W] = l(this.singleton.decorator[W], X, { override: Z === "override" });
          else
            this.singleton.decorator[W] = X;
          return this;
        }
        if (X === null)
          return this;
        return this.singleton.decorator = l(this.singleton.decorator, X, { override: Z === "override" }), this;
      case "function":
        if (W) {
          if (Z === "override" || !(W in this.singleton.decorator))
            this.singleton.decorator[W] = X;
        } else
          this.singleton.decorator = X(this.singleton.decorator);
        return this;
      default:
        if (Z === "override" || !(W in this.singleton.decorator))
          this.singleton.decorator[W] = X;
        return this;
    }
  }
  derive($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "derive", fn: W };
    return this.onTransform($, X);
  }
  model($, W) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([X, Z]) => {
          if (!(X in this.definitions.type))
            this.definitions.type[X] = Z;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = W, this;
  }
  mapDerive($, W) {
    if (!W)
      W = $, $ = { as: "local" };
    const X = { subType: "mapDerive", fn: W };
    return this.onTransform($, X);
  }
  affix($, W, X) {
    if (X === "")
      return this;
    const Z = ["_", "-", " "], J = (K) => K[0].toUpperCase() + K.slice(1), j = $ === "prefix" ? (K, B) => Z.includes(K.at(-1) ?? "") ? K + B : K + J(B) : Z.includes(X.at(-1) ?? "") ? (K, B) => B + K : (K, B) => B + J(K), Q = (K) => {
      const B = {};
      switch (K) {
        case "decorator":
          for (let U in this.singleton.decorator)
            B[j(X, U)] = this.singleton.decorator[U];
          this.singleton.decorator = B;
          break;
        case "state":
          for (let U in this.singleton.store)
            B[j(X, U)] = this.singleton.store[U];
          this.singleton.store = B;
          break;
        case "model":
          for (let U in this.definitions.type)
            B[j(X, U)] = this.definitions.type[U];
          this.definitions.type = B;
          break;
        case "error":
          for (let U in this.definitions.error)
            B[j(X, U)] = this.definitions.error[U];
          this.definitions.error = B;
          break;
      }
    }, Y = Array.isArray(W) ? W : [W];
    for (let K of Y.some((B) => B === "all") ? ["decorator", "state", "model", "error"] : Y)
      Q(K);
    return this;
  }
  prefix($, W) {
    return this.affix("prefix", $, W);
  }
  suffix($, W) {
    return this.affix("suffix", $, W);
  }
  compile() {
    if (this.fetch = this.config.aot ? R1(this) : x1(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server || {}, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => {
    return (this.fetch = this.config.aot ? R1(this) : x1(this))($);
  };
  handleError = async ($, W) => (this.handleError = this.config.aot ? b1(this) : P2(this))($, W);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, W) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.compile(), typeof $ === "string") {
      if (!J1($))
        throw new Error("Port must be a numeric value");
      $ = parseInt($);
    }
    const X = this.fetch, Z = typeof $ === "object" ? { development: !p0, reusePort: true, ...this.config.serve || {}, ...$ || {}, static: this.router.static.http.static, websocket: { ...this.config.websocket || {}, ...T1 || {} }, fetch: X, error: this.outerErrorHandler } : { development: !p0, reusePort: true, ...this.config.serve || {}, static: this.router.static.http.static, websocket: { ...this.config.websocket || {}, ...T1 || {} }, port: $, fetch: X, error: this.outerErrorHandler };
    this.server = Bun?.serve(Z);
    for (let J = 0;J < this.event.start.length; J++)
      this.event.start[J].fn(this);
    if (W)
      W(this.server);
    return process.on("beforeExit", () => {
      if (this.server) {
        this.server.stop(), this.server = null;
        for (let J = 0;J < this.event.stop.length; J++)
          this.event.stop[J].fn(this);
      }
    }), this.promisedModules.then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server) {
      if (this.server.stop(), this.server = null, this.event.stop.length)
        for (let $ = 0;$ < this.event.stop.length; $++)
          this.event.stop[$].fn(this);
    }
  };
  get modules() {
    return Promise.all(this.promisedModules.promises);
  }
}

// node_modules/logestic/dist/index.js
import process2 from "process";
import os from "os";
import tty from "tty";
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, { streamIsTTY: stream && stream.isTTY, ...options });
  return translateLevel(level);
}
function stringReplaceAll(string7, substring, replacer) {
  let index = string7.indexOf(substring);
  if (index === -1)
    return string7;
  const substringLength = substring.length;
  let endIndex = 0, returnValue = "";
  do
    returnValue += string7.slice(endIndex, index) + substring + replacer, endIndex = index + substringLength, index = string7.indexOf(substring, endIndex);
  while (index !== -1);
  return returnValue += string7.slice(endIndex), returnValue;
}
function stringEncaseCRLFWithFirstIndex(string7, prefix, postfix, index) {
  let endIndex = 0, returnValue = "";
  do {
    const gotCR = string7[index - 1] === "\r";
    returnValue += string7.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix, endIndex = index + 1, index = string7.indexOf("\n", endIndex);
  } while (index !== -1);
  return returnValue += string7.slice(endIndex), returnValue;
}
function removeAnsi(text) {
  return text.replace(/\u001b\[\d*m/g, "").trimStart();
}
import fs from "fs";
var assembleStyles = function() {
  const codes = new Map;
  for (let [groupName, group] of Object.entries(styles)) {
    for (let [styleName, style] of Object.entries(group))
      styles[styleName] = { open: `\x1B[${style[0]}m`, close: `\x1B[${style[1]}m` }, group[styleName] = styles[styleName], codes.set(style[0], style[1]);
    Object.defineProperty(styles, groupName, { value: group, enumerable: false });
  }
  return Object.defineProperty(styles, "codes", { value: codes, enumerable: false }), styles.color.close = "\x1B[39m", styles.bgColor.close = "\x1B[49m", styles.color.ansi = wrapAnsi16(), styles.color.ansi256 = wrapAnsi256(), styles.color.ansi16m = wrapAnsi16m(), styles.bgColor.ansi = wrapAnsi16(10), styles.bgColor.ansi256 = wrapAnsi256(10), styles.bgColor.ansi16m = wrapAnsi16m(10), Object.defineProperties(styles, { rgbToAnsi256: { value(red, green, blue) {
    if (red === green && green === blue) {
      if (red < 8)
        return 16;
      if (red > 248)
        return 231;
      return Math.round((red - 8) / 247 * 24) + 232;
    }
    return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
  }, enumerable: false }, hexToRgb: { value(hex) {
    const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
    if (!matches)
      return [0, 0, 0];
    let [colorString] = matches;
    if (colorString.length === 3)
      colorString = [...colorString].map((character) => character + character).join("");
    const integer4 = Number.parseInt(colorString, 16);
    return [integer4 >> 16 & 255, integer4 >> 8 & 255, integer4 & 255];
  }, enumerable: false }, hexToAnsi256: { value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)), enumerable: false }, ansi256ToAnsi: { value(code) {
    if (code < 8)
      return 30 + code;
    if (code < 16)
      return 90 + (code - 8);
    let red, green, blue;
    if (code >= 232)
      red = ((code - 232) * 10 + 8) / 255, green = red, blue = red;
    else {
      code -= 16;
      const remainder = code % 36;
      red = Math.floor(code / 36) / 5, green = Math.floor(remainder / 6) / 5, blue = remainder % 6 / 5;
    }
    const value15 = Math.max(red, green, blue) * 2;
    if (value15 === 0)
      return 30;
    let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
    if (value15 === 2)
      result += 60;
    return result;
  }, enumerable: false }, rgbToAnsi: { value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)), enumerable: false }, hexToAnsi: { value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)), enumerable: false } }), styles;
};
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;
var hasFlag = function(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", position = argv.indexOf(prefix + flag), terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
var envForceColor = function() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true")
      return 1;
    if (env.FORCE_COLOR === "false")
      return 0;
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
};
var translateLevel = function(level) {
  if (level === 0)
    return false;
  return { level, hasBasic: true, has256: level >= 2, has16m: level >= 3 };
};
var _supportsColor = function(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined)
    flagForceColor = noFlagForceColor;
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0)
    return 0;
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor"))
      return 3;
    if (hasFlag("color=256"))
      return 2;
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env)
    return 1;
  if (haveStream && !streamIsTTY && forceColor === undefined)
    return 0;
  const min = forceColor || 0;
  if (env.TERM === "dumb")
    return min;
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586)
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    return 1;
  }
  if ("CI" in env) {
    if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env)
      return 3;
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship")
      return 1;
    return min;
  }
  if ("TEAMCITY_VERSION" in env)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  if (env.COLORTERM === "truecolor")
    return 3;
  if (env.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app":
        return version >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  if (/-256(color)?$/i.test(env.TERM))
    return 2;
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM))
    return 1;
  if ("COLORTERM" in env)
    return 1;
  return min;
};
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never"))
  flagForceColor = 0;
else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always"))
  flagForceColor = 1;
var supportsColor = { stdout: createSupportsColor({ isTTY: tty.isatty(1) }), stderr: createSupportsColor({ isTTY: tty.isatty(2) }) };
var supports_color_default = supportsColor;
var createChalk = function(options) {
  return chalkFactory(options);
};
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
var styles2 = Object.create(null);
var applyOptions = (object13, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object13.level = options.level === undefined ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk = (...strings) => strings.join(" ");
  return applyOptions(chalk, options), Object.setPrototypeOf(chalk, createChalk.prototype), chalk;
};
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (let [styleName, style] of Object.entries(ansi_styles_default))
  styles2[styleName] = { get() {
    const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
    return Object.defineProperty(this, styleName, { value: builder }), builder;
  } };
styles2.visible = { get() {
  const builder = createBuilder(this, this[STYLER], true);
  return Object.defineProperty(this, "visible", { value: builder }), builder;
} };
var getModelAnsi = (model, level, type47, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m")
      return ansi_styles_default[type47].ansi16m(...arguments_);
    if (level === "ansi256")
      return ansi_styles_default[type47].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    return ansi_styles_default[type47].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex")
    return getModelAnsi("rgb", level, type47, ...ansi_styles_default.hexToRgb(...arguments_));
  return ansi_styles_default[type47][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (let model of usedModels) {
  styles2[model] = { get() {
    const { level } = this;
    return function(...arguments_) {
      const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
      return createBuilder(this, styler, this[IS_EMPTY]);
    };
  } };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = { get() {
    const { level } = this;
    return function(...arguments_) {
      const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
      return createBuilder(this, styler, this[IS_EMPTY]);
    };
  } };
}
var proto = Object.defineProperties(() => {
}, { ...styles2, level: { enumerable: true, get() {
  return this[GENERATOR].level;
}, set(level) {
  this[GENERATOR].level = level;
} } });
var createStyler = (open, close, parent) => {
  let openAll, closeAll;
  if (parent === undefined)
    openAll = open, closeAll = close;
  else
    openAll = parent.openAll + open, closeAll = close + parent.closeAll;
  return { open, close, openAll, closeAll, parent };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  return Object.setPrototypeOf(builder, proto), builder[GENERATOR] = self2, builder[STYLER] = _styler, builder[IS_EMPTY] = _isEmpty, builder;
};
var applyStyle = (self2, string7) => {
  if (self2.level <= 0 || !string7)
    return self2[IS_EMPTY] ? "" : string7;
  let styler = self2[STYLER];
  if (styler === undefined)
    return string7;
  const { openAll, closeAll } = styler;
  if (string7.includes("\x1B"))
    while (styler !== undefined)
      string7 = stringReplaceAll(string7, styler.close, styler.open), styler = styler.parent;
  const lfIndex = string7.indexOf("\n");
  if (lfIndex !== -1)
    string7 = stringEncaseCRLFWithFirstIndex(string7, closeAll, openAll, lfIndex);
  return openAll + string7 + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;
var buildAttrs = (ctx, reqAttrs, timeStart) => {
  const { request, path, body, query, set: set2 } = ctx;
  let attrs = {};
  for (let key of reqAttrs)
    switch (key) {
      case "ip":
        attrs.ip = request.headers.get("x-forwarded-for") || "<ip?>";
        break;
      case "method":
        attrs.method = request.method;
        break;
      case "path":
        attrs.path = path;
        break;
      case "body":
        attrs.body = body;
        break;
      case "query":
        attrs.query = query;
        break;
      case "time":
        attrs.time = new Date;
        break;
      case "contentLength":
        attrs.contentLength = Number(request.headers.get("content-length"));
        break;
      case "status":
        if (!set2.status)
          break;
        attrs.status = typeof set2.status === "number" ? set2.status : _0[set2.status];
        break;
      case "referer":
        attrs.referer = request.headers.get("referer") || "<referer?>";
        break;
      case "userAgent":
        attrs.userAgent = request.headers.get("user-agent") || "<user-agent?>";
        break;
      case "duration":
        const now = process.hrtime.bigint();
        attrs.duration = (now - timeStart) / 1000n;
        break;
    }
  return attrs;
};
var colourLogType = (type47, colourDef) => {
  let bgColour = source_default.bgBlack;
  switch (type47) {
    case "http":
      bgColour = colourDef[type47] && source_default.hex(colourDef[type47]) || source_default.bgBlue;
      break;
    case "info":
      bgColour = colourDef[type47] && source_default.hex(colourDef[type47]) || source_default.bgGreen;
      break;
    case "warn":
      bgColour = colourDef[type47] && source_default.hex(colourDef[type47]) || source_default.bgYellow;
      break;
    case "debug":
      bgColour = colourDef[type47] && source_default.hex(colourDef[type47]) || source_default.bgCyan;
      break;
    case "error":
      bgColour = colourDef[type47] && source_default.hex(colourDef[type47]) || source_default.bgRed;
      break;
  }
  const withSpaces = ` ${type47.toUpperCase()} `;
  return bgColour?.(withSpaces) ?? withSpaces;
};
var common_default = (options) => new Logestic(options).use(["time", "method", "path", "status"]).format({ onSuccess({ time, method, path, status }) {
  const grayTime = source_default.gray(`${time.toISOString()}`), methodPath = source_default.cyan(`${method} ${path}`);
  let statusColor = source_default.white;
  if (200 <= status && status < 300)
    statusColor = source_default.green;
  if (400 <= status && status < 500)
    statusColor = source_default.yellow;
  if (500 <= status)
    statusColor = source_default.red;
  return `[${grayTime}] ${methodPath} ${statusColor(status)}`;
}, onFailure({ request, error: error22, code, datetime }) {
  const grayTime = source_default.gray(`${datetime.toISOString()}`), msg = source_default.red(`${request.method} ${request.url} ${error22.message} ${code}`);
  return `[${grayTime}] ${msg}`;
} });
var getDateTimeString = (date5) => {
  const year = date5.getFullYear(), month = date5.getMonth() + 1, day = date5.getDate(), hours = date5.getHours(), minutes = date5.getMinutes(), seconds = date5.getSeconds();
  return `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
};
var defaultOptions = { showLevel: true };
var fancy_default = (options) => new Logestic({ ...defaultOptions, ...options }).use(["time", "method", "path", "duration"]).format({ onSuccess({ time, method, path, duration }) {
  const dateTime = source_default.gray(getDateTimeString(time)), methodPath = source_default.cyan(`${method} ${path}`);
  return `${dateTime} ${methodPath} ${duration}\u03BCs`;
}, onFailure({ request, datetime }) {
  const dateTime = getDateTimeString(datetime);
  return source_default.red(`${dateTime} ${request.method} ${request.url}`);
} });
var commontz_default = (options) => new Logestic(options).use(["time", "method", "path", "status"]).format({ onSuccess({ time, method, path, status }) {
  const grayTime = source_default.gray(`${time.toString()}`), methodPath = source_default.cyan(`${method} ${path}`);
  let statusColor = source_default.white;
  if (200 <= status && status < 300)
    statusColor = source_default.green;
  if (400 <= status && status < 500)
    statusColor = source_default.yellow;
  if (500 <= status)
    statusColor = source_default.red;
  return `[${grayTime}] ${methodPath} ${statusColor(status)}`;
}, onFailure({ request, error: error22, code, datetime }) {
  const grayTime = source_default.gray(`${datetime.toString()}`), msg = source_default.red(`${request.method} ${request.url} ${error22.message} ${code}`);
  return `[${grayTime}] ${msg}`;
} });
var getPreset = (preset) => {
  switch (preset) {
    case "common":
      return common_default;
    case "fancy":
      return fancy_default;
    case "commontz":
      return commontz_default;
  }
};
class Logestic {
  requestedAttrs;
  dest;
  showLevel;
  logLevelColour;
  httpLogging;
  explicitLogging;
  constructor(options = {}) {
    this.requestedAttrs = [], this.showLevel = options.showLevel || false, this.logLevelColour = options.logLevelColour || {}, this.httpLogging = options.httpLogging || true, this.explicitLogging = options.explicitLogging || true, this.setDest(options.dest || Bun.stdout);
  }
  setDest(dest) {
    if (dest === Bun.stdin)
      throw new Error("Cannot log to stdin. Please provide a writable destination.");
    if (dest === Bun.stdout || dest === Bun.stderr) {
      this.dest = dest;
      return;
    }
    this.createFileIfNotExists(dest).then((file) => this.dest = file).catch((err) => {
      throw err;
    });
  }
  async createFileIfNotExists(dest) {
    if (!await dest.exists())
      Bun.write(dest, "");
    return dest;
  }
  use(attrs) {
    if (Array.isArray(attrs)) {
      for (let attr of attrs)
        this._use(attr);
      return this;
    }
    return this._use(attrs), this;
  }
  _use(attr) {
    this.requestedAttrs.push(attr);
  }
  static preset(name, options = {}) {
    return getPreset(name)(options);
  }
  build() {
    return new j0({ name: "logestic" }).decorate("logestic", this);
  }
  format(formatAttr) {
    return this.build().state("logestic_timeStart", 0n).onRequest(({ store, request }) => {
      if (store.logestic_timeStart = process.hrtime.bigint(), formatAttr.onRequest) {
        let msg = formatAttr.onRequest(request);
        if (this.showLevel)
          msg = `${colourLogType("http", this.logLevelColour)} ${msg}`;
        this.log(msg);
      }
    }).onAfterResponse({ as: "global" }, (ctx) => {
      if (!this.httpLogging)
        return;
      const { store: { logestic_timeStart } } = ctx;
      let attrs = buildAttrs(ctx, this.requestedAttrs, logestic_timeStart), msg = formatAttr.onSuccess(attrs);
      if (this.showLevel)
        msg = `${colourLogType("http", this.logLevelColour)} ${msg}`;
      this.log(msg);
    }).onError({ as: "global" }, ({ request, error: error22, code }) => {
      let datetime = new Date, msg = formatAttr.onFailure({ request, error: error22, code, datetime });
      if (this.showLevel)
        msg = `${colourLogType("error", this.logLevelColour)} ${msg}`;
      this.log(msg);
    });
  }
  async log(msg) {
    if (!msg || msg === "")
      return;
    const msgNewLine = `${msg}\n`;
    if (!this.dest.name || !this.dest.name.length) {
      Bun.write(this.dest, msgNewLine);
      return;
    }
    const sanitised = removeAnsi(msgNewLine);
    fs.appendFile(this.dest.name, sanitised, (err) => {
      if (err)
        throw err;
    });
  }
  info(msg) {
    if (!this.explicitLogging)
      return;
    let _msg = msg;
    if (this.showLevel)
      _msg = `${colourLogType("info", this.logLevelColour)} ${msg}`;
    this.log(_msg);
  }
  warn(msg) {
    if (!this.explicitLogging)
      return;
    let _msg = msg;
    if (this.showLevel)
      _msg = `${colourLogType("warn", this.logLevelColour)} ${msg}`;
    this.log(_msg);
  }
  debug(msg) {
    if (!this.explicitLogging)
      return;
    let _msg = msg;
    if (this.showLevel)
      _msg = `${colourLogType("debug", this.logLevelColour)} ${msg}`;
    this.log(_msg);
  }
  error(msg) {
    if (!this.explicitLogging)
      return;
    let _msg = msg;
    if (this.showLevel)
      _msg = `${colourLogType("error", this.logLevelColour)} ${msg}`;
    this.log(_msg);
  }
}

// src/libs/logger.ts
var logger_default = Logestic.preset("fancy");

// src/constants/exceptions.ts
class BadGatewayException extends Error {
  code = "BAD_GATEWAY";
  status = 502;
  constructor(message) {
    super(message ?? "The upstream server returned an invalid response.");
    this.name = "BAD_GATEWAY";
  }
}

class BadRequestException extends Error {
  code = "BAD_REQUEST";
  status = 400;
  constructor(message) {
    super(message ?? "The request is invalid. Please check the data you've entered.");
    this.name = "BAD_REQUEST";
  }
}

class ConflictException extends Error {
  code = "CONFLICT";
  status = 409;
  constructor(message) {
    super(message ?? "The request could not be completed due to a conflict with the current state of the target resource.");
    this.name = "CONFLICT";
  }
}

class ForbiddenException extends Error {
  code = "FORBIDDEN";
  status = 403;
  constructor(message) {
    super(message ?? "You do not have access rights to this resource. Please check your permissions.");
    this.name = "FORBIDDEN";
  }
}

class ImATeapotException extends Error {
  code = "IM_A_TEAPOT";
  status = 418;
  constructor(message) {
    super(message ?? "I'm a teapot. This request cannot be handled by a coffee pot.");
    this.name = "IM_A_TEAPOT";
  }
}

class InternalServerErrorException extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor(message) {
    super(message ?? "An internal server error has occurred. Please contact the administrator.");
    this.name = "INTERNAL_SERVER_ERROR";
  }
}

class MethodNotAllowedException extends Error {
  code = "METHOD_NOT_ALLOWED";
  status = 405;
  constructor(message) {
    super(message ?? "The HTTP method is not allowed. Please check the request method.");
    this.name = "METHOD_NOT_ALLOWED";
  }
}

class NotFoundException extends O0 {
  code = "NOT_FOUND";
  status = 404;
  constructor(message) {
    super(message ?? "The requested resource was not found.");
    this.name = "NOT_FOUND";
  }
}

class NotImplementedException extends Error {
  code = "NOT_IMPLEMENTED";
  status = 501;
  constructor(message) {
    super(message ?? "The requested functionality is not implemented.");
    this.name = "NOT_IMPLEMENTED";
  }
}

class ServiceUnavailableException extends Error {
  code = "SERVICE_UNAVAILABLE";
  status = 503;
  constructor(message) {
    super(message ?? "The server is currently unavailable (because it is overloaded or down for maintenance).");
    this.name = "SERVICE_UNAVAILABLE";
  }
}

class UnauthorizedException extends Error {
  code = "UNAUTHORIZED";
  status = 401;
  constructor(message) {
    super(message ?? "You are not authorized to access this resource.");
    this.name = "UNAUTHORIZED";
  }
}

// src/utils/errorHandler.ts
var error22 = new j0().use(logger_default).error({
  BadGatewayException,
  BadRequestException,
  ConflictException,
  ForbiddenException,
  ImATeapotException,
  InternalServerErrorException,
  MethodNotAllowedException,
  NotFoundException,
  NotImplementedException,
  ServiceUnavailableException,
  UnauthorizedException
}).onError({ as: "global" }, (ctx) => {
  const { code, error: error23, logestic } = ctx;
  switch (code) {
    case "NOT_FOUND":
      return new NotFoundException;
    case "INTERNAL_SERVER_ERROR":
      if (logestic) {
        logestic.error(JSON.stringify({ code, error: error23 }));
      } else {
        console.error("Log is undefined. Error: ", { code, error: error23 });
      }
      return new InternalServerErrorException;
    default:
      if (logestic) {
        logestic.error(JSON.stringify({ code, error: error23 }));
      } else {
        console.error("Log is undefined. Error: ", { code, error: error23 });
      }
      return error23;
  }
});

// node_modules/zod/lib/index.mjs
function setErrorMap(map3) {
  overrideErrorMap = map3;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? undefined : errorMap
    ].filter((x3) => !!x3)
  });
  ctx.common.issues.push(issue);
}
function __classPrivateFieldGet(receiver, state, kind28, f3) {
  if (kind28 === "a" && !f3)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind28 === "m" ? f3 : kind28 === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value15, kind28, f3) {
  if (kind28 === "m")
    throw new TypeError("Private method is not writable");
  if (kind28 === "a" && !f3)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind28 === "a" ? f3.call(receiver, value15) : f3 ? f3.value = value15 : state.set(receiver, value15), value15;
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== undefined ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}\$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}\$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema3) {
  if (schema3 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema3.shape) {
      const fieldSchema = schema3.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema3._def,
      shape: () => newShape
    });
  } else if (schema3 instanceof ZodArray) {
    return new ZodArray({
      ...schema3._def,
      type: deepPartialify(schema3.element)
    });
  } else if (schema3 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodTuple) {
    return ZodTuple.create(schema3.items.map((item) => deepPartialify(item)));
  } else {
    return schema3;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function custom(check11, params = {}, fatal) {
  if (check11)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check11(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p22 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object13) => {
    const keys = [];
    for (const key in object13) {
      if (Object.prototype.hasOwnProperty.call(object13, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array5, separator = " | ") {
    return array5.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value15) => {
    if (typeof value15 === "bigint") {
      return value15.toString();
    }
    return value15;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t3 = typeof data;
  switch (t3) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error23) => {
      for (const issue of error23.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i3++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value15) {
    if (!(value15 instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value15}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error23 = new ZodError(issues);
  return error23;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
  for (const map3 of maps) {
    errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s3 of results) {
      if (s3.status === "aborted")
        return INVALID;
      if (s3.status === "dirty")
        status.dirty();
      arrayValue.push(s3.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value15 = await pair.value;
      syncPairs.push({
        key,
        value: value15
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value15 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value15.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value15.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value15.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value15.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value15) => ({ status: "dirty", value: value15 });
var OK = (value15) => ({ status: "valid", value: value15 });
var isAborted = (x3) => x3.status === "aborted";
var isDirty = (x3) => x3.status === "dirty";
var isValid = (x3) => x3.status === "valid";
var isAsync = (x3) => typeof Promise !== "undefined" && x3 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;

class ParseInputLazyPath {
  constructor(parent, value15, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value15;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error23 = new ZodError(ctx.common.issues);
        this._error = error23;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check11, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check11(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check11, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check11(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform7) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform7 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}\$`);

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check11 of this._def.checks) {
      if (check11.kind === "min") {
        if (input.data.length < check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check11.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        if (input.data.length > check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check11.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "length") {
        const tooBig = input.data.length > check11.value;
        const tooSmall = input.data.length < check11.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check11.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check11.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check11.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check11.message
            });
          }
          status.dirty();
        }
      } else if (check11.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "regex") {
        check11.regex.lastIndex = 0;
        const testResult = check11.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "trim") {
        input.data = input.data.trim();
      } else if (check11.kind === "includes") {
        if (!input.data.includes(check11.value, check11.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check11.value, position: check11.position },
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check11.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check11.kind === "startsWith") {
        if (!input.data.startsWith(check11.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check11.value },
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "endsWith") {
        if (!input.data.endsWith(check11.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check11.value },
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "datetime") {
        const regex = datetimeRegex(check11);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "time") {
        const regex = timeRegex(check11);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "ip") {
        if (!isValidIP(input.data, check11.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check11) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      local: (_b = options === null || options === undefined ? undefined : options.local) !== null && _b !== undefined ? _b : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value15, options) {
    return this._addCheck({
      kind: "includes",
      value: value15,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value15, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value15,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value15, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value15,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check11 of this._def.checks) {
      if (check11.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "min") {
        const tooSmall = check11.inclusive ? input.data < check11.value : input.data <= check11.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check11.value,
            type: "number",
            inclusive: check11.inclusive,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        const tooBig = check11.inclusive ? input.data > check11.value : input.data >= check11.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check11.value,
            type: "number",
            inclusive: check11.inclusive,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check11.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check11.value,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check11.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value15, message) {
    return this.setLimit("min", value15, true, errorUtil.toString(message));
  }
  gt(value15, message) {
    return this.setLimit("min", value15, false, errorUtil.toString(message));
  }
  lte(value15, message) {
    return this.setLimit("max", value15, true, errorUtil.toString(message));
  }
  lt(value15, message) {
    return this.setLimit("max", value15, false, errorUtil.toString(message));
  }
  setLimit(kind28, value15, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: kind28,
          value: value15,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check11) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value15, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value15,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check11 of this._def.checks) {
      if (check11.kind === "min") {
        const tooSmall = check11.inclusive ? input.data < check11.value : input.data <= check11.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check11.value,
            inclusive: check11.inclusive,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        const tooBig = check11.inclusive ? input.data > check11.value : input.data >= check11.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check11.value,
            inclusive: check11.inclusive,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "multipleOf") {
        if (input.data % check11.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check11.value,
            message: check11.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value15, message) {
    return this.setLimit("min", value15, true, errorUtil.toString(message));
  }
  gt(value15, message) {
    return this.setLimit("min", value15, false, errorUtil.toString(message));
  }
  lte(value15, message) {
    return this.setLimit("max", value15, true, errorUtil.toString(message));
  }
  lt(value15, message) {
    return this.setLimit("max", value15, false, errorUtil.toString(message));
  }
  setLimit(kind28, value15, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: kind28,
          value: value15,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check11) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value15, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value15,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check11 of this._def.checks) {
      if (check11.kind === "min") {
        if (input.data.getTime() < check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check11.message,
            inclusive: true,
            exact: false,
            minimum: check11.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        if (input.data.getTime() > check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check11.message,
            inclusive: true,
            exact: false,
            maximum: check11.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check11) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema3, params) => {
  return new ZodArray({
    type: schema3,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value15 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value15, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value15 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value15, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value15 = await pair.value;
          syncPairs.push({
            key,
            value: value15,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema3) {
    return this.augment({ [key]: schema3 });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type47) => {
  if (type47 instanceof ZodLazy) {
    return getDiscriminator(type47.schema);
  } else if (type47 instanceof ZodEffects) {
    return getDiscriminator(type47.innerType());
  } else if (type47 instanceof ZodLiteral) {
    return [type47.value];
  } else if (type47 instanceof ZodEnum) {
    return type47.options;
  } else if (type47 instanceof ZodNativeEnum) {
    return util.objectValues(type47.enum);
  } else if (type47 instanceof ZodDefault) {
    return getDiscriminator(type47._def.innerType);
  } else if (type47 instanceof ZodUndefined) {
    return [undefined];
  } else if (type47 instanceof ZodNull) {
    return [null];
  } else if (type47 instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type47.unwrap())];
  } else if (type47 instanceof ZodNullable) {
    return [null, ...getDiscriminator(type47.unwrap())];
  } else if (type47 instanceof ZodBranded) {
    return getDiscriminator(type47.unwrap());
  } else if (type47 instanceof ZodReadonly) {
    return getDiscriminator(type47.unwrap());
  } else if (type47 instanceof ZodCatch) {
    return getDiscriminator(type47._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type47 of options) {
      const discriminatorValues = getDiscriminator(type47.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value15 of discriminatorValues) {
        if (optionsMap.has(value15)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value15)}`);
        }
        optionsMap.set(value15, type47);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest4 = this._def.rest;
    if (!rest4 && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema3 = this._def.items[itemIndex] || this._def.rest;
      if (!schema3)
        return null;
      return schema3._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x3) => !!x3);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest4) {
    return new ZodTuple({
      ...this._def,
      rest: rest4
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value15], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value15, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value15 = await pair.value;
          if (key.status === "aborted" || value15.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value15.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value15.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value15 = pair.value;
        if (key.status === "aborted" || value15.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value15.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value15.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error23) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error23
        }
      });
    }
    function makeReturnsIssue(returns, error23) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error23
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error23 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error23.addIssue(makeArgsIssue(args, e));
          throw error23;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error23.addIssue(makeReturnsIssue(result, e));
          throw error23;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value15, params) => {
  return new ZodLiteral({
    value: value15,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, undefined);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = new WeakMap;
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, undefined);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = new WeakMap;
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema3, params) => {
  return new ZodPromise({
    type: schema3,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema3, effect, params) => {
  return new ZodEffects({
    schema: schema3,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema3, params) => {
  return new ZodEffects({
    schema: schema3,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type47, params) => {
  return new ZodOptional({
    innerType: type47,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type47, params) => {
  return new ZodNullable({
    innerType: type47,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type47, params) => {
  return new ZodDefault({
    innerType: type47,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type47, params) => {
  return new ZodCatch({
    innerType: type47,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type47, params) => {
  return new ZodReadonly({
    innerType: type47,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/libs/env.ts
var envValidateScheme = z.object({
  NODE_ENV: z.string(),
  DOMAIN: z.string(),
  BASE_URL: z.string().optional(),
  DATABASE_URL: z.string(),
  GOOGLE_CLIENT_ID: z.string(),
  GOOGLE_CLIENT_SECRET: z.string(),
  GITHUB_CLIENT_ID: z.string().optional(),
  GITHUB_CLIENT_SECRET: z.string().optional(),
  DISCORD_CLIENT_ID: z.string().optional(),
  DISCORD_CLIENT_SECRET: z.string().optional(),
  FACEBOOK_CLIENT_ID: z.string().optional(),
  FACEBOOK_CLIENT_SECRET: z.string().optional(),
  PASSWORD_PEPPER: z.string(),
  CLOUDINARY_CLOUD_NAME: z.string(),
  CLOUDINARY_API_KEY: z.string(),
  CLOUDINARY_API_SECRET: z.string(),
  MINIO_HOST: z.string(),
  MINIO_BUCKET_NAME: z.string().optional(),
  MINIO_ACCESS_KEY: z.string(),
  MINIO_SECRET_KEY: z.string(),
  SPOTIFY_CLIENT_ID: z.string().optional(),
  SPOTIFY_CLIENT_SECRET: z.string().optional(),
  ETHEREUM_RPC_URL: z.string().optional(),
  POLYGON_RPC_URL: z.string().optional(),
  BSC_RPC_URL: z.string().optional(),
  ARBITRUM_RPC_URL: z.string().optional(),
  OPTIMISM_RPC_URL: z.string().optional(),
  LOKI_HOST: z.string().optional(),
  LOKI_USERNAME: z.string().optional(),
  LOKI_PASSWORD: z.string().optional()
});
var env2 = () => {
  const app = new j0({
    name: "env"
  });
  const env3 = envValidateScheme.parse(process.env);
  return app.decorate("env", {
    ...env3,
    env: process.env
  });
};

// src/libs/elysia.ts
var baseElysia = (config2) => new j0(config2).use(env2).use(logger_default).use(error22);
var createElysia = (config2) => new j0(config2);

// node_modules/@elysiajs/cors/dist/index.mjs
var isBun = typeof new Headers()?.toJSON === "function";
var processHeaders = (headers) => {
  if (isBun)
    return Object.keys(headers.toJSON()).join(", ");
  let keys = "";
  headers.forEach((_, key) => {
    keys += key + ", ";
  });
  if (keys)
    keys = keys.slice(0, -1);
  return keys;
};
var processOrigin = (origin, request, from) => {
  if (Array.isArray(origin))
    return origin.some((o3) => processOrigin(o3, request, from));
  switch (typeof origin) {
    case "string":
      if (origin.indexOf("://") === -1)
        return from.includes(origin);
      return origin === from;
    case "function":
      return origin(request) === true;
    case "object":
      if (origin instanceof RegExp)
        return origin.test(from);
  }
  return false;
};
var cors = (config2) => {
  let {
    aot = true,
    origin = true,
    methods = true,
    allowedHeaders = true,
    exposeHeaders = true,
    credentials = true,
    maxAge = 5,
    preflight = true
  } = config2 ?? {};
  if (Array.isArray(allowedHeaders))
    allowedHeaders = allowedHeaders.join(", ");
  if (Array.isArray(exposeHeaders))
    exposeHeaders = exposeHeaders.join(", ");
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const app = new j0({
    name: "@elysiajs/cors",
    seed: config2,
    aot
  });
  const anyOrigin = origins?.some((o3) => o3 === "*");
  const handleOrigin = (set2, request) => {
    if (origin === true) {
      set2.headers.vary = "*";
      set2.headers["access-control-allow-origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (anyOrigin) {
      set2.headers.vary = "*";
      set2.headers["access-control-allow-origin"] = "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i3 = 0;i3 < origins.length; i3++) {
        const value15 = processOrigin(origins[i3], request, from);
        if (value15 === true) {
          set2.headers.vary = origin ? "Origin" : "*";
          set2.headers["access-control-allow-origin"] = from || "*";
          return;
        }
        if (value15)
          headers.push(value15);
      }
    }
    set2.headers.vary = "Origin";
    if (headers.length)
      set2.headers["access-control-allow-origin"] = headers.join(", ");
  };
  const handleMethod = (set2, method) => {
    if (!method)
      return;
    if (methods === true)
      return set2.headers["access-control-allow-methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set2.headers["access-control-allow-methods"] = "*";
    if (!Array.isArray(methods))
      return set2.headers["access-control-allow-methods"] = methods;
    set2.headers["access-control-allow-methods"] = methods.join(", ");
  };
  const defaultHeaders = {};
  if (typeof exposeHeaders === "string")
    defaultHeaders["access-control-expose-headers"] = exposeHeaders;
  if (typeof allowedHeaders === "string")
    defaultHeaders["access-control-allow-headers"] = allowedHeaders;
  if (credentials === true)
    defaultHeaders["access-control-allow-credentials"] = "true";
  app.headers(defaultHeaders);
  function handleOption({ set: set2, request, headers }) {
    handleOrigin(set2, request);
    handleMethod(set2, request.headers.get("access-control-request-method"));
    if (allowedHeaders === true || exposeHeaders === true) {
      if (allowedHeaders === true)
        set2.headers["access-control-allow-headers"] = headers["access-control-request-headers"];
      if (exposeHeaders === true)
        set2.headers["access-control-expose-headers"] = Object.keys(headers).join(",");
    }
    if (maxAge)
      set2.headers["access-control-max-age"] = maxAge.toString();
    return new Response(null, {
      status: 204
    });
  }
  if (preflight)
    app.options("/", handleOption).options("/*", handleOption);
  return app.onRequest(function processCors({ set: set2, request }) {
    handleOrigin(set2, request);
    handleMethod(set2, request.method);
    if (allowedHeaders === true || exposeHeaders === true) {
      const headers = processHeaders(request.headers);
      if (allowedHeaders === true)
        set2.headers["access-control-allow-headers"] = headers;
      if (exposeHeaders === true)
        set2.headers["access-control-expose-headers"] = headers;
    }
  });
};
var src_default = cors;

// node_modules/@lucia-auth/adapter-prisma/dist/index.js
function transformIntoDatabaseSession(raw2) {
  const { id, userId, expiresAt, ...attributes } = raw2;
  return {
    id,
    userId,
    expiresAt,
    attributes
  };
}
function transformIntoDatabaseUser(raw2) {
  const { id, ...attributes } = raw2;
  return {
    id,
    attributes
  };
}

class PrismaAdapter {
  sessionModel;
  userModel;
  constructor(sessionModel, userModel) {
    this.sessionModel = sessionModel;
    this.userModel = userModel;
  }
  async deleteSession(sessionId) {
    try {
      await this.sessionModel.delete({
        where: {
          id: sessionId
        }
      });
    } catch {
    }
  }
  async deleteUserSessions(userId) {
    await this.sessionModel.deleteMany({
      where: {
        userId
      }
    });
  }
  async getSessionAndUser(sessionId) {
    const userModelKey = this.userModel.name[0].toLowerCase() + this.userModel.name.slice(1);
    const result = await this.sessionModel.findUnique({
      where: {
        id: sessionId
      },
      include: {
        [userModelKey]: true
      }
    });
    if (!result)
      return [null, null];
    const userResult = result[userModelKey];
    delete result[userModelKey];
    return [transformIntoDatabaseSession(result), transformIntoDatabaseUser(userResult)];
  }
  async getUserSessions(userId) {
    const result = await this.sessionModel.findMany({
      where: {
        userId
      }
    });
    return result.map(transformIntoDatabaseSession);
  }
  async setSession(value15) {
    await this.sessionModel.create({
      data: {
        id: value15.id,
        userId: value15.userId,
        expiresAt: value15.expiresAt,
        ...value15.attributes
      }
    });
  }
  async updateSessionExpiration(sessionId, expiresAt) {
    await this.sessionModel.update({
      where: {
        id: sessionId
      },
      data: {
        expiresAt
      }
    });
  }
  async deleteExpiredSessions() {
    await this.sessionModel.deleteMany({
      where: {
        expiresAt: {
          lte: new Date
        }
      }
    });
  }
}

// node_modules/oslo/dist/index.js
function isWithinExpirationDate(date5) {
  return Date.now() < date5.getTime();
}
function createDate(timeSpan) {
  return new Date(Date.now() + timeSpan.milliseconds());
}

class TimeSpan {
  constructor(value15, unit) {
    this.value = value15;
    this.unit = unit;
  }
  value;
  unit;
  milliseconds() {
    if (this.unit === "ms") {
      return this.value;
    }
    if (this.unit === "s") {
      return this.value * 1000;
    }
    if (this.unit === "m") {
      return this.value * 1000 * 60;
    }
    if (this.unit === "h") {
      return this.value * 1000 * 60 * 60;
    }
    if (this.unit === "d") {
      return this.value * 1000 * 60 * 60 * 24;
    }
    return this.value * 1000 * 60 * 60 * 24 * 7;
  }
  seconds() {
    return this.milliseconds() / 1000;
  }
  transform(x3) {
    return new TimeSpan(Math.round(this.milliseconds() * x3), "ms");
  }
}

// node_modules/oslo/dist/cookie/index.js
function serializeCookie(name, value15, attributes) {
  const keyValueEntries = [];
  keyValueEntries.push([encodeURIComponent(name), encodeURIComponent(value15)]);
  if (attributes?.domain !== undefined) {
    keyValueEntries.push(["Domain", attributes.domain]);
  }
  if (attributes?.expires !== undefined) {
    keyValueEntries.push(["Expires", attributes.expires.toUTCString()]);
  }
  if (attributes?.httpOnly) {
    keyValueEntries.push(["HttpOnly"]);
  }
  if (attributes?.maxAge !== undefined) {
    keyValueEntries.push(["Max-Age", attributes.maxAge.toString()]);
  }
  if (attributes?.path !== undefined) {
    keyValueEntries.push(["Path", attributes.path]);
  }
  if (attributes?.sameSite === "lax") {
    keyValueEntries.push(["SameSite", "Lax"]);
  }
  if (attributes?.sameSite === "none") {
    keyValueEntries.push(["SameSite", "None"]);
  }
  if (attributes?.sameSite === "strict") {
    keyValueEntries.push(["SameSite", "Strict"]);
  }
  if (attributes?.secure) {
    keyValueEntries.push(["Secure"]);
  }
  return keyValueEntries.map((pair) => pair.join("=")).join("; ");
}
function parseCookies(header) {
  const cookies = new Map;
  const items = header.split("; ");
  for (const item of items) {
    const pair = item.split("=");
    const rawKey = pair[0];
    const rawValue = pair[1] ?? "";
    if (!rawKey)
      continue;
    cookies.set(decodeURIComponent(rawKey), decodeURIComponent(rawValue));
  }
  return cookies;
}

class CookieController {
  constructor(cookieName, baseCookieAttributes, cookieOptions) {
    this.cookieName = cookieName;
    this.cookieExpiresIn = cookieOptions?.expiresIn ?? null;
    this.baseCookieAttributes = baseCookieAttributes;
  }
  cookieName;
  cookieExpiresIn;
  baseCookieAttributes;
  createCookie(value15) {
    return new Cookie(this.cookieName, value15, {
      ...this.baseCookieAttributes,
      maxAge: this.cookieExpiresIn?.seconds()
    });
  }
  createBlankCookie() {
    return new Cookie(this.cookieName, "", {
      ...this.baseCookieAttributes,
      maxAge: 0
    });
  }
  parse(header) {
    const cookies = parseCookies(header);
    return cookies.get(this.cookieName) ?? null;
  }
}

class Cookie {
  constructor(name, value15, attributes) {
    this.name = name;
    this.value = value15;
    this.attributes = attributes;
  }
  name;
  value;
  attributes;
  serialize() {
    return serializeCookie(this.name, this.value, this.attributes);
  }
}

// node_modules/oslo/dist/encoding/hex.js
var hexDecodeMap = new Map([
  ["0", 0],
  ["1", 1],
  ["2", 2],
  ["3", 3],
  ["4", 4],
  ["5", 5],
  ["6", 6],
  ["7", 7],
  ["8", 8],
  ["9", 9],
  ["A", 10],
  ["B", 11],
  ["C", 12],
  ["D", 13],
  ["E", 14],
  ["F", 15],
  ["a", 10],
  ["b", 11],
  ["c", 12],
  ["d", 13],
  ["e", 14],
  ["f", 15]
]);
// node_modules/oslo/dist/encoding/base32.js
class Base32Encoding {
  alphabet;
  padding;
  decodeMap = new Map;
  constructor(alphabet, options) {
    if (alphabet.length !== 32) {
      throw new Error("Invalid alphabet");
    }
    this.alphabet = alphabet;
    this.padding = options?.padding ?? "=";
    if (this.alphabet.includes(this.padding) || this.padding.length !== 1) {
      throw new Error("Invalid padding");
    }
    for (let i3 = 0;i3 < alphabet.length; i3++) {
      this.decodeMap.set(alphabet[i3], i3);
    }
  }
  encode(data, options) {
    let result = "";
    let buffer = 0;
    let shift = 0;
    for (let i3 = 0;i3 < data.length; i3++) {
      buffer = buffer << 8 | data[i3];
      shift += 8;
      while (shift >= 5) {
        shift -= 5;
        result += this.alphabet[buffer >> shift & 31];
      }
    }
    if (shift > 0) {
      result += this.alphabet[buffer << 5 - shift & 31];
    }
    const includePadding = options?.includePadding ?? true;
    if (includePadding) {
      const padCount = (8 - result.length % 8) % 8;
      for (let i3 = 0;i3 < padCount; i3++) {
        result += "=";
      }
    }
    return result;
  }
  decode(data, options) {
    const strict4 = options?.strict ?? true;
    const chunkCount = Math.ceil(data.length / 8);
    const result = [];
    for (let i3 = 0;i3 < chunkCount; i3++) {
      let padCount = 0;
      const chunks = [];
      for (let j = 0;j < 8; j++) {
        const encoded = data[i3 * 8 + j];
        if (encoded === "=") {
          if (i3 + 1 !== chunkCount) {
            throw new Error(`Invalid character: ${encoded}`);
          }
          padCount += 1;
          continue;
        }
        if (encoded === undefined) {
          if (strict4) {
            throw new Error("Invalid data");
          }
          padCount += 1;
          continue;
        }
        const value15 = this.decodeMap.get(encoded) ?? null;
        if (value15 === null) {
          throw new Error(`Invalid character: ${encoded}`);
        }
        chunks.push(value15);
      }
      if (padCount === 8 || padCount === 7 || padCount === 5 || padCount === 2) {
        throw new Error("Invalid padding");
      }
      const byte1 = (chunks[0] << 3) + (chunks[1] >> 2);
      result.push(byte1);
      if (padCount < 6) {
        const byte2 = ((chunks[1] & 3) << 6) + (chunks[2] << 1) + (chunks[3] >> 4);
        result.push(byte2);
      }
      if (padCount < 4) {
        const byte3 = ((chunks[3] & 255) << 4) + (chunks[4] >> 1);
        result.push(byte3);
      }
      if (padCount < 3) {
        const byte4 = ((chunks[4] & 1) << 7) + (chunks[5] << 2) + (chunks[6] >> 3);
        result.push(byte4);
      }
      if (padCount < 1) {
        const byte5 = ((chunks[6] & 7) << 5) + chunks[7];
        result.push(byte5);
      }
    }
    return Uint8Array.from(result);
  }
}
var base32 = new Base32Encoding("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567");
var base32hex = new Base32Encoding("0123456789ABCDEFGHIJKLMNOPQRSTUV");
// node_modules/oslo/dist/encoding/base64.js
class Base64Encoding {
  alphabet;
  padding;
  decodeMap = new Map;
  constructor(alphabet, options) {
    if (alphabet.length !== 64) {
      throw new Error("Invalid alphabet");
    }
    this.alphabet = alphabet;
    this.padding = options?.padding ?? "=";
    if (this.alphabet.includes(this.padding) || this.padding.length !== 1) {
      throw new Error("Invalid padding");
    }
    for (let i3 = 0;i3 < alphabet.length; i3++) {
      this.decodeMap.set(alphabet[i3], i3);
    }
  }
  encode(data, options) {
    let result = "";
    let buffer = 0;
    let shift = 0;
    for (let i3 = 0;i3 < data.length; i3++) {
      buffer = buffer << 8 | data[i3];
      shift += 8;
      while (shift >= 6) {
        shift += -6;
        result += this.alphabet[buffer >> shift & 63];
      }
    }
    if (shift > 0) {
      result += this.alphabet[buffer << 6 - shift & 63];
    }
    const includePadding = options?.includePadding ?? true;
    if (includePadding) {
      const padCount = (4 - result.length % 4) % 4;
      for (let i3 = 0;i3 < padCount; i3++) {
        result += "=";
      }
    }
    return result;
  }
  decode(data, options) {
    const strict4 = options?.strict ?? true;
    const chunkCount = Math.ceil(data.length / 4);
    const result = [];
    for (let i3 = 0;i3 < chunkCount; i3++) {
      let padCount = 0;
      let buffer = 0;
      for (let j = 0;j < 4; j++) {
        const encoded = data[i3 * 4 + j];
        if (encoded === "=") {
          if (i3 + 1 !== chunkCount) {
            throw new Error(`Invalid character: ${encoded}`);
          }
          padCount += 1;
          continue;
        }
        if (encoded === undefined) {
          if (strict4) {
            throw new Error("Invalid data");
          }
          padCount += 1;
          continue;
        }
        const value15 = this.decodeMap.get(encoded) ?? null;
        if (value15 === null) {
          throw new Error(`Invalid character: ${encoded}`);
        }
        buffer += value15 << 6 * (3 - j);
      }
      result.push(buffer >> 16 & 255);
      if (padCount < 2) {
        result.push(buffer >> 8 & 255);
      }
      if (padCount < 1) {
        result.push(buffer & 255);
      }
    }
    return Uint8Array.from(result);
  }
}
var base64 = new Base64Encoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
var base64url = new Base64Encoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_");
// node_modules/oslo/dist/bytes.js
function byteToBinary(byte) {
  return byte.toString(2).padStart(8, "0");
}
function bytesToBinary(bytes) {
  return [...bytes].map((val) => byteToBinary(val)).join("");
}
function bytesToInteger(bytes) {
  return parseInt(bytesToBinary(bytes), 2);
}

// node_modules/oslo/dist/crypto/random.js
function generateRandomInteger(max) {
  if (max < 0 || !Number.isInteger(max)) {
    throw new Error("Argument 'max' must be an integer greater than or equal to 0");
  }
  const bitLength = (max - 1).toString(2).length;
  const shift = bitLength % 8;
  const bytes2 = new Uint8Array(Math.ceil(bitLength / 8));
  crypto.getRandomValues(bytes2);
  if (shift !== 0) {
    bytes2[0] &= (1 << shift) - 1;
  }
  let result = bytesToInteger(bytes2);
  while (result >= max) {
    crypto.getRandomValues(bytes2);
    if (shift !== 0) {
      bytes2[0] &= (1 << shift) - 1;
    }
    result = bytesToInteger(bytes2);
  }
  return result;
}
function generateRandomString(length, alphabet) {
  let result = "";
  for (let i3 = 0;i3 < length; i3++) {
    result += alphabet[generateRandomInteger(alphabet.length)];
  }
  return result;
}
function alphabet(...patterns7) {
  const patternSet = new Set(patterns7);
  let result = "";
  for (const pattern3 of patternSet) {
    if (pattern3 === "a-z") {
      result += "abcdefghijklmnopqrstuvwxyz";
    } else if (pattern3 === "A-Z") {
      result += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    } else if (pattern3 === "0-9") {
      result += "0123456789";
    } else {
      result += pattern3;
    }
  }
  return result;
}
// node_modules/lucia/dist/crypto.js
function generateId(length) {
  return generateRandomString(length, alphabet("0-9", "a-z"));
}
function generateIdFromEntropySize(size) {
  const buffer = crypto.getRandomValues(new Uint8Array(size));
  return base32.encode(buffer, {
    includePadding: false
  }).toLowerCase();
}

// node_modules/lucia/dist/core.js
class Lucia {
  adapter;
  sessionExpiresIn;
  sessionCookieController;
  getSessionAttributes;
  getUserAttributes;
  sessionCookieName;
  constructor(adapter, options) {
    this.adapter = adapter;
    this.getUserAttributes = (databaseUserAttributes) => {
      if (options && options.getUserAttributes) {
        return options.getUserAttributes(databaseUserAttributes);
      }
      return {};
    };
    this.getSessionAttributes = (databaseSessionAttributes) => {
      if (options && options.getSessionAttributes) {
        return options.getSessionAttributes(databaseSessionAttributes);
      }
      return {};
    };
    this.sessionExpiresIn = options?.sessionExpiresIn ?? new TimeSpan(30, "d");
    this.sessionCookieName = options?.sessionCookie?.name ?? "auth_session";
    let sessionCookieExpiresIn = this.sessionExpiresIn;
    if (options?.sessionCookie?.expires === false) {
      sessionCookieExpiresIn = new TimeSpan(365 * 2, "d");
    }
    const baseSessionCookieAttributes = {
      httpOnly: true,
      secure: true,
      sameSite: "lax",
      path: "/",
      ...options?.sessionCookie?.attributes
    };
    this.sessionCookieController = new CookieController(this.sessionCookieName, baseSessionCookieAttributes, {
      expiresIn: sessionCookieExpiresIn
    });
  }
  async getUserSessions(userId) {
    const databaseSessions = await this.adapter.getUserSessions(userId);
    const sessions = [];
    for (const databaseSession of databaseSessions) {
      if (!isWithinExpirationDate(databaseSession.expiresAt)) {
        continue;
      }
      sessions.push({
        id: databaseSession.id,
        expiresAt: databaseSession.expiresAt,
        userId: databaseSession.userId,
        fresh: false,
        ...this.getSessionAttributes(databaseSession.attributes)
      });
    }
    return sessions;
  }
  async validateSession(sessionId) {
    const [databaseSession, databaseUser] = await this.adapter.getSessionAndUser(sessionId);
    if (!databaseSession) {
      return { session: null, user: null };
    }
    if (!databaseUser) {
      await this.adapter.deleteSession(databaseSession.id);
      return { session: null, user: null };
    }
    if (!isWithinExpirationDate(databaseSession.expiresAt)) {
      await this.adapter.deleteSession(databaseSession.id);
      return { session: null, user: null };
    }
    const activePeriodExpirationDate = new Date(databaseSession.expiresAt.getTime() - this.sessionExpiresIn.milliseconds() / 2);
    const session = {
      ...this.getSessionAttributes(databaseSession.attributes),
      id: databaseSession.id,
      userId: databaseSession.userId,
      fresh: false,
      expiresAt: databaseSession.expiresAt
    };
    if (!isWithinExpirationDate(activePeriodExpirationDate)) {
      session.fresh = true;
      session.expiresAt = createDate(this.sessionExpiresIn);
      await this.adapter.updateSessionExpiration(databaseSession.id, session.expiresAt);
    }
    const user = {
      ...this.getUserAttributes(databaseUser.attributes),
      id: databaseUser.id
    };
    return { user, session };
  }
  async createSession(userId, attributes, options) {
    const sessionId = options?.sessionId ?? generateIdFromEntropySize(25);
    const sessionExpiresAt = createDate(this.sessionExpiresIn);
    await this.adapter.setSession({
      id: sessionId,
      userId,
      expiresAt: sessionExpiresAt,
      attributes
    });
    const session = {
      id: sessionId,
      userId,
      fresh: true,
      expiresAt: sessionExpiresAt,
      ...this.getSessionAttributes(attributes)
    };
    return session;
  }
  async invalidateSession(sessionId) {
    await this.adapter.deleteSession(sessionId);
  }
  async invalidateUserSessions(userId) {
    await this.adapter.deleteUserSessions(userId);
  }
  async deleteExpiredSessions() {
    await this.adapter.deleteExpiredSessions();
  }
  readSessionCookie(cookieHeader) {
    const sessionId = this.sessionCookieController.parse(cookieHeader);
    return sessionId;
  }
  readBearerToken(authorizationHeader) {
    const [authScheme, token] = authorizationHeader.split(" ");
    if (authScheme !== "Bearer") {
      return null;
    }
    return token ?? null;
  }
  createSessionCookie(sessionId) {
    return this.sessionCookieController.createCookie(sessionId);
  }
  createBlankSessionCookie() {
    return this.sessionCookieController.createBlankCookie();
  }
}
// node_modules/oslo/dist/request/index.js
function verifyRequestOrigin(origin, allowedDomains) {
  if (!origin || allowedDomains.length === 0)
    return false;
  const originHost = safeURL(origin)?.host ?? null;
  if (!originHost)
    return false;
  for (const domain of allowedDomains) {
    let host;
    if (domain.startsWith("http://") || domain.startsWith("https://")) {
      host = safeURL(domain)?.host ?? null;
    } else {
      host = safeURL("https://" + domain)?.host ?? null;
    }
    if (originHost === host)
      return true;
  }
  return false;
}
function safeURL(url) {
  try {
    return new URL(url);
  } catch {
    return null;
  }
}
// src/libs/prismaDatabase.ts
var client = __toESM(require_default2(), 1);
var prismaClientSingleton = () => {
  return new client.PrismaClient;
};
var prisma = globalThis.prismaGlobal || prismaClientSingleton();
if (true)
  globalThis.prismaGlobal = prisma;

// src/libs/luciaAuth.ts
var adapter = new PrismaAdapter(prisma.session, prisma.user);
var lucia = new Lucia(adapter, {
  sessionCookie: {
    attributes: {
      secure: false
    }
  },
  getUserAttributes: (attributes) => {
    return {
      name: attributes.name,
      email: attributes.email,
      about: attributes.about,
      iconUrl: attributes.iconUrl,
      avatarUrl: attributes.avatarUrl,
      bannerUrl: attributes.bannerUrl,
      role: attributes.role,
      headline: attributes.headline,
      location: attributes.location
    };
  }
});

// src/api/controller/auth/signup.ts
var {password: bunPassword } = globalThis.Bun;

// src/models/auth.model.ts
var authModel = new j0().model({
  "auth.login": C.Object({
    email: C.String({
      format: "email"
    }),
    password: C.String()
  }),
  "auth.signup": C.Object({
    email: C.String({
      format: "email"
    }),
    password: C.String({
      minLength: 8,
      maxLength: 64
    }),
    name: C.String({
      minLength: 3,
      maxLength: 32
    })
  })
});
var auth_model_default = authModel;

// src/api/controller/auth/signup.ts
var signup_default = createElysia().use(auth_model_default).post("/signup", async ({
  body: {
    email,
    password,
    name
  },
  cookie: cookie2,
  set: set2,
  logestic,
  env: {
    DOMAIN,
    PASSWORD_PEPPER: passwordPepper
  }
}) => {
  const existingUser = await prisma.user.findUnique({
    where: {
      email
    }
  });
  if (existingUser) {
    logestic.error("User already exists.");
    throw new ConflictException("User already exists.");
  }
  const userId = generateId(15);
  const passwordSalt = generateRandomString(16, alphabet("a-z", "A-Z", "0-9"));
  const hashedPassword = await bunPassword.hash(passwordSalt + password + passwordPepper);
  try {
    const newUser = await prisma.user.create({
      data: {
        id: userId,
        email,
        hashedPassword,
        passwordSalt,
        name
      }
    });
    const session = await lucia.createSession(userId, {});
    const sessionCookie = lucia.createSessionCookie(session.id);
    set2.status = 201;
    cookie2[sessionCookie.name]?.set({
      value: sessionCookie.value,
      domain: DOMAIN,
      ...sessionCookie.attributes
    });
    return newUser;
  } catch (error23) {
    logestic.error(error23);
    throw new InternalServerErrorException;
  }
}, {
  detail: {
    tags: ["Auth"]
  },
  body: "auth.signup"
});

// src/api/controller/auth/login.ts
var {password: bunPassword2 } = globalThis.Bun;
var login_default = createElysia().use(auth_model_default).post("/login", async ({
  body: {
    email,
    password
  },
  cookie: cookie2,
  set: set2,
  logestic,
  env: {
    DOMAIN,
    PASSWORD_PEPPER
  }
}) => {
  const user = await prisma.user.findUnique({
    where: {
      email
    }
  });
  if (!user?.passwordSalt || !user?.hashedPassword) {
    logestic.error("User not found.");
    throw new BadRequestException("User not found.");
  }
  const passwordPepper = PASSWORD_PEPPER;
  if (!passwordPepper) {
    logestic.error("Password pepper is not set.");
    throw new Error("Password pepper is not set.");
  }
  if (!user?.passwordSalt || !user?.hashedPassword) {
    logestic.error("User data is missing or incomplete.");
  } else if (!await bunPassword2.verify(user.passwordSalt + password + passwordPepper, user.hashedPassword)) {
    logestic.error("Password is invalid.");
    throw new BadRequestException("Password is invalid.");
  } else {
    try {
      const session = await lucia.createSession(user.id, {});
      const sessionCookie = lucia.createSessionCookie(session.id);
      set2.status = 200;
      cookie2[sessionCookie.name]?.set({
        value: sessionCookie.value,
        domain: DOMAIN,
        ...sessionCookie.attributes
      });
      return {
        status: "200",
        token: sessionCookie.value
      };
    } catch (error23) {
      set2.status = 500;
    }
  }
}, {
  detail: {
    tags: ["Auth"]
  },
  body: "auth.login"
});

// src/api/controller/auth/logout.ts
var logout_default = createElysia().post("/logout", async ({
  cookie: cookie2,
  env: {
    DOMAIN
  }
}) => {
  const sessionCookie = cookie2[lucia.sessionCookieName];
  if (!sessionCookie?.value) {
    throw new BadRequestException("Session not found");
  }
  await lucia.invalidateSession(sessionCookie.value);
  const blankSessionCookie = lucia.createBlankSessionCookie();
  sessionCookie.set({
    value: blankSessionCookie.value,
    domain: DOMAIN,
    ...blankSessionCookie.attributes
  });
}, {
  detail: {
    tags: ["Auth"]
  }
});
// node_modules/@oslojs/encoding/dist/base32.js
var EncodingPadding;
(function(EncodingPadding2) {
  EncodingPadding2[EncodingPadding2["Include"] = 0] = "Include";
  EncodingPadding2[EncodingPadding2["None"] = 1] = "None";
})(EncodingPadding || (EncodingPadding = {}));
var DecodingPadding;
(function(DecodingPadding2) {
  DecodingPadding2[DecodingPadding2["Required"] = 0] = "Required";
  DecodingPadding2[DecodingPadding2["Ignore"] = 1] = "Ignore";
})(DecodingPadding || (DecodingPadding = {}));
// node_modules/@oslojs/encoding/dist/base64.js
function encodeBase642(bytes2) {
  return encodeBase64_internal(bytes2, base64Alphabet, EncodingPadding2.Include);
}
function encodeBase64urlNoPadding(bytes2) {
  return encodeBase64_internal(bytes2, base64urlAlphabet, EncodingPadding2.None);
}
function encodeBase64_internal(bytes2, alphabet2, padding) {
  let result = "";
  for (let i3 = 0;i3 < bytes2.byteLength; i3 += 3) {
    let buffer = 0;
    let bufferBitSize = 0;
    for (let j = 0;j < 3 && i3 + j < bytes2.byteLength; j++) {
      buffer = buffer << 8 | bytes2[i3 + j];
      bufferBitSize += 8;
    }
    for (let j = 0;j < 4; j++) {
      if (bufferBitSize >= 6) {
        result += alphabet2[buffer >> bufferBitSize - 6 & 63];
        bufferBitSize -= 6;
      } else if (bufferBitSize > 0) {
        result += alphabet2[buffer << 6 - bufferBitSize & 63];
        bufferBitSize = 0;
      } else if (padding === EncodingPadding2.Include) {
        result += "=";
      }
    }
  }
  return result;
}
var base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base64urlAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
var EncodingPadding2;
(function(EncodingPadding3) {
  EncodingPadding3[EncodingPadding3["Include"] = 0] = "Include";
  EncodingPadding3[EncodingPadding3["None"] = 1] = "None";
})(EncodingPadding2 || (EncodingPadding2 = {}));
var DecodingPadding2;
(function(DecodingPadding3) {
  DecodingPadding3[DecodingPadding3["Required"] = 0] = "Required";
  DecodingPadding3[DecodingPadding3["Ignore"] = 1] = "Ignore";
})(DecodingPadding2 || (DecodingPadding2 = {}));
// node_modules/@oslojs/binary/dist/uint.js
class BigEndian {
  uint8(data, offset) {
    if (data.byteLength < offset + 1) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset];
  }
  uint16(data, offset) {
    if (data.byteLength < offset + 2) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset] << 8 | data[offset + 1];
  }
  uint32(data, offset) {
    if (data.byteLength < offset + 4) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0;
    for (let i3 = 0;i3 < 4; i3++) {
      result |= data[offset + i3] << 24 - i3 * 8;
    }
    return result;
  }
  uint64(data, offset) {
    if (data.byteLength < offset + 8) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0n;
    for (let i3 = 0;i3 < 8; i3++) {
      result |= BigInt(data[offset + i3]) << BigInt(56 - i3 * 8);
    }
    return result;
  }
  putUint8(target, value15, offset) {
    if (target.length < offset + 1) {
      throw new TypeError("Not enough space");
    }
    if (value15 < 0 || value15 > 255) {
      throw new TypeError("Invalid uint8 value");
    }
    target[offset] = value15;
  }
  putUint16(target, value15, offset) {
    if (target.length < offset + 2) {
      throw new TypeError("Not enough space");
    }
    if (value15 < 0 || value15 > 65535) {
      throw new TypeError("Invalid uint16 value");
    }
    target[offset] = value15 >> 8;
    target[offset + 1] = value15 & 255;
  }
  putUint32(target, value15, offset) {
    if (target.length < offset + 4) {
      throw new TypeError("Not enough space");
    }
    if (value15 < 0 || value15 > 4294967295) {
      throw new TypeError("Invalid uint32 value");
    }
    for (let i3 = 0;i3 < 4; i3++) {
      target[offset + i3] = value15 >> (3 - i3) * 8 & 255;
    }
  }
  putUint64(target, value15, offset) {
    if (target.length < offset + 8) {
      throw new TypeError("Not enough space");
    }
    if (value15 < 0 || value15 > 18446744073709551615n) {
      throw new TypeError("Invalid uint64 value");
    }
    for (let i3 = 0;i3 < 8; i3++) {
      target[offset + i3] = Number(value15 >> BigInt((7 - i3) * 8) & 0xffn);
    }
  }
}

class LittleEndian {
  uint8(data, offset) {
    if (data.byteLength < offset + 1) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset];
  }
  uint16(data, offset) {
    if (data.byteLength < offset + 2) {
      throw new TypeError("Insufficient bytes");
    }
    return data[offset] | data[offset + 1] << 8;
  }
  uint32(data, offset) {
    if (data.byteLength < offset + 4) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0;
    for (let i3 = 0;i3 < 4; i3++) {
      result |= data[offset + i3] << i3 * 8;
    }
    return result;
  }
  uint64(data, offset) {
    if (data.byteLength < offset + 8) {
      throw new TypeError("Insufficient bytes");
    }
    let result = 0n;
    for (let i3 = 0;i3 < 8; i3++) {
      result |= BigInt(data[offset + i3]) << BigInt(i3 * 8);
    }
    return result;
  }
  putUint8(target, value15, offset) {
    if (target.length < 1 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value15 < 0 || value15 > 255) {
      throw new TypeError("Invalid uint8 value");
    }
    target[offset] = value15;
  }
  putUint16(target, value15, offset) {
    if (target.length < 2 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value15 < 0 || value15 > 65535) {
      throw new TypeError("Invalid uint16 value");
    }
    target[offset + 1] = value15 >> 8;
    target[offset] = value15 & 255;
  }
  putUint32(target, value15, offset) {
    if (target.length < 4 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value15 < 0 || value15 > 4294967295) {
      throw new TypeError("Invalid uint32 value");
    }
    for (let i3 = 0;i3 < 4; i3++) {
      target[offset + i3] = value15 >> i3 * 8 & 255;
    }
  }
  putUint64(target, value15, offset) {
    if (target.length < 8 + offset) {
      throw new TypeError("Insufficient space");
    }
    if (value15 < 0 || value15 > 18446744073709551615n) {
      throw new TypeError("Invalid uint64 value");
    }
    for (let i3 = 0;i3 < 8; i3++) {
      target[offset + i3] = Number(value15 >> BigInt(i3 * 8) & 0xffn);
    }
  }
}
var bigEndian = new BigEndian;
var littleEndian = new LittleEndian;
// node_modules/@oslojs/binary/dist/bits.js
function rotr32(x3, n3) {
  return (x3 << 32 - n3 | x3 >>> n3) >>> 0;
}
function rotr64(x3, n3) {
  return (x3 << BigInt(64 - n3) | x3 >> BigInt(n3)) & 0xffffffffffffffffn;
}
// node_modules/@oslojs/crypto/dist/sha2/sha224.js
class SHA224 {
  blockSize = 64;
  size = 32;
  blocks = new Uint8Array(64);
  currentBlockSize = 0;
  H = new Uint32Array([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]);
  l = 0n;
  w = new Uint32Array(64);
  update(data) {
    this.l += BigInt(data.byteLength) * 8n;
    if (this.currentBlockSize + data.byteLength < 64) {
      this.blocks.set(data, this.currentBlockSize);
      this.currentBlockSize += data.byteLength;
      return;
    }
    let processed = 0;
    if (this.currentBlockSize > 0) {
      const next = data.slice(0, 64 - this.currentBlockSize);
      this.blocks.set(next, this.currentBlockSize);
      this.process();
      processed += next.byteLength;
      this.currentBlockSize = 0;
    }
    while (processed + 64 <= data.byteLength) {
      const next = data.slice(processed, processed + 64);
      this.blocks.set(next);
      this.process();
      processed += 64;
    }
    if (data.byteLength - processed > 0) {
      const remaining = data.slice(processed);
      this.blocks.set(remaining);
      this.currentBlockSize = remaining.byteLength;
    }
  }
  digest() {
    this.blocks[this.currentBlockSize] = 128;
    this.currentBlockSize += 1;
    if (64 - this.currentBlockSize < 8) {
      this.blocks.fill(0, this.currentBlockSize);
      this.process();
      this.currentBlockSize = 0;
    }
    this.blocks.fill(0, this.currentBlockSize);
    bigEndian.putUint64(this.blocks, this.l, this.blockSize - 8);
    this.process();
    const result = new Uint8Array(28);
    for (let i3 = 0;i3 < 7; i3++) {
      bigEndian.putUint32(result, this.H[i3], i3 * 4);
    }
    return result;
  }
  process() {
    for (let t3 = 0;t3 < 16; t3++) {
      this.w[t3] = (this.blocks[t3 * 4] << 24 | this.blocks[t3 * 4 + 1] << 16 | this.blocks[t3 * 4 + 2] << 8 | this.blocks[t3 * 4 + 3]) >>> 0;
    }
    for (let t3 = 16;t3 < 64; t3++) {
      const sigma1 = (rotr32(this.w[t3 - 2], 17) ^ rotr32(this.w[t3 - 2], 19) ^ this.w[t3 - 2] >>> 10) >>> 0;
      const sigma0 = (rotr32(this.w[t3 - 15], 7) ^ rotr32(this.w[t3 - 15], 18) ^ this.w[t3 - 15] >>> 3) >>> 0;
      this.w[t3] = sigma1 + this.w[t3 - 7] + sigma0 + this.w[t3 - 16] | 0;
    }
    let a = this.H[0];
    let b = this.H[1];
    let c3 = this.H[2];
    let d3 = this.H[3];
    let e = this.H[4];
    let f3 = this.H[5];
    let g = this.H[6];
    let h = this.H[7];
    for (let t3 = 0;t3 < 64; t3++) {
      const sigma1 = (rotr32(e, 6) ^ rotr32(e, 11) ^ rotr32(e, 25)) >>> 0;
      const ch = (e & f3 ^ ~e & g) >>> 0;
      const t12 = h + sigma1 + ch + K[t3] + this.w[t3] | 0;
      const sigma0 = (rotr32(a, 2) ^ rotr32(a, 13) ^ rotr32(a, 22)) >>> 0;
      const maj = (a & b ^ a & c3 ^ b & c3) >>> 0;
      const t22 = sigma0 + maj | 0;
      h = g;
      g = f3;
      f3 = e;
      e = d3 + t12 | 0;
      d3 = c3;
      c3 = b;
      b = a;
      a = t12 + t22 | 0;
    }
    this.H[0] = a + this.H[0] | 0;
    this.H[1] = b + this.H[1] | 0;
    this.H[2] = c3 + this.H[2] | 0;
    this.H[3] = d3 + this.H[3] | 0;
    this.H[4] = e + this.H[4] | 0;
    this.H[5] = f3 + this.H[5] | 0;
    this.H[6] = g + this.H[6] | 0;
    this.H[7] = h + this.H[7] | 0;
  }
}
var K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
// node_modules/@oslojs/crypto/dist/sha2/sha256.js
function sha2562(data) {
  const hash7 = new SHA256;
  hash7.update(data);
  return hash7.digest();
}

class SHA256 {
  blockSize = 64;
  size = 32;
  blocks = new Uint8Array(64);
  currentBlockSize = 0;
  H = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  l = 0n;
  w = new Uint32Array(64);
  update(data) {
    this.l += BigInt(data.byteLength) * 8n;
    if (this.currentBlockSize + data.byteLength < 64) {
      this.blocks.set(data, this.currentBlockSize);
      this.currentBlockSize += data.byteLength;
      return;
    }
    let processed = 0;
    if (this.currentBlockSize > 0) {
      const next = data.slice(0, 64 - this.currentBlockSize);
      this.blocks.set(next, this.currentBlockSize);
      this.process();
      processed += next.byteLength;
      this.currentBlockSize = 0;
    }
    while (processed + 64 <= data.byteLength) {
      const next = data.slice(processed, processed + 64);
      this.blocks.set(next);
      this.process();
      processed += 64;
    }
    if (data.byteLength - processed > 0) {
      const remaining = data.slice(processed);
      this.blocks.set(remaining);
      this.currentBlockSize = remaining.byteLength;
    }
  }
  digest() {
    this.blocks[this.currentBlockSize] = 128;
    this.currentBlockSize += 1;
    if (64 - this.currentBlockSize < 8) {
      this.blocks.fill(0, this.currentBlockSize);
      this.process();
      this.currentBlockSize = 0;
    }
    this.blocks.fill(0, this.currentBlockSize);
    bigEndian.putUint64(this.blocks, this.l, this.blockSize - 8);
    this.process();
    const result = new Uint8Array(32);
    for (let i3 = 0;i3 < 8; i3++) {
      bigEndian.putUint32(result, this.H[i3], i3 * 4);
    }
    return result;
  }
  process() {
    for (let t3 = 0;t3 < 16; t3++) {
      this.w[t3] = (this.blocks[t3 * 4] << 24 | this.blocks[t3 * 4 + 1] << 16 | this.blocks[t3 * 4 + 2] << 8 | this.blocks[t3 * 4 + 3]) >>> 0;
    }
    for (let t3 = 16;t3 < 64; t3++) {
      const sigma1 = (rotr32(this.w[t3 - 2], 17) ^ rotr32(this.w[t3 - 2], 19) ^ this.w[t3 - 2] >>> 10) >>> 0;
      const sigma0 = (rotr32(this.w[t3 - 15], 7) ^ rotr32(this.w[t3 - 15], 18) ^ this.w[t3 - 15] >>> 3) >>> 0;
      this.w[t3] = sigma1 + this.w[t3 - 7] + sigma0 + this.w[t3 - 16] | 0;
    }
    let a = this.H[0];
    let b = this.H[1];
    let c3 = this.H[2];
    let d3 = this.H[3];
    let e = this.H[4];
    let f3 = this.H[5];
    let g = this.H[6];
    let h = this.H[7];
    for (let t3 = 0;t3 < 64; t3++) {
      const sigma1 = (rotr32(e, 6) ^ rotr32(e, 11) ^ rotr32(e, 25)) >>> 0;
      const ch = (e & f3 ^ ~e & g) >>> 0;
      const t12 = h + sigma1 + ch + K3[t3] + this.w[t3] | 0;
      const sigma0 = (rotr32(a, 2) ^ rotr32(a, 13) ^ rotr32(a, 22)) >>> 0;
      const maj = (a & b ^ a & c3 ^ b & c3) >>> 0;
      const t22 = sigma0 + maj | 0;
      h = g;
      g = f3;
      f3 = e;
      e = d3 + t12 | 0;
      d3 = c3;
      c3 = b;
      b = a;
      a = t12 + t22 | 0;
    }
    this.H[0] = a + this.H[0] | 0;
    this.H[1] = b + this.H[1] | 0;
    this.H[2] = c3 + this.H[2] | 0;
    this.H[3] = d3 + this.H[3] | 0;
    this.H[4] = e + this.H[4] | 0;
    this.H[5] = f3 + this.H[5] | 0;
    this.H[6] = g + this.H[6] | 0;
    this.H[7] = h + this.H[7] | 0;
  }
}
var K3 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
// node_modules/@oslojs/crypto/dist/sha2/sha512.js
class SharedSHA512 {
  blockSize = 128;
  size = 64;
  blocks = new Uint8Array(128);
  currentBlockSize = 0;
  l = 0n;
  w = new BigUint64Array(80);
  H;
  constructor(H) {
    if (H.byteLength !== 64) {
      throw new TypeError;
    }
    this.H = H;
  }
  update(data) {
    this.l += BigInt(data.byteLength) * 8n;
    if (this.currentBlockSize + data.byteLength < 128) {
      this.blocks.set(data, this.currentBlockSize);
      this.currentBlockSize += data.byteLength;
      return;
    }
    let processed = 0;
    if (this.currentBlockSize > 0) {
      const next = data.slice(0, 128 - this.currentBlockSize);
      this.blocks.set(next, this.currentBlockSize);
      this.process();
      processed += next.byteLength;
      this.currentBlockSize = 0;
    }
    while (processed + 128 <= data.byteLength) {
      const next = data.slice(processed, processed + 128);
      this.blocks.set(next);
      this.process();
      processed += 128;
      this.currentBlockSize = 0;
    }
    if (data.byteLength - processed > 0) {
      const remaining = data.slice(processed);
      this.blocks.set(remaining);
      this.currentBlockSize = remaining.byteLength;
    }
  }
  putDigest(result) {
    if (result.byteLength > 64 || result.byteLength % 8 !== 0) {
      throw new TypeError;
    }
    this.blocks[this.currentBlockSize] = 128;
    this.currentBlockSize += 1;
    if (128 - this.currentBlockSize < 16) {
      this.blocks.fill(0, this.currentBlockSize);
      this.process();
      this.currentBlockSize = 0;
    }
    this.blocks.fill(0, this.currentBlockSize);
    bigEndian.putUint64(this.blocks, this.l, this.blockSize - 8);
    this.process();
    for (let i3 = 0;i3 < result.byteLength / 8; i3++) {
      bigEndian.putUint64(result, this.H[i3], i3 * 8);
    }
  }
  process() {
    for (let t3 = 0;t3 < 16; t3++) {
      this.w[t3] = BigInt(this.blocks[t3 * 8]) << 56n | BigInt(this.blocks[t3 * 8 + 1]) << 48n | BigInt(this.blocks[t3 * 8 + 2]) << 40n | BigInt(this.blocks[t3 * 8 + 3]) << 32n | BigInt(this.blocks[t3 * 8 + 4]) << 24n | BigInt(this.blocks[t3 * 8 + 5]) << 16n | BigInt(this.blocks[t3 * 8 + 6]) << 8n | BigInt(this.blocks[t3 * 8 + 7]);
    }
    for (let t3 = 16;t3 < 80; t3++) {
      const sigma1 = (rotr64(this.w[t3 - 2], 19) ^ rotr64(this.w[t3 - 2], 61) ^ this.w[t3 - 2] >> 6n) & 0xffffffffffffffffn;
      const sigma0 = (rotr64(this.w[t3 - 15], 1) ^ rotr64(this.w[t3 - 15], 8) ^ this.w[t3 - 15] >> 7n) & 0xffffffffffffffffn;
      this.w[t3] = sigma1 + this.w[t3 - 7] + sigma0 + this.w[t3 - 16] & 0xffffffffffffffffn;
    }
    let a = this.H[0];
    let b = this.H[1];
    let c3 = this.H[2];
    let d3 = this.H[3];
    let e = this.H[4];
    let f3 = this.H[5];
    let g = this.H[6];
    let h = this.H[7];
    for (let t3 = 0;t3 < 80; t3++) {
      const sigma1 = (rotr64(e, 14) ^ rotr64(e, 18) ^ rotr64(e, 41)) & 0xffffffffffffffffn;
      const ch = (e & f3 ^ ~e & g) & 0xffffffffffffffffn;
      const t12 = h + sigma1 + ch + K5[t3] + this.w[t3] & 0xffffffffffffffffn;
      const sigma0 = (rotr64(a, 28) ^ rotr64(a, 34) ^ rotr64(a, 39)) & 0xffffffffffffffffn;
      const maj = (a & b ^ a & c3 ^ b & c3) & 0xffffffffffffffffn;
      const t22 = sigma0 + maj & 0xffffffffffffffffn;
      h = g;
      g = f3;
      f3 = e;
      e = d3 + t12 & 0xffffffffffffffffn;
      d3 = c3;
      c3 = b;
      b = a;
      a = t12 + t22 & 0xffffffffffffffffn;
    }
    this.H[0] = a + this.H[0] & 0xffffffffffffffffn;
    this.H[1] = b + this.H[1] & 0xffffffffffffffffn;
    this.H[2] = c3 + this.H[2] & 0xffffffffffffffffn;
    this.H[3] = d3 + this.H[3] & 0xffffffffffffffffn;
    this.H[4] = e + this.H[4] & 0xffffffffffffffffn;
    this.H[5] = f3 + this.H[5] & 0xffffffffffffffffn;
    this.H[6] = g + this.H[6] & 0xffffffffffffffffn;
    this.H[7] = h + this.H[7] & 0xffffffffffffffffn;
  }
}

class SHA512 {
  blockSize = 128;
  size = 64;
  sha512 = new SharedSHA512(new BigUint64Array([
    0x6a09e667f3bcc908n,
    0xbb67ae8584caa73bn,
    0x3c6ef372fe94f82bn,
    0xa54ff53a5f1d36f1n,
    0x510e527fade682d1n,
    0x9b05688c2b3e6c1fn,
    0x1f83d9abfb41bd6bn,
    0x5be0cd19137e2179n
  ]));
  update(data) {
    this.sha512.update(data);
  }
  digest() {
    const result = new Uint8Array(64);
    this.sha512.putDigest(result);
    return result;
  }
}
var K5 = new BigUint64Array([
  0x428a2f98d728ae22n,
  0x7137449123ef65cdn,
  0xb5c0fbcfec4d3b2fn,
  0xe9b5dba58189dbbcn,
  0x3956c25bf348b538n,
  0x59f111f1b605d019n,
  0x923f82a4af194f9bn,
  0xab1c5ed5da6d8118n,
  0xd807aa98a3030242n,
  0x12835b0145706fben,
  0x243185be4ee4b28cn,
  0x550c7dc3d5ffb4e2n,
  0x72be5d74f27b896fn,
  0x80deb1fe3b1696b1n,
  0x9bdc06a725c71235n,
  0xc19bf174cf692694n,
  0xe49b69c19ef14ad2n,
  0xefbe4786384f25e3n,
  0x0fc19dc68b8cd5b5n,
  0x240ca1cc77ac9c65n,
  0x2de92c6f592b0275n,
  0x4a7484aa6ea6e483n,
  0x5cb0a9dcbd41fbd4n,
  0x76f988da831153b5n,
  0x983e5152ee66dfabn,
  0xa831c66d2db43210n,
  0xb00327c898fb213fn,
  0xbf597fc7beef0ee4n,
  0xc6e00bf33da88fc2n,
  0xd5a79147930aa725n,
  0x06ca6351e003826fn,
  0x142929670a0e6e70n,
  0x27b70a8546d22ffcn,
  0x2e1b21385c26c926n,
  0x4d2c6dfc5ac42aedn,
  0x53380d139d95b3dfn,
  0x650a73548baf63den,
  0x766a0abb3c77b2a8n,
  0x81c2c92e47edaee6n,
  0x92722c851482353bn,
  0xa2bfe8a14cf10364n,
  0xa81a664bbc423001n,
  0xc24b8b70d0f89791n,
  0xc76c51a30654be30n,
  0xd192e819d6ef5218n,
  0xd69906245565a910n,
  0xf40e35855771202an,
  0x106aa07032bbd1b8n,
  0x19a4c116b8d2d0c8n,
  0x1e376c085141ab53n,
  0x2748774cdf8eeb99n,
  0x34b0bcb5e19b48a8n,
  0x391c0cb3c5c95a63n,
  0x4ed8aa4ae3418acbn,
  0x5b9cca4f7763e373n,
  0x682e6ff3d6b2b8a3n,
  0x748f82ee5defb2fcn,
  0x78a5636f43172f60n,
  0x84c87814a1f0ab72n,
  0x8cc702081a6439ecn,
  0x90befffa23631e28n,
  0xa4506cebde82bde9n,
  0xbef9a3f7b2c67915n,
  0xc67178f2e372532bn,
  0xca273eceea26619cn,
  0xd186b8c721c0c207n,
  0xeada7dd6cde0eb1en,
  0xf57d4f7fee6ed178n,
  0x06f067aa72176fban,
  0x0a637dc5a2c898a6n,
  0x113f9804bef90daen,
  0x1b710b35131c471bn,
  0x28db77f523047d84n,
  0x32caab7b40c72493n,
  0x3c9ebe0a15c9bebcn,
  0x431d67c49c100d4cn,
  0x4cc5d4becb3e42b6n,
  0x597f299cfc657e2an,
  0x5fcb6fab3ad6faecn,
  0x6c44198c4a475817n
]);

// node_modules/@oslojs/crypto/dist/sha2/sha384.js
class SHA384 {
  blockSize = 128;
  size = 48;
  sha512 = new SharedSHA512(new BigUint64Array([
    0xcbbb9d5dc1059ed8n,
    0x629a292a367cd507n,
    0x9159015a3070dd17n,
    0x152fecd8f70e5939n,
    0x67332667ffc00b31n,
    0x8eb44a8768581511n,
    0xdb0c2e0d64f98fa7n,
    0x47b5481dbefa4fa4n
  ]));
  update(data) {
    this.sha512.update(data);
  }
  digest() {
    const result = new Uint8Array(48);
    this.sha512.putDigest(result);
    return result;
  }
}
// node_modules/@oslojs/crypto/dist/sha2/sha512_224.js
class SHA512_224 {
  blockSize = 128;
  size = 28;
  sha512 = new SharedSHA512(new BigUint64Array([
    0x8c3d37c819544da2n,
    0x73e1996689dcd4d6n,
    0x1dfab7ae32ff9c82n,
    0x679dd514582f9fcfn,
    0x0f6d2b697bd44da8n,
    0x77e36f7304c48942n,
    0x3f9d85a86a1d36c8n,
    0x1112e6ad91d692a1n
  ]));
  update(data) {
    this.sha512.update(data);
  }
  digest() {
    const result = new Uint8Array(32);
    this.sha512.putDigest(result);
    return result.slice(0, 28);
  }
}
// node_modules/@oslojs/crypto/dist/sha2/sha512_256.js
class SHA512_256 {
  blockSize = 128;
  size = 28;
  sha512 = new SharedSHA512(new BigUint64Array([
    0x22312194fc2bf72cn,
    0x9f555fa3c84c64c2n,
    0x2393b86b6f53b151n,
    0x963877195940eabdn,
    0x96283ee2a88effe3n,
    0xbe5e1e2553863992n,
    0x2b0199fc2c85b8aan,
    0x0eb72ddc81c52ca2n
  ]));
  update(data) {
    this.sha512.update(data);
  }
  digest() {
    const result = new Uint8Array(32);
    this.sha512.putDigest(result);
    return result;
  }
}
// node_modules/arctic/dist/oauth2.js
function createS256CodeChallenge(codeVerifier) {
  const codeChallengeBytes = sha2562(new TextEncoder().encode(codeVerifier));
  return encodeBase64urlNoPadding(codeChallengeBytes);
}
function generateCodeVerifier() {
  const randomValues = new Uint8Array(32);
  crypto.getRandomValues(randomValues);
  return encodeBase64urlNoPadding(randomValues);
}
function generateState() {
  const randomValues = new Uint8Array(32);
  crypto.getRandomValues(randomValues);
  return encodeBase64urlNoPadding(randomValues);
}

class OAuth2Tokens {
  data;
  constructor(data) {
    this.data = data;
  }
  tokenType() {
    if ("token_type" in this.data && typeof this.data.token_type === "string") {
      return this.data.token_type;
    }
    throw new Error("Missing or invalid 'token_type' field");
  }
  accessToken() {
    if ("access_token" in this.data && typeof this.data.access_token === "string") {
      return this.data.access_token;
    }
    throw new Error("Missing or invalid 'access_token' field");
  }
  accessTokenExpiresInSeconds() {
    if ("expires_in" in this.data && typeof this.data.expires_in === "number") {
      return this.data.expires_in;
    }
    throw new Error("Missing or invalid 'expires_in' field");
  }
  accessTokenExpiresAt() {
    return new Date(Date.now() + this.accessTokenExpiresInSeconds() * 1000);
  }
  hasRefreshToken() {
    return "refresh_token" in this.data && typeof this.data.refresh_token === "string";
  }
  refreshToken() {
    if ("refresh_token" in this.data && typeof this.data.refresh_token === "string") {
      return this.data.refresh_token;
    }
    throw new Error("Missing or invalid 'refresh_token' field");
  }
  hasScopes() {
    return "scope" in this.data && typeof this.data.scope === "string";
  }
  scopes() {
    if ("scope" in this.data && typeof this.data.scope === "string") {
      return this.data.scope.split(" ");
    }
    throw new Error("Missing or invalid 'scope' field");
  }
  idToken() {
    if ("id_token" in this.data && typeof this.data.id_token === "string") {
      return this.data.id_token;
    }
    throw new Error("Missing or invalid field 'id_token'");
  }
}

// node_modules/arctic/dist/request.js
function createOAuth2Request(endpoint, body) {
  const request = new Request(endpoint, {
    method: "POST",
    body
  });
  request.headers.set("Content-Type", "application/x-www-form-urlencoded");
  request.headers.set("Accept", "application/json");
  request.headers.set("User-Agent", "arctic");
  return request;
}
function encodeBasicCredentials(username, password) {
  const bytes2 = new TextEncoder().encode(`${username}:${password}`);
  return encodeBase642(bytes2);
}
async function sendTokenRequest(request) {
  let response;
  try {
    response = await fetch(request);
  } catch (e) {
    throw new ArcticFetchError(e);
  }
  let data;
  try {
    data = await response.json();
  } catch {
    throw new Error("Failed to parse response body");
  }
  if (typeof data !== "object" || data === null) {
    throw new Error("Unexpected response body data");
  }
  if ("error" in data && typeof data.error === "string") {
    const error23 = createOAuth2RequestError(data);
    throw error23;
  }
  return new OAuth2Tokens(data);
}
async function sendTokenRevocationRequest(request) {
  let response;
  try {
    response = await fetch(request);
  } catch (e) {
    throw new ArcticFetchError(e);
  }
  if (response.ok) {
    return;
  }
  let data;
  try {
    data = await response.json();
  } catch {
    throw new Error("Failed to parse response body");
  }
  if (typeof data !== "object" || data === null) {
    throw new Error("Unexpected response body data");
  }
  if ("error" in data && typeof data.error === "string") {
    const error23 = createOAuth2RequestError(data);
    throw error23;
  }
}
function createOAuth2RequestError(result) {
  let code;
  if ("error" in result && typeof result.error === "string") {
    code = result.error;
  } else {
    throw new Error("Invalid error response");
  }
  let description = null;
  let uri = null;
  let state = null;
  if ("error_description" in result && typeof result.error_description === "string") {
    description = result.error_description;
  }
  if ("error_uri" in result && typeof result.error_uri === "string") {
    uri = result.error_uri;
  }
  if ("state" in result && typeof result.state === "string") {
    state = result.state;
  }
  return new OAuth2RequestError(code, description, uri, state);
}

class ArcticFetchError extends Error {
  constructor(cause) {
    super("Failed to send request", {
      cause
    });
  }
}

class OAuth2RequestError extends Error {
  code;
  description;
  uri;
  state;
  constructor(code, description, uri, state) {
    super(`OAuth request error: ${code}`);
    this.code = code;
    this.description = description;
    this.uri = uri;
    this.state = state;
  }
}

// node_modules/arctic/dist/client.js
class OAuth2Client {
  clientId;
  clientPassword;
  redirectURI;
  constructor(clientId, clientPassword, redirectURI) {
    this.clientId = clientId;
    this.clientPassword = clientPassword;
    this.redirectURI = redirectURI;
  }
  createAuthorizationURL(authorizationEndpoint, state, scopes) {
    const url = new URL(authorizationEndpoint);
    url.searchParams.set("response_type", "code");
    url.searchParams.set("client_id", this.clientId);
    if (this.redirectURI !== null) {
      url.searchParams.set("redirect_uri", this.redirectURI);
    }
    url.searchParams.set("state", state);
    if (scopes.length > 0) {
      url.searchParams.set("scope", scopes.join(" "));
    }
    return url;
  }
  createAuthorizationURLWithPKCE(authorizationEndpoint, state, codeChallengeMethod, codeVerifier, scopes) {
    const url = new URL(authorizationEndpoint);
    url.searchParams.set("response_type", "code");
    url.searchParams.set("client_id", this.clientId);
    if (this.redirectURI !== null) {
      url.searchParams.set("redirect_uri", this.redirectURI);
    }
    url.searchParams.set("state", state);
    if (codeChallengeMethod === CodeChallengeMethod.S256) {
      const codeChallenge = createS256CodeChallenge(codeVerifier);
      url.searchParams.set("code_challenge_method", "S256");
      url.searchParams.set("code_challenge", codeChallenge);
    } else if (codeChallengeMethod === CodeChallengeMethod.Plain) {
      url.searchParams.set("code_challenge_method", "plain");
      url.searchParams.set("code_challenge", codeVerifier);
    }
    if (scopes.length > 0) {
      url.searchParams.set("scope", scopes.join(" "));
    }
    return url;
  }
  async validateAuthorizationCode(tokenEndpoint, code, codeVerifier) {
    const body = new URLSearchParams;
    body.set("grant_type", "authorization_code");
    body.set("code", code);
    if (this.redirectURI !== null) {
      body.set("redirect_uri", this.redirectURI);
    }
    if (codeVerifier !== null) {
      body.set("code_verifier", codeVerifier);
    }
    if (this.clientPassword === null) {
      body.set("client_id", this.clientId);
    }
    const request3 = createOAuth2Request(tokenEndpoint, body);
    if (this.clientPassword !== null) {
      const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientPassword);
      request3.headers.set("Authorization", `Basic ${encodedCredentials}`);
    }
    const tokens = await sendTokenRequest(request3);
    return tokens;
  }
  async refreshAccessToken(tokenEndpoint, refreshToken, scopes) {
    const body = new URLSearchParams;
    body.set("grant_type", "refresh_token");
    body.set("refresh_token", refreshToken);
    if (this.clientPassword === null) {
      body.set("client_id", this.clientId);
    }
    if (scopes.length > 0) {
      body.set("scope", scopes.join(" "));
    }
    const request3 = createOAuth2Request(tokenEndpoint, body);
    if (this.clientPassword !== null) {
      const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientPassword);
      request3.headers.set("Authorization", `Basic ${encodedCredentials}`);
    }
    const tokens = await sendTokenRequest(request3);
    return tokens;
  }
  async revokeToken(tokenRevocationEndpoint, token) {
    const body = new URLSearchParams;
    body.set("token", token);
    if (this.clientPassword === null) {
      body.set("client_id", this.clientId);
    }
    const request3 = createOAuth2Request(tokenRevocationEndpoint, body);
    if (this.clientPassword !== null) {
      const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientPassword);
      request3.headers.set("Authorization", `Basic ${encodedCredentials}`);
    }
    await sendTokenRevocationRequest(request3);
  }
}
var CodeChallengeMethod;
(function(CodeChallengeMethod2) {
  CodeChallengeMethod2[CodeChallengeMethod2["S256"] = 0] = "S256";
  CodeChallengeMethod2[CodeChallengeMethod2["Plain"] = 1] = "Plain";
})(CodeChallengeMethod || (CodeChallengeMethod = {}));
// node_modules/@oslojs/jwt/node_modules/@oslojs/encoding/dist/base32.js
var EncodingPadding3;
(function(EncodingPadding4) {
  EncodingPadding4[EncodingPadding4["Include"] = 0] = "Include";
  EncodingPadding4[EncodingPadding4["None"] = 1] = "None";
})(EncodingPadding3 || (EncodingPadding3 = {}));
var DecodingPadding3;
(function(DecodingPadding4) {
  DecodingPadding4[DecodingPadding4["Required"] = 0] = "Required";
  DecodingPadding4[DecodingPadding4["Ignore"] = 1] = "Ignore";
})(DecodingPadding3 || (DecodingPadding3 = {}));
// node_modules/@oslojs/jwt/node_modules/@oslojs/encoding/dist/base64.js
var EncodingPadding4;
(function(EncodingPadding5) {
  EncodingPadding5[EncodingPadding5["Include"] = 0] = "Include";
  EncodingPadding5[EncodingPadding5["None"] = 1] = "None";
})(EncodingPadding4 || (EncodingPadding4 = {}));
var DecodingPadding4;
(function(DecodingPadding5) {
  DecodingPadding5[DecodingPadding5["Required"] = 0] = "Required";
  DecodingPadding5[DecodingPadding5["Ignore"] = 1] = "Ignore";
})(DecodingPadding4 || (DecodingPadding4 = {}));
// node_modules/arctic/dist/providers/discord.js
var authorizationEndpoint = "https://discord.com/oauth2/authorize";
var tokenEndpoint = "https://discord.com/api/oauth2/token";
var tokenRevocationEndpoint = "https://discord.com/api/oauth2/token/revoke";

class Discord {
  client;
  constructor(clientId, clientSecret, redirectURI) {
    this.client = new OAuth2Client(clientId, clientSecret, redirectURI);
  }
  createAuthorizationURL(state, scopes) {
    const url = this.client.createAuthorizationURL(authorizationEndpoint, state, scopes);
    return url;
  }
  async validateAuthorizationCode(code) {
    const tokens = await this.client.validateAuthorizationCode(tokenEndpoint, code, null);
    return tokens;
  }
  async refreshAccessToken(refreshToken) {
    const tokens = await this.client.refreshAccessToken(tokenEndpoint, refreshToken, []);
    return tokens;
  }
  async revokeToken(token) {
    await this.client.revokeToken(tokenRevocationEndpoint, token);
  }
}
// node_modules/arctic/dist/providers/facebook.js
var authorizationEndpoint2 = "https://www.facebook.com/v16.0/dialog/oauth";
var tokenEndpoint2 = "https://graph.facebook.com/v16.0/oauth/access_token";

class Facebook {
  clientId;
  clientSecret;
  redirectURI;
  constructor(clientId, clientSecret, redirectURI) {
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.redirectURI = redirectURI;
  }
  createAuthorizationURL(state, scopes) {
    const url = new URL(authorizationEndpoint2);
    url.searchParams.set("response_type", "code");
    url.searchParams.set("client_id", this.clientId);
    url.searchParams.set("state", state);
    url.searchParams.set("scope", scopes.join(" "));
    url.searchParams.set("redirect_uri", this.redirectURI);
    return url;
  }
  async validateAuthorizationCode(code) {
    const body = new URLSearchParams;
    body.set("grant_type", "authorization_code");
    body.set("code", code);
    body.set("redirect_uri", this.redirectURI);
    body.set("client_id", this.clientId);
    body.set("client_secret", this.clientSecret);
    const request9 = createOAuth2Request(tokenEndpoint2, body);
    const tokens = await sendTokenRequest(request9);
    return tokens;
  }
}
// node_modules/arctic/dist/providers/github.js
var authorizationEndpoint3 = "https://github.com/login/oauth/authorize";
var tokenEndpoint3 = "https://github.com/login/oauth/access_token";

class GitHub {
  clientId;
  clientSecret;
  redirectURI;
  constructor(clientId, clientSecret, redirectURI) {
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.redirectURI = redirectURI;
  }
  createAuthorizationURL(state, scopes) {
    const url = new URL(authorizationEndpoint3);
    url.searchParams.set("response_type", "code");
    url.searchParams.set("client_id", this.clientId);
    url.searchParams.set("state", state);
    url.searchParams.set("scope", scopes.join(" "));
    if (this.redirectURI !== null) {
      url.searchParams.set("redirect_uri", this.redirectURI);
    }
    return url;
  }
  async validateAuthorizationCode(code) {
    const body = new URLSearchParams;
    body.set("grant_type", "authorization_code");
    body.set("code", code);
    if (this.redirectURI !== null) {
      body.set("redirect_uri", this.redirectURI);
    }
    const request10 = createOAuth2Request(tokenEndpoint3, body);
    const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientSecret);
    request10.headers.set("Authorization", `Basic ${encodedCredentials}`);
    const tokens = await sendTokenRequest(request10);
    return tokens;
  }
  async refreshAccessToken(refreshToken) {
    const body = new URLSearchParams;
    body.set("grant_type", "refresh_token");
    body.set("refresh_token", refreshToken);
    const request10 = createOAuth2Request(tokenEndpoint3, body);
    const encodedCredentials = encodeBasicCredentials(this.clientId, this.clientSecret);
    request10.headers.set("Authorization", `Basic ${encodedCredentials}`);
    const tokens = await sendTokenRequest(request10);
    return tokens;
  }
}
// node_modules/arctic/dist/providers/google.js
var authorizationEndpoint4 = "https://accounts.google.com/o/oauth2/v2/auth";
var tokenEndpoint4 = "https://oauth2.googleapis.com/token";
var tokenRevocationEndpoint2 = "https://oauth2.googleapis.com/revoke";

class Google {
  client;
  constructor(clientId, clientSecret, redirectURI) {
    this.client = new OAuth2Client(clientId, clientSecret, redirectURI);
  }
  createAuthorizationURL(state, codeVerifier, scopes) {
    const url = this.client.createAuthorizationURLWithPKCE(authorizationEndpoint4, state, CodeChallengeMethod.S256, codeVerifier, scopes);
    return url;
  }
  async validateAuthorizationCode(code, codeVerifier) {
    const tokens = await this.client.validateAuthorizationCode(tokenEndpoint4, code, codeVerifier);
    return tokens;
  }
  async refreshAccessToken(refreshToken) {
    const tokens = await this.client.refreshAccessToken(tokenEndpoint4, refreshToken, []);
    return tokens;
  }
  async revokeToken(token) {
    await this.client.revokeToken(tokenRevocationEndpoint2, token);
  }
}
// src/libs/oauthProviders.ts
var baseURL = Bun.env.BASE_URL ?? "http://localhost:3121";
var googleClientId = Bun.env.GOOGLE_CLIENT_ID;
var googleClientSecret = Bun.env.GOOGLE_CLIENT_SECRET;
var google = new Google(googleClientId, googleClientSecret, `${baseURL}/v2/auth/google/callback`);
var githubClientId = Bun.env.GITHUB_CLIENT_ID;
var githubClientSecret = Bun.env.GITHUB_CLIENT_SECRET;
var github = githubClientId && githubClientSecret ? new GitHub(githubClientId, githubClientSecret, `${baseURL}/v2/auth/github/callback`) : null;
var discordClientId = Bun.env.DISCORD_CLIENT_ID;
var discordClientSecret = Bun.env.DISCORD_CLIENT_SECRET;
var discord = discordClientId && discordClientSecret ? new Discord(discordClientId, discordClientSecret, `${baseURL}/v2/auth/discord/callback`) : null;
var facebookClientId = Bun.env.FACEBOOK_CLIENT_ID;
var facebookClientSecret = Bun.env.FACEBOOK_CLIENT_SECRET;
var facebook = facebookClientId && facebookClientSecret ? new Facebook(facebookClientId, facebookClientSecret, `${baseURL}/v2/auth/facebook/callback`) : null;
var oauthProviders = {
  google,
  github,
  discord,
  facebook
};

// src/libs/lokiLogger.ts
var import_pino = __toESM(require_pino(), 1);
var lokiHost = Bun.env.LOKI_HOST;
var lokiUsername = Bun.env.LOKI_USERNAME;
var lokiPassword = Bun.env.LOKI_PASSWORD;
var logger3 = import_pino.default({
  level: Bun.env.NODE_ENV === "production" ? "info" : "debug",
  transport: lokiHost ? {
    target: "pino-loki",
    options: {
      batching: true,
      interval: 5,
      host: lokiHost,
      basicAuth: lokiUsername && lokiPassword ? {
        username: lokiUsername,
        password: lokiPassword
      } : undefined,
      labels: {
        application: "portfolio-v3-api",
        environment: Bun.env.NODE_ENV || "development"
      }
    }
  } : {
    target: "pino-pretty",
    options: {
      colorize: true,
      translateTime: "HH:MM:ss Z",
      ignore: "pid,hostname"
    }
  }
});
var lokiLogger_default = logger3;

// src/api/controller/auth/provider.ts
var provider_default = createElysia().get("/:provider", async ({ params: { provider }, cookie: cookie2, set: set2 }) => {
  const providerInstance = oauthProviders[provider];
  if (!providerInstance) {
    throw new BadRequestException(`OAuth provider '${provider}' is not configured`);
  }
  const state = generateState();
  const codeVerifier = generateCodeVerifier();
  cookie2.oauth_state.set({
    value: state,
    httpOnly: true,
    secure: Bun.env.NODE_ENV === "production",
    path: "/",
    maxAge: 60 * 10
  });
  cookie2.oauth_code_verifier.set({
    value: codeVerifier,
    httpOnly: true,
    secure: Bun.env.NODE_ENV === "production",
    path: "/",
    maxAge: 60 * 10
  });
  let authUrl;
  switch (provider) {
    case "google":
      authUrl = await providerInstance.createAuthorizationURL(state, codeVerifier, {
        scopes: ["profile", "email"]
      });
      break;
    case "github":
      authUrl = await providerInstance.createAuthorizationURL(state, codeVerifier, ["user:email"]);
      break;
    case "discord":
      authUrl = await providerInstance.createAuthorizationURL(state, codeVerifier, ["identify", "email"]);
      break;
    case "facebook":
      authUrl = await providerInstance.createAuthorizationURL(state, codeVerifier, ["email", "public_profile"]);
      break;
    default:
      throw new BadRequestException(`Unsupported provider: ${provider}`);
  }
  lokiLogger_default.info({
    message: "OAuth flow initiated",
    provider
  });
  set2.redirect = authUrl.toString();
}, {
  params: C.Object({
    provider: C.String()
  }),
  detail: {
    tags: ["Authentication"],
    summary: "Initiate OAuth authentication",
    description: "Start OAuth flow for supported providers (google, github, discord, facebook)"
  }
});

// src/utils/oauthUtils.ts
async function checkEmailConflict(email, currentProvider) {
  const user = await prisma.user.findUnique({
    where: { email },
    include: {
      oauthAccounts: true
    }
  });
  if (!user) {
    return { hasConflict: false };
  }
  const existingOAuthAccount = user.oauthAccounts.find((account) => account.provider !== currentProvider);
  if (existingOAuthAccount) {
    lokiLogger_default.warn({
      message: "Email conflict detected",
      email,
      currentProvider,
      existingProvider: existingOAuthAccount.provider
    });
    return {
      hasConflict: true,
      existingProvider: existingOAuthAccount.provider
    };
  }
  return { hasConflict: false };
}
async function handleOAuthUser(userInfo) {
  const { email, name, picture, provider, providerId } = userInfo;
  const conflict = await checkEmailConflict(email, provider);
  if (conflict.hasConflict) {
    throw new Error(`This email is already registered with ${conflict.existingProvider}. Please sign in using that provider.`);
  }
  const existingOAuthAccount = await prisma.oAuthAccount.findUnique({
    where: {
      provider_providerAccountId: {
        provider,
        providerAccountId: providerId
      }
    },
    include: {
      user: true
    }
  });
  if (existingOAuthAccount) {
    lokiLogger_default.info({
      message: "Existing OAuth user logged in",
      userId: existingOAuthAccount.userId,
      provider
    });
    return existingOAuthAccount.user;
  }
  const existingUser = await prisma.user.findUnique({
    where: { email }
  });
  if (existingUser) {
    await prisma.oAuthAccount.create({
      data: {
        provider,
        providerAccountId: providerId,
        userId: existingUser.id
      }
    });
    lokiLogger_default.info({
      message: "OAuth account linked to existing user",
      userId: existingUser.id,
      provider
    });
    return existingUser;
  }
  const userId = generateIdFromEntropySize(10);
  const newUser = await prisma.user.create({
    data: {
      id: userId,
      email,
      name,
      iconUrl: picture,
      emailVerified: true,
      oauthAccounts: {
        create: {
          provider,
          providerAccountId: providerId
        }
      }
    }
  });
  lokiLogger_default.info({
    message: "New user created via OAuth",
    userId: newUser.id,
    provider
  });
  return newUser;
}
async function createUserSession(userId) {
  const session = await lucia.createSession(userId, {});
  return lucia.createSessionCookie(session.id);
}

// src/api/controller/auth/providerCallback.ts
var providerCallback_default = createElysia().get("/:provider/callback", async ({ params: { provider }, query, cookie: cookie2, set: set2 }) => {
  const { code, state } = query;
  const storedState = cookie2.oauth_state.value;
  const codeVerifier = cookie2.oauth_code_verifier.value;
  if (!code || !state || !storedState || state !== storedState) {
    lokiLogger_default.error({
      message: "OAuth state mismatch or missing parameters",
      provider
    });
    throw new BadRequestException("Invalid OAuth state");
  }
  if (!codeVerifier) {
    throw new BadRequestException("Missing code verifier");
  }
  const providerInstance = oauthProviders[provider];
  if (!providerInstance) {
    throw new BadRequestException(`OAuth provider '${provider}' is not configured`);
  }
  try {
    let tokens;
    let userInfo;
    switch (provider) {
      case "google": {
        tokens = await providerInstance.validateAuthorizationCode(code, codeVerifier);
        const response = await fetch("https://openidconnect.googleapis.com/v1/userinfo", {
          headers: {
            Authorization: `Bearer ${tokens.accessToken}`
          }
        });
        const data = await response.json();
        userInfo = {
          email: data.email,
          name: data.name,
          picture: data.picture,
          provider: "google",
          providerId: data.sub
        };
        break;
      }
      case "github": {
        tokens = await providerInstance.validateAuthorizationCode(code, codeVerifier);
        const response = await fetch("https://api.github.com/user", {
          headers: {
            Authorization: `Bearer ${tokens.accessToken}`
          }
        });
        const data = await response.json();
        let email = data.email;
        if (!email) {
          const emailResponse = await fetch("https://api.github.com/user/emails", {
            headers: {
              Authorization: `Bearer ${tokens.accessToken}`
            }
          });
          const emails = await emailResponse.json();
          const primaryEmail = emails.find((e) => e.primary && e.verified);
          email = primaryEmail?.email || emails[0]?.email;
        }
        if (!email) {
          throw new UnauthorizedException("Unable to retrieve email from GitHub");
        }
        userInfo = {
          email,
          name: data.name || `github_${data.id}`,
          picture: data.avatar_url,
          provider: "github",
          providerId: String(data.id)
        };
        break;
      }
      case "discord": {
        tokens = await providerInstance.validateAuthorizationCode(code, codeVerifier);
        const response = await fetch("https://discord.com/api/users/@me", {
          headers: {
            Authorization: `Bearer ${tokens.accessToken}`
          }
        });
        const data = await response.json();
        userInfo = {
          email: data.email,
          name: data.username,
          picture: data.avatar ? `https://cdn.discordapp.com/avatars/${data.id}/${data.avatar}.png` : undefined,
          provider: "discord",
          providerId: data.id
        };
        break;
      }
      case "facebook": {
        tokens = await providerInstance.validateAuthorizationCode(code, codeVerifier);
        const response = await fetch("https://graph.facebook.com/me?fields=id,name,email,picture", {
          headers: {
            Authorization: `Bearer ${tokens.accessToken}`
          }
        });
        const data = await response.json();
        userInfo = {
          email: data.email,
          name: data.name,
          picture: data.picture?.data?.url,
          provider: "facebook",
          providerId: data.id
        };
        break;
      }
      default:
        throw new BadRequestException(`Unsupported provider: ${provider}`);
    }
    const user = await handleOAuthUser(userInfo);
    const sessionCookie = await createUserSession(user.id);
    cookie2[lucia.sessionCookieName].set({
      value: sessionCookie.value,
      ...sessionCookie.attributes
    });
    cookie2.oauth_state.remove();
    cookie2.oauth_code_verifier.remove();
    lokiLogger_default.info({
      message: "OAuth authentication successful",
      provider,
      userId: user.id
    });
    set2.redirect = Bun.env.FRONTEND_URL || "http://localhost:3000";
  } catch (error23) {
    lokiLogger_default.error({
      message: "OAuth authentication failed",
      provider,
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    throw error23 instanceof Error ? error23 : new UnauthorizedException("OAuth authentication failed");
  }
}, {
  params: C.Object({
    provider: C.String()
  }),
  query: C.Object({
    code: C.String(),
    state: C.String()
  }),
  detail: {
    tags: ["Authentication"],
    summary: "OAuth callback handler",
    description: "Handle OAuth callback from provider"
  }
});

// src/utils/pagination.ts
function encodeCursor(value15) {
  const str = value15 instanceof Date ? value15.toISOString() : String(value15);
  return Buffer.from(str).toString("base64");
}
function decodeCursor(cursor) {
  try {
    return Buffer.from(cursor, "base64").toString("utf-8");
  } catch {
    throw new Error("Invalid cursor format");
  }
}
function createPaginatedResponse(items, limit, getCursorValue) {
  const hasMore = items.length > limit;
  const data = hasMore ? items.slice(0, limit) : items;
  const nextCursor = hasMore ? encodeCursor(getCursorValue(items[limit - 1])) : null;
  return {
    data,
    nextCursor,
    hasMore
  };
}
function parseCursorToDate(cursor) {
  if (!cursor)
    return;
  try {
    const decoded = decodeCursor(cursor);
    const date5 = new Date(decoded);
    if (isNaN(date5.getTime())) {
      throw new Error("Invalid date in cursor");
    }
    return date5;
  } catch {
    throw new Error("Invalid cursor format");
  }
}
function parseCursorToNumber(cursor) {
  if (!cursor)
    return;
  try {
    const decoded = decodeCursor(cursor);
    const num = parseInt(decoded, 10);
    if (isNaN(num)) {
      throw new Error("Invalid number in cursor");
    }
    return num;
  } catch {
    throw new Error("Invalid cursor format");
  }
}
var paginationQuerySchema = z.object({
  cursor: z.string().optional(),
  limit: z.coerce.number().min(1).max(50).default(10)
});

// src/api/controller/project/getAllProject.ts
var getAllProject_default = createElysia().get("/", async ({ query }) => {
  const { cursor, limit } = paginationQuerySchema.parse(query);
  const cursorDate = parseCursorToDate(cursor);
  const projects = await prisma.project.findMany({
    where: cursorDate ? {
      created_at: {
        lt: cursorDate
      }
    } : undefined,
    orderBy: {
      created_at: "desc"
    },
    take: limit + 1
  });
  const paginatedResponse = createPaginatedResponse(projects, limit, (project) => project.created_at);
  return {
    status: 200,
    message: "Success",
    ...paginatedResponse
  };
}, {
  query: C.Object({
    cursor: C.Optional(C.String()),
    limit: C.Optional(C.Number({ minimum: 1, maximum: 50, default: 10 }))
  }),
  detail: {
    tags: ["Project"],
    summary: "Get all projects",
    description: "Get paginated list of projects"
  }
});

// src/libs/authGuard.ts
var sessionCookieName = lucia.sessionCookieName;
var authGuard = new j0({
  name: "authGuard"
}).guard({
  cookie: C.Object({
    [sessionCookieName]: C.Optional(C.String())
  }),
  headers: C.Object({
    origin: C.Optional(C.String()),
    host: C.Optional(C.String()),
    authorization: C.Optional(C.String())
  })
}).resolve({ as: "scoped" }, async ({ cookie: cookie2, headers: { origin, host, authorization }, request: { method } }) => {
  const sessionCookie = cookie2[sessionCookieName];
  const sessionId = lucia.readBearerToken(authorization ?? "") ?? sessionCookie?.value;
  if (!authorization && method !== "GET" && (!origin || !host || !verifyRequestOrigin(origin, [
    "https://rizkyhaksono.vercel.app",
    "rizkyhaksono.vercel.app",
    "https://rizkyhaksono.natee.my.id",
    "rizkyhaksono.natee.my.id",
    "https://natee.me",
    "natee.me",
    "https://natee.my.id",
    "natee.my.id",
    "http://localhost:3000",
    "localhost:3000"
  ]))) {
    throw new ForbiddenException("Invalid origin");
  }
  if (!sessionId) {
    throw new UnauthorizedException;
  }
  const { session, user } = await lucia.validateSession(sessionId || "");
  if (!session) {
    const newSessionCookie = lucia.createBlankSessionCookie();
    sessionCookie?.set({
      value: newSessionCookie.value,
      ...newSessionCookie.attributes
    });
    throw new UnauthorizedException;
  }
  if (session?.fresh) {
    const newSessionCookie = lucia.createSessionCookie(sessionId || "");
    sessionCookie?.set({
      value: newSessionCookie.value,
      ...newSessionCookie.attributes
    });
  }
  return { user };
});

// src/models/project.model.ts
var projectModel = new j0().model({
  "project.model": C.Object({
    image: C.String(),
    title: C.String(),
    description: C.String(),
    content: C.String(),
    projectLink: C.String(),
    sourceCodeLink: C.Optional(C.String()),
    isFeatured: C.Boolean(),
    created_at: C.Optional(C.Date()),
    updated_at: C.Optional(C.Date())
  })
});
var project_model_default = projectModel;

// src/api/controller/project/createProject.ts
var createProject_default = createElysia().use(project_model_default).use(authGuard).post("/", async ({ body }) => {
  return await prisma.project.create({
    data: {
      ...body
    }
  });
}, {
  body: "project.model",
  detail: {
    tags: ["Project"]
  }
});

// src/api/controller/project/getProjectById.ts
var getProjectById_default = createElysia().get("/:id", async ({ params: { id } }) => {
  const project2 = await prisma.project.findUnique({
    where: { id: parseInt(id) }
  });
  return {
    status: 200,
    data: project2
  };
}, {
  detail: {
    tags: ["Project"]
  }
});

// src/api/controller/project/updateProject.ts
var updateProject_default = createElysia().use(authGuard).use(project_model_default).patch("/:id", async ({ body, user, params: { id } }) => {
  if (!user.isAdmin)
    throw new ForbiddenException;
  await prisma.project.update({
    where: { id: parseInt(id) },
    data: body
  });
  return {
    status: 200,
    message: "Project updated successfully"
  };
}, {
  body: "project.model",
  detail: {
    tags: ["Project"]
  }
});

// src/api/controller/project/deleteProject.ts
var deleteProject_default = createElysia().use(project_model_default).use(authGuard).delete("/:id", async ({ params: { id } }) => {
  await prisma.project.delete({
    where: { id: parseInt(id) }
  });
  return {
    status: 200,
    message: "Project deleted successfully"
  };
}, {
  body: "project.model",
  detail: {
    tags: ["Project"]
  }
});

// src/models/work.model.ts
var workModel = new j0().model({
  "work.model": C.Object({
    logo: C.String({ format: "uri" }),
    jobTitle: C.String(),
    content: C.String(),
    instance: C.String(),
    instanceLink: C.String(),
    address: C.String(),
    duration: C.String(),
    created_at: C.Optional(C.Date()),
    updated_at: C.Optional(C.Date())
  }),
  "work.model.response": C.Object({
    id: C.Number(),
    logo: C.String({ format: "uri" }),
    jobTitle: C.String(),
    content: C.String(),
    instance: C.String(),
    instanceLink: C.String(),
    address: C.String(),
    duration: C.String(),
    created_at: C.Optional(C.Date()),
    updated_at: C.Optional(C.Date())
  })
});
var work_model_default = workModel;

// src/api/controller/work/createWork.ts
var createWork_default = createElysia().use(work_model_default).use(authGuard).post("/", async ({ body }) => {
  return await prisma.work.create({
    data: {
      ...body
    }
  });
}, {
  body: "work.model",
  detail: {
    tags: ["Work"]
  }
});

// src/api/controller/work/getAllWork.ts
var getAllWork_default = createElysia().get("/", async ({ query }) => {
  const { cursor, limit } = paginationQuerySchema.parse(query);
  const cursorDate = parseCursorToDate(cursor);
  const work2 = await prisma.work.findMany({
    where: cursorDate ? {
      created_at: {
        lt: cursorDate
      }
    } : undefined,
    orderBy: {
      created_at: "desc"
    },
    take: limit + 1
  });
  const paginatedResponse = createPaginatedResponse(work2, limit, (w) => w.created_at);
  return {
    status: 200,
    message: "Success",
    ...paginatedResponse
  };
}, {
  query: C.Object({
    cursor: C.Optional(C.String()),
    limit: C.Optional(C.Number({ minimum: 1, maximum: 50, default: 10 }))
  }),
  detail: {
    tags: ["Work"],
    summary: "Get all work experience",
    description: "Get paginated list of work experience records"
  }
});

// src/api/controller/work/getWorkById.ts
var getWorkById_default = createElysia().get("/:id", async ({ params: { id } }) => {
  const work2 = await prisma.work.findUnique({
    where: { id: parseInt(id) }
  });
  return {
    status: 200,
    data: work2
  };
}, {
  detail: {
    tags: ["Work"]
  }
});

// src/api/controller/work/updateWork.ts
var updateWork_default = createElysia().use(work_model_default).use(authGuard).patch("/:id", async ({ body, params: { id } }) => {
  await prisma.work.update({
    where: { id: parseInt(id) },
    data: body
  });
  return {
    status: 200,
    message: "Work updated successfully"
  };
}, {
  body: "work.model",
  detail: {
    tags: ["Work"]
  }
});

// src/api/controller/work/deleteWork.ts
var deleteWork_default = createElysia().use(work_model_default).use(authGuard).delete("/:id", async ({ params: { id } }) => {
  await prisma.work.delete({
    where: { id: parseInt(id) }
  });
  return {
    status: 200,
    message: "Work deleted successfully"
  };
}, {
  body: "work.model",
  detail: {
    tags: ["Work"]
  }
});

// src/models/education.model.ts
var educationModel = new j0().model({
  "education.model": C.Object({
    logo: C.String({ format: "uri" }),
    instance: C.String(),
    content: C.String(),
    address: C.String(),
    duration: C.String(),
    created_at: C.Optional(C.Date()),
    updated_at: C.Optional(C.Date())
  })
});
var education_model_default = educationModel;

// src/api/controller/education/createEducation.ts
var createEducation_default = createElysia().use(education_model_default).use(authGuard).post("/", async ({ body }) => {
  return await prisma.education.create({
    data: {
      ...body
    }
  });
}, {
  body: "education.model",
  detail: {
    tags: ["Education"]
  }
});

// src/api/controller/education/getAllEducation.ts
var getAllEducation_default = createElysia().get("/", async ({ query }) => {
  const { cursor, limit } = paginationQuerySchema.parse(query);
  const cursorDate = parseCursorToDate(cursor);
  const education2 = await prisma.education.findMany({
    where: cursorDate ? {
      created_at: {
        lt: cursorDate
      }
    } : undefined,
    orderBy: {
      created_at: "desc"
    },
    take: limit + 1
  });
  const paginatedResponse = createPaginatedResponse(education2, limit, (edu) => edu.created_at);
  return {
    status: 200,
    message: "Success",
    ...paginatedResponse
  };
}, {
  query: C.Object({
    cursor: C.Optional(C.String()),
    limit: C.Optional(C.Number({ minimum: 1, maximum: 50, default: 10 }))
  }),
  detail: {
    tags: ["Education"],
    summary: "Get all education",
    description: "Get paginated list of education records"
  }
});

// src/api/controller/education/getEducationById.ts
var getEducationById_default = createElysia().get("/:id", async ({ params: { id } }) => {
  const education2 = await prisma.education.findUnique({
    where: { id: parseInt(id) }
  });
  return {
    status: 200,
    data: education2
  };
}, {
  detail: {
    tags: ["Education"]
  }
});

// src/api/controller/education/updateEducation.ts
var updateEducation_default = createElysia().use(authGuard).use(education_model_default).patch("/:id", async ({ body, params: { id } }) => {
  return prisma.education.update({
    where: { id: parseInt(id) },
    data: {
      ...body
    }
  });
}, {
  body: "education.model",
  detail: {
    tags: ["Education"]
  }
});

// src/api/controller/education/deleteEducation.ts
var deleteEducation_default = createElysia().use(authGuard).use(education_model_default).delete("/:id", async ({ params: { id } }) => {
  await prisma.education.delete({
    where: { id: parseInt(id) }
  });
  return {
    status: 200,
    data: "Education deleted successfully"
  };
}, {
  body: "education.model",
  detail: {
    tags: ["Education"]
  }
});

// node_modules/@google/generative-ai/dist/index.mjs
function getClientHeaders(requestOptions) {
  const clientHeaders = [];
  if (requestOptions === null || requestOptions === undefined ? undefined : requestOptions.apiClient) {
    clientHeaders.push(requestOptions.apiClient);
  }
  clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
  return clientHeaders.join(" ");
}
async function getHeaders(url) {
  var _a;
  const headers = new Headers;
  headers.append("Content-Type", "application/json");
  headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
  headers.append("x-goog-api-key", url.apiKey);
  let customHeaders = (_a = url.requestOptions) === null || _a === undefined ? undefined : _a.customHeaders;
  if (customHeaders) {
    if (!(customHeaders instanceof Headers)) {
      try {
        customHeaders = new Headers(customHeaders);
      } catch (e) {
        throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);
      }
    }
    for (const [headerName, headerValue] of customHeaders.entries()) {
      if (headerName === "x-goog-api-key") {
        throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);
      } else if (headerName === "x-goog-api-client") {
        throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);
      }
      headers.append(headerName, headerValue);
    }
  }
  return headers;
}
async function constructModelRequest(model, task, apiKey, stream, body, requestOptions) {
  const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
  return {
    url: url.toString(),
    fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: await getHeaders(url), body })
  };
}
async function makeModelRequest(model, task, apiKey, stream, body, requestOptions = {}, fetchFn = fetch) {
  const { url, fetchOptions } = await constructModelRequest(model, task, apiKey, stream, body, requestOptions);
  return makeRequest(url, fetchOptions, fetchFn);
}
async function makeRequest(url, fetchOptions, fetchFn = fetch) {
  let response;
  try {
    response = await fetchFn(url, fetchOptions);
  } catch (e) {
    handleResponseError(e, url);
  }
  if (!response.ok) {
    await handleResponseNotOk(response, url);
  }
  return response;
}
function handleResponseError(e, url) {
  let err = e;
  if (!(e instanceof GoogleGenerativeAIFetchError || e instanceof GoogleGenerativeAIRequestInputError)) {
    err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
    err.stack = e.stack;
  }
  throw err;
}
async function handleResponseNotOk(response, url) {
  let message = "";
  let errorDetails;
  try {
    const json2 = await response.json();
    message = json2.error.message;
    if (json2.error.details) {
      message += ` ${JSON.stringify(json2.error.details)}`;
      errorDetails = json2.error.details;
    }
  } catch (e) {
  }
  throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
}
function buildFetchOptions(requestOptions) {
  const fetchOptions = {};
  if ((requestOptions === null || requestOptions === undefined ? undefined : requestOptions.signal) !== undefined || (requestOptions === null || requestOptions === undefined ? undefined : requestOptions.timeout) >= 0) {
    const controller = new AbortController;
    if ((requestOptions === null || requestOptions === undefined ? undefined : requestOptions.timeout) >= 0) {
      setTimeout(() => controller.abort(), requestOptions.timeout);
    }
    if (requestOptions === null || requestOptions === undefined ? undefined : requestOptions.signal) {
      requestOptions.signal.addEventListener("abort", () => {
        controller.abort();
      });
    }
    fetchOptions.signal = controller.signal;
  }
  return fetchOptions;
}
function addHelpers(response) {
  response.text = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} ` + `candidates. Returning text from the first candidate only. ` + `Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getText(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return "";
  };
  response.functionCall = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} ` + `candidates. Returning function calls from the first candidate only. ` + `Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      console.warn(`response.functionCall() is deprecated. ` + `Use response.functionCalls() instead.`);
      return getFunctionCalls(response)[0];
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return;
  };
  response.functionCalls = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} ` + `candidates. Returning function calls from the first candidate only. ` + `Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getFunctionCalls(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return;
  };
  return response;
}
function getText(response) {
  var _a, _b, _c, _d;
  const textStrings = [];
  if ((_b = (_a = response.candidates) === null || _a === undefined ? undefined : _a[0].content) === null || _b === undefined ? undefined : _b.parts) {
    for (const part of (_d = (_c = response.candidates) === null || _c === undefined ? undefined : _c[0].content) === null || _d === undefined ? undefined : _d.parts) {
      if (part.text) {
        textStrings.push(part.text);
      }
      if (part.executableCode) {
        textStrings.push("\n```" + part.executableCode.language + "\n" + part.executableCode.code + "\n```\n");
      }
      if (part.codeExecutionResult) {
        textStrings.push("\n```\n" + part.codeExecutionResult.output + "\n```\n");
      }
    }
  }
  if (textStrings.length > 0) {
    return textStrings.join("");
  } else {
    return "";
  }
}
function getFunctionCalls(response) {
  var _a, _b, _c, _d;
  const functionCalls = [];
  if ((_b = (_a = response.candidates) === null || _a === undefined ? undefined : _a[0].content) === null || _b === undefined ? undefined : _b.parts) {
    for (const part of (_d = (_c = response.candidates) === null || _c === undefined ? undefined : _c[0].content) === null || _d === undefined ? undefined : _d.parts) {
      if (part.functionCall) {
        functionCalls.push(part.functionCall);
      }
    }
  }
  if (functionCalls.length > 0) {
    return functionCalls;
  } else {
    return;
  }
}
function hadBadFinishReason(candidate) {
  return !!candidate.finishReason && badFinishReasons.includes(candidate.finishReason);
}
function formatBlockErrorMessage(response) {
  var _a, _b, _c;
  let message = "";
  if ((!response.candidates || response.candidates.length === 0) && response.promptFeedback) {
    message += "Response was blocked";
    if ((_a = response.promptFeedback) === null || _a === undefined ? undefined : _a.blockReason) {
      message += ` due to ${response.promptFeedback.blockReason}`;
    }
    if ((_b = response.promptFeedback) === null || _b === undefined ? undefined : _b.blockReasonMessage) {
      message += `: ${response.promptFeedback.blockReasonMessage}`;
    }
  } else if ((_c = response.candidates) === null || _c === undefined ? undefined : _c[0]) {
    const firstCandidate = response.candidates[0];
    if (hadBadFinishReason(firstCandidate)) {
      message += `Candidate was blocked due to ${firstCandidate.finishReason}`;
      if (firstCandidate.finishMessage) {
        message += `: ${firstCandidate.finishMessage}`;
      }
    }
  }
  return message;
}
function __await(v3) {
  return this instanceof __await ? (this.v = v3, this) : new __await(v3);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i3, q = [];
  return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3;
  function verb(n3) {
    if (g[n3])
      i3[n3] = function(v3) {
        return new Promise(function(a, b) {
          q.push([n3, v3, a, b]) > 1 || resume(n3, v3);
        });
      };
  }
  function resume(n3, v3) {
    try {
      step(g[n3](v3));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value15) {
    resume("next", value15);
  }
  function reject(value15) {
    resume("throw", value15);
  }
  function settle(f3, v3) {
    if (f3(v3), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function processStream(response) {
  const inputStream = response.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }));
  const responseStream = getResponseStream(inputStream);
  const [stream1, stream2] = responseStream.tee();
  return {
    stream: generateResponseSequence(stream1),
    response: getResponsePromise(stream2)
  };
}
async function getResponsePromise(stream) {
  const allResponses = [];
  const reader = stream.getReader();
  while (true) {
    const { done, value: value15 } = await reader.read();
    if (done) {
      return addHelpers(aggregateResponses(allResponses));
    }
    allResponses.push(value15);
  }
}
function generateResponseSequence(stream) {
  return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {
    const reader = stream.getReader();
    while (true) {
      const { value: value15, done } = yield __await(reader.read());
      if (done) {
        break;
      }
      yield yield __await(addHelpers(value15));
    }
  });
}
function getResponseStream(inputStream) {
  const reader = inputStream.getReader();
  const stream = new ReadableStream({
    start(controller) {
      let currentText = "";
      return pump();
      function pump() {
        return reader.read().then(({ value: value15, done }) => {
          if (done) {
            if (currentText.trim()) {
              controller.error(new GoogleGenerativeAIError("Failed to parse stream"));
              return;
            }
            controller.close();
            return;
          }
          currentText += value15;
          let match = currentText.match(responseLineRE);
          let parsedResponse;
          while (match) {
            try {
              parsedResponse = JSON.parse(match[1]);
            } catch (e) {
              controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match[1]}"`));
              return;
            }
            controller.enqueue(parsedResponse);
            currentText = currentText.substring(match[0].length);
            match = currentText.match(responseLineRE);
          }
          return pump();
        });
      }
    }
  });
  return stream;
}
function aggregateResponses(responses) {
  const lastResponse = responses[responses.length - 1];
  const aggregatedResponse = {
    promptFeedback: lastResponse === null || lastResponse === undefined ? undefined : lastResponse.promptFeedback
  };
  for (const response of responses) {
    if (response.candidates) {
      for (const candidate of response.candidates) {
        const i3 = candidate.index;
        if (!aggregatedResponse.candidates) {
          aggregatedResponse.candidates = [];
        }
        if (!aggregatedResponse.candidates[i3]) {
          aggregatedResponse.candidates[i3] = {
            index: candidate.index
          };
        }
        aggregatedResponse.candidates[i3].citationMetadata = candidate.citationMetadata;
        aggregatedResponse.candidates[i3].groundingMetadata = candidate.groundingMetadata;
        aggregatedResponse.candidates[i3].finishReason = candidate.finishReason;
        aggregatedResponse.candidates[i3].finishMessage = candidate.finishMessage;
        aggregatedResponse.candidates[i3].safetyRatings = candidate.safetyRatings;
        if (candidate.content && candidate.content.parts) {
          if (!aggregatedResponse.candidates[i3].content) {
            aggregatedResponse.candidates[i3].content = {
              role: candidate.content.role || "user",
              parts: []
            };
          }
          const newPart = {};
          for (const part of candidate.content.parts) {
            if (part.text) {
              newPart.text = part.text;
            }
            if (part.functionCall) {
              newPart.functionCall = part.functionCall;
            }
            if (part.executableCode) {
              newPart.executableCode = part.executableCode;
            }
            if (part.codeExecutionResult) {
              newPart.codeExecutionResult = part.codeExecutionResult;
            }
            if (Object.keys(newPart).length === 0) {
              newPart.text = "";
            }
            aggregatedResponse.candidates[i3].content.parts.push(newPart);
          }
        }
      }
    }
    if (response.usageMetadata) {
      aggregatedResponse.usageMetadata = response.usageMetadata;
    }
  }
  return aggregatedResponse;
}
async function generateContentStream(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(model, Task.STREAM_GENERATE_CONTENT, apiKey, true, JSON.stringify(params), requestOptions);
  return processStream(response);
}
async function generateContent(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(model, Task.GENERATE_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
  const responseJson = await response.json();
  const enhancedResponse = addHelpers(responseJson);
  return {
    response: enhancedResponse
  };
}
function formatSystemInstruction(input) {
  if (input == null) {
    return;
  } else if (typeof input === "string") {
    return { role: "system", parts: [{ text: input }] };
  } else if (input.text) {
    return { role: "system", parts: [input] };
  } else if (input.parts) {
    if (!input.role) {
      return { role: "system", parts: input.parts };
    } else {
      return input;
    }
  }
}
function formatNewContent(request25) {
  let newParts = [];
  if (typeof request25 === "string") {
    newParts = [{ text: request25 }];
  } else {
    for (const partOrString of request25) {
      if (typeof partOrString === "string") {
        newParts.push({ text: partOrString });
      } else {
        newParts.push(partOrString);
      }
    }
  }
  return assignRoleToPartsAndValidateSendMessageRequest(newParts);
}
function assignRoleToPartsAndValidateSendMessageRequest(parts) {
  const userContent = { role: "user", parts: [] };
  const functionContent = { role: "function", parts: [] };
  let hasUserContent = false;
  let hasFunctionContent = false;
  for (const part of parts) {
    if ("functionResponse" in part) {
      functionContent.parts.push(part);
      hasFunctionContent = true;
    } else {
      userContent.parts.push(part);
      hasUserContent = true;
    }
  }
  if (hasUserContent && hasFunctionContent) {
    throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
  }
  if (!hasUserContent && !hasFunctionContent) {
    throw new GoogleGenerativeAIError("No content is provided for sending chat message.");
  }
  if (hasUserContent) {
    return userContent;
  }
  return functionContent;
}
function formatCountTokensInput(params, modelParams) {
  var _a;
  let formattedGenerateContentRequest = {
    model: modelParams === null || modelParams === undefined ? undefined : modelParams.model,
    generationConfig: modelParams === null || modelParams === undefined ? undefined : modelParams.generationConfig,
    safetySettings: modelParams === null || modelParams === undefined ? undefined : modelParams.safetySettings,
    tools: modelParams === null || modelParams === undefined ? undefined : modelParams.tools,
    toolConfig: modelParams === null || modelParams === undefined ? undefined : modelParams.toolConfig,
    systemInstruction: modelParams === null || modelParams === undefined ? undefined : modelParams.systemInstruction,
    cachedContent: (_a = modelParams === null || modelParams === undefined ? undefined : modelParams.cachedContent) === null || _a === undefined ? undefined : _a.name,
    contents: []
  };
  const containsGenerateContentRequest = params.generateContentRequest != null;
  if (params.contents) {
    if (containsGenerateContentRequest) {
      throw new GoogleGenerativeAIRequestInputError("CountTokensRequest must have one of contents or generateContentRequest, not both.");
    }
    formattedGenerateContentRequest.contents = params.contents;
  } else if (containsGenerateContentRequest) {
    formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);
  } else {
    const content = formatNewContent(params);
    formattedGenerateContentRequest.contents = [content];
  }
  return { generateContentRequest: formattedGenerateContentRequest };
}
function formatGenerateContentInput(params) {
  let formattedRequest;
  if (params.contents) {
    formattedRequest = params;
  } else {
    const content = formatNewContent(params);
    formattedRequest = { contents: [content] };
  }
  if (params.systemInstruction) {
    formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);
  }
  return formattedRequest;
}
function formatEmbedContentInput(params) {
  if (typeof params === "string" || Array.isArray(params)) {
    const content = formatNewContent(params);
    return { content };
  }
  return params;
}
function validateChatHistory(history) {
  let prevContent = false;
  for (const currContent of history) {
    const { role, parts } = currContent;
    if (!prevContent && role !== "user") {
      throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);
    }
    if (!POSSIBLE_ROLES.includes(role)) {
      throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);
    }
    if (!Array.isArray(parts)) {
      throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts");
    }
    if (parts.length === 0) {
      throw new GoogleGenerativeAIError("Each Content should have at least one part");
    }
    const countFields = {
      text: 0,
      inlineData: 0,
      functionCall: 0,
      functionResponse: 0,
      fileData: 0,
      executableCode: 0,
      codeExecutionResult: 0
    };
    for (const part of parts) {
      for (const key of VALID_PART_FIELDS) {
        if (key in part) {
          countFields[key] += 1;
        }
      }
    }
    const validParts = VALID_PARTS_PER_ROLE[role];
    for (const key of VALID_PART_FIELDS) {
      if (!validParts.includes(key) && countFields[key] > 0) {
        throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);
      }
    }
    prevContent = true;
  }
}
async function countTokens(apiKey, model, params, singleRequestOptions) {
  const response = await makeModelRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(params), singleRequestOptions);
  return response.json();
}
async function embedContent(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
  return response.json();
}
async function batchEmbedContents(apiKey, model, params, requestOptions) {
  const requestsWithModel = params.requests.map((request25) => {
    return Object.assign(Object.assign({}, request25), { model });
  });
  const response = await makeModelRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);
  return response.json();
}
var SchemaType;
(function(SchemaType2) {
  SchemaType2["STRING"] = "string";
  SchemaType2["NUMBER"] = "number";
  SchemaType2["INTEGER"] = "integer";
  SchemaType2["BOOLEAN"] = "boolean";
  SchemaType2["ARRAY"] = "array";
  SchemaType2["OBJECT"] = "object";
})(SchemaType || (SchemaType = {}));
var ExecutableCodeLanguage;
(function(ExecutableCodeLanguage2) {
  ExecutableCodeLanguage2["LANGUAGE_UNSPECIFIED"] = "language_unspecified";
  ExecutableCodeLanguage2["PYTHON"] = "python";
})(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));
var Outcome;
(function(Outcome2) {
  Outcome2["OUTCOME_UNSPECIFIED"] = "outcome_unspecified";
  Outcome2["OUTCOME_OK"] = "outcome_ok";
  Outcome2["OUTCOME_FAILED"] = "outcome_failed";
  Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "outcome_deadline_exceeded";
})(Outcome || (Outcome = {}));
var POSSIBLE_ROLES = ["user", "model", "function", "system"];
var HarmCategory;
(function(HarmCategory2) {
  HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
  HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
  HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
  HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
  HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
})(HarmCategory || (HarmCategory = {}));
var HarmBlockThreshold;
(function(HarmBlockThreshold2) {
  HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
  HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
})(HarmBlockThreshold || (HarmBlockThreshold = {}));
var HarmProbability;
(function(HarmProbability2) {
  HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
  HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
  HarmProbability2["LOW"] = "LOW";
  HarmProbability2["MEDIUM"] = "MEDIUM";
  HarmProbability2["HIGH"] = "HIGH";
})(HarmProbability || (HarmProbability = {}));
var BlockReason;
(function(BlockReason2) {
  BlockReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
  BlockReason2["SAFETY"] = "SAFETY";
  BlockReason2["OTHER"] = "OTHER";
})(BlockReason || (BlockReason = {}));
var FinishReason;
(function(FinishReason2) {
  FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
  FinishReason2["STOP"] = "STOP";
  FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
  FinishReason2["SAFETY"] = "SAFETY";
  FinishReason2["RECITATION"] = "RECITATION";
  FinishReason2["LANGUAGE"] = "LANGUAGE";
  FinishReason2["OTHER"] = "OTHER";
})(FinishReason || (FinishReason = {}));
var TaskType;
(function(TaskType2) {
  TaskType2["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
  TaskType2["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
  TaskType2["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
  TaskType2["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
  TaskType2["CLASSIFICATION"] = "CLASSIFICATION";
  TaskType2["CLUSTERING"] = "CLUSTERING";
})(TaskType || (TaskType = {}));
var FunctionCallingMode;
(function(FunctionCallingMode2) {
  FunctionCallingMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  FunctionCallingMode2["AUTO"] = "AUTO";
  FunctionCallingMode2["ANY"] = "ANY";
  FunctionCallingMode2["NONE"] = "NONE";
})(FunctionCallingMode || (FunctionCallingMode = {}));
var DynamicRetrievalMode;
(function(DynamicRetrievalMode2) {
  DynamicRetrievalMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  DynamicRetrievalMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(DynamicRetrievalMode || (DynamicRetrievalMode = {}));

class GoogleGenerativeAIError extends Error {
  constructor(message) {
    super(`[GoogleGenerativeAI Error]: ${message}`);
  }
}

class GoogleGenerativeAIResponseError extends GoogleGenerativeAIError {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
}

class GoogleGenerativeAIFetchError extends GoogleGenerativeAIError {
  constructor(message, status, statusText, errorDetails) {
    super(message);
    this.status = status;
    this.statusText = statusText;
    this.errorDetails = errorDetails;
  }
}

class GoogleGenerativeAIRequestInputError extends GoogleGenerativeAIError {
}
var DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
var DEFAULT_API_VERSION = "v1beta";
var PACKAGE_VERSION = "0.21.0";
var PACKAGE_LOG_HEADER = "genai-js";
var Task;
(function(Task2) {
  Task2["GENERATE_CONTENT"] = "generateContent";
  Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
  Task2["COUNT_TOKENS"] = "countTokens";
  Task2["EMBED_CONTENT"] = "embedContent";
  Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
})(Task || (Task = {}));

class RequestUrl {
  constructor(model, task, apiKey, stream, requestOptions) {
    this.model = model;
    this.task = task;
    this.apiKey = apiKey;
    this.stream = stream;
    this.requestOptions = requestOptions;
  }
  toString() {
    var _a, _b;
    const apiVersion = ((_a = this.requestOptions) === null || _a === undefined ? undefined : _a.apiVersion) || DEFAULT_API_VERSION;
    const baseUrl = ((_b = this.requestOptions) === null || _b === undefined ? undefined : _b.baseUrl) || DEFAULT_BASE_URL;
    let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;
    if (this.stream) {
      url += "?alt=sse";
    }
    return url;
  }
}
var badFinishReasons = [
  FinishReason.RECITATION,
  FinishReason.SAFETY,
  FinishReason.LANGUAGE
];
var responseLineRE = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
var VALID_PART_FIELDS = [
  "text",
  "inlineData",
  "functionCall",
  "functionResponse",
  "executableCode",
  "codeExecutionResult"
];
var VALID_PARTS_PER_ROLE = {
  user: ["text", "inlineData"],
  function: ["functionResponse"],
  model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
  system: ["text"]
};
var SILENT_ERROR = "SILENT_ERROR";

class ChatSession {
  constructor(apiKey, model, params, _requestOptions = {}) {
    this.model = model;
    this.params = params;
    this._requestOptions = _requestOptions;
    this._history = [];
    this._sendPromise = Promise.resolve();
    this._apiKey = apiKey;
    if (params === null || params === undefined ? undefined : params.history) {
      validateChatHistory(params.history);
      this._history = params.history;
    }
  }
  async getHistory() {
    await this._sendPromise;
    return this._history;
  }
  async sendMessage(request25, requestOptions = {}) {
    var _a, _b, _c, _d, _e, _f;
    await this._sendPromise;
    const newContent = formatNewContent(request25);
    const generateContentRequest = {
      safetySettings: (_a = this.params) === null || _a === undefined ? undefined : _a.safetySettings,
      generationConfig: (_b = this.params) === null || _b === undefined ? undefined : _b.generationConfig,
      tools: (_c = this.params) === null || _c === undefined ? undefined : _c.tools,
      toolConfig: (_d = this.params) === null || _d === undefined ? undefined : _d.toolConfig,
      systemInstruction: (_e = this.params) === null || _e === undefined ? undefined : _e.systemInstruction,
      cachedContent: (_f = this.params) === null || _f === undefined ? undefined : _f.cachedContent,
      contents: [...this._history, newContent]
    };
    const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    let finalResult;
    this._sendPromise = this._sendPromise.then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions)).then((result) => {
      var _a2;
      if (result.response.candidates && result.response.candidates.length > 0) {
        this._history.push(newContent);
        const responseContent = Object.assign({
          parts: [],
          role: "model"
        }, (_a2 = result.response.candidates) === null || _a2 === undefined ? undefined : _a2[0].content);
        this._history.push(responseContent);
      } else {
        const blockErrorMessage = formatBlockErrorMessage(result.response);
        if (blockErrorMessage) {
          console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
        }
      }
      finalResult = result;
    });
    await this._sendPromise;
    return finalResult;
  }
  async sendMessageStream(request25, requestOptions = {}) {
    var _a, _b, _c, _d, _e, _f;
    await this._sendPromise;
    const newContent = formatNewContent(request25);
    const generateContentRequest = {
      safetySettings: (_a = this.params) === null || _a === undefined ? undefined : _a.safetySettings,
      generationConfig: (_b = this.params) === null || _b === undefined ? undefined : _b.generationConfig,
      tools: (_c = this.params) === null || _c === undefined ? undefined : _c.tools,
      toolConfig: (_d = this.params) === null || _d === undefined ? undefined : _d.toolConfig,
      systemInstruction: (_e = this.params) === null || _e === undefined ? undefined : _e.systemInstruction,
      cachedContent: (_f = this.params) === null || _f === undefined ? undefined : _f.cachedContent,
      contents: [...this._history, newContent]
    };
    const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);
    this._sendPromise = this._sendPromise.then(() => streamPromise).catch((_ignored) => {
      throw new Error(SILENT_ERROR);
    }).then((streamResult) => streamResult.response).then((response) => {
      if (response.candidates && response.candidates.length > 0) {
        this._history.push(newContent);
        const responseContent = Object.assign({}, response.candidates[0].content);
        if (!responseContent.role) {
          responseContent.role = "model";
        }
        this._history.push(responseContent);
      } else {
        const blockErrorMessage = formatBlockErrorMessage(response);
        if (blockErrorMessage) {
          console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
        }
      }
    }).catch((e) => {
      if (e.message !== SILENT_ERROR) {
        console.error(e);
      }
    });
    return streamPromise;
  }
}

class GenerativeModel {
  constructor(apiKey, modelParams, _requestOptions = {}) {
    this.apiKey = apiKey;
    this._requestOptions = _requestOptions;
    if (modelParams.model.includes("/")) {
      this.model = modelParams.model;
    } else {
      this.model = `models/${modelParams.model}`;
    }
    this.generationConfig = modelParams.generationConfig || {};
    this.safetySettings = modelParams.safetySettings || [];
    this.tools = modelParams.tools;
    this.toolConfig = modelParams.toolConfig;
    this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);
    this.cachedContent = modelParams.cachedContent;
  }
  async generateContent(request25, requestOptions = {}) {
    var _a;
    const formattedParams = formatGenerateContentInput(request25);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === undefined ? undefined : _a.name }, formattedParams), generativeModelRequestOptions);
  }
  async generateContentStream(request25, requestOptions = {}) {
    var _a;
    const formattedParams = formatGenerateContentInput(request25);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === undefined ? undefined : _a.name }, formattedParams), generativeModelRequestOptions);
  }
  startChat(startChatParams) {
    var _a;
    return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === undefined ? undefined : _a.name }, startChatParams), this._requestOptions);
  }
  async countTokens(request25, requestOptions = {}) {
    const formattedParams = formatCountTokensInput(request25, {
      model: this.model,
      generationConfig: this.generationConfig,
      safetySettings: this.safetySettings,
      tools: this.tools,
      toolConfig: this.toolConfig,
      systemInstruction: this.systemInstruction,
      cachedContent: this.cachedContent
    });
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
  }
  async embedContent(request25, requestOptions = {}) {
    const formattedParams = formatEmbedContentInput(request25);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
  }
  async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);
  }
}

class GoogleGenerativeAI {
  constructor(apiKey) {
    this.apiKey = apiKey;
  }
  getGenerativeModel(modelParams, requestOptions) {
    if (!modelParams.model) {
      throw new GoogleGenerativeAIError(`Must provide a model name. ` + `Example: genai.getGenerativeModel({ model: 'my-model-name' })`);
    }
    return new GenerativeModel(this.apiKey, modelParams, requestOptions);
  }
  getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions) {
    if (!cachedContent.name) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `name` field.");
    }
    if (!cachedContent.model) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `model` field.");
    }
    const disallowedDuplicates = ["model", "systemInstruction"];
    for (const key of disallowedDuplicates) {
      if ((modelParams === null || modelParams === undefined ? undefined : modelParams[key]) && cachedContent[key] && (modelParams === null || modelParams === undefined ? undefined : modelParams[key]) !== cachedContent[key]) {
        if (key === "model") {
          const modelParamsComp = modelParams.model.startsWith("models/") ? modelParams.model.replace("models/", "") : modelParams.model;
          const cachedContentComp = cachedContent.model.startsWith("models/") ? cachedContent.model.replace("models/", "") : cachedContent.model;
          if (modelParamsComp === cachedContentComp) {
            continue;
          }
        }
        throw new GoogleGenerativeAIRequestInputError(`Different value for "${key}" specified in modelParams` + ` (${modelParams[key]}) and cachedContent (${cachedContent[key]})`);
      }
    }
    const modelParamsFromCache = Object.assign(Object.assign({}, modelParams), { model: cachedContent.model, tools: cachedContent.tools, toolConfig: cachedContent.toolConfig, systemInstruction: cachedContent.systemInstruction, cachedContent });
    return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);
  }
}

// src/models/ai.model.ts
var aiModel = new j0().model({
  "ai.model": C.Object({
    text: C.String()
  })
});
var ai_model_default = aiModel;

// src/api/controller/ai/requestAIChat.ts
var genAI = new GoogleGenerativeAI("AIzaSyCCVquc8xLj2EQXQAYrlnxUfUEZGVgSWjU");
var model = genAI.getGenerativeModel({ model: "gemini-1.5-flash-latest" });
var requestAIChat_default = createElysia().use(ai_model_default).use(authGuard).post("/", async ({ body, user }) => {
  const { text } = body;
  const result = await model.generateContent(text);
  if (result?.response?.candidates) {
    const ai2 = await prisma.AIChat.create({
      data: {
        userId: user.id,
        chatTitle: text
      }
    });
    await prisma.AIChatMessage.create({
      data: {
        msg: result?.response?.candidates[0]?.content?.parts?.map((part) => part.text).join(" "),
        role: result?.response?.candidates[0]?.content?.role,
        createdAt: new Date,
        aIChatId: ai2?.id
      }
    });
    return {
      status: 200,
      data: result?.response?.candidates[0]?.content?.parts?.map((part) => part.text).join(" ")
    };
  }
  return new InternalServerErrorException("Failed to generate content");
}, {
  body: "ai.model",
  detail: {
    tags: ["AI"]
  }
});

// src/api/controller/ai/getAIChat.ts
var getAIChat_default = createElysia().use(ai_model_default).use(authGuard).get("/", async ({ user }) => {
  const aiChats = await prisma.AIChat.findMany({
    where: {
      userId: user.id
    },
    orderBy: {
      createdAt: "desc"
    },
    include: {
      messages: true
    }
  });
  const history = aiChats.map((chat) => ({
    id: chat.id,
    title: chat.chatTitle,
    createdAt: chat.createdAt,
    messages: chat.messages.map((message) => ({
      id: message.id,
      msg: message.msg,
      role: message.role,
      createdAt: message.createdAt
    }))
  }));
  return {
    status: 200,
    data: history
  };
}, {
  detail: {
    tags: ["AI"]
  }
});

// src/models/user.model.ts
var userModel = new j0().model({
  "user.model": C.Object({
    email: C.String({ format: "email" }),
    email_verified: C.Optional(C.Boolean()),
    name: C.String(),
    headline: C.Optional(C.String()),
    location: C.Optional(C.String()),
    about: C.Optional(C.String()),
    bannerUrl: C.Optional(C.String({ format: "uri" })),
    icon_url: C.Optional(C.String({ format: "uri" })),
    created_at: C.Optional(C.Date()),
    updated_at: C.Optional(C.Date())
  }),
  "update.user.model": C.Object({
    email: C.Optional(C.String({ format: "email" })),
    emailVerified: C.Optional(C.Boolean()),
    name: C.Optional(C.String()),
    headline: C.Optional(C.String()),
    location: C.Optional(C.String()),
    about: C.Optional(C.String()),
    bannerUrl: C.Optional(C.String())
  })
});
var user_model_default = userModel;

// src/api/controller/user/getUser.ts
var getUser_default = createElysia().use(user_model_default).use(authGuard).get("/", async ({ user: user2 }) => {
  const userInfo = await prisma.User.findUnique({
    where: {
      id: user2.id
    },
    include: {
      aiChat: true
    }
  });
  return {
    status: 200,
    data: userInfo
  };
}, {
  detail: {
    tags: ["User"]
  }
});

// src/api/controller/user/updateUser.ts
var updateUser_default = createElysia().use(user_model_default).use(authGuard).patch("/:id", async ({
  body,
  params: {
    id
  },
  logestic
}) => {
  const userInfo = await prisma.User.findUnique({
    where: { id }
  });
  if (!userInfo) {
    logestic.error("User not found.");
    throw new BadRequestException("User not found.");
  }
  return await prisma.User.update({
    where: { id },
    data: {
      ...body
    }
  });
}, {
  body: "update.user.model",
  detail: {
    tags: ["User"]
  }
});

// src/libs/roleGuards.ts
var adminGuard = new j0({
  name: "adminGuard"
}).use(authGuard).resolve({ as: "scoped" }, async ({ user: user3 }) => {
  if (!user3 || user3?.role !== "ADMIN") {
    throw new ForbiddenException("Admin access required");
  }
  return { user: user3 };
});
var userGuard = new j0({
  name: "userGuard"
}).use(authGuard).resolve({ as: "scoped" }, async ({ user: user3 }) => {
  if (!user3 || !user3?.role || !["USER", "ADMIN"].includes(user3.role)) {
    throw new ForbiddenException("User authentication required");
  }
  return { user: user3 };
});

// node_modules/minio/dist/esm/minio.mjs
var import_xml2js2 = __toESM(require_xml2js(), 1);
import * as Stream from "stream";

// node_modules/minio/dist/esm/errors.mjs
class ExtendableError extends Error {
  constructor(message, opt) {
    super(message, opt);
    this.name = this.constructor.name;
  }
}

class AnonymousRequestError extends ExtendableError {
}

class InvalidArgumentError extends ExtendableError {
}
class InvalidEndpointError extends ExtendableError {
}

class InvalidBucketNameError extends ExtendableError {
}

class InvalidObjectNameError extends ExtendableError {
}

class AccessKeyRequiredError extends ExtendableError {
}

class SecretKeyRequiredError extends ExtendableError {
}

class ExpiresParamError extends ExtendableError {
}

class InvalidDateError extends ExtendableError {
}

class InvalidPrefixError extends ExtendableError {
}

class InvalidBucketPolicyError extends ExtendableError {
}
class InvalidXMLError extends ExtendableError {
}

class S3Error extends ExtendableError {
}

class IsValidBucketNameError extends ExtendableError {
}

// node_modules/minio/dist/esm/internal/callbackify.mjs
function callbackify(fn) {
  return function() {
    const args = [...arguments];
    const callback = args.pop();
    if (typeof callback === "function") {
      return fn.apply(this, args).then((result) => callback(null, result), (err) => callback(err));
    }
    return fn.apply(this, arguments);
  };
}

// node_modules/minio/dist/esm/internal/client.mjs
import * as crypto7 from "crypto";
import * as fs3 from "fs";
import * as http from "http";
import * as https from "https";
import * as path from "path";
import * as stream4 from "stream";

// node_modules/async/dist/async.mjs
function initialParams(fn) {
  return function(...args) {
    var callback = args.pop();
    return fn.call(this, args, callback);
  };
}
function fallback(fn) {
  setTimeout(fn, 0);
}
function wrap(defer) {
  return (fn, ...args) => defer(() => fn(...args));
}
function asyncify(func) {
  if (isAsync2(func)) {
    return function(...args) {
      const callback = args.pop();
      const promise5 = func.apply(this, args);
      return handlePromise(promise5, callback);
    };
  }
  return initialParams(function(args, callback) {
    var result;
    try {
      result = func.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result && typeof result.then === "function") {
      return handlePromise(result, callback);
    } else {
      callback(null, result);
    }
  });
}
function handlePromise(promise5, callback) {
  return promise5.then((value15) => {
    invokeCallback(callback, null, value15);
  }, (err) => {
    invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
  });
}
function invokeCallback(callback, error23, value15) {
  try {
    callback(error23, value15);
  } catch (err) {
    setImmediate$1((e) => {
      throw e;
    }, err);
  }
}
function isAsync2(fn) {
  return fn[Symbol.toStringTag] === "AsyncFunction";
}
function isAsyncGenerator(fn) {
  return fn[Symbol.toStringTag] === "AsyncGenerator";
}
function isAsyncIterable(obj) {
  return typeof obj[Symbol.asyncIterator] === "function";
}
function wrapAsync(asyncFn) {
  if (typeof asyncFn !== "function")
    throw new Error("expected a function");
  return isAsync2(asyncFn) ? asyncify(asyncFn) : asyncFn;
}
function awaitify(asyncFn, arity) {
  if (!arity)
    arity = asyncFn.length;
  if (!arity)
    throw new Error("arity is undefined");
  function awaitable(...args) {
    if (typeof args[arity - 1] === "function") {
      return asyncFn.apply(this, args);
    }
    return new Promise((resolve, reject) => {
      args[arity - 1] = (err, ...cbArgs) => {
        if (err)
          return reject(err);
        resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
      };
      asyncFn.apply(this, args);
    });
  }
  return awaitable;
}
function applyEach$1(eachfn) {
  return function applyEach(fns, ...callArgs) {
    const go = awaitify(function(callback) {
      var that = this;
      return eachfn(fns, (fn, cb) => {
        wrapAsync(fn).apply(that, callArgs.concat(cb));
      }, callback);
    });
    return go;
  };
}
function _asyncMap(eachfn, arr, iteratee, callback) {
  arr = arr || [];
  var results = [];
  var counter = 0;
  var _iteratee = wrapAsync(iteratee);
  return eachfn(arr, (value15, _, iterCb) => {
    var index = counter++;
    _iteratee(value15, (err, v3) => {
      results[index] = v3;
      iterCb(err);
    });
  }, (err) => {
    callback(err, results);
  });
}
function isArrayLike(value15) {
  return value15 && typeof value15.length === "number" && value15.length >= 0 && value15.length % 1 === 0;
}
function once(fn) {
  function wrapper(...args) {
    if (fn === null)
      return;
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  }
  Object.assign(wrapper, fn);
  return wrapper;
}
function getIterator(coll) {
  return coll[Symbol.iterator] && coll[Symbol.iterator]();
}
function createArrayIterator(coll) {
  var i3 = -1;
  var len = coll.length;
  return function next() {
    return ++i3 < len ? { value: coll[i3], key: i3 } : null;
  };
}
function createES2015Iterator(iterator5) {
  var i3 = -1;
  return function next() {
    var item = iterator5.next();
    if (item.done)
      return null;
    i3++;
    return { value: item.value, key: i3 };
  };
}
function createObjectIterator(obj) {
  var okeys = obj ? Object.keys(obj) : [];
  var i3 = -1;
  var len = okeys.length;
  return function next() {
    var key = okeys[++i3];
    if (key === "__proto__") {
      return next();
    }
    return i3 < len ? { value: obj[key], key } : null;
  };
}
function createIterator(coll) {
  if (isArrayLike(coll)) {
    return createArrayIterator(coll);
  }
  var iterator5 = getIterator(coll);
  return iterator5 ? createES2015Iterator(iterator5) : createObjectIterator(coll);
}
function onlyOnce(fn) {
  return function(...args) {
    if (fn === null)
      throw new Error("Callback was already called.");
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  };
}
function asyncEachOfLimit(generator, limit, iteratee, callback) {
  let done = false;
  let canceled = false;
  let awaiting = false;
  let running = 0;
  let idx = 0;
  function replenish() {
    if (running >= limit || awaiting || done)
      return;
    awaiting = true;
    generator.next().then(({ value: value15, done: iterDone }) => {
      if (canceled || done)
        return;
      awaiting = false;
      if (iterDone) {
        done = true;
        if (running <= 0) {
          callback(null);
        }
        return;
      }
      running++;
      iteratee(value15, idx, iterateeCallback);
      idx++;
      replenish();
    }).catch(handleError);
  }
  function iterateeCallback(err, result) {
    running -= 1;
    if (canceled)
      return;
    if (err)
      return handleError(err);
    if (err === false) {
      done = true;
      canceled = true;
      return;
    }
    if (result === breakLoop || done && running <= 0) {
      done = true;
      return callback(null);
    }
    replenish();
  }
  function handleError(err) {
    if (canceled)
      return;
    awaiting = false;
    done = true;
    callback(err);
  }
  replenish();
}
function eachOfLimit(coll, limit, iteratee, callback) {
  return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
}
function eachOfArrayLike(coll, iteratee, callback) {
  callback = once(callback);
  var index = 0, completed = 0, { length } = coll, canceled = false;
  if (length === 0) {
    callback(null);
  }
  function iteratorCallback(err, value15) {
    if (err === false) {
      canceled = true;
    }
    if (canceled === true)
      return;
    if (err) {
      callback(err);
    } else if (++completed === length || value15 === breakLoop) {
      callback(null);
    }
  }
  for (;index < length; index++) {
    iteratee(coll[index], index, onlyOnce(iteratorCallback));
  }
}
function eachOfGeneric(coll, iteratee, callback) {
  return eachOfLimit$1(coll, Infinity, iteratee, callback);
}
function eachOf(coll, iteratee, callback) {
  var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
  return eachOfImplementation(coll, wrapAsync(iteratee), callback);
}
function map3(coll, iteratee, callback) {
  return _asyncMap(eachOf$1, coll, iteratee, callback);
}
function eachOfSeries(coll, iteratee, callback) {
  return eachOfLimit$1(coll, 1, iteratee, callback);
}
function mapSeries(coll, iteratee, callback) {
  return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
}
function reduce(coll, memo, iteratee, callback) {
  callback = once(callback);
  var _iteratee = wrapAsync(iteratee);
  return eachOfSeries$1(coll, (x3, i3, iterCb) => {
    _iteratee(memo, x3, (err, v3) => {
      memo = v3;
      iterCb(err);
    });
  }, (err) => callback(err, memo));
}
function mapLimit(coll, limit, iteratee, callback) {
  return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
}
function concatLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err, ...args) => {
      if (err)
        return iterCb(err);
      return iterCb(err, args);
    });
  }, (err, mapResults) => {
    var result = [];
    for (var i3 = 0;i3 < mapResults.length; i3++) {
      if (mapResults[i3]) {
        result = result.concat(...mapResults[i3]);
      }
    }
    return callback(err, result);
  });
}
function concat(coll, iteratee, callback) {
  return concatLimit$1(coll, Infinity, iteratee, callback);
}
function concatSeries(coll, iteratee, callback) {
  return concatLimit$1(coll, 1, iteratee, callback);
}
function _createTester(check11, getResult) {
  return (eachfn, arr, _iteratee, cb) => {
    var testPassed = false;
    var testResult;
    const iteratee = wrapAsync(_iteratee);
    eachfn(arr, (value15, _, callback) => {
      iteratee(value15, (err, result) => {
        if (err || err === false)
          return callback(err);
        if (check11(result) && !testResult) {
          testPassed = true;
          testResult = getResult(true, value15);
          return callback(null, breakLoop);
        }
        callback();
      });
    }, (err) => {
      if (err)
        return cb(err);
      cb(null, testPassed ? testResult : getResult(false));
    });
  };
}
function detect(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
}
function detectLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
}
function detectSeries(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
}
function consoleFunc(name) {
  return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
    if (typeof console === "object") {
      if (err) {
        if (console.error) {
          console.error(err);
        }
      } else if (console[name]) {
        resultArgs.forEach((x3) => console[name](x3));
      }
    }
  });
}
function doWhilst(iteratee, test, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results;
  function next(err, ...args) {
    if (err)
      return callback(err);
    if (err === false)
      return;
    results = args;
    _test(...args, check11);
  }
  function check11(err, truth) {
    if (err)
      return callback(err);
    if (err === false)
      return;
    if (!truth)
      return callback(null, ...results);
    _fn(next);
  }
  return check11(null, true);
}
function _withoutIndex(iteratee) {
  return (value15, index, callback) => iteratee(value15, callback);
}
function eachLimit$2(coll, iteratee, callback) {
  return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
function eachLimit(coll, limit, iteratee, callback) {
  return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
function eachSeries(coll, iteratee, callback) {
  return eachLimit$1(coll, 1, iteratee, callback);
}
function ensureAsync(fn) {
  if (isAsync2(fn))
    return fn;
  return function(...args) {
    var callback = args.pop();
    var sync = true;
    args.push((...innerArgs) => {
      if (sync) {
        setImmediate$1(() => callback(...innerArgs));
      } else {
        callback(...innerArgs);
      }
    });
    fn.apply(this, args);
    sync = false;
  };
}
function every(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
}
function everyLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
}
function everySeries(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
}
function filterArray(eachfn, arr, iteratee, callback) {
  var truthValues = new Array(arr.length);
  eachfn(arr, (x3, index, iterCb) => {
    iteratee(x3, (err, v3) => {
      truthValues[index] = !!v3;
      iterCb(err);
    });
  }, (err) => {
    if (err)
      return callback(err);
    var results = [];
    for (var i3 = 0;i3 < arr.length; i3++) {
      if (truthValues[i3])
        results.push(arr[i3]);
    }
    callback(null, results);
  });
}
function filterGeneric(eachfn, coll, iteratee, callback) {
  var results = [];
  eachfn(coll, (x3, index, iterCb) => {
    iteratee(x3, (err, v3) => {
      if (err)
        return iterCb(err);
      if (v3) {
        results.push({ index, value: x3 });
      }
      iterCb(err);
    });
  }, (err) => {
    if (err)
      return callback(err);
    callback(null, results.sort((a, b) => a.index - b.index).map((v3) => v3.value));
  });
}
function _filter(eachfn, coll, iteratee, callback) {
  var filter = isArrayLike(coll) ? filterArray : filterGeneric;
  return filter(eachfn, coll, wrapAsync(iteratee), callback);
}
function filter(coll, iteratee, callback) {
  return _filter(eachOf$1, coll, iteratee, callback);
}
function filterLimit(coll, limit, iteratee, callback) {
  return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
}
function filterSeries(coll, iteratee, callback) {
  return _filter(eachOfSeries$1, coll, iteratee, callback);
}
function forever(fn, errback) {
  var done = onlyOnce(errback);
  var task = wrapAsync(ensureAsync(fn));
  function next(err) {
    if (err)
      return done(err);
    if (err === false)
      return;
    task(next);
  }
  return next();
}
function groupByLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err, key) => {
      if (err)
        return iterCb(err);
      return iterCb(err, { key, val });
    });
  }, (err, mapResults) => {
    var result = {};
    var { hasOwnProperty } = Object.prototype;
    for (var i3 = 0;i3 < mapResults.length; i3++) {
      if (mapResults[i3]) {
        var { key } = mapResults[i3];
        var { val } = mapResults[i3];
        if (hasOwnProperty.call(result, key)) {
          result[key].push(val);
        } else {
          result[key] = [val];
        }
      }
    }
    return callback(err, result);
  });
}
function mapValuesLimit(obj, limit, iteratee, callback) {
  callback = once(callback);
  var newObj = {};
  var _iteratee = wrapAsync(iteratee);
  return eachOfLimit$2(limit)(obj, (val, key, next) => {
    _iteratee(val, key, (err, result) => {
      if (err)
        return next(err);
      newObj[key] = result;
      next(err);
    });
  }, (err) => callback(err, newObj));
}
function race(tasks, callback) {
  callback = once(callback);
  if (!Array.isArray(tasks))
    return callback(new TypeError("First argument to race must be an array of functions"));
  if (!tasks.length)
    return callback();
  for (var i3 = 0, l3 = tasks.length;i3 < l3; i3++) {
    wrapAsync(tasks[i3])(callback);
  }
}
function reject$2(eachfn, arr, _iteratee, callback) {
  const iteratee = wrapAsync(_iteratee);
  return _filter(eachfn, arr, (value15, cb) => {
    iteratee(value15, (err, v3) => {
      cb(err, !v3);
    });
  }, callback);
}
function reject(coll, iteratee, callback) {
  return reject$2(eachOf$1, coll, iteratee, callback);
}
function rejectLimit(coll, limit, iteratee, callback) {
  return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
}
function rejectSeries(coll, iteratee, callback) {
  return reject$2(eachOfSeries$1, coll, iteratee, callback);
}
function some(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
}
function someLimit(coll, limit, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
}
function someSeries(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
}
function sortBy(coll, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return map$1(coll, (x3, iterCb) => {
    _iteratee(x3, (err, criteria) => {
      if (err)
        return iterCb(err);
      iterCb(err, { value: x3, criteria });
    });
  }, (err, results) => {
    if (err)
      return callback(err);
    callback(null, results.sort(comparator).map((v3) => v3.value));
  });
  function comparator(left, right) {
    var a = left.criteria, b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }
}
function tryEach(tasks, callback) {
  var error23 = null;
  var result;
  return eachSeries$1(tasks, (task, taskCb) => {
    wrapAsync(task)((err, ...args) => {
      if (err === false)
        return taskCb(err);
      if (args.length < 2) {
        [result] = args;
      } else {
        result = args;
      }
      error23 = err;
      taskCb(err ? null : {});
    });
  }, () => callback(error23, result));
}
function whilst(test, iteratee, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results = [];
  function next(err, ...rest4) {
    if (err)
      return callback(err);
    results = rest4;
    if (err === false)
      return;
    _test(check11);
  }
  function check11(err, truth) {
    if (err)
      return callback(err);
    if (err === false)
      return;
    if (!truth)
      return callback(null, ...results);
    _fn(next);
  }
  return _test(check11);
}
function waterfall(tasks, callback) {
  callback = once(callback);
  if (!Array.isArray(tasks))
    return callback(new Error("First argument to waterfall must be an array of functions"));
  if (!tasks.length)
    return callback();
  var taskIndex = 0;
  function nextTask(args) {
    var task = wrapAsync(tasks[taskIndex++]);
    task(...args, onlyOnce(next));
  }
  function next(err, ...args) {
    if (err === false)
      return;
    if (err || taskIndex === tasks.length) {
      return callback(err, ...args);
    }
    nextTask(args);
  }
  nextTask([]);
}
var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
var _defer$1;
if (hasQueueMicrotask) {
  _defer$1 = queueMicrotask;
} else if (hasSetImmediate) {
  _defer$1 = setImmediate;
} else if (hasNextTick) {
  _defer$1 = process.nextTick;
} else {
  _defer$1 = fallback;
}
var setImmediate$1 = wrap(_defer$1);
var breakLoop = {};
var eachOfLimit$2 = (limit) => {
  return (obj, iteratee, callback) => {
    callback = once(callback);
    if (limit <= 0) {
      throw new RangeError("concurrency limit cannot be less than 1");
    }
    if (!obj) {
      return callback(null);
    }
    if (isAsyncGenerator(obj)) {
      return asyncEachOfLimit(obj, limit, iteratee, callback);
    }
    if (isAsyncIterable(obj)) {
      return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
    }
    var nextElem = createIterator(obj);
    var done = false;
    var canceled = false;
    var running = 0;
    var looping = false;
    function iterateeCallback(err, value15) {
      if (canceled)
        return;
      running -= 1;
      if (err) {
        done = true;
        callback(err);
      } else if (err === false) {
        done = true;
        canceled = true;
      } else if (value15 === breakLoop || done && running <= 0) {
        done = true;
        return callback(null);
      } else if (!looping) {
        replenish();
      }
    }
    function replenish() {
      looping = true;
      while (running < limit && !done) {
        var elem = nextElem();
        if (elem === null) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running += 1;
        iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
      }
      looping = false;
    }
    replenish();
  };
};
var eachOfLimit$1 = awaitify(eachOfLimit, 4);
var eachOf$1 = awaitify(eachOf, 3);
var map$1 = awaitify(map3, 3);
var applyEach = applyEach$1(map$1);
var eachOfSeries$1 = awaitify(eachOfSeries, 3);
var mapSeries$1 = awaitify(mapSeries, 3);
var applyEachSeries = applyEach$1(mapSeries$1);
var PROMISE_SYMBOL = Symbol("promiseCallback");
var reduce$1 = awaitify(reduce, 4);
var mapLimit$1 = awaitify(mapLimit, 4);
var concatLimit$1 = awaitify(concatLimit, 4);
var concat$1 = awaitify(concat, 3);
var concatSeries$1 = awaitify(concatSeries, 3);
var detect$1 = awaitify(detect, 3);
var detectLimit$1 = awaitify(detectLimit, 4);
var detectSeries$1 = awaitify(detectSeries, 3);
var dir = consoleFunc("dir");
var doWhilst$1 = awaitify(doWhilst, 3);
var each = awaitify(eachLimit$2, 3);
var eachLimit$1 = awaitify(eachLimit, 4);
var eachSeries$1 = awaitify(eachSeries, 3);
var every$1 = awaitify(every, 3);
var everyLimit$1 = awaitify(everyLimit, 4);
var everySeries$1 = awaitify(everySeries, 3);
var filter$1 = awaitify(filter, 3);
var filterLimit$1 = awaitify(filterLimit, 4);
var filterSeries$1 = awaitify(filterSeries, 3);
var forever$1 = awaitify(forever, 2);
var groupByLimit$1 = awaitify(groupByLimit, 4);
var log = consoleFunc("log");
var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
var _defer;
if (hasNextTick) {
  _defer = process.nextTick;
} else if (hasSetImmediate) {
  _defer = setImmediate;
} else {
  _defer = fallback;
}
var nextTick = wrap(_defer);
var _parallel = awaitify((eachfn, tasks, callback) => {
  var results = isArrayLike(tasks) ? [] : {};
  eachfn(tasks, (task, key, taskCb) => {
    wrapAsync(task)((err, ...result) => {
      if (result.length < 2) {
        [result] = result;
      }
      results[key] = result;
      taskCb(err);
    });
  }, (err) => callback(err, results));
}, 3);
var race$1 = awaitify(race, 2);
var reject$1 = awaitify(reject, 3);
var rejectLimit$1 = awaitify(rejectLimit, 4);
var rejectSeries$1 = awaitify(rejectSeries, 3);
var some$1 = awaitify(some, 3);
var someLimit$1 = awaitify(someLimit, 4);
var someSeries$1 = awaitify(someSeries, 3);
var sortBy$1 = awaitify(sortBy, 3);
var tryEach$1 = awaitify(tryEach);
var whilst$1 = awaitify(whilst, 3);
var waterfall$1 = awaitify(waterfall);

// node_modules/minio/dist/esm/internal/client.mjs
var import_block_stream2 = __toESM(require_block_stream2(), 1);
var import_browser_or_node = __toESM(require_lib2(), 1);
var import_lodash2 = __toESM(require_lodash(), 1);

// node_modules/query-string/index.js
function encoderForArrayFormat(options) {
  switch (options.arrayFormat) {
    case "index":
      return (key) => (result, value15) => {
        const index = result.length;
        if (value15 === undefined || options.skipNull && value15 === null || options.skipEmptyString && value15 === "") {
          return result;
        }
        if (value15 === null) {
          return [...result, [encode2(key, options), "[", index, "]"].join("")];
        }
        return [
          ...result,
          [encode2(key, options), "[", encode2(index, options), "]=", encode2(value15, options)].join("")
        ];
      };
    case "bracket":
      return (key) => (result, value15) => {
        if (value15 === undefined || options.skipNull && value15 === null || options.skipEmptyString && value15 === "") {
          return result;
        }
        if (value15 === null) {
          return [...result, [encode2(key, options), "[]"].join("")];
        }
        return [...result, [encode2(key, options), "[]=", encode2(value15, options)].join("")];
      };
    case "colon-list-separator":
      return (key) => (result, value15) => {
        if (value15 === undefined || options.skipNull && value15 === null || options.skipEmptyString && value15 === "") {
          return result;
        }
        if (value15 === null) {
          return [...result, [encode2(key, options), ":list="].join("")];
        }
        return [...result, [encode2(key, options), ":list=", encode2(value15, options)].join("")];
      };
    case "comma":
    case "separator":
    case "bracket-separator": {
      const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
      return (key) => (result, value15) => {
        if (value15 === undefined || options.skipNull && value15 === null || options.skipEmptyString && value15 === "") {
          return result;
        }
        value15 = value15 === null ? "" : value15;
        if (result.length === 0) {
          return [[encode2(key, options), keyValueSep, encode2(value15, options)].join("")];
        }
        return [[result, encode2(value15, options)].join(options.arrayFormatSeparator)];
      };
    }
    default:
      return (key) => (result, value15) => {
        if (value15 === undefined || options.skipNull && value15 === null || options.skipEmptyString && value15 === "") {
          return result;
        }
        if (value15 === null) {
          return [...result, encode2(key, options)];
        }
        return [...result, [encode2(key, options), "=", encode2(value15, options)].join("")];
      };
  }
}
function validateArrayFormatSeparator(value15) {
  if (typeof value15 !== "string" || value15.length !== 1) {
    throw new TypeError("arrayFormatSeparator must be single character string");
  }
}
function encode2(value15, options) {
  if (options.encode) {
    return options.strict ? strictUriEncode(value15) : encodeURIComponent(value15);
  }
  return value15;
}
var strictUriEncode = require_strict_uri_encode();
var decodeComponent = require_decode_uri_component();
var splitOnFirst = require_split_on_first();
var filterObject = require_filter_obj();
var isNullOrUndefined = (value15) => value15 === null || value15 === undefined;
var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
var $stringify = (object13, options) => {
  if (!object13) {
    return "";
  }
  options = Object.assign({
    encode: true,
    strict: true,
    arrayFormat: "none",
    arrayFormatSeparator: ","
  }, options);
  validateArrayFormatSeparator(options.arrayFormatSeparator);
  const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object13[key]) || options.skipEmptyString && object13[key] === "";
  const formatter = encoderForArrayFormat(options);
  const objectCopy = {};
  for (const key of Object.keys(object13)) {
    if (!shouldFilter(key)) {
      objectCopy[key] = object13[key];
    }
  }
  const keys = Object.keys(objectCopy);
  if (options.sort !== false) {
    keys.sort(options.sort);
  }
  return keys.map((key) => {
    const value15 = object13[key];
    if (value15 === undefined) {
      return "";
    }
    if (value15 === null) {
      return encode2(key, options);
    }
    if (Array.isArray(value15)) {
      if (value15.length === 0 && options.arrayFormat === "bracket-separator") {
        return encode2(key, options) + "[]";
      }
      return value15.reduce(formatter(key), []).join("&");
    }
    return encode2(key, options) + "=" + encode2(value15, options);
  }).filter((x3) => x3.length > 0).join("&");
};

// node_modules/minio/dist/esm/internal/client.mjs
var import_xml2js = __toESM(require_xml2js(), 1);

// node_modules/minio/dist/esm/Credentials.mjs
class Credentials {
  constructor({
    accessKey,
    secretKey,
    sessionToken
  }) {
    this.accessKey = accessKey;
    this.secretKey = secretKey;
    this.sessionToken = sessionToken;
  }
  setAccessKey(accessKey) {
    this.accessKey = accessKey;
  }
  getAccessKey() {
    return this.accessKey;
  }
  setSecretKey(secretKey) {
    this.secretKey = secretKey;
  }
  getSecretKey() {
    return this.secretKey;
  }
  setSessionToken(sessionToken) {
    this.sessionToken = sessionToken;
  }
  getSessionToken() {
    return this.sessionToken;
  }
  get() {
    return this;
  }
}

// node_modules/minio/dist/esm/CredentialProvider.mjs
class CredentialProvider {
  constructor({
    accessKey,
    secretKey,
    sessionToken
  }) {
    this.credentials = new Credentials({
      accessKey,
      secretKey,
      sessionToken
    });
  }
  async getCredentials() {
    return this.credentials.get();
  }
  setCredentials(credentials) {
    if (credentials instanceof Credentials) {
      this.credentials = credentials;
    } else {
      throw new Error("Unable to set Credentials. it should be an instance of Credentials class");
    }
  }
  setAccessKey(accessKey) {
    this.credentials.setAccessKey(accessKey);
  }
  getAccessKey() {
    return this.credentials.getAccessKey();
  }
  setSecretKey(secretKey) {
    this.credentials.setSecretKey(secretKey);
  }
  getSecretKey() {
    return this.credentials.getSecretKey();
  }
  setSessionToken(sessionToken) {
    this.credentials.setSessionToken(sessionToken);
  }
  getSessionToken() {
    return this.credentials.getSessionToken();
  }
}

// node_modules/minio/dist/esm/internal/helper.mjs
var import_fast_xml_parser = __toESM(require_fxp(), 1);
var import_ipaddr = __toESM(require_ipaddr(), 1);
var import_lodash = __toESM(require_lodash(), 1);
import * as crypto5 from "crypto";
import * as stream2 from "stream";

// node_modules/mime-types/index.js
function lookup(path) {
  if (!path || typeof path !== "string") {
    return false;
  }
  var extension = extname("x." + path).toLowerCase().substr(1);
  if (!extension) {
    return false;
  }
  return $types[extension] || false;
}
function populateMaps(extensions, types) {
  var preference = ["nginx", "apache", undefined, "iana"];
  Object.keys(db).forEach(function forEachMimeType(type47) {
    var mime = db[type47];
    var exts = mime.extensions;
    if (!exts || !exts.length) {
      return;
    }
    extensions[type47] = exts;
    for (var i3 = 0;i3 < exts.length; i3++) {
      var extension = exts[i3];
      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source);
        var to = preference.indexOf(mime.source);
        if (types[extension] !== "application/octet-stream" && (from > to || from === to && types[extension].substr(0, 12) === "application/")) {
          continue;
        }
      }
      types[extension] = type47;
    }
  });
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var db = require_mime_db();
var extname = import.meta.require("path").extname;
var $extensions = Object.create(null);
var $lookup = lookup;
var $types = Object.create(null);
populateMaps($extensions, $types);

// node_modules/minio/dist/esm/internal/async.mjs
import * as fs2 from "fs";
import * as stream from "stream";
import {promisify} from "util";
import {promises} from "fs";
var streamPromise = {
  pipeline: promisify(stream.pipeline)
};
var fstat2 = promisify(fs2.fstat);

// node_modules/minio/dist/esm/internal/type.mjs
var ENCRYPTION_TYPES = /* @__PURE__ */ function(ENCRYPTION_TYPES2) {
  ENCRYPTION_TYPES2["SSEC"] = "SSE-C";
  ENCRYPTION_TYPES2["KMS"] = "KMS";
  return ENCRYPTION_TYPES2;
}({});
var RETENTION_MODES = /* @__PURE__ */ function(RETENTION_MODES2) {
  RETENTION_MODES2["GOVERNANCE"] = "GOVERNANCE";
  RETENTION_MODES2["COMPLIANCE"] = "COMPLIANCE";
  return RETENTION_MODES2;
}({});
var RETENTION_VALIDITY_UNITS = /* @__PURE__ */ function(RETENTION_VALIDITY_UNITS2) {
  RETENTION_VALIDITY_UNITS2["DAYS"] = "Days";
  RETENTION_VALIDITY_UNITS2["YEARS"] = "Years";
  return RETENTION_VALIDITY_UNITS2;
}({});
var LEGAL_HOLD_STATUS = /* @__PURE__ */ function(LEGAL_HOLD_STATUS2) {
  LEGAL_HOLD_STATUS2["ENABLED"] = "ON";
  LEGAL_HOLD_STATUS2["DISABLED"] = "OFF";
  return LEGAL_HOLD_STATUS2;
}({});

// node_modules/minio/dist/esm/internal/helper.mjs
function hashBinary(buf, enableSHA256) {
  let sha256sum = "";
  if (enableSHA256) {
    sha256sum = crypto5.createHash("sha256").update(buf).digest("hex");
  }
  const md5sum = crypto5.createHash("md5").update(buf).digest("base64");
  return {
    md5sum,
    sha256sum
  };
}
function uriEscape(uriStr) {
  return encodeURIComponent(uriStr).replace(/[!'()*]/g, encodeAsHex);
}
function uriResourceEscape(string7) {
  return uriEscape(string7).replace(/%2F/g, "/");
}
function getScope(region, date5, serviceName = "s3") {
  return `${makeDateShort(date5)}/${region}/${serviceName}/aws4_request`;
}
function isAmazonEndpoint(endpoint) {
  return endpoint === "s3.amazonaws.com" || endpoint === "s3.cn-north-1.amazonaws.com.cn";
}
function isVirtualHostStyle(endpoint, protocol, bucket, pathStyle) {
  if (protocol === "https:" && bucket.includes(".")) {
    return false;
  }
  return isAmazonEndpoint(endpoint) || !pathStyle;
}
function isValidIP2(ip) {
  return import_ipaddr.default.isValid(ip);
}
function isValidEndpoint(endpoint) {
  return isValidDomain(endpoint) || isValidIP2(endpoint);
}
function isValidDomain(host) {
  if (!isString(host)) {
    return false;
  }
  if (host.length === 0 || host.length > 255) {
    return false;
  }
  if (host[0] === "-" || host.slice(-1) === "-") {
    return false;
  }
  if (host[0] === "_" || host.slice(-1) === "_") {
    return false;
  }
  if (host[0] === ".") {
    return false;
  }
  const nonAlphaNumerics = '`~!@#$%^&*()+={}[]|\\"\';:><?/';
  for (const char of nonAlphaNumerics) {
    if (host.includes(char)) {
      return false;
    }
  }
  return true;
}
function probeContentType(path) {
  let contentType = $lookup(path);
  if (!contentType) {
    contentType = "application/octet-stream";
  }
  return contentType;
}
function isValidPort(port) {
  const portNum = typeof port === "string" ? parseInt(port, 10) : port;
  if (!isNumber(portNum) || isNaN(portNum)) {
    return false;
  }
  return 0 <= portNum && portNum <= 65535;
}
function isValidBucketName(bucket) {
  if (!isString(bucket)) {
    return false;
  }
  if (bucket.length < 3 || bucket.length > 63) {
    return false;
  }
  if (bucket.includes("..")) {
    return false;
  }
  if (/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/.test(bucket)) {
    return false;
  }
  if (/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/.test(bucket)) {
    return true;
  }
  return false;
}
function isValidObjectName(objectName) {
  if (!isValidPrefix(objectName)) {
    return false;
  }
  return objectName.length !== 0;
}
function isValidPrefix(prefix) {
  if (!isString(prefix)) {
    return false;
  }
  if (prefix.length > 1024) {
    return false;
  }
  return true;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isString(arg) {
  return typeof arg === "string";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isReadableStream(arg) {
  return isObject(arg) && isFunction(arg._read);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isEmpty(o3) {
  return import_lodash.default.isEmpty(o3);
}
function isEmptyObject(o3) {
  return Object.values(o3).filter((x3) => x3 !== undefined).length !== 0;
}
function isDefined(o3) {
  return o3 !== null && o3 !== undefined;
}
function makeDateLong(date5) {
  date5 = date5 || new Date;
  const s3 = date5.toISOString();
  return s3.slice(0, 4) + s3.slice(5, 7) + s3.slice(8, 13) + s3.slice(14, 16) + s3.slice(17, 19) + "Z";
}
function makeDateShort(date5) {
  date5 = date5 || new Date;
  const s3 = date5.toISOString();
  return s3.slice(0, 4) + s3.slice(5, 7) + s3.slice(8, 10);
}
function pipesetup(...streams) {
  return streams.reduce((src, dst) => {
    src.on("error", (err) => dst.emit("error", err));
    return src.pipe(dst);
  });
}
function readableStream(data) {
  const s3 = new stream2.Readable;
  s3._read = () => {
  };
  s3.push(data);
  s3.push(null);
  return s3;
}
function insertContentType(metaData, filePath) {
  for (const key in metaData) {
    if (key.toLowerCase() === "content-type") {
      return metaData;
    }
  }
  return {
    ...metaData,
    "content-type": probeContentType(filePath)
  };
}
function prependXAMZMeta(metaData) {
  if (!metaData) {
    return {};
  }
  return import_lodash.default.mapKeys(metaData, (value15, key) => {
    if (isAmzHeader(key) || isSupportedHeader(key) || isStorageClassHeader(key)) {
      return key;
    }
    return MetaDataHeaderPrefix + key;
  });
}
function isAmzHeader(key) {
  const temp = key.toLowerCase();
  return temp.startsWith(MetaDataHeaderPrefix) || temp === "x-amz-acl" || temp.startsWith("x-amz-server-side-encryption-") || temp === "x-amz-server-side-encryption";
}
function isSupportedHeader(key) {
  const supported_headers = ["content-type", "cache-control", "content-encoding", "content-disposition", "content-language", "x-amz-website-redirect-location", "if-none-match", "if-match"];
  return supported_headers.includes(key.toLowerCase());
}
function isStorageClassHeader(key) {
  return key.toLowerCase() === "x-amz-storage-class";
}
function extractMetadata(headers) {
  return import_lodash.default.mapKeys(import_lodash.default.pickBy(headers, (value15, key) => isSupportedHeader(key) || isStorageClassHeader(key) || isAmzHeader(key)), (value15, key) => {
    const lower = key.toLowerCase();
    if (lower.startsWith(MetaDataHeaderPrefix)) {
      return lower.slice(MetaDataHeaderPrefix.length);
    }
    return key;
  });
}
function getVersionId(headers = {}) {
  return headers["x-amz-version-id"] || null;
}
function getSourceVersionId(headers = {}) {
  return headers["x-amz-copy-source-version-id"] || null;
}
function sanitizeETag(etag = "") {
  const replaceChars = {
    '"': "",
    "&quot;": "",
    "&#34;": "",
    "&QUOT;": "",
    "&#x00022": ""
  };
  return etag.replace(/^("|&quot;|&#34;)|("|&quot;|&#34;)$/g, (m3) => replaceChars[m3]);
}
function toMd5(payload) {
  return crypto5.createHash("md5").update(Buffer.from(payload)).digest().toString("base64");
}
function toSha256(payload) {
  return crypto5.createHash("sha256").update(payload).digest("hex");
}
function toArray(param) {
  if (!Array.isArray(param)) {
    return [param];
  }
  return param;
}
function sanitizeObjectKey(objectName) {
  const asStrName = (objectName ? objectName.toString() : "").replace(/\+/g, " ");
  return decodeURIComponent(asStrName);
}
function sanitizeSize(size) {
  return size ? Number.parseInt(size) : undefined;
}
function getEncryptionHeaders(encConfig) {
  const encType = encConfig.type;
  if (!isEmpty(encType)) {
    if (encType === ENCRYPTION_TYPES.SSEC) {
      return {
        [ENCRYPTION_HEADERS.sseGenericHeader]: "AES256"
      };
    } else if (encType === ENCRYPTION_TYPES.KMS) {
      return {
        [ENCRYPTION_HEADERS.sseGenericHeader]: encConfig.SSEAlgorithm,
        [ENCRYPTION_HEADERS.sseKmsKeyID]: encConfig.KMSMasterKeyID
      };
    }
  }
  return {};
}
function partsRequired(size) {
  const maxPartSize = PART_CONSTRAINTS.MAX_MULTIPART_PUT_OBJECT_SIZE / (PART_CONSTRAINTS.MAX_PARTS_COUNT - 1);
  let requiredPartSize = size / maxPartSize;
  if (size % maxPartSize > 0) {
    requiredPartSize++;
  }
  requiredPartSize = Math.trunc(requiredPartSize);
  return requiredPartSize;
}
function calculateEvenSplits(size, objInfo) {
  if (size === 0) {
    return null;
  }
  const reqParts = partsRequired(size);
  const startIndexParts = [];
  const endIndexParts = [];
  let start = objInfo.Start;
  if (isEmpty(start) || start === -1) {
    start = 0;
  }
  const divisorValue = Math.trunc(size / reqParts);
  const reminderValue = size % reqParts;
  let nextStart = start;
  for (let i3 = 0;i3 < reqParts; i3++) {
    let curPartSize = divisorValue;
    if (i3 < reminderValue) {
      curPartSize++;
    }
    const currentStart = nextStart;
    const currentEnd = currentStart + curPartSize - 1;
    nextStart = currentEnd + 1;
    startIndexParts.push(currentStart);
    endIndexParts.push(currentEnd);
  }
  return {
    startIndex: startIndexParts,
    endIndex: endIndexParts,
    objInfo
  };
}
function parseXml(xml) {
  const result = fxp.parse(xml);
  if (result.Error) {
    throw result.Error;
  }
  return result;
}
async function getContentLength(s3) {
  if (typeof s3 === "string" || Buffer.isBuffer(s3)) {
    return s3.length;
  }
  const filePath = s3.path;
  if (filePath && typeof filePath === "string") {
    const stat = await promises.lstat(filePath);
    return stat.size;
  }
  const fd = s3.fd;
  if (fd && typeof fd === "number") {
    const stat = await fstat2(fd);
    return stat.size;
  }
  return null;
}
var MetaDataHeaderPrefix = "x-amz-meta-";
var encodeAsHex = (c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`;
var PART_CONSTRAINTS = {
  ABS_MIN_PART_SIZE: 1024 * 1024 * 5,
  MIN_PART_SIZE: 1024 * 1024 * 16,
  MAX_PARTS_COUNT: 1e4,
  MAX_PART_SIZE: 1024 * 1024 * 1024 * 5,
  MAX_SINGLE_PUT_OBJECT_SIZE: 1024 * 1024 * 1024 * 5,
  MAX_MULTIPART_PUT_OBJECT_SIZE: 1024 * 1024 * 1024 * 1024 * 5
};
var GENERIC_SSE_HEADER = "X-Amz-Server-Side-Encryption";
var ENCRYPTION_HEADERS = {
  sseGenericHeader: GENERIC_SSE_HEADER,
  sseKmsKeyID: GENERIC_SSE_HEADER + "-Aws-Kms-Key-Id"
};
var fxp = new import_fast_xml_parser.XMLParser;
// node_modules/minio/dist/esm/helpers.mjs
var DEFAULT_REGION = "us-east-1";
var PRESIGN_EXPIRY_DAYS_MAX = 24 * 60 * 60 * 7;

class CopySourceOptions {
  constructor({
    Bucket,
    Object: Object3,
    VersionID = "",
    MatchETag = "",
    NoMatchETag = "",
    MatchModifiedSince = null,
    MatchUnmodifiedSince = null,
    MatchRange = false,
    Start = 0,
    End = 0,
    Encryption = undefined
  }) {
    this.Bucket = Bucket;
    this.Object = Object3;
    this.VersionID = VersionID;
    this.MatchETag = MatchETag;
    this.NoMatchETag = NoMatchETag;
    this.MatchModifiedSince = MatchModifiedSince;
    this.MatchUnmodifiedSince = MatchUnmodifiedSince;
    this.MatchRange = MatchRange;
    this.Start = Start;
    this.End = End;
    this.Encryption = Encryption;
  }
  validate() {
    if (!isValidBucketName(this.Bucket)) {
      throw new InvalidBucketNameError("Invalid Source bucket name: " + this.Bucket);
    }
    if (!isValidObjectName(this.Object)) {
      throw new InvalidObjectNameError(`Invalid Source object name: ${this.Object}`);
    }
    if (this.MatchRange && this.Start !== -1 && this.End !== -1 && this.Start > this.End || this.Start < 0) {
      throw new InvalidObjectNameError("Source start must be non-negative, and start must be at most end.");
    } else if (this.MatchRange && !isNumber(this.Start) || !isNumber(this.End)) {
      throw new InvalidObjectNameError("MatchRange is specified. But Invalid Start and End values are specified.");
    }
    return true;
  }
  getHeaders() {
    const headerOptions = {};
    headerOptions["x-amz-copy-source"] = encodeURI(this.Bucket + "/" + this.Object);
    if (!isEmpty(this.VersionID)) {
      headerOptions["x-amz-copy-source"] = `${encodeURI(this.Bucket + "/" + this.Object)}?versionId=${this.VersionID}`;
    }
    if (!isEmpty(this.MatchETag)) {
      headerOptions["x-amz-copy-source-if-match"] = this.MatchETag;
    }
    if (!isEmpty(this.NoMatchETag)) {
      headerOptions["x-amz-copy-source-if-none-match"] = this.NoMatchETag;
    }
    if (!isEmpty(this.MatchModifiedSince)) {
      headerOptions["x-amz-copy-source-if-modified-since"] = this.MatchModifiedSince;
    }
    if (!isEmpty(this.MatchUnmodifiedSince)) {
      headerOptions["x-amz-copy-source-if-unmodified-since"] = this.MatchUnmodifiedSince;
    }
    return headerOptions;
  }
}

class CopyDestinationOptions {
  constructor({
    Bucket,
    Object: Object3,
    Encryption,
    UserMetadata,
    UserTags,
    LegalHold,
    RetainUntilDate,
    Mode,
    MetadataDirective,
    Headers: Headers2
  }) {
    this.Bucket = Bucket;
    this.Object = Object3;
    this.Encryption = Encryption ?? undefined;
    this.UserMetadata = UserMetadata;
    this.UserTags = UserTags;
    this.LegalHold = LegalHold;
    this.Mode = Mode;
    this.RetainUntilDate = RetainUntilDate;
    this.MetadataDirective = MetadataDirective;
    this.Headers = Headers2;
  }
  getHeaders() {
    const replaceDirective = "REPLACE";
    const headerOptions = {};
    const userTags = this.UserTags;
    if (!isEmpty(userTags)) {
      headerOptions["X-Amz-Tagging-Directive"] = replaceDirective;
      headerOptions["X-Amz-Tagging"] = isObject(userTags) ? $stringify(userTags) : isString(userTags) ? userTags : "";
    }
    if (this.Mode) {
      headerOptions["X-Amz-Object-Lock-Mode"] = this.Mode;
    }
    if (this.RetainUntilDate) {
      headerOptions["X-Amz-Object-Lock-Retain-Until-Date"] = this.RetainUntilDate;
    }
    if (this.LegalHold) {
      headerOptions["X-Amz-Object-Lock-Legal-Hold"] = this.LegalHold;
    }
    if (this.UserMetadata) {
      for (const [key, value15] of Object.entries(this.UserMetadata)) {
        headerOptions[`X-Amz-Meta-${key}`] = value15.toString();
      }
    }
    if (this.MetadataDirective) {
      headerOptions[`X-Amz-Metadata-Directive`] = this.MetadataDirective;
    }
    if (this.Encryption) {
      const encryptionHeaders = getEncryptionHeaders(this.Encryption);
      for (const [key, value15] of Object.entries(encryptionHeaders)) {
        headerOptions[key] = value15;
      }
    }
    if (this.Headers) {
      for (const [key, value15] of Object.entries(this.Headers)) {
        headerOptions[key] = value15;
      }
    }
    return headerOptions;
  }
  validate() {
    if (!isValidBucketName(this.Bucket)) {
      throw new InvalidBucketNameError("Invalid Destination bucket name: " + this.Bucket);
    }
    if (!isValidObjectName(this.Object)) {
      throw new InvalidObjectNameError(`Invalid Destination object name: ${this.Object}`);
    }
    if (!isEmpty(this.UserMetadata) && !isObject(this.UserMetadata)) {
      throw new InvalidObjectNameError(`Destination UserMetadata should be an object with key value pairs`);
    }
    if (!isEmpty(this.Mode) && ![RETENTION_MODES.GOVERNANCE, RETENTION_MODES.COMPLIANCE].includes(this.Mode)) {
      throw new InvalidObjectNameError(`Invalid Mode specified for destination object it should be one of [GOVERNANCE,COMPLIANCE]`);
    }
    if (this.Encryption !== undefined && isEmptyObject(this.Encryption)) {
      throw new InvalidObjectNameError(`Invalid Encryption configuration for destination object `);
    }
    return true;
  }
}

class SelectResults {
  constructor({
    records,
    response,
    stats,
    progress
  }) {
    this.records = records;
    this.response = response;
    this.stats = stats;
    this.progress = progress;
  }
  setStats(stats) {
    this.stats = stats;
  }
  getStats() {
    return this.stats;
  }
  setProgress(progress) {
    this.progress = progress;
  }
  getProgress() {
    return this.progress;
  }
  setResponse(response) {
    this.response = response;
  }
  getResponse() {
    return this.response;
  }
  setRecords(records) {
    this.records = records;
  }
  getRecords() {
    return this.records;
  }
}

// node_modules/minio/dist/esm/signing.mjs
import * as crypto6 from "crypto";
function getCanonicalRequest(method, path, headers, signedHeaders, hashedPayload) {
  if (!isString(method)) {
    throw new TypeError('method should be of type "string"');
  }
  if (!isString(path)) {
    throw new TypeError('path should be of type "string"');
  }
  if (!isObject(headers)) {
    throw new TypeError('headers should be of type "object"');
  }
  if (!Array.isArray(signedHeaders)) {
    throw new TypeError('signedHeaders should be of type "array"');
  }
  if (!isString(hashedPayload)) {
    throw new TypeError('hashedPayload should be of type "string"');
  }
  const headersArray = signedHeaders.reduce((acc, i3) => {
    const val = `${headers[i3]}`.replace(/ +/g, " ");
    acc.push(`${i3.toLowerCase()}:${val}`);
    return acc;
  }, []);
  const requestResource = path.split("?")[0];
  let requestQuery = path.split("?")[1];
  if (!requestQuery) {
    requestQuery = "";
  }
  if (requestQuery) {
    requestQuery = requestQuery.split("&").sort().map((element) => !element.includes("=") ? element + "=" : element).join("&");
  }
  return [method.toUpperCase(), requestResource, requestQuery, headersArray.join("\n") + "\n", signedHeaders.join(";").toLowerCase(), hashedPayload].join("\n");
}
function getCredential(accessKey, region, requestDate, serviceName = "s3") {
  if (!isString(accessKey)) {
    throw new TypeError('accessKey should be of type "string"');
  }
  if (!isString(region)) {
    throw new TypeError('region should be of type "string"');
  }
  if (!isObject(requestDate)) {
    throw new TypeError('requestDate should be of type "object"');
  }
  return `${accessKey}/${getScope(region, requestDate, serviceName)}`;
}
function getSignedHeaders(headers) {
  if (!isObject(headers)) {
    throw new TypeError('request should be of type "object"');
  }
  const ignoredHeaders = ["authorization", "content-length", "content-type", "user-agent"];
  return Object.keys(headers).filter((header) => !ignoredHeaders.includes(header)).sort();
}
function getSigningKey(date5, region, secretKey, serviceName = "s3") {
  if (!isObject(date5)) {
    throw new TypeError('date should be of type "object"');
  }
  if (!isString(region)) {
    throw new TypeError('region should be of type "string"');
  }
  if (!isString(secretKey)) {
    throw new TypeError('secretKey should be of type "string"');
  }
  const dateLine = makeDateShort(date5);
  const hmac1 = crypto6.createHmac("sha256", "AWS4" + secretKey).update(dateLine).digest(), hmac2 = crypto6.createHmac("sha256", hmac1).update(region).digest(), hmac3 = crypto6.createHmac("sha256", hmac2).update(serviceName).digest();
  return crypto6.createHmac("sha256", hmac3).update("aws4_request").digest();
}
function getStringToSign(canonicalRequest, requestDate, region, serviceName = "s3") {
  if (!isString(canonicalRequest)) {
    throw new TypeError('canonicalRequest should be of type "string"');
  }
  if (!isObject(requestDate)) {
    throw new TypeError('requestDate should be of type "object"');
  }
  if (!isString(region)) {
    throw new TypeError('region should be of type "string"');
  }
  const hash7 = crypto6.createHash("sha256").update(canonicalRequest).digest("hex");
  const scope = getScope(region, requestDate, serviceName);
  const stringToSign = [signV4Algorithm, makeDateLong(requestDate), scope, hash7];
  return stringToSign.join("\n");
}
function postPresignSignatureV4(region, date5, secretKey, policyBase64) {
  if (!isString(region)) {
    throw new TypeError('region should be of type "string"');
  }
  if (!isObject(date5)) {
    throw new TypeError('date should be of type "object"');
  }
  if (!isString(secretKey)) {
    throw new TypeError('secretKey should be of type "string"');
  }
  if (!isString(policyBase64)) {
    throw new TypeError('policyBase64 should be of type "string"');
  }
  const signingKey = getSigningKey(date5, region, secretKey);
  return crypto6.createHmac("sha256", signingKey).update(policyBase64).digest("hex").toLowerCase();
}
function signV4(request25, accessKey, secretKey, region, requestDate, sha256sum, serviceName = "s3") {
  if (!isObject(request25)) {
    throw new TypeError('request should be of type "object"');
  }
  if (!isString(accessKey)) {
    throw new TypeError('accessKey should be of type "string"');
  }
  if (!isString(secretKey)) {
    throw new TypeError('secretKey should be of type "string"');
  }
  if (!isString(region)) {
    throw new TypeError('region should be of type "string"');
  }
  if (!accessKey) {
    throw new AccessKeyRequiredError("accessKey is required for signing");
  }
  if (!secretKey) {
    throw new SecretKeyRequiredError("secretKey is required for signing");
  }
  const signedHeaders = getSignedHeaders(request25.headers);
  const canonicalRequest = getCanonicalRequest(request25.method, request25.path, request25.headers, signedHeaders, sha256sum);
  const serviceIdentifier = serviceName || "s3";
  const stringToSign = getStringToSign(canonicalRequest, requestDate, region, serviceIdentifier);
  const signingKey = getSigningKey(requestDate, region, secretKey, serviceIdentifier);
  const credential = getCredential(accessKey, region, requestDate, serviceIdentifier);
  const signature = crypto6.createHmac("sha256", signingKey).update(stringToSign).digest("hex").toLowerCase();
  return `${signV4Algorithm} Credential=${credential}, SignedHeaders=${signedHeaders.join(";").toLowerCase()}, Signature=${signature}`;
}
function presignSignatureV4(request25, accessKey, secretKey, sessionToken, region, requestDate, expires) {
  if (!isObject(request25)) {
    throw new TypeError('request should be of type "object"');
  }
  if (!isString(accessKey)) {
    throw new TypeError('accessKey should be of type "string"');
  }
  if (!isString(secretKey)) {
    throw new TypeError('secretKey should be of type "string"');
  }
  if (!isString(region)) {
    throw new TypeError('region should be of type "string"');
  }
  if (!accessKey) {
    throw new AccessKeyRequiredError("accessKey is required for presigning");
  }
  if (!secretKey) {
    throw new SecretKeyRequiredError("secretKey is required for presigning");
  }
  if (expires && !isNumber(expires)) {
    throw new TypeError('expires should be of type "number"');
  }
  if (expires && expires < 1) {
    throw new ExpiresParamError("expires param cannot be less than 1 seconds");
  }
  if (expires && expires > PRESIGN_EXPIRY_DAYS_MAX) {
    throw new ExpiresParamError("expires param cannot be greater than 7 days");
  }
  const iso8601Date = makeDateLong(requestDate);
  const signedHeaders = getSignedHeaders(request25.headers);
  const credential = getCredential(accessKey, region, requestDate);
  const hashedPayload = "UNSIGNED-PAYLOAD";
  const requestQuery = [];
  requestQuery.push(`X-Amz-Algorithm=${signV4Algorithm}`);
  requestQuery.push(`X-Amz-Credential=${uriEscape(credential)}`);
  requestQuery.push(`X-Amz-Date=${iso8601Date}`);
  requestQuery.push(`X-Amz-Expires=${expires}`);
  requestQuery.push(`X-Amz-SignedHeaders=${uriEscape(signedHeaders.join(";").toLowerCase())}`);
  if (sessionToken) {
    requestQuery.push(`X-Amz-Security-Token=${uriEscape(sessionToken)}`);
  }
  const resource = request25.path.split("?")[0];
  let query = request25.path.split("?")[1];
  if (query) {
    query = query + "&" + requestQuery.join("&");
  } else {
    query = requestQuery.join("&");
  }
  const path = resource + "?" + query;
  const canonicalRequest = getCanonicalRequest(request25.method, path, request25.headers, signedHeaders, hashedPayload);
  const stringToSign = getStringToSign(canonicalRequest, requestDate, region);
  const signingKey = getSigningKey(requestDate, region, secretKey);
  const signature = crypto6.createHmac("sha256", signingKey).update(stringToSign).digest("hex").toLowerCase();
  return request25.protocol + "//" + request25.headers.host + path + `&X-Amz-Signature=${signature}`;
}
var signV4Algorithm = "AWS4-HMAC-SHA256";

// node_modules/minio/dist/esm/internal/copy-conditions.mjs
class CopyConditions {
  modified = "";
  unmodified = "";
  matchETag = "";
  matchETagExcept = "";
  setModified(date5) {
    if (!(date5 instanceof Date)) {
      throw new TypeError("date must be of type Date");
    }
    this.modified = date5.toUTCString();
  }
  setUnmodified(date5) {
    if (!(date5 instanceof Date)) {
      throw new TypeError("date must be of type Date");
    }
    this.unmodified = date5.toUTCString();
  }
  setMatchETag(etag) {
    this.matchETag = etag;
  }
  setMatchETagExcept(etag) {
    this.matchETagExcept = etag;
  }
}

// node_modules/minio/dist/esm/internal/extensions.mjs
import * as stream3 from "stream";

// node_modules/minio/dist/esm/internal/response.mjs
async function readAsBuffer(res) {
  return new Promise((resolve, reject2) => {
    const body = [];
    res.on("data", (chunk) => body.push(chunk)).on("error", (e) => reject2(e)).on("end", () => resolve(Buffer.concat(body)));
  });
}
async function readAsString(res) {
  const body = await readAsBuffer(res);
  return body.toString();
}
async function drainResponse(res) {
  return new Promise((resolve, reject2) => {
    res.on("data", () => {
    }).on("error", (e) => reject2(e)).on("end", () => resolve());
  });
}

// node_modules/buffer-crc32/dist/index.mjs
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
function ensureBuffer(input) {
  if (Buffer.isBuffer(input)) {
    return input;
  }
  if (typeof input === "number") {
    return Buffer.alloc(input);
  } else if (typeof input === "string") {
    return Buffer.from(input);
  } else {
    throw new Error("input must be buffer, number, or string, received " + typeof input);
  }
}
function bufferizeInt(num) {
  const tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}
function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  let crc = ~~previous ^ -1;
  for (var n3 = 0;n3 < buf.length; n3++) {
    crc = CRC_TABLE[(crc ^ buf[n3]) & 255] ^ crc >>> 8;
  }
  return crc ^ -1;
}
function crc32() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
var CRC_TABLE = new Int32Array([
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918000,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
]);
crc32.signed = function() {
  return _crc32.apply(null, arguments);
};
crc32.unsigned = function() {
  return _crc32.apply(null, arguments) >>> 0;
};
var bufferCrc32 = crc32;
var index = /* @__PURE__ */ getDefaultExportFromCjs(bufferCrc32);

// node_modules/minio/dist/esm/internal/xml-parser.mjs
var import_fast_xml_parser2 = __toESM(require_fxp(), 1);
function parseBucketRegion(xml) {
  return parseXml(xml).LocationConstraint;
}
function parseError(xml, headerInfo) {
  let xmlErr = {};
  const xmlObj = fxp2.parse(xml);
  if (xmlObj.Error) {
    xmlErr = xmlObj.Error;
  }
  const e = new S3Error;
  Object.entries(xmlErr).forEach(([key, value15]) => {
    e[key.toLowerCase()] = value15;
  });
  Object.entries(headerInfo).forEach(([key, value15]) => {
    e[key] = value15;
  });
  return e;
}
async function parseResponseError(response2) {
  const statusCode = response2.statusCode;
  let code, message;
  if (statusCode === 301) {
    code = "MovedPermanently";
    message = "Moved Permanently";
  } else if (statusCode === 307) {
    code = "TemporaryRedirect";
    message = "Are you using the correct endpoint URL?";
  } else if (statusCode === 403) {
    code = "AccessDenied";
    message = "Valid and authorized credentials required";
  } else if (statusCode === 404) {
    code = "NotFound";
    message = "Not Found";
  } else if (statusCode === 405) {
    code = "MethodNotAllowed";
    message = "Method Not Allowed";
  } else if (statusCode === 501) {
    code = "MethodNotAllowed";
    message = "Method Not Allowed";
  } else {
    code = "UnknownError";
    message = `${statusCode}`;
  }
  const headerInfo = {};
  headerInfo.amzRequestid = response2.headers["x-amz-request-id"];
  headerInfo.amzId2 = response2.headers["x-amz-id-2"];
  headerInfo.amzBucketRegion = response2.headers["x-amz-bucket-region"];
  const xmlString = await readAsString(response2);
  if (xmlString) {
    throw parseError(xmlString, headerInfo);
  }
  const e = new S3Error(message, {
    cause: headerInfo
  });
  e.code = code;
  Object.entries(headerInfo).forEach(([key, value15]) => {
    e[key] = value15;
  });
  throw e;
}
function parseListObjectsV2WithMetadata(xml) {
  const result = {
    objects: [],
    isTruncated: false,
    nextContinuationToken: ""
  };
  let xmlobj = parseXml(xml);
  if (!xmlobj.ListBucketResult) {
    throw new InvalidXMLError('Missing tag: "ListBucketResult"');
  }
  xmlobj = xmlobj.ListBucketResult;
  if (xmlobj.IsTruncated) {
    result.isTruncated = xmlobj.IsTruncated;
  }
  if (xmlobj.NextContinuationToken) {
    result.nextContinuationToken = xmlobj.NextContinuationToken;
  }
  if (xmlobj.Contents) {
    toArray(xmlobj.Contents).forEach((content) => {
      const name = sanitizeObjectKey(content.Key);
      const lastModified = new Date(content.LastModified);
      const etag = sanitizeETag(content.ETag);
      const size = content.Size;
      let tags = {};
      if (content.UserTags != null) {
        toArray(content.UserTags.split("&")).forEach((tag) => {
          const [key, value15] = tag.split("=");
          tags[key] = value15;
        });
      } else {
        tags = {};
      }
      let metadata;
      if (content.UserMetadata != null) {
        metadata = toArray(content.UserMetadata)[0];
      } else {
        metadata = null;
      }
      result.objects.push({
        name,
        lastModified,
        etag,
        size,
        metadata,
        tags
      });
    });
  }
  if (xmlobj.CommonPrefixes) {
    toArray(xmlobj.CommonPrefixes).forEach((commonPrefix) => {
      result.objects.push({
        prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0]),
        size: 0
      });
    });
  }
  return result;
}
function parseListParts(xml) {
  let xmlobj = parseXml(xml);
  const result = {
    isTruncated: false,
    parts: [],
    marker: 0
  };
  if (!xmlobj.ListPartsResult) {
    throw new InvalidXMLError('Missing tag: "ListPartsResult"');
  }
  xmlobj = xmlobj.ListPartsResult;
  if (xmlobj.IsTruncated) {
    result.isTruncated = xmlobj.IsTruncated;
  }
  if (xmlobj.NextPartNumberMarker) {
    result.marker = toArray(xmlobj.NextPartNumberMarker)[0] || "";
  }
  if (xmlobj.Part) {
    toArray(xmlobj.Part).forEach((p) => {
      const part = parseInt(toArray(p.PartNumber)[0], 10);
      const lastModified = new Date(p.LastModified);
      const etag = p.ETag.replace(/^"/g, "").replace(/"$/g, "").replace(/^&quot;/g, "").replace(/&quot;$/g, "").replace(/^&#34;/g, "").replace(/&#34;$/g, "");
      result.parts.push({
        part,
        lastModified,
        etag,
        size: parseInt(p.Size, 10)
      });
    });
  }
  return result;
}
function parseListBucket(xml) {
  let result = [];
  const listBucketResultParser = new import_fast_xml_parser2.XMLParser({
    parseTagValue: true,
    numberParseOptions: {
      leadingZeros: false,
      hex: false,
      skipLike: /^[0-9]+$/
    },
    tagValueProcessor: (tagName, tagValue = "") => {
      if (tagName === "Name") {
        return tagValue.toString();
      }
      return tagValue;
    },
    ignoreAttributes: false
  });
  const parsedXmlRes = listBucketResultParser.parse(xml);
  if (!parsedXmlRes.ListAllMyBucketsResult) {
    throw new InvalidXMLError('Missing tag: "ListAllMyBucketsResult"');
  }
  const {
    ListAllMyBucketsResult: {
      Buckets = {}
    } = {}
  } = parsedXmlRes;
  if (Buckets.Bucket) {
    result = toArray(Buckets.Bucket).map((bucket = {}) => {
      const {
        Name: bucketName,
        CreationDate
      } = bucket;
      const creationDate = new Date(CreationDate);
      return {
        name: bucketName,
        creationDate
      };
    });
  }
  return result;
}
function parseInitiateMultipart(xml) {
  let xmlobj = parseXml(xml);
  if (!xmlobj.InitiateMultipartUploadResult) {
    throw new InvalidXMLError('Missing tag: "InitiateMultipartUploadResult"');
  }
  xmlobj = xmlobj.InitiateMultipartUploadResult;
  if (xmlobj.UploadId) {
    return xmlobj.UploadId;
  }
  throw new InvalidXMLError('Missing tag: "UploadId"');
}
function parseReplicationConfig(xml) {
  const xmlObj = parseXml(xml);
  const {
    Role,
    Rule
  } = xmlObj.ReplicationConfiguration;
  return {
    ReplicationConfiguration: {
      role: Role,
      rules: toArray(Rule)
    }
  };
}
function parseObjectLegalHoldConfig(xml) {
  const xmlObj = parseXml(xml);
  return xmlObj.LegalHold;
}
function parseTagging(xml) {
  const xmlObj = parseXml(xml);
  let result = [];
  if (xmlObj.Tagging && xmlObj.Tagging.TagSet && xmlObj.Tagging.TagSet.Tag) {
    const tagResult = xmlObj.Tagging.TagSet.Tag;
    if (isObject(tagResult)) {
      result.push(tagResult);
    } else {
      result = tagResult;
    }
  }
  return result;
}
function parseCompleteMultipart(xml) {
  const xmlobj = parseXml(xml).CompleteMultipartUploadResult;
  if (xmlobj.Location) {
    const location = toArray(xmlobj.Location)[0];
    const bucket = toArray(xmlobj.Bucket)[0];
    const key = xmlobj.Key;
    const etag = xmlobj.ETag.replace(/^"/g, "").replace(/"$/g, "").replace(/^&quot;/g, "").replace(/&quot;$/g, "").replace(/^&#34;/g, "").replace(/&#34;$/g, "");
    return {
      location,
      bucket,
      key,
      etag
    };
  }
  if (xmlobj.Code && xmlobj.Message) {
    const errCode = toArray(xmlobj.Code)[0];
    const errMessage = toArray(xmlobj.Message)[0];
    return {
      errCode,
      errMessage
    };
  }
}
function parseListMultipart(xml) {
  const result = {
    prefixes: [],
    uploads: [],
    isTruncated: false,
    nextKeyMarker: "",
    nextUploadIdMarker: ""
  };
  let xmlobj = parseXml(xml);
  if (!xmlobj.ListMultipartUploadsResult) {
    throw new InvalidXMLError('Missing tag: "ListMultipartUploadsResult"');
  }
  xmlobj = xmlobj.ListMultipartUploadsResult;
  if (xmlobj.IsTruncated) {
    result.isTruncated = xmlobj.IsTruncated;
  }
  if (xmlobj.NextKeyMarker) {
    result.nextKeyMarker = xmlobj.NextKeyMarker;
  }
  if (xmlobj.NextUploadIdMarker) {
    result.nextUploadIdMarker = xmlobj.nextUploadIdMarker || "";
  }
  if (xmlobj.CommonPrefixes) {
    toArray(xmlobj.CommonPrefixes).forEach((prefix) => {
      result.prefixes.push({
        prefix: sanitizeObjectKey(toArray(prefix.Prefix)[0])
      });
    });
  }
  if (xmlobj.Upload) {
    toArray(xmlobj.Upload).forEach((upload) => {
      const uploadItem = {
        key: upload.Key,
        uploadId: upload.UploadId,
        storageClass: upload.StorageClass,
        initiated: new Date(upload.Initiated)
      };
      if (upload.Initiator) {
        uploadItem.initiator = {
          id: upload.Initiator.ID,
          displayName: upload.Initiator.DisplayName
        };
      }
      if (upload.Owner) {
        uploadItem.owner = {
          id: upload.Owner.ID,
          displayName: upload.Owner.DisplayName
        };
      }
      result.uploads.push(uploadItem);
    });
  }
  return result;
}
function parseObjectLockConfig(xml) {
  const xmlObj = parseXml(xml);
  let lockConfigResult = {};
  if (xmlObj.ObjectLockConfiguration) {
    lockConfigResult = {
      objectLockEnabled: xmlObj.ObjectLockConfiguration.ObjectLockEnabled
    };
    let retentionResp;
    if (xmlObj.ObjectLockConfiguration && xmlObj.ObjectLockConfiguration.Rule && xmlObj.ObjectLockConfiguration.Rule.DefaultRetention) {
      retentionResp = xmlObj.ObjectLockConfiguration.Rule.DefaultRetention || {};
      lockConfigResult.mode = retentionResp.Mode;
    }
    if (retentionResp) {
      const isUnitYears = retentionResp.Years;
      if (isUnitYears) {
        lockConfigResult.validity = isUnitYears;
        lockConfigResult.unit = RETENTION_VALIDITY_UNITS.YEARS;
      } else {
        lockConfigResult.validity = retentionResp.Days;
        lockConfigResult.unit = RETENTION_VALIDITY_UNITS.DAYS;
      }
    }
  }
  return lockConfigResult;
}
function parseBucketVersioningConfig(xml) {
  const xmlObj = parseXml(xml);
  return xmlObj.VersioningConfiguration;
}
function extractHeaderType(stream3) {
  const headerNameLen = Buffer.from(stream3.read(1)).readUInt8();
  const headerNameWithSeparator = Buffer.from(stream3.read(headerNameLen)).toString();
  const splitBySeparator = (headerNameWithSeparator || "").split(":");
  return splitBySeparator.length >= 1 ? splitBySeparator[1] : "";
}
function extractHeaderValue(stream3) {
  const bodyLen = Buffer.from(stream3.read(2)).readUInt16BE();
  return Buffer.from(stream3.read(bodyLen)).toString();
}
function parseSelectObjectContentResponse(res) {
  const selectResults = new SelectResults({});
  const responseStream = readableStream(res);
  while (responseStream._readableState.length) {
    let msgCrcAccumulator;
    const totalByteLengthBuffer = Buffer.from(responseStream.read(4));
    msgCrcAccumulator = index(totalByteLengthBuffer);
    const headerBytesBuffer = Buffer.from(responseStream.read(4));
    msgCrcAccumulator = index(headerBytesBuffer, msgCrcAccumulator);
    const calculatedPreludeCrc = msgCrcAccumulator.readInt32BE();
    const preludeCrcBuffer = Buffer.from(responseStream.read(4));
    msgCrcAccumulator = index(preludeCrcBuffer, msgCrcAccumulator);
    const totalMsgLength = totalByteLengthBuffer.readInt32BE();
    const headerLength = headerBytesBuffer.readInt32BE();
    const preludeCrcByteValue = preludeCrcBuffer.readInt32BE();
    if (preludeCrcByteValue !== calculatedPreludeCrc) {
      throw new Error(`Header Checksum Mismatch, Prelude CRC of ${preludeCrcByteValue} does not equal expected CRC of ${calculatedPreludeCrc}`);
    }
    const headers = {};
    if (headerLength > 0) {
      const headerBytes = Buffer.from(responseStream.read(headerLength));
      msgCrcAccumulator = index(headerBytes, msgCrcAccumulator);
      const headerReaderStream = readableStream(headerBytes);
      while (headerReaderStream._readableState.length) {
        const headerTypeName = extractHeaderType(headerReaderStream);
        headerReaderStream.read(1);
        if (headerTypeName) {
          headers[headerTypeName] = extractHeaderValue(headerReaderStream);
        }
      }
    }
    let payloadStream;
    const payLoadLength = totalMsgLength - headerLength - 16;
    if (payLoadLength > 0) {
      const payLoadBuffer = Buffer.from(responseStream.read(payLoadLength));
      msgCrcAccumulator = index(payLoadBuffer, msgCrcAccumulator);
      const messageCrcByteValue = Buffer.from(responseStream.read(4)).readInt32BE();
      const calculatedCrc = msgCrcAccumulator.readInt32BE();
      if (messageCrcByteValue !== calculatedCrc) {
        throw new Error(`Message Checksum Mismatch, Message CRC of ${messageCrcByteValue} does not equal expected CRC of ${calculatedCrc}`);
      }
      payloadStream = readableStream(payLoadBuffer);
    }
    const messageType = headers["message-type"];
    switch (messageType) {
      case "error": {
        const errorMessage = headers["error-code"] + ':"' + headers["error-message"] + '"';
        throw new Error(errorMessage);
      }
      case "event": {
        const contentType = headers["content-type"];
        const eventType = headers["event-type"];
        switch (eventType) {
          case "End": {
            selectResults.setResponse(res);
            return selectResults;
          }
          case "Records": {
            var _payloadStream;
            const readData = (_payloadStream = payloadStream) === null || _payloadStream === undefined ? undefined : _payloadStream.read(payLoadLength);
            selectResults.setRecords(readData);
            break;
          }
          case "Progress":
            {
              switch (contentType) {
                case "text/xml": {
                  var _payloadStream2;
                  const progressData = (_payloadStream2 = payloadStream) === null || _payloadStream2 === undefined ? undefined : _payloadStream2.read(payLoadLength);
                  selectResults.setProgress(progressData.toString());
                  break;
                }
                default: {
                  const errorMessage = `Unexpected content-type ${contentType} sent for event-type Progress`;
                  throw new Error(errorMessage);
                }
              }
            }
            break;
          case "Stats":
            {
              switch (contentType) {
                case "text/xml": {
                  var _payloadStream3;
                  const statsData = (_payloadStream3 = payloadStream) === null || _payloadStream3 === undefined ? undefined : _payloadStream3.read(payLoadLength);
                  selectResults.setStats(statsData.toString());
                  break;
                }
                default: {
                  const errorMessage = `Unexpected content-type ${contentType} sent for event-type Stats`;
                  throw new Error(errorMessage);
                }
              }
            }
            break;
          default: {
            const warningMessage = `Un implemented event detected  ${messageType}.`;
            console.warn(warningMessage);
          }
        }
      }
    }
  }
}
function parseLifecycleConfig(xml) {
  const xmlObj = parseXml(xml);
  return xmlObj.LifecycleConfiguration;
}
function parseBucketEncryptionConfig(xml) {
  return parseXml(xml);
}
function parseObjectRetentionConfig(xml) {
  const xmlObj = parseXml(xml);
  const retentionConfig = xmlObj.Retention;
  return {
    mode: retentionConfig.Mode,
    retainUntilDate: retentionConfig.RetainUntilDate
  };
}
function removeObjectsParser(xml) {
  const xmlObj = parseXml(xml);
  if (xmlObj.DeleteResult && xmlObj.DeleteResult.Error) {
    return toArray(xmlObj.DeleteResult.Error);
  }
  return [];
}
function parseCopyObject(xml) {
  const result = {
    etag: "",
    lastModified: ""
  };
  let xmlobj = parseXml(xml);
  if (!xmlobj.CopyObjectResult) {
    throw new InvalidXMLError('Missing tag: "CopyObjectResult"');
  }
  xmlobj = xmlobj.CopyObjectResult;
  if (xmlobj.ETag) {
    result.etag = xmlobj.ETag.replace(/^"/g, "").replace(/"$/g, "").replace(/^&quot;/g, "").replace(/&quot;$/g, "").replace(/^&#34;/g, "").replace(/&#34;$/g, "");
  }
  if (xmlobj.LastModified) {
    result.lastModified = new Date(xmlobj.LastModified);
  }
  return result;
}
function parseListObjects(xml) {
  const result = {
    objects: [],
    isTruncated: false,
    nextMarker: undefined,
    versionIdMarker: undefined
  };
  let isTruncated = false;
  let nextMarker, nextVersionKeyMarker;
  const xmlobj = fxpWithoutNumParser.parse(xml);
  const parseCommonPrefixesEntity = (commonPrefixEntry) => {
    if (commonPrefixEntry) {
      toArray(commonPrefixEntry).forEach((commonPrefix) => {
        result.objects.push({
          prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0] || ""),
          size: 0
        });
      });
    }
  };
  const listBucketResult = xmlobj.ListBucketResult;
  const listVersionsResult = xmlobj.ListVersionsResult;
  if (listBucketResult) {
    if (listBucketResult.IsTruncated) {
      isTruncated = listBucketResult.IsTruncated;
    }
    if (listBucketResult.Contents) {
      toArray(listBucketResult.Contents).forEach((content) => {
        const name = sanitizeObjectKey(toArray(content.Key)[0] || "");
        const lastModified = new Date(toArray(content.LastModified)[0] || "");
        const etag = sanitizeETag(toArray(content.ETag)[0] || "");
        const size = sanitizeSize(content.Size || "");
        result.objects.push({
          name,
          lastModified,
          etag,
          size
        });
      });
    }
    if (listBucketResult.Marker) {
      nextMarker = listBucketResult.Marker;
    } else if (isTruncated && result.objects.length > 0) {
      var _result$objects;
      nextMarker = (_result$objects = result.objects[result.objects.length - 1]) === null || _result$objects === undefined ? undefined : _result$objects.name;
    }
    if (listBucketResult.CommonPrefixes) {
      parseCommonPrefixesEntity(listBucketResult.CommonPrefixes);
    }
  }
  if (listVersionsResult) {
    if (listVersionsResult.IsTruncated) {
      isTruncated = listVersionsResult.IsTruncated;
    }
    if (listVersionsResult.Version) {
      toArray(listVersionsResult.Version).forEach((content) => {
        result.objects.push(formatObjInfo(content));
      });
    }
    if (listVersionsResult.DeleteMarker) {
      toArray(listVersionsResult.DeleteMarker).forEach((content) => {
        result.objects.push(formatObjInfo(content, {
          IsDeleteMarker: true
        }));
      });
    }
    if (listVersionsResult.NextKeyMarker) {
      nextVersionKeyMarker = listVersionsResult.NextKeyMarker;
    }
    if (listVersionsResult.NextVersionIdMarker) {
      result.versionIdMarker = listVersionsResult.NextVersionIdMarker;
    }
    if (listVersionsResult.CommonPrefixes) {
      parseCommonPrefixesEntity(listVersionsResult.CommonPrefixes);
    }
  }
  result.isTruncated = isTruncated;
  if (isTruncated) {
    result.nextMarker = nextVersionKeyMarker || nextMarker;
  }
  return result;
}
function uploadPartParser(xml) {
  const xmlObj = parseXml(xml);
  const respEl = xmlObj.CopyPartResult;
  return respEl;
}
var fxp2 = new import_fast_xml_parser2.XMLParser;
var fxpWithoutNumParser = new import_fast_xml_parser2.XMLParser({
  numberParseOptions: {
    skipLike: /./
  }
});
var formatObjInfo = (content, opts = {}) => {
  const {
    Key,
    LastModified,
    ETag,
    Size: Size2,
    VersionId,
    IsLatest
  } = content;
  if (!isObject(opts)) {
    opts = {};
  }
  const name = sanitizeObjectKey(toArray(Key)[0] || "");
  const lastModified = LastModified ? new Date(toArray(LastModified)[0] || "") : undefined;
  const etag = sanitizeETag(toArray(ETag)[0] || "");
  const size = sanitizeSize(Size2 || "");
  return {
    name,
    lastModified,
    etag,
    size,
    versionId: VersionId,
    isLatest: IsLatest,
    isDeleteMarker: opts.IsDeleteMarker ? opts.IsDeleteMarker : false
  };
};

// node_modules/minio/dist/esm/internal/extensions.mjs
class Extensions2 {
  constructor(client33) {
    this.client = client33;
  }
  listObjectsV2WithMetadata(bucketName, prefix, recursive4, startAfter) {
    if (prefix === undefined) {
      prefix = "";
    }
    if (recursive4 === undefined) {
      recursive4 = false;
    }
    if (startAfter === undefined) {
      startAfter = "";
    }
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidPrefix(prefix)) {
      throw new InvalidPrefixError(`Invalid prefix : ${prefix}`);
    }
    if (!isString(prefix)) {
      throw new TypeError('prefix should be of type "string"');
    }
    if (!isBoolean(recursive4)) {
      throw new TypeError('recursive should be of type "boolean"');
    }
    if (!isString(startAfter)) {
      throw new TypeError('startAfter should be of type "string"');
    }
    const delimiter = recursive4 ? "" : "/";
    return stream3.Readable.from(this.listObjectsV2WithMetadataGen(bucketName, prefix, delimiter, startAfter), {
      objectMode: true
    });
  }
  async* listObjectsV2WithMetadataGen(bucketName, prefix, delimiter, startAfter) {
    let ended = false;
    let continuationToken = "";
    do {
      const result = await this.listObjectsV2WithMetadataQuery(bucketName, prefix, continuationToken, delimiter, startAfter);
      ended = !result.isTruncated;
      continuationToken = result.nextContinuationToken;
      for (const obj of result.objects) {
        yield obj;
      }
    } while (!ended);
  }
  async listObjectsV2WithMetadataQuery(bucketName, prefix, continuationToken, delimiter, startAfter) {
    const queries = [];
    queries.push(`list-type=2`);
    queries.push(`encoding-type=url`);
    queries.push(`prefix=${uriEscape(prefix)}`);
    queries.push(`delimiter=${uriEscape(delimiter)}`);
    queries.push(`metadata=true`);
    if (continuationToken) {
      continuationToken = uriEscape(continuationToken);
      queries.push(`continuation-token=${continuationToken}`);
    }
    if (startAfter) {
      startAfter = uriEscape(startAfter);
      queries.push(`start-after=${startAfter}`);
    }
    queries.push(`max-keys=1000`);
    queries.sort();
    let query = "";
    if (queries.length > 0) {
      query = `${queries.join("&")}`;
    }
    const method = "GET";
    const res = await this.client.makeRequestAsync({
      method,
      bucketName,
      query
    });
    return parseListObjectsV2WithMetadata(await readAsString(res));
  }
}

// node_modules/minio/dist/esm/internal/join-host-port.mjs
function joinHostPort(host, port) {
  if (port === undefined) {
    return host;
  }
  if (host.includes(":")) {
    return `[${host}]:${port.toString()}`;
  }
  return `${host}:${port.toString()}`;
}

// node_modules/minio/dist/esm/internal/post-policy.mjs
class PostPolicy {
  policy = {
    conditions: []
  };
  formData = {};
  setExpires(date5) {
    if (!date5) {
      throw new InvalidDateError("Invalid date: cannot be null");
    }
    this.policy.expiration = date5.toISOString();
  }
  setKey(objectName) {
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name : ${objectName}`);
    }
    this.policy.conditions.push(["eq", "$key", objectName]);
    this.formData.key = objectName;
  }
  setKeyStartsWith(prefix) {
    if (!isValidPrefix(prefix)) {
      throw new InvalidPrefixError(`Invalid prefix : ${prefix}`);
    }
    this.policy.conditions.push(["starts-with", "$key", prefix]);
    this.formData.key = prefix;
  }
  setBucket(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name : ${bucketName}`);
    }
    this.policy.conditions.push(["eq", "$bucket", bucketName]);
    this.formData.bucket = bucketName;
  }
  setContentType(type50) {
    if (!type50) {
      throw new Error("content-type cannot be null");
    }
    this.policy.conditions.push(["eq", "$Content-Type", type50]);
    this.formData["Content-Type"] = type50;
  }
  setContentTypeStartsWith(prefix) {
    if (!prefix) {
      throw new Error("content-type cannot be null");
    }
    this.policy.conditions.push(["starts-with", "$Content-Type", prefix]);
    this.formData["Content-Type"] = prefix;
  }
  setContentDisposition(value15) {
    if (!value15) {
      throw new Error("content-disposition cannot be null");
    }
    this.policy.conditions.push(["eq", "$Content-Disposition", value15]);
    this.formData["Content-Disposition"] = value15;
  }
  setContentLengthRange(min, max) {
    if (min > max) {
      throw new Error("min cannot be more than max");
    }
    if (min < 0) {
      throw new Error("min should be > 0");
    }
    if (max < 0) {
      throw new Error("max should be > 0");
    }
    this.policy.conditions.push(["content-length-range", min, max]);
  }
  setUserMetaData(metaData) {
    if (!isObject(metaData)) {
      throw new TypeError('metadata should be of type "object"');
    }
    Object.entries(metaData).forEach(([key, value15]) => {
      const amzMetaDataKey = `x-amz-meta-${key}`;
      this.policy.conditions.push(["eq", `\$${amzMetaDataKey}`, value15]);
      this.formData[amzMetaDataKey] = value15.toString();
    });
  }
}

// node_modules/minio/dist/esm/internal/request.mjs
import {pipeline as pipeline2} from "stream";
async function request25(transport, opt, body = null) {
  return new Promise((resolve, reject2) => {
    const requestObj = transport.request(opt, (resp) => {
      resolve(resp);
    });
    if (!body || Buffer.isBuffer(body) || typeof body === "string") {
      requestObj.on("error", (e) => {
        reject2(e);
      }).end(body);
      return;
    }
    pipeline2(body, requestObj, (err) => {
      if (err) {
        reject2(err);
      }
    });
  });
}

// node_modules/minio/dist/esm/internal/s3-endpoints.mjs
function getS3Endpoint(region) {
  if (!isString(region)) {
    throw new TypeError(`Invalid region: ${region}`);
  }
  const endpoint = awsS3Endpoint[region];
  if (endpoint) {
    return endpoint;
  }
  return "s3.amazonaws.com";
}
var awsS3Endpoint = {
  "af-south-1": "s3.af-south-1.amazonaws.com",
  "ap-east-1": "s3.ap-east-1.amazonaws.com",
  "ap-south-1": "s3.ap-south-1.amazonaws.com",
  "ap-south-2": "s3.ap-south-2.amazonaws.com",
  "ap-southeast-1": "s3.ap-southeast-1.amazonaws.com",
  "ap-southeast-2": "s3.ap-southeast-2.amazonaws.com",
  "ap-southeast-3": "s3.ap-southeast-3.amazonaws.com",
  "ap-southeast-4": "s3.ap-southeast-4.amazonaws.com",
  "ap-southeast-5": "s3.ap-southeast-5.amazonaws.com",
  "ap-northeast-1": "s3.ap-northeast-1.amazonaws.com",
  "ap-northeast-2": "s3.ap-northeast-2.amazonaws.com",
  "ap-northeast-3": "s3.ap-northeast-3.amazonaws.com",
  "ca-central-1": "s3.ca-central-1.amazonaws.com",
  "ca-west-1": "s3.ca-west-1.amazonaws.com",
  "cn-north-1": "s3.cn-north-1.amazonaws.com.cn",
  "eu-central-1": "s3.eu-central-1.amazonaws.com",
  "eu-central-2": "s3.eu-central-2.amazonaws.com",
  "eu-north-1": "s3.eu-north-1.amazonaws.com",
  "eu-south-1": "s3.eu-south-1.amazonaws.com",
  "eu-south-2": "s3.eu-south-2.amazonaws.com",
  "eu-west-1": "s3.eu-west-1.amazonaws.com",
  "eu-west-2": "s3.eu-west-2.amazonaws.com",
  "eu-west-3": "s3.eu-west-3.amazonaws.com",
  "il-central-1": "s3.il-central-1.amazonaws.com",
  "me-central-1": "s3.me-central-1.amazonaws.com",
  "me-south-1": "s3.me-south-1.amazonaws.com",
  "sa-east-1": "s3.sa-east-1.amazonaws.com",
  "us-east-1": "s3.us-east-1.amazonaws.com",
  "us-east-2": "s3.us-east-2.amazonaws.com",
  "us-west-1": "s3.us-west-1.amazonaws.com",
  "us-west-2": "s3.us-west-2.amazonaws.com",
  "us-gov-east-1": "s3.us-gov-east-1.amazonaws.com",
  "us-gov-west-1": "s3.us-gov-west-1.amazonaws.com"
};

// node_modules/minio/dist/esm/internal/client.mjs
var xml = new import_xml2js.default.Builder({
  renderOpts: {
    pretty: false
  },
  headless: true
});
var Package = {
  version: "8.0.4"
};
var requestOptionProperties = ["agent", "ca", "cert", "ciphers", "clientCertEngine", "crl", "dhparam", "ecdhCurve", "family", "honorCipherOrder", "key", "passphrase", "pfx", "rejectUnauthorized", "secureOptions", "secureProtocol", "servername", "sessionIdContext"];

class TypedClient {
  partSize = 64 * 1024 * 1024;
  maximumPartSize = 5 * 1024 * 1024 * 1024;
  maxObjectSize = 5 * 1024 * 1024 * 1024 * 1024;
  constructor(params) {
    if (params.secure !== undefined) {
      throw new Error('"secure" option deprecated, "useSSL" should be used instead');
    }
    if (params.useSSL === undefined) {
      params.useSSL = true;
    }
    if (!params.port) {
      params.port = 0;
    }
    if (!isValidEndpoint(params.endPoint)) {
      throw new InvalidEndpointError(`Invalid endPoint : ${params.endPoint}`);
    }
    if (!isValidPort(params.port)) {
      throw new InvalidArgumentError(`Invalid port : ${params.port}`);
    }
    if (!isBoolean(params.useSSL)) {
      throw new InvalidArgumentError(`Invalid useSSL flag type : ${params.useSSL}, expected to be of type "boolean"`);
    }
    if (params.region) {
      if (!isString(params.region)) {
        throw new InvalidArgumentError(`Invalid region : ${params.region}`);
      }
    }
    const host = params.endPoint.toLowerCase();
    let port = params.port;
    let protocol;
    let transport;
    let transportAgent;
    if (params.useSSL) {
      transport = https;
      protocol = "https:";
      port = port || 443;
      transportAgent = https.globalAgent;
    } else {
      transport = http;
      protocol = "http:";
      port = port || 80;
      transportAgent = http.globalAgent;
    }
    if (params.transport) {
      if (!isObject(params.transport)) {
        throw new InvalidArgumentError(`Invalid transport type : ${params.transport}, expected to be type "object"`);
      }
      transport = params.transport;
    }
    if (params.transportAgent) {
      if (!isObject(params.transportAgent)) {
        throw new InvalidArgumentError(`Invalid transportAgent type: ${params.transportAgent}, expected to be type "object"`);
      }
      transportAgent = params.transportAgent;
    }
    const libraryComments = `(${process.platform}; ${process.arch})`;
    const libraryAgent = `MinIO ${libraryComments} minio-js/${Package.version}`;
    this.transport = transport;
    this.transportAgent = transportAgent;
    this.host = host;
    this.port = port;
    this.protocol = protocol;
    this.userAgent = `${libraryAgent}`;
    if (params.pathStyle === undefined) {
      this.pathStyle = true;
    } else {
      this.pathStyle = params.pathStyle;
    }
    this.accessKey = params.accessKey ?? "";
    this.secretKey = params.secretKey ?? "";
    this.sessionToken = params.sessionToken;
    this.anonymous = !this.accessKey || !this.secretKey;
    if (params.credentialsProvider) {
      this.anonymous = false;
      this.credentialsProvider = params.credentialsProvider;
    }
    this.regionMap = {};
    if (params.region) {
      this.region = params.region;
    }
    if (params.partSize) {
      this.partSize = params.partSize;
      this.overRidePartSize = true;
    }
    if (this.partSize < 5 * 1024 * 1024) {
      throw new InvalidArgumentError(`Part size should be greater than 5MB`);
    }
    if (this.partSize > 5 * 1024 * 1024 * 1024) {
      throw new InvalidArgumentError(`Part size should be less than 5GB`);
    }
    this.enableSHA256 = !this.anonymous && !params.useSSL;
    this.s3AccelerateEndpoint = params.s3AccelerateEndpoint || undefined;
    this.reqOptions = {};
    this.clientExtensions = new Extensions2(this);
  }
  get extensions() {
    return this.clientExtensions;
  }
  setS3TransferAccelerate(endPoint) {
    this.s3AccelerateEndpoint = endPoint;
  }
  setRequestOptions(options) {
    if (!isObject(options)) {
      throw new TypeError('request options should be of type "object"');
    }
    this.reqOptions = import_lodash2.default.pick(options, requestOptionProperties);
  }
  getAccelerateEndPointIfSet(bucketName, objectName) {
    if (!isEmpty(this.s3AccelerateEndpoint) && !isEmpty(bucketName) && !isEmpty(objectName)) {
      if (bucketName.includes(".")) {
        throw new Error(`Transfer Acceleration is not supported for non compliant bucket:${bucketName}`);
      }
      return this.s3AccelerateEndpoint;
    }
    return false;
  }
  setAppInfo(appName, appVersion) {
    if (!isString(appName)) {
      throw new TypeError(`Invalid appName: ${appName}`);
    }
    if (appName.trim() === "") {
      throw new InvalidArgumentError("Input appName cannot be empty.");
    }
    if (!isString(appVersion)) {
      throw new TypeError(`Invalid appVersion: ${appVersion}`);
    }
    if (appVersion.trim() === "") {
      throw new InvalidArgumentError("Input appVersion cannot be empty.");
    }
    this.userAgent = `${this.userAgent} ${appName}/${appVersion}`;
  }
  getRequestOptions(opts) {
    const method = opts.method;
    const region = opts.region;
    const bucketName = opts.bucketName;
    let objectName = opts.objectName;
    const headers = opts.headers;
    const query = opts.query;
    let reqOptions = {
      method,
      headers: {},
      protocol: this.protocol,
      agent: this.transportAgent
    };
    let virtualHostStyle;
    if (bucketName) {
      virtualHostStyle = isVirtualHostStyle(this.host, this.protocol, bucketName, this.pathStyle);
    }
    let path2 = "/";
    let host = this.host;
    let port;
    if (this.port) {
      port = this.port;
    }
    if (objectName) {
      objectName = uriResourceEscape(objectName);
    }
    if (isAmazonEndpoint(host)) {
      const accelerateEndPoint = this.getAccelerateEndPointIfSet(bucketName, objectName);
      if (accelerateEndPoint) {
        host = `${accelerateEndPoint}`;
      } else {
        host = getS3Endpoint(region);
      }
    }
    if (virtualHostStyle && !opts.pathStyle) {
      if (bucketName) {
        host = `${bucketName}.${host}`;
      }
      if (objectName) {
        path2 = `/${objectName}`;
      }
    } else {
      if (bucketName) {
        path2 = `/${bucketName}`;
      }
      if (objectName) {
        path2 = `/${bucketName}/${objectName}`;
      }
    }
    if (query) {
      path2 += `?${query}`;
    }
    reqOptions.headers.host = host;
    if (reqOptions.protocol === "http:" && port !== 80 || reqOptions.protocol === "https:" && port !== 443) {
      reqOptions.headers.host = joinHostPort(host, port);
    }
    reqOptions.headers["user-agent"] = this.userAgent;
    if (headers) {
      for (const [k, v3] of Object.entries(headers)) {
        reqOptions.headers[k.toLowerCase()] = v3;
      }
    }
    reqOptions = Object.assign({}, this.reqOptions, reqOptions);
    return {
      ...reqOptions,
      headers: import_lodash2.default.mapValues(import_lodash2.default.pickBy(reqOptions.headers, isDefined), (v3) => v3.toString()),
      host,
      port,
      path: path2
    };
  }
  async setCredentialsProvider(credentialsProvider) {
    if (!(credentialsProvider instanceof CredentialProvider)) {
      throw new Error("Unable to get credentials. Expected instance of CredentialProvider");
    }
    this.credentialsProvider = credentialsProvider;
    await this.checkAndRefreshCreds();
  }
  async checkAndRefreshCreds() {
    if (this.credentialsProvider) {
      try {
        const credentialsConf = await this.credentialsProvider.getCredentials();
        this.accessKey = credentialsConf.getAccessKey();
        this.secretKey = credentialsConf.getSecretKey();
        this.sessionToken = credentialsConf.getSessionToken();
      } catch (e) {
        throw new Error(`Unable to get credentials: ${e}`, {
          cause: e
        });
      }
    }
  }
  logHTTP(reqOptions, response4, err) {
    if (!this.logStream) {
      return;
    }
    if (!isObject(reqOptions)) {
      throw new TypeError('reqOptions should be of type "object"');
    }
    if (response4 && !isReadableStream(response4)) {
      throw new TypeError('response should be of type "Stream"');
    }
    if (err && !(err instanceof Error)) {
      throw new TypeError('err should be of type "Error"');
    }
    const logStream = this.logStream;
    const logHeaders = (headers) => {
      Object.entries(headers).forEach(([k, v3]) => {
        if (k == "authorization") {
          if (isString(v3)) {
            const redactor = new RegExp("Signature=([0-9a-f]+)");
            v3 = v3.replace(redactor, "Signature=**REDACTED**");
          }
        }
        logStream.write(`${k}: ${v3}\n`);
      });
      logStream.write("\n");
    };
    logStream.write(`REQUEST: ${reqOptions.method} ${reqOptions.path}\n`);
    logHeaders(reqOptions.headers);
    if (response4) {
      this.logStream.write(`RESPONSE: ${response4.statusCode}\n`);
      logHeaders(response4.headers);
    }
    if (err) {
      logStream.write("ERROR BODY:\n");
      const errJSON = JSON.stringify(err, null, "\t");
      logStream.write(`${errJSON}\n`);
    }
  }
  traceOn(stream5) {
    if (!stream5) {
      stream5 = process.stdout;
    }
    this.logStream = stream5;
  }
  traceOff() {
    this.logStream = undefined;
  }
  async makeRequestAsync(options, payload = "", expectedCodes = [200], region = "") {
    if (!isObject(options)) {
      throw new TypeError('options should be of type "object"');
    }
    if (!isString(payload) && !isObject(payload)) {
      throw new TypeError('payload should be of type "string" or "Buffer"');
    }
    expectedCodes.forEach((statusCode) => {
      if (!isNumber(statusCode)) {
        throw new TypeError('statusCode should be of type "number"');
      }
    });
    if (!isString(region)) {
      throw new TypeError('region should be of type "string"');
    }
    if (!options.headers) {
      options.headers = {};
    }
    if (options.method === "POST" || options.method === "PUT" || options.method === "DELETE") {
      options.headers["content-length"] = payload.length.toString();
    }
    const sha256sum = this.enableSHA256 ? toSha256(payload) : "";
    return this.makeRequestStreamAsync(options, payload, sha256sum, expectedCodes, region);
  }
  async makeRequestAsyncOmit(options, payload = "", statusCodes = [200], region = "") {
    const res = await this.makeRequestAsync(options, payload, statusCodes, region);
    await drainResponse(res);
    return res;
  }
  async makeRequestStreamAsync(options, body, sha256sum, statusCodes, region) {
    if (!isObject(options)) {
      throw new TypeError('options should be of type "object"');
    }
    if (!(Buffer.isBuffer(body) || typeof body === "string" || isReadableStream(body))) {
      throw new InvalidArgumentError(`stream should be a Buffer, string or readable Stream, got ${typeof body} instead`);
    }
    if (!isString(sha256sum)) {
      throw new TypeError('sha256sum should be of type "string"');
    }
    statusCodes.forEach((statusCode) => {
      if (!isNumber(statusCode)) {
        throw new TypeError('statusCode should be of type "number"');
      }
    });
    if (!isString(region)) {
      throw new TypeError('region should be of type "string"');
    }
    if (!this.enableSHA256 && sha256sum.length !== 0) {
      throw new InvalidArgumentError(`sha256sum expected to be empty for anonymous or https requests`);
    }
    if (this.enableSHA256 && sha256sum.length !== 64) {
      throw new InvalidArgumentError(`Invalid sha256sum : ${sha256sum}`);
    }
    await this.checkAndRefreshCreds();
    region = region || await this.getBucketRegionAsync(options.bucketName);
    const reqOptions = this.getRequestOptions({
      ...options,
      region
    });
    if (!this.anonymous) {
      if (!this.enableSHA256) {
        sha256sum = "UNSIGNED-PAYLOAD";
      }
      const date5 = new Date;
      reqOptions.headers["x-amz-date"] = makeDateLong(date5);
      reqOptions.headers["x-amz-content-sha256"] = sha256sum;
      if (this.sessionToken) {
        reqOptions.headers["x-amz-security-token"] = this.sessionToken;
      }
      reqOptions.headers.authorization = signV4(reqOptions, this.accessKey, this.secretKey, region, date5, sha256sum);
    }
    const response4 = await request25(this.transport, reqOptions, body);
    if (!response4.statusCode) {
      throw new Error("BUG: response doesn't have a statusCode");
    }
    if (!statusCodes.includes(response4.statusCode)) {
      delete this.regionMap[options.bucketName];
      const err = await parseResponseError(response4);
      this.logHTTP(reqOptions, response4, err);
      throw err;
    }
    this.logHTTP(reqOptions, response4);
    return response4;
  }
  async getBucketRegionAsync(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name : ${bucketName}`);
    }
    if (this.region) {
      return this.region;
    }
    const cached = this.regionMap[bucketName];
    if (cached) {
      return cached;
    }
    const extractRegionAsync = async (response4) => {
      const body = await readAsString(response4);
      const region2 = parseBucketRegion(body) || DEFAULT_REGION;
      this.regionMap[bucketName] = region2;
      return region2;
    };
    const method = "GET";
    const query = "location";
    const pathStyle = this.pathStyle && !import_browser_or_node.isBrowser;
    let region;
    try {
      const res2 = await this.makeRequestAsync({
        method,
        bucketName,
        query,
        pathStyle
      }, "", [200], DEFAULT_REGION);
      return extractRegionAsync(res2);
    } catch (e) {
      if (e instanceof S3Error) {
        const errCode = e.code;
        const errRegion = e.region;
        if (errCode === "AccessDenied" && !errRegion) {
          return DEFAULT_REGION;
        }
      }
      if (!(e.name === "AuthorizationHeaderMalformed")) {
        throw e;
      }
      region = e.Region;
      if (!region) {
        throw e;
      }
    }
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      query,
      pathStyle
    }, "", [200], region);
    return await extractRegionAsync(res);
  }
  makeRequest(options, payload = "", expectedCodes = [200], region = "", returnResponse, cb) {
    let prom;
    if (returnResponse) {
      prom = this.makeRequestAsync(options, payload, expectedCodes, region);
    } else {
      prom = this.makeRequestAsyncOmit(options, payload, expectedCodes, region);
    }
    prom.then((result) => cb(null, result), (err) => {
      cb(err);
    });
  }
  makeRequestStream(options, stream5, sha256sum, statusCodes, region, returnResponse, cb) {
    const executor = async () => {
      const res = await this.makeRequestStreamAsync(options, stream5, sha256sum, statusCodes, region);
      if (!returnResponse) {
        await drainResponse(res);
      }
      return res;
    };
    executor().then((result) => cb(null, result), (err) => cb(err));
  }
  getBucketRegion(bucketName, cb) {
    return this.getBucketRegionAsync(bucketName).then((result) => cb(null, result), (err) => cb(err));
  }
  async makeBucket(bucketName, region = "", makeOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (isObject(region)) {
      makeOpts = region;
      region = "";
    }
    if (!isString(region)) {
      throw new TypeError('region should be of type "string"');
    }
    if (makeOpts && !isObject(makeOpts)) {
      throw new TypeError('makeOpts should be of type "object"');
    }
    let payload = "";
    if (region && this.region) {
      if (region !== this.region) {
        throw new InvalidArgumentError(`Configured region ${this.region}, requested ${region}`);
      }
    }
    if (region && region !== DEFAULT_REGION) {
      payload = xml.buildObject({
        CreateBucketConfiguration: {
          $: {
            xmlns: "http://s3.amazonaws.com/doc/2006-03-01/"
          },
          LocationConstraint: region
        }
      });
    }
    const method = "PUT";
    const headers = {};
    if (makeOpts && makeOpts.ObjectLocking) {
      headers["x-amz-bucket-object-lock-enabled"] = true;
    }
    const finalRegion = this.region || region || DEFAULT_REGION;
    const requestOpt = {
      method,
      bucketName,
      headers
    };
    try {
      await this.makeRequestAsyncOmit(requestOpt, payload, [200], finalRegion);
    } catch (err) {
      if (region === "" || region === DEFAULT_REGION) {
        if (err instanceof S3Error) {
          const errCode = err.code;
          const errRegion = err.region;
          if (errCode === "AuthorizationHeaderMalformed" && errRegion !== "") {
            await this.makeRequestAsyncOmit(requestOpt, payload, [200], errCode);
          }
        }
      }
      throw err;
    }
  }
  async bucketExists(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    const method = "HEAD";
    try {
      await this.makeRequestAsyncOmit({
        method,
        bucketName
      });
    } catch (err) {
      if (err.code === "NoSuchBucket" || err.code === "NotFound") {
        return false;
      }
      throw err;
    }
    return true;
  }
  async removeBucket(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    const method = "DELETE";
    await this.makeRequestAsyncOmit({
      method,
      bucketName
    }, "", [204]);
    delete this.regionMap[bucketName];
  }
  async getObject(bucketName, objectName, getOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    return this.getPartialObject(bucketName, objectName, 0, 0, getOpts);
  }
  async getPartialObject(bucketName, objectName, offset, length = 0, getOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!isNumber(offset)) {
      throw new TypeError('offset should be of type "number"');
    }
    if (!isNumber(length)) {
      throw new TypeError('length should be of type "number"');
    }
    let range = "";
    if (offset || length) {
      if (offset) {
        range = `bytes=${+offset}-`;
      } else {
        range = "bytes=0-";
        offset = 0;
      }
      if (length) {
        range += `${+length + offset - 1}`;
      }
    }
    let query = "";
    let headers = {
      ...range !== "" && {
        range
      }
    };
    if (getOpts) {
      const sseHeaders = {
        ...getOpts.SSECustomerAlgorithm && {
          "X-Amz-Server-Side-Encryption-Customer-Algorithm": getOpts.SSECustomerAlgorithm
        },
        ...getOpts.SSECustomerKey && {
          "X-Amz-Server-Side-Encryption-Customer-Key": getOpts.SSECustomerKey
        },
        ...getOpts.SSECustomerKeyMD5 && {
          "X-Amz-Server-Side-Encryption-Customer-Key-MD5": getOpts.SSECustomerKeyMD5
        }
      };
      query = $stringify(getOpts);
      headers = {
        ...prependXAMZMeta(sseHeaders),
        ...headers
      };
    }
    const expectedStatusCodes = [200];
    if (range) {
      expectedStatusCodes.push(206);
    }
    const method = "GET";
    return await this.makeRequestAsync({
      method,
      bucketName,
      objectName,
      headers,
      query
    }, "", expectedStatusCodes);
  }
  async fGetObject(bucketName, objectName, filePath, getOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!isString(filePath)) {
      throw new TypeError('filePath should be of type "string"');
    }
    const downloadToTmpFile = async () => {
      let partFileStream;
      const objStat = await this.statObject(bucketName, objectName, getOpts);
      const encodedEtag = Buffer.from(objStat.etag).toString("base64");
      const partFile2 = `${filePath}.${encodedEtag}.part.minio`;
      await promises.mkdir(path.dirname(filePath), {
        recursive: true
      });
      let offset = 0;
      try {
        const stats2 = await promises.stat(partFile2);
        if (objStat.size === stats2.size) {
          return partFile2;
        }
        offset = stats2.size;
        partFileStream = fs3.createWriteStream(partFile2, {
          flags: "a"
        });
      } catch (e) {
        if (e instanceof Error && e.code === "ENOENT") {
          partFileStream = fs3.createWriteStream(partFile2, {
            flags: "w"
          });
        } else {
          throw e;
        }
      }
      const downloadStream = await this.getPartialObject(bucketName, objectName, offset, 0, getOpts);
      await streamPromise.pipeline(downloadStream, partFileStream);
      const stats = await promises.stat(partFile2);
      if (stats.size === objStat.size) {
        return partFile2;
      }
      throw new Error("Size mismatch between downloaded file and the object");
    };
    const partFile = await downloadToTmpFile();
    await promises.rename(partFile, filePath);
  }
  async statObject(bucketName, objectName, statOpts) {
    const statOptDef = statOpts || {};
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!isObject(statOptDef)) {
      throw new InvalidArgumentError('statOpts should be of type "object"');
    }
    const query = $stringify(statOptDef);
    const method = "HEAD";
    const res = await this.makeRequestAsyncOmit({
      method,
      bucketName,
      objectName,
      query
    });
    return {
      size: parseInt(res.headers["content-length"]),
      metaData: extractMetadata(res.headers),
      lastModified: new Date(res.headers["last-modified"]),
      versionId: getVersionId(res.headers),
      etag: sanitizeETag(res.headers.etag)
    };
  }
  async removeObject(bucketName, objectName, removeOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (removeOpts && !isObject(removeOpts)) {
      throw new InvalidArgumentError('removeOpts should be of type "object"');
    }
    const method = "DELETE";
    const headers = {};
    if (removeOpts !== null && removeOpts !== undefined && removeOpts.governanceBypass) {
      headers["X-Amz-Bypass-Governance-Retention"] = true;
    }
    if (removeOpts !== null && removeOpts !== undefined && removeOpts.forceDelete) {
      headers["x-minio-force-delete"] = true;
    }
    const queryParams = {};
    if (removeOpts !== null && removeOpts !== undefined && removeOpts.versionId) {
      queryParams.versionId = `${removeOpts.versionId}`;
    }
    const query = $stringify(queryParams);
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      objectName,
      headers,
      query
    }, "", [200, 204]);
  }
  listIncompleteUploads(bucket, prefix, recursive4) {
    if (prefix === undefined) {
      prefix = "";
    }
    if (recursive4 === undefined) {
      recursive4 = false;
    }
    if (!isValidBucketName(bucket)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucket);
    }
    if (!isValidPrefix(prefix)) {
      throw new InvalidPrefixError(`Invalid prefix : ${prefix}`);
    }
    if (!isBoolean(recursive4)) {
      throw new TypeError('recursive should be of type "boolean"');
    }
    const delimiter = recursive4 ? "" : "/";
    let keyMarker = "";
    let uploadIdMarker = "";
    const uploads = [];
    let ended = false;
    const readStream = new stream4.Readable({
      objectMode: true
    });
    readStream._read = () => {
      if (uploads.length) {
        return readStream.push(uploads.shift());
      }
      if (ended) {
        return readStream.push(null);
      }
      this.listIncompleteUploadsQuery(bucket, prefix, keyMarker, uploadIdMarker, delimiter).then((result) => {
        result.prefixes.forEach((prefix2) => uploads.push(prefix2));
        eachSeries$1(result.uploads, (upload, cb) => {
          this.listParts(bucket, upload.key, upload.uploadId).then((parts) => {
            upload.size = parts.reduce((acc, item) => acc + item.size, 0);
            uploads.push(upload);
            cb();
          }, (err) => cb(err));
        }, (err) => {
          if (err) {
            readStream.emit("error", err);
            return;
          }
          if (result.isTruncated) {
            keyMarker = result.nextKeyMarker;
            uploadIdMarker = result.nextUploadIdMarker;
          } else {
            ended = true;
          }
          readStream._read();
        });
      }, (e) => {
        readStream.emit("error", e);
      });
    };
    return readStream;
  }
  async listIncompleteUploadsQuery(bucketName, prefix, keyMarker, uploadIdMarker, delimiter) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isString(prefix)) {
      throw new TypeError('prefix should be of type "string"');
    }
    if (!isString(keyMarker)) {
      throw new TypeError('keyMarker should be of type "string"');
    }
    if (!isString(uploadIdMarker)) {
      throw new TypeError('uploadIdMarker should be of type "string"');
    }
    if (!isString(delimiter)) {
      throw new TypeError('delimiter should be of type "string"');
    }
    const queries = [];
    queries.push(`prefix=${uriEscape(prefix)}`);
    queries.push(`delimiter=${uriEscape(delimiter)}`);
    if (keyMarker) {
      queries.push(`key-marker=${uriEscape(keyMarker)}`);
    }
    if (uploadIdMarker) {
      queries.push(`upload-id-marker=${uploadIdMarker}`);
    }
    const maxUploads = 1000;
    queries.push(`max-uploads=${maxUploads}`);
    queries.sort();
    queries.unshift("uploads");
    let query = "";
    if (queries.length > 0) {
      query = `${queries.join("&")}`;
    }
    const method = "GET";
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      query
    });
    const body = await readAsString(res);
    return parseListMultipart(body);
  }
  async initiateNewMultipartUpload(bucketName, objectName, headers) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!isObject(headers)) {
      throw new InvalidObjectNameError('contentType should be of type "object"');
    }
    const method = "POST";
    const query = "uploads";
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      objectName,
      query,
      headers
    });
    const body = await readAsBuffer(res);
    return parseInitiateMultipart(body.toString());
  }
  async abortMultipartUpload(bucketName, objectName, uploadId) {
    const method = "DELETE";
    const query = `uploadId=${uploadId}`;
    const requestOptions = {
      method,
      bucketName,
      objectName,
      query
    };
    await this.makeRequestAsyncOmit(requestOptions, "", [204]);
  }
  async findUploadId(bucketName, objectName) {
    var _latestUpload;
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    let latestUpload;
    let keyMarker = "";
    let uploadIdMarker = "";
    for (;; ) {
      const result = await this.listIncompleteUploadsQuery(bucketName, objectName, keyMarker, uploadIdMarker, "");
      for (const upload of result.uploads) {
        if (upload.key === objectName) {
          if (!latestUpload || upload.initiated.getTime() > latestUpload.initiated.getTime()) {
            latestUpload = upload;
          }
        }
      }
      if (result.isTruncated) {
        keyMarker = result.nextKeyMarker;
        uploadIdMarker = result.nextUploadIdMarker;
        continue;
      }
      break;
    }
    return (_latestUpload = latestUpload) === null || _latestUpload === undefined ? undefined : _latestUpload.uploadId;
  }
  async completeMultipartUpload(bucketName, objectName, uploadId, etags) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!isString(uploadId)) {
      throw new TypeError('uploadId should be of type "string"');
    }
    if (!isObject(etags)) {
      throw new TypeError('etags should be of type "Array"');
    }
    if (!uploadId) {
      throw new InvalidArgumentError("uploadId cannot be empty");
    }
    const method = "POST";
    const query = `uploadId=${uriEscape(uploadId)}`;
    const builder = new import_xml2js.default.Builder;
    const payload = builder.buildObject({
      CompleteMultipartUpload: {
        $: {
          xmlns: "http://s3.amazonaws.com/doc/2006-03-01/"
        },
        Part: etags.map((etag) => {
          return {
            PartNumber: etag.part,
            ETag: etag.etag
          };
        })
      }
    });
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      objectName,
      query
    }, payload);
    const body = await readAsBuffer(res);
    const result = parseCompleteMultipart(body.toString());
    if (!result) {
      throw new Error("BUG: failed to parse server response");
    }
    if (result.errCode) {
      throw new S3Error(result.errMessage);
    }
    return {
      etag: result.etag,
      versionId: getVersionId(res.headers)
    };
  }
  async listParts(bucketName, objectName, uploadId) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!isString(uploadId)) {
      throw new TypeError('uploadId should be of type "string"');
    }
    if (!uploadId) {
      throw new InvalidArgumentError("uploadId cannot be empty");
    }
    const parts = [];
    let marker = 0;
    let result;
    do {
      result = await this.listPartsQuery(bucketName, objectName, uploadId, marker);
      marker = result.marker;
      parts.push(...result.parts);
    } while (result.isTruncated);
    return parts;
  }
  async listPartsQuery(bucketName, objectName, uploadId, marker) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!isString(uploadId)) {
      throw new TypeError('uploadId should be of type "string"');
    }
    if (!isNumber(marker)) {
      throw new TypeError('marker should be of type "number"');
    }
    if (!uploadId) {
      throw new InvalidArgumentError("uploadId cannot be empty");
    }
    let query = `uploadId=${uriEscape(uploadId)}`;
    if (marker) {
      query += `&part-number-marker=${marker}`;
    }
    const method = "GET";
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      objectName,
      query
    });
    return parseListParts(await readAsString(res));
  }
  async listBuckets() {
    const method = "GET";
    const regionConf = this.region || DEFAULT_REGION;
    const httpRes = await this.makeRequestAsync({
      method
    }, "", [200], regionConf);
    const xmlResult = await readAsString(httpRes);
    return parseListBucket(xmlResult);
  }
  calculatePartSize(size) {
    if (!isNumber(size)) {
      throw new TypeError('size should be of type "number"');
    }
    if (size > this.maxObjectSize) {
      throw new TypeError(`size should not be more than ${this.maxObjectSize}`);
    }
    if (this.overRidePartSize) {
      return this.partSize;
    }
    let partSize = this.partSize;
    for (;; ) {
      if (partSize * 1e4 > size) {
        return partSize;
      }
      partSize += 16 * 1024 * 1024;
    }
  }
  async fPutObject(bucketName, objectName, filePath, metaData) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!isString(filePath)) {
      throw new TypeError('filePath should be of type "string"');
    }
    if (metaData && !isObject(metaData)) {
      throw new TypeError('metaData should be of type "object"');
    }
    metaData = insertContentType(metaData || {}, filePath);
    const stat = await promises.lstat(filePath);
    return await this.putObject(bucketName, objectName, fs3.createReadStream(filePath), stat.size, metaData);
  }
  async putObject(bucketName, objectName, stream5, size, metaData) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (isObject(size)) {
      metaData = size;
    }
    const headers = prependXAMZMeta(metaData);
    if (typeof stream5 === "string" || stream5 instanceof Buffer) {
      size = stream5.length;
      stream5 = readableStream(stream5);
    } else if (!isReadableStream(stream5)) {
      throw new TypeError('third argument should be of type "stream.Readable" or "Buffer" or "string"');
    }
    if (isNumber(size) && size < 0) {
      throw new InvalidArgumentError(`size cannot be negative, given size: ${size}`);
    }
    if (!isNumber(size)) {
      size = this.maxObjectSize;
    }
    if (size === undefined) {
      const statSize = await getContentLength(stream5);
      if (statSize !== null) {
        size = statSize;
      }
    }
    if (!isNumber(size)) {
      size = this.maxObjectSize;
    }
    const partSize = this.calculatePartSize(size);
    if (typeof stream5 === "string" || Buffer.isBuffer(stream5) || size <= partSize) {
      const buf = isReadableStream(stream5) ? await readAsBuffer(stream5) : Buffer.from(stream5);
      return this.uploadBuffer(bucketName, objectName, headers, buf);
    }
    return this.uploadStream(bucketName, objectName, headers, stream5, partSize);
  }
  async uploadBuffer(bucketName, objectName, headers, buf) {
    const {
      md5sum,
      sha256sum
    } = hashBinary(buf, this.enableSHA256);
    headers["Content-Length"] = buf.length;
    if (!this.enableSHA256) {
      headers["Content-MD5"] = md5sum;
    }
    const res = await this.makeRequestStreamAsync({
      method: "PUT",
      bucketName,
      objectName,
      headers
    }, buf, sha256sum, [200], "");
    await drainResponse(res);
    return {
      etag: sanitizeETag(res.headers.etag),
      versionId: getVersionId(res.headers)
    };
  }
  async uploadStream(bucketName, objectName, headers, body, partSize) {
    const oldParts = {};
    const eTags = [];
    const previousUploadId = await this.findUploadId(bucketName, objectName);
    let uploadId;
    if (!previousUploadId) {
      uploadId = await this.initiateNewMultipartUpload(bucketName, objectName, headers);
    } else {
      uploadId = previousUploadId;
      const oldTags = await this.listParts(bucketName, objectName, previousUploadId);
      oldTags.forEach((e) => {
        oldParts[e.part] = e;
      });
    }
    const chunkier = new import_block_stream2.default({
      size: partSize,
      zeroPadding: false
    });
    const [_5, o3] = await Promise.all([new Promise((resolve, reject2) => {
      body.pipe(chunkier).on("error", reject2);
      chunkier.on("end", resolve).on("error", reject2);
    }), (async () => {
      let partNumber = 1;
      for await (const chunk of chunkier) {
        const md5 = crypto7.createHash("md5").update(chunk).digest();
        const oldPart = oldParts[partNumber];
        if (oldPart) {
          if (oldPart.etag === md5.toString("hex")) {
            eTags.push({
              part: partNumber,
              etag: oldPart.etag
            });
            partNumber++;
            continue;
          }
        }
        partNumber++;
        const options = {
          method: "PUT",
          query: $stringify({
            partNumber,
            uploadId
          }),
          headers: {
            "Content-Length": chunk.length,
            "Content-MD5": md5.toString("base64")
          },
          bucketName,
          objectName
        };
        const response4 = await this.makeRequestAsyncOmit(options, chunk);
        let etag = response4.headers.etag;
        if (etag) {
          etag = etag.replace(/^"/, "").replace(/"$/, "");
        } else {
          etag = "";
        }
        eTags.push({
          part: partNumber,
          etag
        });
      }
      return await this.completeMultipartUpload(bucketName, objectName, uploadId, eTags);
    })()]);
    return o3;
  }
  async removeBucketReplication(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    const method = "DELETE";
    const query = "replication";
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      query
    }, "", [200, 204], "");
  }
  async setBucketReplication(bucketName, replicationConfig) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isObject(replicationConfig)) {
      throw new InvalidArgumentError('replicationConfig should be of type "object"');
    } else {
      if (import_lodash2.default.isEmpty(replicationConfig.role)) {
        throw new InvalidArgumentError("Role cannot be empty");
      } else if (replicationConfig.role && !isString(replicationConfig.role)) {
        throw new InvalidArgumentError("Invalid value for role", replicationConfig.role);
      }
      if (import_lodash2.default.isEmpty(replicationConfig.rules)) {
        throw new InvalidArgumentError("Minimum one replication rule must be specified");
      }
    }
    const method = "PUT";
    const query = "replication";
    const headers = {};
    const replicationParamsConfig = {
      ReplicationConfiguration: {
        Role: replicationConfig.role,
        Rule: replicationConfig.rules
      }
    };
    const builder = new import_xml2js.default.Builder({
      renderOpts: {
        pretty: false
      },
      headless: true
    });
    const payload = builder.buildObject(replicationParamsConfig);
    headers["Content-MD5"] = toMd5(payload);
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      query,
      headers
    }, payload);
  }
  async getBucketReplication(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    const method = "GET";
    const query = "replication";
    const httpRes = await this.makeRequestAsync({
      method,
      bucketName,
      query
    }, "", [200, 204]);
    const xmlResult = await readAsString(httpRes);
    return parseReplicationConfig(xmlResult);
  }
  async getObjectLegalHold(bucketName, objectName, getOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (getOpts) {
      if (!isObject(getOpts)) {
        throw new TypeError('getOpts should be of type "Object"');
      } else if (Object.keys(getOpts).length > 0 && getOpts.versionId && !isString(getOpts.versionId)) {
        throw new TypeError("versionId should be of type string.:", getOpts.versionId);
      }
    }
    const method = "GET";
    let query = "legal-hold";
    if (getOpts !== null && getOpts !== undefined && getOpts.versionId) {
      query += `&versionId=${getOpts.versionId}`;
    }
    const httpRes = await this.makeRequestAsync({
      method,
      bucketName,
      objectName,
      query
    }, "", [200]);
    const strRes = await readAsString(httpRes);
    return parseObjectLegalHoldConfig(strRes);
  }
  async setObjectLegalHold(bucketName, objectName, setOpts = {
    status: LEGAL_HOLD_STATUS.ENABLED
  }) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!isObject(setOpts)) {
      throw new TypeError('setOpts should be of type "Object"');
    } else {
      if (![LEGAL_HOLD_STATUS.ENABLED, LEGAL_HOLD_STATUS.DISABLED].includes(setOpts === null || setOpts === undefined ? undefined : setOpts.status)) {
        throw new TypeError("Invalid status: " + setOpts.status);
      }
      if (setOpts.versionId && !setOpts.versionId.length) {
        throw new TypeError("versionId should be of type string.:" + setOpts.versionId);
      }
    }
    const method = "PUT";
    let query = "legal-hold";
    if (setOpts.versionId) {
      query += `&versionId=${setOpts.versionId}`;
    }
    const config2 = {
      Status: setOpts.status
    };
    const builder = new import_xml2js.default.Builder({
      rootName: "LegalHold",
      renderOpts: {
        pretty: false
      },
      headless: true
    });
    const payload = builder.buildObject(config2);
    const headers = {};
    headers["Content-MD5"] = toMd5(payload);
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      objectName,
      query,
      headers
    }, payload);
  }
  async getBucketTagging(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);
    }
    const method = "GET";
    const query = "tagging";
    const requestOptions = {
      method,
      bucketName,
      query
    };
    const response4 = await this.makeRequestAsync(requestOptions);
    const body = await readAsString(response4);
    return parseTagging(body);
  }
  async getObjectTagging(bucketName, objectName, getOpts) {
    const method = "GET";
    let query = "tagging";
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidBucketNameError("Invalid object name: " + objectName);
    }
    if (getOpts && !isObject(getOpts)) {
      throw new InvalidArgumentError('getOpts should be of type "object"');
    }
    if (getOpts && getOpts.versionId) {
      query = `${query}&versionId=${getOpts.versionId}`;
    }
    const requestOptions = {
      method,
      bucketName,
      query
    };
    if (objectName) {
      requestOptions["objectName"] = objectName;
    }
    const response4 = await this.makeRequestAsync(requestOptions);
    const body = await readAsString(response4);
    return parseTagging(body);
  }
  async setBucketPolicy(bucketName, policy2) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);
    }
    if (!isString(policy2)) {
      throw new InvalidBucketPolicyError(`Invalid bucket policy: ${policy2} - must be "string"`);
    }
    const query = "policy";
    let method = "DELETE";
    if (policy2) {
      method = "PUT";
    }
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      query
    }, policy2, [204], "");
  }
  async getBucketPolicy(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);
    }
    const method = "GET";
    const query = "policy";
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      query
    });
    return await readAsString(res);
  }
  async putObjectRetention(bucketName, objectName, retentionOpts = {}) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!isObject(retentionOpts)) {
      throw new InvalidArgumentError('retentionOpts should be of type "object"');
    } else {
      if (retentionOpts.governanceBypass && !isBoolean(retentionOpts.governanceBypass)) {
        throw new InvalidArgumentError(`Invalid value for governanceBypass: ${retentionOpts.governanceBypass}`);
      }
      if (retentionOpts.mode && ![RETENTION_MODES.COMPLIANCE, RETENTION_MODES.GOVERNANCE].includes(retentionOpts.mode)) {
        throw new InvalidArgumentError(`Invalid object retention mode: ${retentionOpts.mode}`);
      }
      if (retentionOpts.retainUntilDate && !isString(retentionOpts.retainUntilDate)) {
        throw new InvalidArgumentError(`Invalid value for retainUntilDate: ${retentionOpts.retainUntilDate}`);
      }
      if (retentionOpts.versionId && !isString(retentionOpts.versionId)) {
        throw new InvalidArgumentError(`Invalid value for versionId: ${retentionOpts.versionId}`);
      }
    }
    const method = "PUT";
    let query = "retention";
    const headers = {};
    if (retentionOpts.governanceBypass) {
      headers["X-Amz-Bypass-Governance-Retention"] = true;
    }
    const builder = new import_xml2js.default.Builder({
      rootName: "Retention",
      renderOpts: {
        pretty: false
      },
      headless: true
    });
    const params = {};
    if (retentionOpts.mode) {
      params.Mode = retentionOpts.mode;
    }
    if (retentionOpts.retainUntilDate) {
      params.RetainUntilDate = retentionOpts.retainUntilDate;
    }
    if (retentionOpts.versionId) {
      query += `&versionId=${retentionOpts.versionId}`;
    }
    const payload = builder.buildObject(params);
    headers["Content-MD5"] = toMd5(payload);
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      objectName,
      query,
      headers
    }, payload, [200, 204]);
  }
  async getObjectLockConfig(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    const method = "GET";
    const query = "object-lock";
    const httpRes = await this.makeRequestAsync({
      method,
      bucketName,
      query
    });
    const xmlResult = await readAsString(httpRes);
    return parseObjectLockConfig(xmlResult);
  }
  async setObjectLockConfig(bucketName, lockConfigOpts) {
    const retentionModes = [RETENTION_MODES.COMPLIANCE, RETENTION_MODES.GOVERNANCE];
    const validUnits = [RETENTION_VALIDITY_UNITS.DAYS, RETENTION_VALIDITY_UNITS.YEARS];
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (lockConfigOpts.mode && !retentionModes.includes(lockConfigOpts.mode)) {
      throw new TypeError(`lockConfigOpts.mode should be one of ${retentionModes}`);
    }
    if (lockConfigOpts.unit && !validUnits.includes(lockConfigOpts.unit)) {
      throw new TypeError(`lockConfigOpts.unit should be one of ${validUnits}`);
    }
    if (lockConfigOpts.validity && !isNumber(lockConfigOpts.validity)) {
      throw new TypeError(`lockConfigOpts.validity should be a number`);
    }
    const method = "PUT";
    const query = "object-lock";
    const config2 = {
      ObjectLockEnabled: "Enabled"
    };
    const configKeys = Object.keys(lockConfigOpts);
    const isAllKeysSet = ["unit", "mode", "validity"].every((lck) => configKeys.includes(lck));
    if (configKeys.length > 0) {
      if (!isAllKeysSet) {
        throw new TypeError(`lockConfigOpts.mode,lockConfigOpts.unit,lockConfigOpts.validity all the properties should be specified.`);
      } else {
        config2.Rule = {
          DefaultRetention: {}
        };
        if (lockConfigOpts.mode) {
          config2.Rule.DefaultRetention.Mode = lockConfigOpts.mode;
        }
        if (lockConfigOpts.unit === RETENTION_VALIDITY_UNITS.DAYS) {
          config2.Rule.DefaultRetention.Days = lockConfigOpts.validity;
        } else if (lockConfigOpts.unit === RETENTION_VALIDITY_UNITS.YEARS) {
          config2.Rule.DefaultRetention.Years = lockConfigOpts.validity;
        }
      }
    }
    const builder = new import_xml2js.default.Builder({
      rootName: "ObjectLockConfiguration",
      renderOpts: {
        pretty: false
      },
      headless: true
    });
    const payload = builder.buildObject(config2);
    const headers = {};
    headers["Content-MD5"] = toMd5(payload);
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      query,
      headers
    }, payload);
  }
  async getBucketVersioning(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    const method = "GET";
    const query = "versioning";
    const httpRes = await this.makeRequestAsync({
      method,
      bucketName,
      query
    });
    const xmlResult = await readAsString(httpRes);
    return await parseBucketVersioningConfig(xmlResult);
  }
  async setBucketVersioning(bucketName, versionConfig) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!Object.keys(versionConfig).length) {
      throw new InvalidArgumentError('versionConfig should be of type "object"');
    }
    const method = "PUT";
    const query = "versioning";
    const builder = new import_xml2js.default.Builder({
      rootName: "VersioningConfiguration",
      renderOpts: {
        pretty: false
      },
      headless: true
    });
    const payload = builder.buildObject(versionConfig);
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      query
    }, payload);
  }
  async setTagging(taggingParams) {
    const {
      bucketName,
      objectName,
      tags,
      putOpts
    } = taggingParams;
    const method = "PUT";
    let query = "tagging";
    if (putOpts && putOpts !== null && putOpts !== undefined && putOpts.versionId) {
      query = `${query}&versionId=${putOpts.versionId}`;
    }
    const tagsList = [];
    for (const [key, value15] of Object.entries(tags)) {
      tagsList.push({
        Key: key,
        Value: value15
      });
    }
    const taggingConfig = {
      Tagging: {
        TagSet: {
          Tag: tagsList
        }
      }
    };
    const headers = {};
    const builder = new import_xml2js.default.Builder({
      headless: true,
      renderOpts: {
        pretty: false
      }
    });
    const payloadBuf = Buffer.from(builder.buildObject(taggingConfig));
    const requestOptions = {
      method,
      bucketName,
      query,
      headers,
      ...objectName && {
        objectName
      }
    };
    headers["Content-MD5"] = toMd5(payloadBuf);
    await this.makeRequestAsyncOmit(requestOptions, payloadBuf);
  }
  async removeTagging({
    bucketName,
    objectName,
    removeOpts
  }) {
    const method = "DELETE";
    let query = "tagging";
    if (removeOpts && Object.keys(removeOpts).length && removeOpts.versionId) {
      query = `${query}&versionId=${removeOpts.versionId}`;
    }
    const requestOptions = {
      method,
      bucketName,
      objectName,
      query
    };
    if (objectName) {
      requestOptions["objectName"] = objectName;
    }
    await this.makeRequestAsync(requestOptions, "", [200, 204]);
  }
  async setBucketTagging(bucketName, tags) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isObject(tags)) {
      throw new InvalidArgumentError('tags should be of type "object"');
    }
    if (Object.keys(tags).length > 10) {
      throw new InvalidArgumentError('maximum tags allowed is 10"');
    }
    await this.setTagging({
      bucketName,
      tags
    });
  }
  async removeBucketTagging(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    await this.removeTagging({
      bucketName
    });
  }
  async setObjectTagging(bucketName, objectName, tags, putOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidBucketNameError("Invalid object name: " + objectName);
    }
    if (!isObject(tags)) {
      throw new InvalidArgumentError('tags should be of type "object"');
    }
    if (Object.keys(tags).length > 10) {
      throw new InvalidArgumentError('Maximum tags allowed is 10"');
    }
    await this.setTagging({
      bucketName,
      objectName,
      tags,
      putOpts
    });
  }
  async removeObjectTagging(bucketName, objectName, removeOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidBucketNameError("Invalid object name: " + objectName);
    }
    if (removeOpts && Object.keys(removeOpts).length && !isObject(removeOpts)) {
      throw new InvalidArgumentError('removeOpts should be of type "object"');
    }
    await this.removeTagging({
      bucketName,
      objectName,
      removeOpts
    });
  }
  async selectObjectContent(bucketName, objectName, selectOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (!import_lodash2.default.isEmpty(selectOpts)) {
      if (!isString(selectOpts.expression)) {
        throw new TypeError('sqlExpression should be of type "string"');
      }
      if (!import_lodash2.default.isEmpty(selectOpts.inputSerialization)) {
        if (!isObject(selectOpts.inputSerialization)) {
          throw new TypeError('inputSerialization should be of type "object"');
        }
      } else {
        throw new TypeError("inputSerialization is required");
      }
      if (!import_lodash2.default.isEmpty(selectOpts.outputSerialization)) {
        if (!isObject(selectOpts.outputSerialization)) {
          throw new TypeError('outputSerialization should be of type "object"');
        }
      } else {
        throw new TypeError("outputSerialization is required");
      }
    } else {
      throw new TypeError("valid select configuration is required");
    }
    const method = "POST";
    const query = `select&select-type=2`;
    const config2 = [{
      Expression: selectOpts.expression
    }, {
      ExpressionType: selectOpts.expressionType || "SQL"
    }, {
      InputSerialization: [selectOpts.inputSerialization]
    }, {
      OutputSerialization: [selectOpts.outputSerialization]
    }];
    if (selectOpts.requestProgress) {
      config2.push({
        RequestProgress: selectOpts === null || selectOpts === undefined ? undefined : selectOpts.requestProgress
      });
    }
    if (selectOpts.scanRange) {
      config2.push({
        ScanRange: selectOpts.scanRange
      });
    }
    const builder = new import_xml2js.default.Builder({
      rootName: "SelectObjectContentRequest",
      renderOpts: {
        pretty: false
      },
      headless: true
    });
    const payload = builder.buildObject(config2);
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      objectName,
      query
    }, payload);
    const body = await readAsBuffer(res);
    return parseSelectObjectContentResponse(body);
  }
  async applyBucketLifecycle(bucketName, policyConfig) {
    const method = "PUT";
    const query = "lifecycle";
    const headers = {};
    const builder = new import_xml2js.default.Builder({
      rootName: "LifecycleConfiguration",
      headless: true,
      renderOpts: {
        pretty: false
      }
    });
    const payload = builder.buildObject(policyConfig);
    headers["Content-MD5"] = toMd5(payload);
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      query,
      headers
    }, payload);
  }
  async removeBucketLifecycle(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    const method = "DELETE";
    const query = "lifecycle";
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      query
    }, "", [204]);
  }
  async setBucketLifecycle(bucketName, lifeCycleConfig) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (import_lodash2.default.isEmpty(lifeCycleConfig)) {
      await this.removeBucketLifecycle(bucketName);
    } else {
      await this.applyBucketLifecycle(bucketName, lifeCycleConfig);
    }
  }
  async getBucketLifecycle(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    const method = "GET";
    const query = "lifecycle";
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      query
    });
    const body = await readAsString(res);
    return parseLifecycleConfig(body);
  }
  async setBucketEncryption(bucketName, encryptionConfig) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!import_lodash2.default.isEmpty(encryptionConfig) && encryptionConfig.Rule.length > 1) {
      throw new InvalidArgumentError("Invalid Rule length. Only one rule is allowed.: " + encryptionConfig.Rule);
    }
    let encryptionObj = encryptionConfig;
    if (import_lodash2.default.isEmpty(encryptionConfig)) {
      encryptionObj = {
        Rule: [{
          ApplyServerSideEncryptionByDefault: {
            SSEAlgorithm: "AES256"
          }
        }]
      };
    }
    const method = "PUT";
    const query = "encryption";
    const builder = new import_xml2js.default.Builder({
      rootName: "ServerSideEncryptionConfiguration",
      renderOpts: {
        pretty: false
      },
      headless: true
    });
    const payload = builder.buildObject(encryptionObj);
    const headers = {};
    headers["Content-MD5"] = toMd5(payload);
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      query,
      headers
    }, payload);
  }
  async getBucketEncryption(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    const method = "GET";
    const query = "encryption";
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      query
    });
    const body = await readAsString(res);
    return parseBucketEncryptionConfig(body);
  }
  async removeBucketEncryption(bucketName) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    const method = "DELETE";
    const query = "encryption";
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      query
    }, "", [204]);
  }
  async getObjectRetention(bucketName, objectName, getOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    if (getOpts && !isObject(getOpts)) {
      throw new InvalidArgumentError('getOpts should be of type "object"');
    } else if (getOpts !== null && getOpts !== undefined && getOpts.versionId && !isString(getOpts.versionId)) {
      throw new InvalidArgumentError('versionId should be of type "string"');
    }
    const method = "GET";
    let query = "retention";
    if (getOpts !== null && getOpts !== undefined && getOpts.versionId) {
      query += `&versionId=${getOpts.versionId}`;
    }
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      objectName,
      query
    });
    const body = await readAsString(res);
    return parseObjectRetentionConfig(body);
  }
  async removeObjects(bucketName, objectsList) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!Array.isArray(objectsList)) {
      throw new InvalidArgumentError("objectsList should be a list");
    }
    const runDeleteObjects = async (batch) => {
      const delObjects = batch.map((value15) => {
        return isObject(value15) ? {
          Key: value15.name,
          VersionId: value15.versionId
        } : {
          Key: value15
        };
      });
      const remObjects = {
        Delete: {
          Quiet: true,
          Object: delObjects
        }
      };
      const payload = Buffer.from(new import_xml2js.default.Builder({
        headless: true
      }).buildObject(remObjects));
      const headers = {
        "Content-MD5": toMd5(payload)
      };
      const res = await this.makeRequestAsync({
        method: "POST",
        bucketName,
        query: "delete",
        headers
      }, payload);
      const body = await readAsString(res);
      return removeObjectsParser(body);
    };
    const maxEntries = 1000;
    const batches = [];
    for (let i3 = 0;i3 < objectsList.length; i3 += maxEntries) {
      batches.push(objectsList.slice(i3, i3 + maxEntries));
    }
    const batchResults = await Promise.all(batches.map(runDeleteObjects));
    return batchResults.flat();
  }
  async removeIncompleteUpload(bucketName, objectName) {
    if (!isValidBucketName(bucketName)) {
      throw new IsValidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    const removeUploadId = await this.findUploadId(bucketName, objectName);
    const method = "DELETE";
    const query = `uploadId=${removeUploadId}`;
    await this.makeRequestAsyncOmit({
      method,
      bucketName,
      objectName,
      query
    }, "", [204]);
  }
  async copyObjectV1(targetBucketName, targetObjectName, sourceBucketNameAndObjectName, conditions) {
    if (typeof conditions == "function") {
      conditions = null;
    }
    if (!isValidBucketName(targetBucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + targetBucketName);
    }
    if (!isValidObjectName(targetObjectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${targetObjectName}`);
    }
    if (!isString(sourceBucketNameAndObjectName)) {
      throw new TypeError('sourceBucketNameAndObjectName should be of type "string"');
    }
    if (sourceBucketNameAndObjectName === "") {
      throw new InvalidPrefixError(`Empty source prefix`);
    }
    if (conditions != null && !(conditions instanceof CopyConditions)) {
      throw new TypeError('conditions should be of type "CopyConditions"');
    }
    const headers = {};
    headers["x-amz-copy-source"] = uriResourceEscape(sourceBucketNameAndObjectName);
    if (conditions) {
      if (conditions.modified !== "") {
        headers["x-amz-copy-source-if-modified-since"] = conditions.modified;
      }
      if (conditions.unmodified !== "") {
        headers["x-amz-copy-source-if-unmodified-since"] = conditions.unmodified;
      }
      if (conditions.matchETag !== "") {
        headers["x-amz-copy-source-if-match"] = conditions.matchETag;
      }
      if (conditions.matchETagExcept !== "") {
        headers["x-amz-copy-source-if-none-match"] = conditions.matchETagExcept;
      }
    }
    const method = "PUT";
    const res = await this.makeRequestAsync({
      method,
      bucketName: targetBucketName,
      objectName: targetObjectName,
      headers
    });
    const body = await readAsString(res);
    return parseCopyObject(body);
  }
  async copyObjectV2(sourceConfig, destConfig) {
    if (!(sourceConfig instanceof CopySourceOptions)) {
      throw new InvalidArgumentError("sourceConfig should of type CopySourceOptions ");
    }
    if (!(destConfig instanceof CopyDestinationOptions)) {
      throw new InvalidArgumentError("destConfig should of type CopyDestinationOptions ");
    }
    if (!destConfig.validate()) {
      return Promise.reject();
    }
    if (!destConfig.validate()) {
      return Promise.reject();
    }
    const headers = Object.assign({}, sourceConfig.getHeaders(), destConfig.getHeaders());
    const bucketName = destConfig.Bucket;
    const objectName = destConfig.Object;
    const method = "PUT";
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      objectName,
      headers
    });
    const body = await readAsString(res);
    const copyRes = parseCopyObject(body);
    const resHeaders = res.headers;
    const sizeHeaderValue = resHeaders && resHeaders["content-length"];
    const size = typeof sizeHeaderValue === "number" ? sizeHeaderValue : undefined;
    return {
      Bucket: destConfig.Bucket,
      Key: destConfig.Object,
      LastModified: copyRes.lastModified,
      MetaData: extractMetadata(resHeaders),
      VersionId: getVersionId(resHeaders),
      SourceVersionId: getSourceVersionId(resHeaders),
      Etag: sanitizeETag(resHeaders.etag),
      Size: size
    };
  }
  async copyObject(...allArgs) {
    if (typeof allArgs[0] === "string") {
      const [targetBucketName, targetObjectName, sourceBucketNameAndObjectName, conditions] = allArgs;
      return await this.copyObjectV1(targetBucketName, targetObjectName, sourceBucketNameAndObjectName, conditions);
    }
    const [source, dest] = allArgs;
    return await this.copyObjectV2(source, dest);
  }
  async uploadPart(partConfig, payload) {
    const {
      bucketName,
      objectName,
      uploadID,
      partNumber,
      headers
    } = partConfig;
    const method = "PUT";
    const query = `uploadId=${uploadID}&partNumber=${partNumber}`;
    const requestOptions = {
      method,
      bucketName,
      objectName,
      query,
      headers
    };
    const res = await this.makeRequestAsync(requestOptions, payload);
    const body = await readAsString(res);
    const partRes = uploadPartParser(body);
    return {
      etag: sanitizeETag(partRes.ETag),
      key: objectName,
      part: partNumber
    };
  }
  async composeObject(destObjConfig, sourceObjList) {
    const sourceFilesLength = sourceObjList.length;
    if (!Array.isArray(sourceObjList)) {
      throw new InvalidArgumentError("sourceConfig should an array of CopySourceOptions ");
    }
    if (!(destObjConfig instanceof CopyDestinationOptions)) {
      throw new InvalidArgumentError("destConfig should of type CopyDestinationOptions ");
    }
    if (sourceFilesLength < 1 || sourceFilesLength > PART_CONSTRAINTS.MAX_PARTS_COUNT) {
      throw new InvalidArgumentError(`"There must be as least one and up to ${PART_CONSTRAINTS.MAX_PARTS_COUNT} source objects.`);
    }
    for (let i3 = 0;i3 < sourceFilesLength; i3++) {
      const sObj = sourceObjList[i3];
      if (!sObj.validate()) {
        return false;
      }
    }
    if (!destObjConfig.validate()) {
      return false;
    }
    const getStatOptions = (srcConfig) => {
      let statOpts = {};
      if (!import_lodash2.default.isEmpty(srcConfig.VersionID)) {
        statOpts = {
          versionId: srcConfig.VersionID
        };
      }
      return statOpts;
    };
    const srcObjectSizes = [];
    let totalSize = 0;
    let totalParts = 0;
    const sourceObjStats = sourceObjList.map((srcItem) => this.statObject(srcItem.Bucket, srcItem.Object, getStatOptions(srcItem)));
    const srcObjectInfos = await Promise.all(sourceObjStats);
    const validatedStats = srcObjectInfos.map((resItemStat, index2) => {
      const srcConfig = sourceObjList[index2];
      let srcCopySize = resItemStat.size;
      if (srcConfig && srcConfig.MatchRange) {
        const srcStart = srcConfig.Start;
        const srcEnd = srcConfig.End;
        if (srcEnd >= srcCopySize || srcStart < 0) {
          throw new InvalidArgumentError(`CopySrcOptions ${index2} has invalid segment-to-copy [${srcStart}, ${srcEnd}] (size is ${srcCopySize})`);
        }
        srcCopySize = srcEnd - srcStart + 1;
      }
      if (srcCopySize < PART_CONSTRAINTS.ABS_MIN_PART_SIZE && index2 < sourceFilesLength - 1) {
        throw new InvalidArgumentError(`CopySrcOptions ${index2} is too small (${srcCopySize}) and it is not the last part.`);
      }
      totalSize += srcCopySize;
      if (totalSize > PART_CONSTRAINTS.MAX_MULTIPART_PUT_OBJECT_SIZE) {
        throw new InvalidArgumentError(`Cannot compose an object of size ${totalSize} (> 5TiB)`);
      }
      srcObjectSizes[index2] = srcCopySize;
      totalParts += partsRequired(srcCopySize);
      if (totalParts > PART_CONSTRAINTS.MAX_PARTS_COUNT) {
        throw new InvalidArgumentError(`Your proposed compose object requires more than ${PART_CONSTRAINTS.MAX_PARTS_COUNT} parts`);
      }
      return resItemStat;
    });
    if (totalParts === 1 && totalSize <= PART_CONSTRAINTS.MAX_PART_SIZE || totalSize === 0) {
      return await this.copyObject(sourceObjList[0], destObjConfig);
    }
    for (let i3 = 0;i3 < sourceFilesLength; i3++) {
      sourceObjList[i3].MatchETag = validatedStats[i3].etag;
    }
    const splitPartSizeList = validatedStats.map((resItemStat, idx) => {
      return calculateEvenSplits(srcObjectSizes[idx], sourceObjList[idx]);
    });
    const getUploadPartConfigList = (uploadId2) => {
      const uploadPartConfigList = [];
      splitPartSizeList.forEach((splitSize, splitIndex) => {
        if (splitSize) {
          const {
            startIndex: startIdx,
            endIndex: endIdx,
            objInfo: objConfig
          } = splitSize;
          const partIndex = splitIndex + 1;
          const totalUploads = Array.from(startIdx);
          const headers = sourceObjList[splitIndex].getHeaders();
          totalUploads.forEach((splitStart, upldCtrIdx) => {
            const splitEnd = endIdx[upldCtrIdx];
            const sourceObj = `${objConfig.Bucket}/${objConfig.Object}`;
            headers["x-amz-copy-source"] = `${sourceObj}`;
            headers["x-amz-copy-source-range"] = `bytes=${splitStart}-${splitEnd}`;
            const uploadPartConfig = {
              bucketName: destObjConfig.Bucket,
              objectName: destObjConfig.Object,
              uploadID: uploadId2,
              partNumber: partIndex,
              headers,
              sourceObj
            };
            uploadPartConfigList.push(uploadPartConfig);
          });
        }
      });
      return uploadPartConfigList;
    };
    const uploadAllParts = async (uploadList) => {
      const partUploads = uploadList.map(async (item) => {
        return this.uploadPart(item);
      });
      return await Promise.all(partUploads);
    };
    const performUploadParts = async (uploadId2) => {
      const uploadList = getUploadPartConfigList(uploadId2);
      const partsRes = await uploadAllParts(uploadList);
      return partsRes.map((partCopy) => ({
        etag: partCopy.etag,
        part: partCopy.part
      }));
    };
    const newUploadHeaders = destObjConfig.getHeaders();
    const uploadId = await this.initiateNewMultipartUpload(destObjConfig.Bucket, destObjConfig.Object, newUploadHeaders);
    try {
      const partsDone = await performUploadParts(uploadId);
      return await this.completeMultipartUpload(destObjConfig.Bucket, destObjConfig.Object, uploadId, partsDone);
    } catch (err) {
      return await this.abortMultipartUpload(destObjConfig.Bucket, destObjConfig.Object, uploadId);
    }
  }
  async presignedUrl(method, bucketName, objectName, expires, reqParams, requestDate) {
    var _requestDate;
    if (this.anonymous) {
      throw new AnonymousRequestError(`Presigned ${method} url cannot be generated for anonymous requests`);
    }
    if (!expires) {
      expires = PRESIGN_EXPIRY_DAYS_MAX;
    }
    if (!reqParams) {
      reqParams = {};
    }
    if (!requestDate) {
      requestDate = new Date;
    }
    if (expires && typeof expires !== "number") {
      throw new TypeError('expires should be of type "number"');
    }
    if (reqParams && typeof reqParams !== "object") {
      throw new TypeError('reqParams should be of type "object"');
    }
    if (requestDate && !(requestDate instanceof Date) || requestDate && isNaN((_requestDate = requestDate) === null || _requestDate === undefined ? undefined : _requestDate.getTime())) {
      throw new TypeError('requestDate should be of type "Date" and valid');
    }
    const query = reqParams ? $stringify(reqParams) : undefined;
    try {
      const region = await this.getBucketRegionAsync(bucketName);
      await this.checkAndRefreshCreds();
      const reqOptions = this.getRequestOptions({
        method,
        region,
        bucketName,
        objectName,
        query
      });
      return presignSignatureV4(reqOptions, this.accessKey, this.secretKey, this.sessionToken, region, requestDate, expires);
    } catch (err) {
      if (err instanceof InvalidBucketNameError) {
        throw new InvalidArgumentError(`Unable to get bucket region for ${bucketName}.`);
      }
      throw err;
    }
  }
  async presignedGetObject(bucketName, objectName, expires, respHeaders, requestDate) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    const validRespHeaders = ["response-content-type", "response-content-language", "response-expires", "response-cache-control", "response-content-disposition", "response-content-encoding"];
    validRespHeaders.forEach((header) => {
      if (respHeaders !== undefined && respHeaders[header] !== undefined && !isString(respHeaders[header])) {
        throw new TypeError(`response header ${header} should be of type "string"`);
      }
    });
    return this.presignedUrl("GET", bucketName, objectName, expires, respHeaders, requestDate);
  }
  async presignedPutObject(bucketName, objectName, expires) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);
    }
    if (!isValidObjectName(objectName)) {
      throw new InvalidObjectNameError(`Invalid object name: ${objectName}`);
    }
    return this.presignedUrl("PUT", bucketName, objectName, expires);
  }
  newPostPolicy() {
    return new PostPolicy;
  }
  async presignedPostPolicy(postPolicy) {
    if (this.anonymous) {
      throw new AnonymousRequestError("Presigned POST policy cannot be generated for anonymous requests");
    }
    if (!isObject(postPolicy)) {
      throw new TypeError('postPolicy should be of type "object"');
    }
    const bucketName = postPolicy.formData.bucket;
    try {
      const region = await this.getBucketRegionAsync(bucketName);
      const date5 = new Date;
      const dateStr = makeDateLong(date5);
      await this.checkAndRefreshCreds();
      if (!postPolicy.policy.expiration) {
        const expires = new Date;
        expires.setSeconds(PRESIGN_EXPIRY_DAYS_MAX);
        postPolicy.setExpires(expires);
      }
      postPolicy.policy.conditions.push(["eq", "$x-amz-date", dateStr]);
      postPolicy.formData["x-amz-date"] = dateStr;
      postPolicy.policy.conditions.push(["eq", "$x-amz-algorithm", "AWS4-HMAC-SHA256"]);
      postPolicy.formData["x-amz-algorithm"] = "AWS4-HMAC-SHA256";
      postPolicy.policy.conditions.push(["eq", "$x-amz-credential", this.accessKey + "/" + getScope(region, date5)]);
      postPolicy.formData["x-amz-credential"] = this.accessKey + "/" + getScope(region, date5);
      if (this.sessionToken) {
        postPolicy.policy.conditions.push(["eq", "$x-amz-security-token", this.sessionToken]);
        postPolicy.formData["x-amz-security-token"] = this.sessionToken;
      }
      const policyBase64 = Buffer.from(JSON.stringify(postPolicy.policy)).toString("base64");
      postPolicy.formData.policy = policyBase64;
      postPolicy.formData["x-amz-signature"] = postPresignSignatureV4(region, date5, this.secretKey, policyBase64);
      const opts = {
        region,
        bucketName,
        method: "POST"
      };
      const reqOptions = this.getRequestOptions(opts);
      const portStr = this.port == 80 || this.port === 443 ? "" : `:${this.port.toString()}`;
      const urlStr = `${reqOptions.protocol}//${reqOptions.host}${portStr}${reqOptions.path}`;
      return {
        postURL: urlStr,
        formData: postPolicy.formData
      };
    } catch (err) {
      if (err instanceof InvalidBucketNameError) {
        throw new InvalidArgumentError(`Unable to get bucket region for ${bucketName}.`);
      }
      throw err;
    }
  }
  async listObjectsQuery(bucketName, prefix, marker, listQueryOpts) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isString(prefix)) {
      throw new TypeError('prefix should be of type "string"');
    }
    if (!isString(marker)) {
      throw new TypeError('marker should be of type "string"');
    }
    if (listQueryOpts && !isObject(listQueryOpts)) {
      throw new TypeError('listQueryOpts should be of type "object"');
    }
    let {
      Delimiter,
      MaxKeys,
      IncludeVersion
    } = listQueryOpts;
    if (!isString(Delimiter)) {
      throw new TypeError('Delimiter should be of type "string"');
    }
    if (!isNumber(MaxKeys)) {
      throw new TypeError('MaxKeys should be of type "number"');
    }
    const queries = [];
    queries.push(`prefix=${uriEscape(prefix)}`);
    queries.push(`delimiter=${uriEscape(Delimiter)}`);
    queries.push(`encoding-type=url`);
    if (IncludeVersion) {
      queries.push(`versions`);
    }
    if (marker) {
      marker = uriEscape(marker);
      if (IncludeVersion) {
        queries.push(`key-marker=${marker}`);
      } else {
        queries.push(`marker=${marker}`);
      }
    }
    if (MaxKeys) {
      if (MaxKeys >= 1000) {
        MaxKeys = 1000;
      }
      queries.push(`max-keys=${MaxKeys}`);
    }
    queries.sort();
    let query = "";
    if (queries.length > 0) {
      query = `${queries.join("&")}`;
    }
    const method = "GET";
    const res = await this.makeRequestAsync({
      method,
      bucketName,
      query
    });
    const body = await readAsString(res);
    const listQryList = parseListObjects(body);
    return listQryList;
  }
  listObjects(bucketName, prefix, recursive4, listOpts) {
    if (prefix === undefined) {
      prefix = "";
    }
    if (recursive4 === undefined) {
      recursive4 = false;
    }
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidPrefix(prefix)) {
      throw new InvalidPrefixError(`Invalid prefix : ${prefix}`);
    }
    if (!isString(prefix)) {
      throw new TypeError('prefix should be of type "string"');
    }
    if (!isBoolean(recursive4)) {
      throw new TypeError('recursive should be of type "boolean"');
    }
    if (listOpts && !isObject(listOpts)) {
      throw new TypeError('listOpts should be of type "object"');
    }
    let marker = "";
    const listQueryOpts = {
      Delimiter: recursive4 ? "" : "/",
      MaxKeys: 1000,
      IncludeVersion: listOpts === null || listOpts === undefined ? undefined : listOpts.IncludeVersion
    };
    let objects = [];
    let ended = false;
    const readStream = new stream4.Readable({
      objectMode: true
    });
    readStream._read = async () => {
      if (objects.length) {
        readStream.push(objects.shift());
        return;
      }
      if (ended) {
        return readStream.push(null);
      }
      try {
        const result = await this.listObjectsQuery(bucketName, prefix, marker, listQueryOpts);
        if (result.isTruncated) {
          marker = result.nextMarker || result.versionIdMarker;
        } else {
          ended = true;
        }
        if (result.objects) {
          objects = result.objects;
        }
        readStream._read();
      } catch (err) {
        readStream.emit("error", err);
      }
    };
    return readStream;
  }
}

// node_modules/eventemitter3/index.mjs
var import_2 = __toESM(require_eventemitter3(), 1);

// node_modules/minio/dist/esm/notification.mjs
var Parser = __toESM(require_Parser(), 1);
class TargetConfig {
  setId(id) {
    this.Id = id;
  }
  addEvent(newevent) {
    if (!this.Event) {
      this.Event = [];
    }
    this.Event.push(newevent);
  }
  addFilterSuffix(suffix) {
    if (!this.Filter) {
      this.Filter = {
        S3Key: {
          FilterRule: []
        }
      };
    }
    this.Filter.S3Key.FilterRule.push({
      Name: "suffix",
      Value: suffix
    });
  }
  addFilterPrefix(prefix) {
    if (!this.Filter) {
      this.Filter = {
        S3Key: {
          FilterRule: []
        }
      };
    }
    this.Filter.S3Key.FilterRule.push({
      Name: "prefix",
      Value: prefix
    });
  }
}

class TopicConfig extends TargetConfig {
  constructor(arn) {
    super();
    this.Topic = arn;
  }
}

class QueueConfig extends TargetConfig {
  constructor(arn) {
    super();
    this.Queue = arn;
  }
}

class CloudFunctionConfig extends TargetConfig {
  constructor(arn) {
    super();
    this.CloudFunction = arn;
  }
}

class NotificationConfig {
  add(target) {
    let instance;
    if (target instanceof TopicConfig) {
      instance = this.TopicConfiguration ?? (this.TopicConfiguration = []);
    }
    if (target instanceof QueueConfig) {
      instance = this.QueueConfiguration ?? (this.QueueConfiguration = []);
    }
    if (target instanceof CloudFunctionConfig) {
      instance = this.CloudFunctionConfiguration ?? (this.CloudFunctionConfiguration = []);
    }
    if (instance) {
      instance.push(target);
    }
  }
}
class NotificationPoller extends import_2.default {
  constructor(client33, bucketName, prefix, suffix, events) {
    super();
    this.client = client33;
    this.bucketName = bucketName;
    this.prefix = prefix;
    this.suffix = suffix;
    this.events = events;
    this.ending = false;
  }
  start() {
    this.ending = false;
    process.nextTick(() => {
      this.checkForChanges();
    });
  }
  stop() {
    this.ending = true;
  }
  checkForChanges() {
    if (this.ending) {
      return;
    }
    const method = "GET";
    const queries = [];
    if (this.prefix) {
      const prefix = uriEscape(this.prefix);
      queries.push(`prefix=${prefix}`);
    }
    if (this.suffix) {
      const suffix = uriEscape(this.suffix);
      queries.push(`suffix=${suffix}`);
    }
    if (this.events) {
      this.events.forEach((s3event) => queries.push("events=" + uriEscape(s3event)));
    }
    queries.sort();
    let query = "";
    if (queries.length > 0) {
      query = `${queries.join("&")}`;
    }
    const region = this.client.region || DEFAULT_REGION;
    this.client.makeRequestAsync({
      method,
      bucketName: this.bucketName,
      query
    }, "", [200], region).then((response4) => {
      const asm = Parser.default.make();
      pipesetup(response4, asm).on("data", (data) => {
        let records = data.value.Records;
        if (!records) {
          records = [];
        }
        records.forEach((record4) => {
          this.emit("notification", record4);
        });
        if (this.ending) {
          response4 === null || response4 === undefined || response4.destroy();
        }
      }).on("error", (e) => this.emit("error", e)).on("end", () => {
        process.nextTick(() => {
          this.checkForChanges();
        });
      });
    }, (e) => {
      return this.emit("error", e);
    });
  }
}

// node_modules/minio/dist/esm/promisify.mjs
function promisify2(fn) {
  return function() {
    let callback = arguments[arguments.length - 1];
    if (typeof callback === "function") {
      return fn.apply(this, arguments);
    }
    let args = [...arguments];
    return new Promise((resolve, reject2) => {
      args.push((err, value15) => {
        if (err) {
          return reject2(err);
        }
        resolve(value15);
      });
      fn.apply(this, args);
    });
  };
}

// node_modules/minio/dist/esm/transformers.mjs
var import_through2 = __toESM(require_through2(), 1);

// node_modules/minio/dist/esm/xml-parsers.mjs
function parseBucketNotification(xml2) {
  var result = {
    TopicConfiguration: [],
    QueueConfiguration: [],
    CloudFunctionConfiguration: []
  };
  var genEvents = function(events) {
    var result2 = [];
    if (events) {
      toArray(events).forEach((s3event) => {
        result2.push(s3event);
      });
    }
    return result2;
  };
  var genFilterRules = function(filters) {
    var result2 = [];
    if (filters) {
      filters = toArray(filters);
      if (filters[0].S3Key) {
        filters[0].S3Key = toArray(filters[0].S3Key);
        if (filters[0].S3Key[0].FilterRule) {
          toArray(filters[0].S3Key[0].FilterRule).forEach((rule) => {
            var Name = toArray(rule.Name)[0];
            var Value = toArray(rule.Value)[0];
            result2.push({
              Name,
              Value
            });
          });
        }
      }
    }
    return result2;
  };
  var xmlobj = parseXml(xml2);
  xmlobj = xmlobj.NotificationConfiguration;
  if (xmlobj.TopicConfiguration) {
    toArray(xmlobj.TopicConfiguration).forEach((config2) => {
      var Id = toArray(config2.Id)[0];
      var Topic = toArray(config2.Topic)[0];
      var Event2 = genEvents(config2.Event);
      var Filter = genFilterRules(config2.Filter);
      result.TopicConfiguration.push({
        Id,
        Topic,
        Event: Event2,
        Filter
      });
    });
  }
  if (xmlobj.QueueConfiguration) {
    toArray(xmlobj.QueueConfiguration).forEach((config2) => {
      var Id = toArray(config2.Id)[0];
      var Queue = toArray(config2.Queue)[0];
      var Event2 = genEvents(config2.Event);
      var Filter = genFilterRules(config2.Filter);
      result.QueueConfiguration.push({
        Id,
        Queue,
        Event: Event2,
        Filter
      });
    });
  }
  if (xmlobj.CloudFunctionConfiguration) {
    toArray(xmlobj.CloudFunctionConfiguration).forEach((config2) => {
      var Id = toArray(config2.Id)[0];
      var CloudFunction = toArray(config2.CloudFunction)[0];
      var Event2 = genEvents(config2.Event);
      var Filter = genFilterRules(config2.Filter);
      result.CloudFunctionConfiguration.push({
        Id,
        CloudFunction,
        Event: Event2,
        Filter
      });
    });
  }
  return result;
}
function parseListObjectsV2(xml2) {
  var result = {
    objects: [],
    isTruncated: false
  };
  var xmlobj = parseXml(xml2);
  if (!xmlobj.ListBucketResult) {
    throw new InvalidXMLError('Missing tag: "ListBucketResult"');
  }
  xmlobj = xmlobj.ListBucketResult;
  if (xmlobj.IsTruncated) {
    result.isTruncated = xmlobj.IsTruncated;
  }
  if (xmlobj.NextContinuationToken) {
    result.nextContinuationToken = xmlobj.NextContinuationToken;
  }
  if (xmlobj.Contents) {
    toArray(xmlobj.Contents).forEach((content) => {
      var name = sanitizeObjectKey(toArray(content.Key)[0]);
      var lastModified = new Date(content.LastModified);
      var etag = sanitizeETag(content.ETag);
      var size = content.Size;
      result.objects.push({
        name,
        lastModified,
        etag,
        size
      });
    });
  }
  if (xmlobj.CommonPrefixes) {
    toArray(xmlobj.CommonPrefixes).forEach((commonPrefix) => {
      result.objects.push({
        prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0]),
        size: 0
      });
    });
  }
  return result;
}

// node_modules/minio/dist/esm/transformers.mjs
function getConcater(parser, emitError) {
  var objectMode = false;
  var bufs = [];
  if (parser && !isFunction(parser)) {
    throw new TypeError('parser should be of type "function"');
  }
  if (parser) {
    objectMode = true;
  }
  return import_through2.default({
    objectMode
  }, function(chunk, enc, cb) {
    bufs.push(chunk);
    cb();
  }, function(cb) {
    if (emitError) {
      cb(parser(Buffer.concat(bufs).toString()));
      this.push(null);
      return;
    }
    if (bufs.length) {
      if (parser) {
        this.push(parser(Buffer.concat(bufs).toString()));
      } else {
        this.push(Buffer.concat(bufs));
      }
    }
    cb();
  });
}
function getListObjectsV2Transformer() {
  return getConcater(parseListObjectsV2);
}
function getBucketNotificationTransformer() {
  return getConcater(parseBucketNotification);
}
// node_modules/minio/dist/esm/minio.mjs
class Client extends TypedClient {
  listObjectsV2Query(bucketName, prefix, continuationToken, delimiter, maxKeys, startAfter) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isString(prefix)) {
      throw new TypeError('prefix should be of type "string"');
    }
    if (!isString(continuationToken)) {
      throw new TypeError('continuationToken should be of type "string"');
    }
    if (!isString(delimiter)) {
      throw new TypeError('delimiter should be of type "string"');
    }
    if (!isNumber(maxKeys)) {
      throw new TypeError('maxKeys should be of type "number"');
    }
    if (!isString(startAfter)) {
      throw new TypeError('startAfter should be of type "string"');
    }
    var queries = [];
    queries.push(`list-type=2`);
    queries.push(`encoding-type=url`);
    queries.push(`prefix=${uriEscape(prefix)}`);
    queries.push(`delimiter=${uriEscape(delimiter)}`);
    if (continuationToken) {
      continuationToken = uriEscape(continuationToken);
      queries.push(`continuation-token=${continuationToken}`);
    }
    if (startAfter) {
      startAfter = uriEscape(startAfter);
      queries.push(`start-after=${startAfter}`);
    }
    if (maxKeys) {
      if (maxKeys >= 1000) {
        maxKeys = 1000;
      }
      queries.push(`max-keys=${maxKeys}`);
    }
    queries.sort();
    var query = "";
    if (queries.length > 0) {
      query = `${queries.join("&")}`;
    }
    var method = "GET";
    var transformer = getListObjectsV2Transformer();
    this.makeRequest({
      method,
      bucketName,
      query
    }, "", [200], "", true, (e, response4) => {
      if (e) {
        return transformer.emit("error", e);
      }
      pipesetup(response4, transformer);
    });
    return transformer;
  }
  listObjectsV2(bucketName, prefix, recursive4, startAfter) {
    if (prefix === undefined) {
      prefix = "";
    }
    if (recursive4 === undefined) {
      recursive4 = false;
    }
    if (startAfter === undefined) {
      startAfter = "";
    }
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isValidPrefix(prefix)) {
      throw new InvalidPrefixError(`Invalid prefix : ${prefix}`);
    }
    if (!isString(prefix)) {
      throw new TypeError('prefix should be of type "string"');
    }
    if (!isBoolean(recursive4)) {
      throw new TypeError('recursive should be of type "boolean"');
    }
    if (!isString(startAfter)) {
      throw new TypeError('startAfter should be of type "string"');
    }
    var delimiter = recursive4 ? "" : "/";
    var continuationToken = "";
    var objects = [];
    var ended = false;
    var readStream = Stream.Readable({
      objectMode: true
    });
    readStream._read = () => {
      if (objects.length) {
        readStream.push(objects.shift());
        return;
      }
      if (ended) {
        return readStream.push(null);
      }
      this.listObjectsV2Query(bucketName, prefix, continuationToken, delimiter, 1000, startAfter).on("error", (e) => readStream.emit("error", e)).on("data", (result) => {
        if (result.isTruncated) {
          continuationToken = result.nextContinuationToken;
        } else {
          ended = true;
        }
        objects = result.objects;
        readStream._read();
      });
    };
    return readStream;
  }
  setBucketNotification(bucketName, config2, cb) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isObject(config2)) {
      throw new TypeError('notification config should be of type "Object"');
    }
    if (!isFunction(cb)) {
      throw new TypeError('callback should be of type "function"');
    }
    var method = "PUT";
    var query = "notification";
    var builder = new import_xml2js2.default.Builder({
      rootName: "NotificationConfiguration",
      renderOpts: {
        pretty: false
      },
      headless: true
    });
    var payload = builder.buildObject(config2);
    this.makeRequest({
      method,
      bucketName,
      query
    }, payload, [200], "", false, cb);
  }
  removeAllBucketNotification(bucketName, cb) {
    this.setBucketNotification(bucketName, new NotificationConfig, cb);
  }
  getBucketNotification(bucketName, cb) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError("Invalid bucket name: " + bucketName);
    }
    if (!isFunction(cb)) {
      throw new TypeError('callback should be of type "function"');
    }
    var method = "GET";
    var query = "notification";
    this.makeRequest({
      method,
      bucketName,
      query
    }, "", [200], "", true, (e, response4) => {
      if (e) {
        return cb(e);
      }
      var transformer = getBucketNotificationTransformer();
      var bucketNotification;
      pipesetup(response4, transformer).on("data", (result) => bucketNotification = result).on("error", (e3) => cb(e3)).on("end", () => cb(null, bucketNotification));
    });
  }
  listenBucketNotification(bucketName, prefix, suffix, events) {
    if (!isValidBucketName(bucketName)) {
      throw new InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);
    }
    if (!isString(prefix)) {
      throw new TypeError("prefix must be of type string");
    }
    if (!isString(suffix)) {
      throw new TypeError("suffix must be of type string");
    }
    if (!Array.isArray(events)) {
      throw new TypeError("events must be of type Array");
    }
    let listener = new NotificationPoller(this, bucketName, prefix, suffix, events);
    listener.start();
    return listener;
  }
}
Client.prototype.getBucketNotification = promisify2(Client.prototype.getBucketNotification);
Client.prototype.setBucketNotification = promisify2(Client.prototype.setBucketNotification);
Client.prototype.removeAllBucketNotification = promisify2(Client.prototype.removeAllBucketNotification);
Client.prototype.makeBucket = callbackify(Client.prototype.makeBucket);
Client.prototype.bucketExists = callbackify(Client.prototype.bucketExists);
Client.prototype.removeBucket = callbackify(Client.prototype.removeBucket);
Client.prototype.listBuckets = callbackify(Client.prototype.listBuckets);
Client.prototype.getObject = callbackify(Client.prototype.getObject);
Client.prototype.fGetObject = callbackify(Client.prototype.fGetObject);
Client.prototype.getPartialObject = callbackify(Client.prototype.getPartialObject);
Client.prototype.statObject = callbackify(Client.prototype.statObject);
Client.prototype.putObjectRetention = callbackify(Client.prototype.putObjectRetention);
Client.prototype.putObject = callbackify(Client.prototype.putObject);
Client.prototype.fPutObject = callbackify(Client.prototype.fPutObject);
Client.prototype.removeObject = callbackify(Client.prototype.removeObject);
Client.prototype.removeBucketReplication = callbackify(Client.prototype.removeBucketReplication);
Client.prototype.setBucketReplication = callbackify(Client.prototype.setBucketReplication);
Client.prototype.getBucketReplication = callbackify(Client.prototype.getBucketReplication);
Client.prototype.getObjectLegalHold = callbackify(Client.prototype.getObjectLegalHold);
Client.prototype.setObjectLegalHold = callbackify(Client.prototype.setObjectLegalHold);
Client.prototype.setObjectLockConfig = callbackify(Client.prototype.setObjectLockConfig);
Client.prototype.getObjectLockConfig = callbackify(Client.prototype.getObjectLockConfig);
Client.prototype.getBucketPolicy = callbackify(Client.prototype.getBucketPolicy);
Client.prototype.setBucketPolicy = callbackify(Client.prototype.setBucketPolicy);
Client.prototype.getBucketTagging = callbackify(Client.prototype.getBucketTagging);
Client.prototype.getObjectTagging = callbackify(Client.prototype.getObjectTagging);
Client.prototype.setBucketTagging = callbackify(Client.prototype.setBucketTagging);
Client.prototype.removeBucketTagging = callbackify(Client.prototype.removeBucketTagging);
Client.prototype.setObjectTagging = callbackify(Client.prototype.setObjectTagging);
Client.prototype.removeObjectTagging = callbackify(Client.prototype.removeObjectTagging);
Client.prototype.getBucketVersioning = callbackify(Client.prototype.getBucketVersioning);
Client.prototype.setBucketVersioning = callbackify(Client.prototype.setBucketVersioning);
Client.prototype.selectObjectContent = callbackify(Client.prototype.selectObjectContent);
Client.prototype.setBucketLifecycle = callbackify(Client.prototype.setBucketLifecycle);
Client.prototype.getBucketLifecycle = callbackify(Client.prototype.getBucketLifecycle);
Client.prototype.removeBucketLifecycle = callbackify(Client.prototype.removeBucketLifecycle);
Client.prototype.setBucketEncryption = callbackify(Client.prototype.setBucketEncryption);
Client.prototype.getBucketEncryption = callbackify(Client.prototype.getBucketEncryption);
Client.prototype.removeBucketEncryption = callbackify(Client.prototype.removeBucketEncryption);
Client.prototype.getObjectRetention = callbackify(Client.prototype.getObjectRetention);
Client.prototype.removeObjects = callbackify(Client.prototype.removeObjects);
Client.prototype.removeIncompleteUpload = callbackify(Client.prototype.removeIncompleteUpload);
Client.prototype.copyObject = callbackify(Client.prototype.copyObject);
Client.prototype.composeObject = callbackify(Client.prototype.composeObject);
Client.prototype.presignedUrl = callbackify(Client.prototype.presignedUrl);
Client.prototype.presignedGetObject = callbackify(Client.prototype.presignedGetObject);
Client.prototype.presignedPutObject = callbackify(Client.prototype.presignedPutObject);
Client.prototype.presignedPostPolicy = callbackify(Client.prototype.presignedPostPolicy);

// src/libs/minioClient.ts
var MinioClient = new Client({
  endPoint: Bun.env.MINIO_HOST,
  accessKey: Bun.env.MINIO_ACCESS_KEY,
  secretKey: Bun.env.MINIO_SECRET_KEY,
  useSSL: true
});
var minioClient_default = MinioClient;

// node_modules/peek-readable/lib/EndOfStreamError.js
var defaultMessages = "End-Of-Stream";

class EndOfStreamError extends Error {
  constructor() {
    super(defaultMessages);
  }
}
// node_modules/peek-readable/lib/AbstractStreamReader.js
class AbstractStreamReader {
  constructor() {
    this.maxStreamReadSize = 1 * 1024 * 1024;
    this.endOfStream = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, offset, length) {
    const bytesRead = await this.read(uint8Array, offset, length);
    this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
    return bytesRead;
  }
  async read(buffer, offset, length) {
    if (length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer, offset, length);
    bytesRead += await this.readRemainderFromStream(buffer, offset + bytesRead, length - bytesRead);
    if (bytesRead === 0) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  readFromPeekBuffer(buffer, offset, length) {
    let remaining = length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, offset, initialRemaining) {
    let remaining = initialRemaining;
    let bytesRead = 0;
    while (remaining > 0 && !this.endOfStream) {
      const reqLen = Math.min(remaining, this.maxStreamReadSize);
      const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
      remaining -= chunkLen;
    }
    return bytesRead;
  }
}
// node_modules/peek-readable/lib/WebStreamReader.js
class WebStreamReader extends AbstractStreamReader {
  constructor(stream5) {
    super();
    this.reader = stream5.getReader({ mode: "byob" });
  }
  async readFromStream(buffer, offset, length) {
    if (this.endOfStream) {
      throw new EndOfStreamError;
    }
    const result = await this.reader.read(new Uint8Array(length));
    if (result.done) {
      this.endOfStream = result.done;
    }
    if (result.value) {
      buffer.set(result.value, offset);
      return result.value.byteLength;
    }
    return 0;
  }
  async abort() {
    await this.reader.cancel();
    this.reader.releaseLock();
  }
}
// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async ignore(length) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
}

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256000;

class ReadStreamTokenizer extends AbstractTokenizer {
  constructor(streamReader, options) {
    super(options);
    this.streamReader = streamReader;
    this.fileInfo = options?.fileInfo ?? {};
  }
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const skipBytes = normOptions.position - this.position;
    if (skipBytes > 0) {
      await this.ignore(skipBytes);
      return this.readBuffer(uint8Array, options);
    }
    if (skipBytes < 0) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    if (normOptions.length === 0) {
      return 0;
    }
    const bytesRead = await this.streamReader.read(uint8Array, 0, normOptions.length);
    this.position += bytesRead;
    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    let bytesRead = 0;
    if (normOptions.position) {
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
        bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
        uint8Array.set(skipBuffer.subarray(skipBytes));
        return bytesRead - skipBytes;
      }
      if (skipBytes < 0) {
        throw new Error("Cannot peek from a negative offset in a stream");
      }
    }
    if (normOptions.length > 0) {
      try {
        bytesRead = await this.streamReader.peek(uint8Array, 0, normOptions.length);
      } catch (err) {
        if (options?.mayBeLess && err instanceof EndOfStreamError) {
          return 0;
        }
        throw err;
      }
      if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
    }
    return bytesRead;
  }
  async ignore(length) {
    const bufSize = Math.min(maxBufferSize, length);
    const buf = new Uint8Array(bufSize);
    let totBytesRead = 0;
    while (totBytesRead < length) {
      const remaining = length - totBytesRead;
      const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
      if (bytesRead < 0) {
        return bytesRead;
      }
      totBytesRead += bytesRead;
    }
    return totBytesRead;
  }
  abort() {
    return this.streamReader.abort();
  }
  supportsRandomAccess() {
    return false;
  }
}

// node_modules/strtok3/lib/BufferTokenizer.js
class BufferTokenizer extends AbstractTokenizer {
  constructor(uint8Array, options) {
    super(options);
    this.uint8Array = uint8Array;
    this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
  }
  async readBuffer(uint8Array, options) {
    if (options?.position) {
      this.position = options.position;
    }
    const bytesRead = await this.peekBuffer(uint8Array, options);
    this.position += bytesRead;
    return bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
    if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
      throw new EndOfStreamError;
    }
    uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
    return bytes2read;
  }
  close() {
    return super.close();
  }
  supportsRandomAccess() {
    return true;
  }
  setPosition(position) {
    this.position = position;
  }
}
// node_modules/strtok3/lib/core.js
function fromWebStream(webStream, options) {
  return new ReadStreamTokenizer(new WebStreamReader(webStream), options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}

// node_modules/strtok3/lib/FileTokenizer.js
import {open as fsOpen} from "fs/promises";

class FileTokenizer extends AbstractTokenizer {
  static async fromFile(sourceFilePath) {
    const fileHandle = await fsOpen(sourceFilePath, "r");
    const stat = await fileHandle.stat();
    return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
  }
  constructor(fileHandle, options) {
    super(options);
    this.fileHandle = fileHandle;
    this.fileInfo = options.fileInfo;
  }
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    this.position = normOptions.position;
    if (normOptions.length === 0)
      return 0;
    const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
    this.position += res.bytesRead;
    if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
      throw new EndOfStreamError;
    }
    return res.bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
    if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
      throw new EndOfStreamError;
    }
    return res.bytesRead;
  }
  async close() {
    await this.fileHandle.close();
    return super.close();
  }
  setPosition(position) {
    this.position = position;
  }
  supportsRandomAccess() {
    return true;
  }
}
// node_modules/strtok3/lib/index.js
var fromFile = FileTokenizer.fromFile;

// node_modules/ieee754/index.js
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

// node_modules/token-types/lib/index.js
function dv(array5) {
  return new DataView(array5.buffer, array5.byteOffset);
}
var UINT8 = {
  len: 1,
  get(array5, offset) {
    return dv(array5).getUint8(offset);
  },
  put(array5, offset, value15) {
    dv(array5).setUint8(offset, value15);
    return offset + 1;
  }
};
var UINT16_LE = {
  len: 2,
  get(array5, offset) {
    return dv(array5).getUint16(offset, true);
  },
  put(array5, offset, value15) {
    dv(array5).setUint16(offset, value15, true);
    return offset + 2;
  }
};
var UINT16_BE = {
  len: 2,
  get(array5, offset) {
    return dv(array5).getUint16(offset);
  },
  put(array5, offset, value15) {
    dv(array5).setUint16(offset, value15);
    return offset + 2;
  }
};
var UINT32_LE = {
  len: 4,
  get(array5, offset) {
    return dv(array5).getUint32(offset, true);
  },
  put(array5, offset, value15) {
    dv(array5).setUint32(offset, value15, true);
    return offset + 4;
  }
};
var UINT32_BE = {
  len: 4,
  get(array5, offset) {
    return dv(array5).getUint32(offset);
  },
  put(array5, offset, value15) {
    dv(array5).setUint32(offset, value15);
    return offset + 4;
  }
};
var INT32_BE = {
  len: 4,
  get(array5, offset) {
    return dv(array5).getInt32(offset);
  },
  put(array5, offset, value15) {
    dv(array5).setInt32(offset, value15);
    return offset + 4;
  }
};
var UINT64_LE = {
  len: 8,
  get(array5, offset) {
    return dv(array5).getBigUint64(offset, true);
  },
  put(array5, offset, value15) {
    dv(array5).setBigUint64(offset, value15, true);
    return offset + 8;
  }
};
class StringType2 {
  constructor(len, encoding5) {
    this.len = len;
    this.encoding = encoding5;
    this.textDecoder = new TextDecoder(encoding5);
  }
  get(uint8Array, offset) {
    return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
  }
}

// node_modules/fflate/esm/index.mjs
import {createRequire} from "module";
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var require2 = createRequire("/");
var Worker;
try {
  Worker = require2("worker_threads").Worker;
} catch (e) {
}
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i3 = 0;i3 < 31; ++i3) {
    b[i3] = start += 1 << eb[i3 - 1];
  }
  var r = new i32(b[30]);
  for (var i3 = 1;i3 < 30; ++i3) {
    for (var j = b[i3];j < b[i3 + 1]; ++j) {
      r[j] = j - b[i3] << 5 | i3;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i3 = 0;i3 < 32768; ++i3) {
  x3 = (i3 & 43690) >> 1 | (i3 & 21845) << 1;
  x3 = (x3 & 52428) >> 2 | (x3 & 13107) << 2;
  x3 = (x3 & 61680) >> 4 | (x3 & 3855) << 4;
  rev[i3] = ((x3 & 65280) >> 8 | (x3 & 255) << 8) >> 1;
}
var x3;
var i3;
var hMap = function(cd, mb, r) {
  var s3 = cd.length;
  var i3 = 0;
  var l3 = new u16(mb);
  for (;i3 < s3; ++i3) {
    if (cd[i3])
      ++l3[cd[i3] - 1];
  }
  var le = new u16(mb);
  for (i3 = 1;i3 < mb; ++i3) {
    le[i3] = le[i3 - 1] + l3[i3 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i3 = 0;i3 < s3; ++i3) {
      if (cd[i3]) {
        var sv = i3 << 4 | cd[i3];
        var r_1 = mb - cd[i3];
        var v3 = le[cd[i3] - 1]++ << r_1;
        for (var m3 = v3 | (1 << r_1) - 1;v3 <= m3; ++v3) {
          co[rev[v3] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s3);
    for (i3 = 0;i3 < s3; ++i3) {
      if (cd[i3]) {
        co[i3] = rev[le[cd[i3] - 1]++] >> 15 - cd[i3];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i3 = 0;i3 < 144; ++i3)
  flt[i3] = 8;
var i3;
for (i3 = 144;i3 < 256; ++i3)
  flt[i3] = 9;
var i3;
for (i3 = 256;i3 < 280; ++i3)
  flt[i3] = 7;
var i3;
for (i3 = 280;i3 < 288; ++i3)
  flt[i3] = 8;
var i3;
var fdt = new u8(32);
for (i3 = 0;i3 < 32; ++i3)
  fdt[i3] = 5;
var i3;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a) {
  var m3 = a[0];
  for (var i3 = 1;i3 < a.length; ++i3) {
    if (a[i3] > m3)
      m3 = a[i3];
  }
  return m3;
};
var bits = function(d3, p, m3) {
  var o3 = p / 8 | 0;
  return (d3[o3] | d3[o3 + 1] << 8) >> (p & 7) & m3;
};
var bits16 = function(d3, p) {
  var o3 = p / 8 | 0;
  return (d3[o3] | d3[o3 + 1] << 8 | d3[o3 + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v3, s3, e) {
  if (s3 == null || s3 < 0)
    s3 = 0;
  if (e == null || e > v3.length)
    e = v3.length;
  return new u8(v3.subarray(s3, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l4) {
    var bl = buf.length;
    if (l4 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l4));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type50 = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type50) {
        var s3 = shft(pos) + 4, l3 = dat[s3 - 4] | dat[s3 - 3] << 8, t3 = s3 + l3;
        if (t3 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l3);
        buf.set(dat.subarray(s3, t3), bt);
        st.b = bt += l3, st.p = pos = t3 * 8, st.f = final;
        continue;
      } else if (type50 == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type50 == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i3 = 0;i3 < hcLen; ++i3) {
          clt[clim[i3]] = bits(dat, pos + i3 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i3 = 0;i3 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s3 = r >> 4;
          if (s3 < 16) {
            ldt[i3++] = s3;
          } else {
            var c3 = 0, n3 = 0;
            if (s3 == 16)
              n3 = 3 + bits(dat, pos, 3), pos += 2, c3 = ldt[i3 - 1];
            else if (s3 == 17)
              n3 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s3 == 18)
              n3 = 11 + bits(dat, pos, 127), pos += 7;
            while (n3--)
              ldt[i3++] = c3;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c3 = lm[bits16(dat, pos) & lms], sym = c3 >> 4;
      pos += c3 & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c3)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i3 = sym - 257, b = fleb[i3];
          add = bits(dat, pos, (1 << b) - 1) + fl[i3];
          pos += b;
        }
        var d3 = dm[bits16(dat, pos) & dms], dsym = d3 >> 4;
        if (!d3)
          err(3);
        pos += d3 & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (;bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var gzs = function(d3) {
  if (d3[0] != 31 || d3[1] != 139 || d3[2] != 8)
    err(6, "invalid gzip data");
  var flg = d3[3];
  var st = 10;
  if (flg & 4)
    st += (d3[10] | d3[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1);zs > 0; zs -= !d3[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d3) {
  var l3 = d3.length;
  return (d3[l3 - 4] | d3[l3 - 3] << 8 | d3[l3 - 2] << 16 | d3[l3 - 1] << 24) >>> 0;
};
var zls = function(d3, dict) {
  if ((d3[0] & 15) != 8 || d3[0] >> 4 > 7 || (d3[0] << 8 | d3[1]) % 31)
    err(6, "invalid zlib data");
  if ((d3[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d3[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d3[1] >> 3 & 4) + 2;
};
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}

// node_modules/@tokenizer/inflate/lib/index.js
var import_debug = __toESM(require_src(), 1);

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature = {
  LocalFileHeader: 67324752,
  DataDescriptor: 134695760,
  CentralFileHeader: 33639248,
  EndOfCentralDirectory: 101010256
};
var DataDescriptor = {
  get(array5) {
    const flags = UINT16_LE.get(array5, 6);
    return {
      signature: UINT32_LE.get(array5, 0),
      compressedSize: UINT32_LE.get(array5, 8),
      uncompressedSize: UINT32_LE.get(array5, 12)
    };
  },
  len: 16
};
var LocalFileHeaderToken = {
  get(array5) {
    const flags = UINT16_LE.get(array5, 6);
    return {
      signature: UINT32_LE.get(array5, 0),
      minVersion: UINT16_LE.get(array5, 4),
      dataDescriptor: !!(flags & 8),
      compressedMethod: UINT16_LE.get(array5, 8),
      compressedSize: UINT32_LE.get(array5, 18),
      uncompressedSize: UINT32_LE.get(array5, 22),
      filenameLength: UINT16_LE.get(array5, 26),
      extraFieldLength: UINT16_LE.get(array5, 28),
      filename: null
    };
  },
  len: 30
};
var EndOfCentralDirectoryRecordToken = {
  get(array5) {
    return {
      signature: UINT32_LE.get(array5, 0),
      nrOfThisDisk: UINT16_LE.get(array5, 4),
      nrOfThisDiskWithTheStart: UINT16_LE.get(array5, 6),
      nrOfEntriesOnThisDisk: UINT16_LE.get(array5, 8),
      nrOfEntriesOfSize: UINT16_LE.get(array5, 10),
      sizeOfCd: UINT32_LE.get(array5, 12),
      offsetOfStartOfCd: UINT32_LE.get(array5, 16),
      zipFileCommentLength: UINT16_LE.get(array5, 20)
    };
  },
  len: 22
};
var FileHeader = {
  get(array5) {
    const flags = UINT16_LE.get(array5, 8);
    return {
      signature: UINT32_LE.get(array5, 0),
      minVersion: UINT16_LE.get(array5, 6),
      dataDescriptor: !!(flags & 8),
      compressedMethod: UINT16_LE.get(array5, 10),
      compressedSize: UINT32_LE.get(array5, 20),
      uncompressedSize: UINT32_LE.get(array5, 24),
      filenameLength: UINT16_LE.get(array5, 28),
      extraFieldLength: UINT16_LE.get(array5, 30),
      fileCommentLength: UINT16_LE.get(array5, 32),
      relativeOffsetOfLocalHeader: UINT32_LE.get(array5, 42),
      filename: null
    };
  },
  len: 46
};

// node_modules/@tokenizer/inflate/lib/index.js
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}
function indexOf(buffer, portion) {
  const bufferLength = buffer.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength)
    return -1;
  for (let i3 = 0;i3 <= bufferLength - portionLength; i3++) {
    let found = true;
    for (let j = 0;j < portionLength; j++) {
      if (buffer[i3 + j] !== portion[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      return i3;
    }
  }
  return -1;
}
function mergeArrays(chunks) {
  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    mergedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return mergedArray;
}
var debug = import_debug.default("tokenizer:inflate");
var syncBufferSize = 256 * 1024;
var ddSignatureArray = signatureToArray(Signature.DataDescriptor);
var eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);

class ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i3 = buffer.length - 4;i3 >= 0; i3--) {
      if (buffer[i3] === eocdSignatureBytes[0] && buffer[i3 + 1] === eocdSignatureBytes[1] && buffer[i3 + 2] === eocdSignatureBytes[2] && buffer[i3 + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i3;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug("Cannot reading central-directory without random-read support");
      return;
    }
    debug("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n3 = 0;n3 < eocdHeader.nrOfEntriesOfSize; ++n3) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType2(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug(`Add central-directory file-entry: n=${n3 + 1}/${files.length}: filename=${files[n3].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) {
      return this.iterateOverCentralDirectory(entries, fileCb);
    }
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = undefined;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else {
            await this.tokenizer.ignore(size);
          }
        }
        debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
        }
      } else {
        if (next.handler) {
          debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        } else {
          debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType2(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
}

// node_modules/uint8array-extras/index.js
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}
function indexOf2(array5, value15) {
  const arrayLength = array5.length;
  const valueLength = value15.length;
  if (valueLength === 0) {
    return -1;
  }
  if (valueLength > arrayLength) {
    return -1;
  }
  const validOffsetLength = arrayLength - valueLength;
  for (let index2 = 0;index2 <= validOffsetLength; index2++) {
    let isMatch = true;
    for (let index22 = 0;index22 < valueLength; index22++) {
      if (array5[index2 + index22] !== value15[index22]) {
        isMatch = false;
        break;
      }
    }
    if (isMatch) {
      return index2;
    }
  }
  return -1;
}
function includes(array5, value15) {
  return indexOf2(array5, value15) !== -1;
}
var cachedDecoders = {
  utf8: new globalThis.TextDecoder("utf8")
};
var cachedEncoder = new globalThis.TextEncoder;
var byteToHexLookupTable = Array.from({ length: 256 }, (_5, index2) => index2.toString(16).padStart(2, "0"));

// node_modules/file-type/util.js
function stringToBytes(string7) {
  return [...string7].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType2(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index2 = offset;index2 < offset + 148; index2++) {
    sum += arrayBuffer[index2];
  }
  for (let index2 = offset + 156;index2 < offset + 512; index2++) {
    sum += arrayBuffer[index2];
  }
  return readSum === sum;
}
var uint32SyncSafeToken = {
  get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
  len: 4
};

// node_modules/file-type/supported.js
var extensions2 = [
  "jpg",
  "png",
  "apng",
  "gif",
  "webp",
  "flif",
  "xcf",
  "cr2",
  "cr3",
  "orf",
  "arw",
  "dng",
  "nef",
  "rw2",
  "raf",
  "tif",
  "bmp",
  "icns",
  "jxr",
  "psd",
  "indd",
  "zip",
  "tar",
  "rar",
  "gz",
  "bz2",
  "7z",
  "dmg",
  "mp4",
  "mid",
  "mkv",
  "webm",
  "mov",
  "avi",
  "mpg",
  "mp2",
  "mp3",
  "m4a",
  "oga",
  "ogg",
  "ogv",
  "opus",
  "flac",
  "wav",
  "spx",
  "amr",
  "pdf",
  "epub",
  "elf",
  "macho",
  "exe",
  "swf",
  "rtf",
  "wasm",
  "woff",
  "woff2",
  "eot",
  "ttf",
  "otf",
  "ico",
  "flv",
  "ps",
  "xz",
  "sqlite",
  "nes",
  "crx",
  "xpi",
  "cab",
  "deb",
  "ar",
  "rpm",
  "Z",
  "lz",
  "cfb",
  "mxf",
  "mts",
  "blend",
  "bpg",
  "docx",
  "pptx",
  "xlsx",
  "3gp",
  "3g2",
  "j2c",
  "jp2",
  "jpm",
  "jpx",
  "mj2",
  "aif",
  "qcp",
  "odt",
  "ods",
  "odp",
  "xml",
  "mobi",
  "heic",
  "cur",
  "ktx",
  "ape",
  "wv",
  "dcm",
  "ics",
  "glb",
  "pcap",
  "dsf",
  "lnk",
  "alias",
  "voc",
  "ac3",
  "m4v",
  "m4p",
  "m4b",
  "f4v",
  "f4p",
  "f4b",
  "f4a",
  "mie",
  "asf",
  "ogm",
  "ogx",
  "mpc",
  "arrow",
  "shp",
  "aac",
  "mp1",
  "it",
  "s3m",
  "xm",
  "ai",
  "skp",
  "avif",
  "eps",
  "lzh",
  "pgp",
  "asar",
  "stl",
  "chm",
  "3mf",
  "zst",
  "jxl",
  "vcf",
  "jls",
  "pst",
  "dwg",
  "parquet",
  "class",
  "arj",
  "cpio",
  "ace",
  "avro",
  "icc",
  "fbx",
  "vsdx",
  "vtt",
  "apk",
  "drc",
  "lz4",
  "potx",
  "xltx",
  "dotx",
  "xltm",
  "ott",
  "ots",
  "otp",
  "odg",
  "otg",
  "xlsm",
  "docm",
  "dotm",
  "potm",
  "pptm",
  "jar"
];
var mimeTypes = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "image/flif",
  "image/x-xcf",
  "image/x-canon-cr2",
  "image/x-canon-cr3",
  "image/tiff",
  "image/bmp",
  "image/vnd.ms-photo",
  "image/vnd.adobe.photoshop",
  "application/x-indesign",
  "application/epub+zip",
  "application/x-xpinstall",
  "application/vnd.oasis.opendocument.text",
  "application/vnd.oasis.opendocument.spreadsheet",
  "application/vnd.oasis.opendocument.presentation",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "application/zip",
  "application/x-tar",
  "application/x-rar-compressed",
  "application/gzip",
  "application/x-bzip2",
  "application/x-7z-compressed",
  "application/x-apple-diskimage",
  "application/x-apache-arrow",
  "video/mp4",
  "audio/midi",
  "video/x-matroska",
  "video/webm",
  "video/quicktime",
  "video/vnd.avi",
  "audio/wav",
  "audio/qcelp",
  "audio/x-ms-asf",
  "video/x-ms-asf",
  "application/vnd.ms-asf",
  "video/mpeg",
  "video/3gpp",
  "audio/mpeg",
  "audio/mp4",
  "video/ogg",
  "audio/ogg",
  "audio/ogg; codecs=opus",
  "application/ogg",
  "audio/x-flac",
  "audio/ape",
  "audio/wavpack",
  "audio/amr",
  "application/pdf",
  "application/x-elf",
  "application/x-mach-binary",
  "application/x-msdownload",
  "application/x-shockwave-flash",
  "application/rtf",
  "application/wasm",
  "font/woff",
  "font/woff2",
  "application/vnd.ms-fontobject",
  "font/ttf",
  "font/otf",
  "image/x-icon",
  "video/x-flv",
  "application/postscript",
  "application/eps",
  "application/x-xz",
  "application/x-sqlite3",
  "application/x-nintendo-nes-rom",
  "application/x-google-chrome-extension",
  "application/vnd.ms-cab-compressed",
  "application/x-deb",
  "application/x-unix-archive",
  "application/x-rpm",
  "application/x-compress",
  "application/x-lzip",
  "application/x-cfb",
  "application/x-mie",
  "application/mxf",
  "video/mp2t",
  "application/x-blender",
  "image/bpg",
  "image/j2c",
  "image/jp2",
  "image/jpx",
  "image/jpm",
  "image/mj2",
  "audio/aiff",
  "application/xml",
  "application/x-mobipocket-ebook",
  "image/heif",
  "image/heif-sequence",
  "image/heic",
  "image/heic-sequence",
  "image/icns",
  "image/ktx",
  "application/dicom",
  "audio/x-musepack",
  "text/calendar",
  "text/vcard",
  "text/vtt",
  "model/gltf-binary",
  "application/vnd.tcpdump.pcap",
  "audio/x-dsf",
  "application/x.ms.shortcut",
  "application/x.apple.alias",
  "audio/x-voc",
  "audio/vnd.dolby.dd-raw",
  "audio/x-m4a",
  "image/apng",
  "image/x-olympus-orf",
  "image/x-sony-arw",
  "image/x-adobe-dng",
  "image/x-nikon-nef",
  "image/x-panasonic-rw2",
  "image/x-fujifilm-raf",
  "video/x-m4v",
  "video/3gpp2",
  "application/x-esri-shape",
  "audio/aac",
  "audio/x-it",
  "audio/x-s3m",
  "audio/x-xm",
  "video/MP1S",
  "video/MP2P",
  "application/vnd.sketchup.skp",
  "image/avif",
  "application/x-lzh-compressed",
  "application/pgp-encrypted",
  "application/x-asar",
  "model/stl",
  "application/vnd.ms-htmlhelp",
  "model/3mf",
  "image/jxl",
  "application/zstd",
  "image/jls",
  "application/vnd.ms-outlook",
  "image/vnd.dwg",
  "application/x-parquet",
  "application/java-vm",
  "application/x-arj",
  "application/x-cpio",
  "application/x-ace-compressed",
  "application/avro",
  "application/vnd.iccprofile",
  "application/x.autodesk.fbx",
  "application/vnd.visio",
  "application/vnd.android.package-archive",
  "application/vnd.google.draco",
  "application/x-lz4",
  "application/vnd.openxmlformats-officedocument.presentationml.template",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
  "application/vnd.ms-excel.template.macroenabled.12",
  "application/vnd.oasis.opendocument.text-template",
  "application/vnd.oasis.opendocument.spreadsheet-template",
  "application/vnd.oasis.opendocument.presentation-template",
  "application/vnd.oasis.opendocument.graphics",
  "application/vnd.oasis.opendocument.graphics-template",
  "application/vnd.ms-excel.sheet.macroEnabled.12",
  "application/vnd.ms-word.document.macroEnabled.12",
  "application/vnd.ms-word.template.macroEnabled.12",
  "application/vnd.ms-powerpoint.template.macroEnabled.12",
  "application/vnd.ms-powerpoint.presentation.macroEnabled.12",
  "application/java-archive"
];

// node_modules/file-type/core.js
async function fileTypeFromBuffer(input) {
  return new FileTypeParser().fromBuffer(input);
}
function getFileTypeFromMimeType(mimeType) {
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: "application/epub+zip"
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: "application/vnd.oasis.opendocument.text"
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: "application/vnd.oasis.opendocument.text-template"
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: "application/vnd.oasis.opendocument.spreadsheet"
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: "application/vnd.oasis.opendocument.spreadsheet-template"
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: "application/vnd.oasis.opendocument.presentation"
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: "application/vnd.oasis.opendocument.presentation-template"
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: "application/vnd.oasis.opendocument.graphics"
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: "application/vnd.oasis.opendocument.graphics-template"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
      };
    case "application/vnd.ms-excel.sheet.macroEnabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroEnabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.template"
      };
    case "application/vnd.ms-excel.template.macroEnabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
      };
    case "application/vnd.ms-word.document.macroEnabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroEnabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.template"
      };
    case "application/vnd.ms-word.template.macroEnabledTemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroEnabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: "application/vnd.openxmlformats-officedocument.presentationml.template"
      };
    case "application/vnd.ms-powerpoint.template.macroEnabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroEnabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
      };
    case "application/vnd.ms-powerpoint.presentation.macroEnabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroEnabled.12"
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio"
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf"
      };
    default:
  }
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index2, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index2] & buffer[index2 + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index2 + options.offset]) {
      return false;
    }
  }
  return true;
}
var reasonableDetectionSizeInBytes = 4100;

class FileTypeParser {
  constructor(options) {
    this.detectors = [
      ...options?.customDetectors ?? [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options?.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream5) {
    const tokenizer = await fromWebStream(stream5, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream5, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream5.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk;
      if (!done && chunk) {
        try {
          detectedFileType = await this.fromBuffer(chunk.slice(0, sampleSize));
        } catch (error23) {
          if (!(error23 instanceof EndOfStreamError)) {
            throw error23;
          }
          detectedFileType = undefined;
        }
      }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      }
    });
    const newStream = stream5.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === undefined) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
    if (this.check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (this.check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (this.check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (this.check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
      if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (this.check([31, 160]) || this.check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (this.check([199, 113])) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.check([96, 234])) {
      return {
        ext: "arj",
        mime: "application/x-arj"
      };
    }
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (this.check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (this.check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (this.check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 })) {
        return {
          ext: "jls",
          mime: "image/jls"
        };
      }
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (this.check([79, 98, 106, 1])) {
      return {
        ext: "avro",
        mime: "application/avro"
      };
    }
    if (this.checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (this.checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (this.checkString("WEBP", { offset: 8 })) {
      return {
        ext: "webp",
        mime: "image/webp"
      };
    }
    if (this.checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (this.checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (this.checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
            return {
              stop: true
            };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive"
            };
            return {
              stop: true
            };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive"
              };
              return { stop: true };
            }
            return {};
        }
      });
      return fileType ?? {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type50 = new Uint8Array(8);
      await tokenizer.readBuffer(type50);
      if (_check(type50, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus"
        };
      }
      if (_check(type50, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type50, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type50, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type50, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type50, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (this.checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (this.checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (this.checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/x-flac"
      };
    }
    if (this.check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (this.checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (this.checkString("%PDF")) {
      try {
        await tokenizer.ignore(1350);
        const maxBufferSize2 = 10 * 1024 * 1024;
        const buffer = new Uint8Array(Math.min(maxBufferSize2, tokenizer.fileInfo.size));
        await tokenizer.readBuffer(buffer, { mayBeLess: true });
        if (includes(buffer, new TextEncoder().encode("AIPrivateData"))) {
          return {
            ext: "ai",
            mime: "application/postscript"
          };
        }
      } catch (error23) {
        if (!(error23 instanceof EndOfStreamError)) {
          throw error23;
        }
      }
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (this.check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) {
        return fileType;
      }
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) {
        return fileType;
      }
    }
    if (this.checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> lengthField.length - 1;
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView)
        };
      }
      async function readChildren(children2) {
        while (children2 > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(new StringType2(element.len));
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children2;
        }
      }
      const re = await readElement();
      const documentType = await readChildren(re.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/x-matroska"
          };
        default:
          return;
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (this.check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/wav"
        };
      }
      if (this.check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (this.checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (this.check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (this.checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (this.checkString("MSCF") || this.checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (this.check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (this.check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (this.check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (this.check([127, 69, 76, 70])) {
      return {
        ext: "elf",
        mime: "application/x-elf"
      };
    }
    if (this.check([33, 66, 68, 78])) {
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook"
      };
    }
    if (this.checkString("PAR1")) {
      return {
        ext: "parquet",
        mime: "application/x-parquet"
      };
    }
    if (this.check([207, 250, 237, 254])) {
      return {
        ext: "macho",
        mime: "application/x-mach-binary"
      };
    }
    if (this.check([4, 34, 77, 24])) {
      return {
        ext: "lz4",
        mime: "application/x-lz4"
      };
    }
    if (this.check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (this.checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (this.checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (this.check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (this.checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (this.check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (this.checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (this.check([202, 254, 186, 190])) {
      return {
        ext: "class",
        mime: "application/java-vm"
      };
    }
    if (this.checkString("DRACO")) {
      return {
        ext: "drc",
        mime: "application/vnd.google.draco"
      };
    }
    if (this.check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (this.checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (this.check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (this.checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (this.checkString("AC")) {
      const version = new StringType2(4, "latin1").get(this.buffer, 2);
      if (version.match("^d*") && version >= 1000 && version <= 1050) {
        return {
          ext: "dwg",
          mime: "image/vnd.dwg"
        };
      }
    }
    if (this.checkString("070707")) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string7 = await tokenizer.readToken(new StringType2(13, "ascii"));
      if (string7 === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (this.checkString("WEBVTT") && ["\n", "\r", "\t", " ", "\0"].some((char7) => this.checkString(char7, { offset: 6 }))) {
      return {
        ext: "vtt",
        mime: "text/vtt"
      };
    }
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType2(4, "latin1"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/x-apache-arrow"
      };
    }
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (this.checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      const brandMajor = new StringType2(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = new Uint8Array(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (this.check([255, 79, 255, 81])) {
      return {
        ext: "j2c",
        mime: "image/j2c"
      };
    }
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type50 = await tokenizer.readToken(new StringType2(4, "ascii"));
      switch (type50) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      return;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([97, 99, 115, 112], { offset: 36 })) {
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile"
      };
    }
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
      return {
        ext: "ace",
        mime: "application/x-ace-compressed"
      };
    }
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (this.checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (this.checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (this.checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (this.checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
        try {
          const header = new TextDecoder().decode(this.buffer.slice(16, jsonSize + 16));
          const json2 = JSON.parse(header);
          if (json2.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch {
        }
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (this.checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (this.check([71]) && this.check([71], { offset: 188 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (this.check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (this.checkString("Kaydara FBX Binary  \0")) {
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx"
      };
    }
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (tarHeaderChecksumMatches(this.buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      return;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (this.check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (this.check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (this.check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    if (this.buffer.length >= 2 && this.check([255, 224], { offset: 0, mask: [255, 224] })) {
      if (this.check([16], { offset: 1, mask: [22] })) {
        if (this.check([8], { offset: 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  };
  async readTiffTag(bigEndian2) {
    const tagId = await this.tokenizer.readToken(bigEndian2 ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian2) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian2 ? UINT16_BE : UINT16_LE);
    for (let n3 = 0;n3 < numberOfTags; ++n3) {
      const fileType = await this.readTiffTag(bigEndian2);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian2) {
    const version = (bigEndian2 ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian2 ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian2 ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian2 ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian2);
      return fileType ?? {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
}
var supportedExtensions = new Set(extensions2);
var supportedMimeTypes = new Set(mimeTypes);
// src/utils/minioUtils.ts
var isMetaDataImg = async (values) => {
  const buffer = new Uint8Array(values);
  const type50 = await fileTypeFromBuffer(buffer);
  if (!type50?.mime?.startsWith("image/")) {
    return false;
  }
  return true;
};
var getMinioPublicLink = async (fileName) => {
  return await minioClient_default.presignedUrl("GET", Bun.env.MINIO_BUCKET_NAME, fileName);
};
var getMiniObject = async (fileName) => {
  return await minioClient_default.getObject(Bun.env.MINIO_BUCKET_NAME, fileName);
};

// src/api/controller/user/uploadAvatar.ts
var import_short_unique_id = __toESM(require_short_unique_id(), 1);
var uid = new import_short_unique_id.default({ length: 10 });
var uploadAvatar_default = createElysia().use(userGuard).post("/avatar", async ({ body: { file }, user: user3 }) => {
  const buffer = await file.arrayBuffer();
  const isImage = await isMetaDataImg(buffer);
  if (!isImage) {
    throw new BadRequestException("File must be an image");
  }
  const bucketName = Bun.env.MINIO_BUCKET_NAME;
  const fileName = `avatars/${user3.id}_${uid.rnd()}_${file.name}`;
  const currentUser = await prisma.user.findUnique({
    where: { id: user3.id },
    select: { avatarMinioKey: true }
  });
  if (currentUser?.avatarMinioKey) {
    try {
      await minioClient_default.removeObject(bucketName, currentUser.avatarMinioKey);
      lokiLogger_default.info({
        message: "Old avatar deleted",
        userId: user3.id,
        key: currentUser.avatarMinioKey
      });
    } catch (error23) {
      lokiLogger_default.warn({
        message: "Failed to delete old avatar",
        userId: user3.id,
        error: error23 instanceof Error ? error23.message : "Unknown error"
      });
    }
  }
  await minioClient_default.putObject(bucketName, fileName, Buffer.from(buffer), buffer.byteLength, {
    "Content-Type": file.type
  });
  const avatarUrl = await minioClient_default.presignedUrl("GET", bucketName, fileName, 7 * 24 * 60 * 60);
  await prisma.user.update({
    where: { id: user3.id },
    data: {
      avatarUrl,
      avatarMinioKey: fileName
    }
  });
  lokiLogger_default.info({
    message: "Avatar uploaded",
    userId: user3.id,
    fileName
  });
  return {
    status: 200,
    message: "Avatar uploaded successfully",
    data: {
      avatarUrl
    }
  };
}, {
  body: C.Object({
    file: C.File({
      type: ["image/png", "image/jpeg", "image/gif", "image/webp"],
      maxSize: 5 * 1024 * 1024
    })
  }),
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String(),
      data: C.Object({
        avatarUrl: C.String()
      })
    })
  },
  detail: {
    tags: ["User"],
    summary: "Upload user avatar",
    description: "Upload or update user avatar image (replaces existing)"
  }
});

// src/api/controller/user/uploadBanner.ts
var import_short_unique_id2 = __toESM(require_short_unique_id(), 1);
var uid2 = new import_short_unique_id2.default({ length: 10 });
var uploadBanner_default = createElysia().use(userGuard).post("/banner", async ({ body: { file }, user: user3 }) => {
  const buffer = await file.arrayBuffer();
  const isImage = await isMetaDataImg(buffer);
  if (!isImage) {
    throw new BadRequestException("File must be an image");
  }
  const bucketName = Bun.env.MINIO_BUCKET_NAME;
  const fileName = `banners/${user3.id}_${uid2.rnd()}_${file.name}`;
  const currentUser = await prisma.user.findUnique({
    where: { id: user3.id },
    select: { bannerMinioKey: true }
  });
  if (currentUser?.bannerMinioKey) {
    try {
      await minioClient_default.removeObject(bucketName, currentUser.bannerMinioKey);
      lokiLogger_default.info({
        message: "Old banner deleted",
        userId: user3.id,
        key: currentUser.bannerMinioKey
      });
    } catch (error23) {
      lokiLogger_default.warn({
        message: "Failed to delete old banner",
        userId: user3.id,
        error: error23 instanceof Error ? error23.message : "Unknown error"
      });
    }
  }
  await minioClient_default.putObject(bucketName, fileName, Buffer.from(buffer), buffer.byteLength, {
    "Content-Type": file.type
  });
  const bannerUrl = await minioClient_default.presignedUrl("GET", bucketName, fileName, 7 * 24 * 60 * 60);
  await prisma.user.update({
    where: { id: user3.id },
    data: {
      bannerUrl,
      bannerMinioKey: fileName
    }
  });
  lokiLogger_default.info({
    message: "Banner uploaded",
    userId: user3.id,
    fileName
  });
  return {
    status: 200,
    message: "Banner uploaded successfully",
    data: {
      bannerUrl
    }
  };
}, {
  body: C.Object({
    file: C.File({
      type: ["image/png", "image/jpeg", "image/gif", "image/webp"],
      maxSize: 10 * 1024 * 1024
    })
  }),
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String(),
      data: C.Object({
        bannerUrl: C.String()
      })
    })
  },
  detail: {
    tags: ["User"],
    summary: "Upload user banner",
    description: "Upload or update user banner image (replaces existing)"
  }
});

// src/api/controller/user/deleteAvatar.ts
var deleteAvatar_default = createElysia().use(userGuard).delete("/avatar", async ({ user: user3 }) => {
  const currentUser = await prisma.user.findUnique({
    where: { id: user3.id },
    select: { avatarMinioKey: true }
  });
  if (!currentUser?.avatarMinioKey) {
    throw new NotFoundException("No avatar found to delete");
  }
  const bucketName = Bun.env.MINIO_BUCKET_NAME;
  try {
    await minioClient_default.removeObject(bucketName, currentUser.avatarMinioKey);
    await prisma.user.update({
      where: { id: user3.id },
      data: {
        avatarUrl: null,
        avatarMinioKey: null
      }
    });
    lokiLogger_default.info({
      message: "Avatar deleted",
      userId: user3.id,
      key: currentUser.avatarMinioKey
    });
    return {
      status: 200,
      message: "Avatar deleted successfully"
    };
  } catch (error23) {
    lokiLogger_default.error({
      message: "Failed to delete avatar",
      userId: user3.id,
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    throw error23;
  }
}, {
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String()
    })
  },
  detail: {
    tags: ["User"],
    summary: "Delete user avatar",
    description: "Remove user avatar from Minio storage"
  }
});

// src/api/controller/user/deleteBanner.ts
var deleteBanner_default = createElysia().use(userGuard).delete("/banner", async ({ user: user3 }) => {
  const currentUser = await prisma.user.findUnique({
    where: { id: user3.id },
    select: { bannerMinioKey: true }
  });
  if (!currentUser?.bannerMinioKey) {
    throw new NotFoundException("No banner found to delete");
  }
  const bucketName = Bun.env.MINIO_BUCKET_NAME;
  try {
    await minioClient_default.removeObject(bucketName, currentUser.bannerMinioKey);
    await prisma.user.update({
      where: { id: user3.id },
      data: {
        bannerUrl: null,
        bannerMinioKey: null
      }
    });
    lokiLogger_default.info({
      message: "Banner deleted",
      userId: user3.id,
      key: currentUser.bannerMinioKey
    });
    return {
      status: 200,
      message: "Banner deleted successfully"
    };
  } catch (error23) {
    lokiLogger_default.error({
      message: "Failed to delete banner",
      userId: user3.id,
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    throw error23;
  }
}, {
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String()
    })
  },
  detail: {
    tags: ["User"],
    summary: "Delete user banner",
    description: "Remove user banner from Minio storage"
  }
});

// src/api/controller/user/getAvatar.ts
var getAvatar_default = createElysia().use(userGuard).get("/avatar", async ({ user: user3 }) => {
  const currentUser = await prisma.user.findUnique({
    where: { id: user3.id },
    select: { avatarMinioKey: true }
  });
  if (!currentUser?.avatarMinioKey) {
    throw new NotFoundException("No avatar found");
  }
  const bucketName = Bun.env.MINIO_BUCKET_NAME;
  const expirySeconds = 7 * 24 * 60 * 60;
  try {
    const url = await minioClient_default.presignedUrl("GET", bucketName, currentUser.avatarMinioKey, expirySeconds);
    lokiLogger_default.info({
      message: "Avatar URL generated",
      userId: user3.id
    });
    return {
      status: 200,
      message: "Avatar URL retrieved successfully",
      data: {
        url,
        expiresIn: expirySeconds
      }
    };
  } catch (error23) {
    lokiLogger_default.error({
      message: "Failed to generate avatar URL",
      userId: user3.id,
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    throw error23;
  }
}, {
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String(),
      data: C.Object({
        url: C.String(),
        expiresIn: C.Number()
      })
    })
  },
  detail: {
    tags: ["User"],
    summary: "Get user avatar",
    description: "Get presigned URL for user avatar from Minio"
  }
});

// src/api/controller/user/getBanner.ts
var getBanner_default = createElysia().use(userGuard).get("/banner", async ({ user: user3 }) => {
  const currentUser = await prisma.user.findUnique({
    where: { id: user3.id },
    select: { bannerMinioKey: true }
  });
  if (!currentUser?.bannerMinioKey) {
    throw new NotFoundException("No banner found");
  }
  const bucketName = Bun.env.MINIO_BUCKET_NAME;
  const expirySeconds = 7 * 24 * 60 * 60;
  try {
    const url = await minioClient_default.presignedUrl("GET", bucketName, currentUser.bannerMinioKey, expirySeconds);
    lokiLogger_default.info({
      message: "Banner URL generated",
      userId: user3.id
    });
    return {
      status: 200,
      message: "Banner URL retrieved successfully",
      data: {
        url,
        expiresIn: expirySeconds
      }
    };
  } catch (error23) {
    lokiLogger_default.error({
      message: "Failed to generate banner URL",
      userId: user3.id,
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    throw error23;
  }
}, {
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String(),
      data: C.Object({
        url: C.String(),
        expiresIn: C.Number()
      })
    })
  },
  detail: {
    tags: ["User"],
    summary: "Get user banner",
    description: "Get presigned URL for user banner from Minio"
  }
});

// src/libs/cloudinary.ts
var import_cloudinary = __toESM(require_cloudinary(), 1);
import_cloudinary.v2.config({
  cloud_name: Bun.env.CLOUDINARY_CLOUD_NAME,
  api_key: Bun.env.CLOUDINARY_API_KEY,
  api_secret: Bun.env.CLOUDINARY_API_SECRET
});

// src/models/cloudinary.model.ts
var cloudinaryModel = new j0().model({
  "cloudinary.model": C.Object({
    image: C.String()
  })
});
var cloudinary_model_default = cloudinaryModel;

// src/api/controller/asset/cloudinaryUpload.ts
var cloudinaryUpload_default = createElysia().use(cloudinary_model_default).use(authGuard).post("/cloudinary", async ({ body }) => {
  const secureUrl = await import_cloudinary.v2.uploader.upload(body.image, {
    transformation: [{ fetch_format: "auto" }]
  });
  return {
    status: "200",
    data: {
      secureUrl
    }
  };
}, {
  body: "cloudinary.model",
  tags: ["Assets"]
});

// src/api/controller/asset/minioUpload.ts
var import_short_unique_id3 = __toESM(require_short_unique_id(), 1);

// src/models/minio.model.ts
var minioModel = new j0().model({
  "minio.upload": C.Object({
    file: C.File({
      type: ["image/png", "image/jpeg", "image/gif", "image/bmp", "image/webp"],
      maxSize: 5 * 1024 * 1024
    })
  }),
  "minio.download": C.Object({
    filename: C.String({})
  })
});

// src/api/controller/asset/minioUpload.ts
var minioUpload_default = createElysia().use(minioModel).use(authGuard).post("/minio", async ({ body }) => {
  try {
    const fileBuffer = await body.file.arrayBuffer();
    const { randomUUID } = new import_short_unique_id3.default({ length: 20 });
    if (!await isMetaDataImg(fileBuffer)) {
      return {
        data: null,
        message: "Uploaded file is not a valid image"
      };
    }
    const fileName = `${randomUUID()}.png`;
    const metadata = {
      "Content-Type": body.file.type,
      "Content-Length": body.file.size.toString()
    };
    await minioClient_default.putObject(Bun.env.MINIO_BUCKET_NAME, fileName, Buffer.from(fileBuffer), body.file.size, metadata);
    return {
      data: {
        fileName,
        publicLink: await getMinioPublicLink(fileName),
        bucket: Bun.env.MINIO_BUCKET_NAME,
        fileSize: body.file.size,
        metadata
      },
      message: "success"
    };
  } catch (error23) {
    return {
      data: "There is something wrong",
      message: error23
    };
  }
}, {
  body: "minio.upload",
  type: "multipart/form-data",
  tags: ["Assets"]
});

// src/api/controller/asset/minioDownload.ts
var minioDownload_default = createElysia().use(minioModel).post("/minio/download", async ({ body }) => {
  const chunks = [];
  for await (const chunk of await getMiniObject(body.filename)) {
    chunks.push(chunk);
  }
  const fileBuffer = Buffer.concat(chunks);
  const type50 = await fileTypeFromBuffer(new Uint8Array(fileBuffer));
  if (!type50) {
    return {
      data: null,
      message: "Unable to determine file type"
    };
  }
  const headers = {
    "Content-Type": type50?.mime ?? "image/jpeg",
    "Content-Disposition": `attachment; filename="${body.filename}"`
  };
  return new Response(fileBuffer, { headers });
}, {
  body: "minio.download",
  tags: ["Assets"]
}).post("/minio/download/public", async ({ body }) => {
  return {
    data: getMinioPublicLink(body.filename),
    message: "success"
  };
}, {
  body: "minio.download",
  tags: ["Assets"]
});

// src/api/controller/tools/getYoutubeDownloader.ts
var import_youtube_dl_exec = __toESM(require_src3(), 1);
var getYoutubeDownloader_default = createElysia().get("/", async () => {
  return {
    message: "YouTube Downloader API",
    endpoints: {
      info: "GET /info?url=YOUTUBE_URL - Get video information",
      download: "GET /download?url=YOUTUBE_URL&format=mp4|mp3 - Download video/audio"
    },
    usage: {
      "Get video info": "/info?url=https://youtube.com/watch?v=VIDEO_ID",
      "Download video": "/download?url=https://youtube.com/watch?v=VIDEO_ID&format=mp4",
      "Download audio": "/download?url=https://youtube.com/watch?v=VIDEO_ID&format=mp3"
    },
    note: "Requires yt-dlp or youtube-dl installed on the system. Install with: 'pip install yt-dlp' or 'brew install yt-dlp'"
  };
}, {
  detail: {
    tags: ["YouTube Downloader"],
    summary: "YouTube Downloader API Information"
  }
}).get("/info", async ({ query, set: set2 }) => {
  const { url } = query;
  if (!url) {
    set2.status = 400;
    return {
      success: false,
      error: "URL parameter is required"
    };
  }
  try {
    const result = await import_youtube_dl_exec.default(url, {
      dumpSingleJson: true,
      noCheckCertificates: true,
      noWarnings: true,
      preferFreeFormats: true
    });
    const info = result;
    return {
      success: true,
      data: {
        title: info.title,
        duration: info.duration,
        thumbnail: info.thumbnail,
        author: info.uploader || info.channel,
        viewCount: info.view_count,
        description: info.description,
        uploadDate: info.upload_date,
        formats: {
          video: info.formats?.filter((f3) => f3.vcodec !== "none" && f3.acodec !== "none").map((f3) => ({
            quality: f3.format_note || f3.height ? `${f3.height}p` : "unknown",
            format: f3.ext,
            filesize: f3.filesize || f3.filesize_approx,
            fps: f3.fps
          })).slice(0, 10) || [],
          audio: info.formats?.filter((f3) => f3.acodec !== "none" && f3.vcodec === "none").map((f3) => ({
            quality: f3.abr ? `${f3.abr}kbps` : "unknown",
            format: f3.ext,
            filesize: f3.filesize || f3.filesize_approx
          })).slice(0, 5) || []
        }
      }
    };
  } catch (error23) {
    set2.status = 500;
    return {
      success: false,
      error: error23.message || "Failed to fetch video information",
      hint: "Make sure yt-dlp is installed: pip install yt-dlp"
    };
  }
}, {
  query: C.Object({
    url: C.String()
  }),
  detail: {
    tags: ["YouTube Downloader"],
    summary: "Get YouTube video information",
    description: "Returns video metadata including title, duration, thumbnail, and available formats"
  }
}).get("/download", async ({ query, set: set2 }) => {
  const { url, format = "mp4" } = query;
  if (!url) {
    set2.status = 400;
    return { success: false, error: "URL parameter is required" };
  }
  try {
    const infoResult = await import_youtube_dl_exec.default(url, {
      dumpSingleJson: true,
      noCheckCertificates: true,
      noWarnings: true
    });
    const info = infoResult;
    const title = info.title.replace(/[^\w\s-]/gi, "").trim().replace(/\s+/g, "_");
    if (format === "mp3") {
      const audioResult = await import_youtube_dl_exec.default(url, {
        extractAudio: true,
        audioFormat: "mp3",
        audioQuality: 0,
        output: "-",
        noCheckCertificates: true,
        noWarnings: true
      });
      const audioBuffer = audioResult.stdout || audioResult;
      return new Response(audioBuffer, {
        headers: {
          "Content-Type": "audio/mpeg",
          "Content-Disposition": `attachment; filename="${title}.mp3"`
        }
      });
    } else {
      const videoResult = await import_youtube_dl_exec.default(url, {
        format: "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best",
        output: "-",
        noCheckCertificates: true,
        noWarnings: true
      });
      const videoBuffer = videoResult.stdout || videoResult;
      return new Response(videoBuffer, {
        headers: {
          "Content-Type": "video/mp4",
          "Content-Disposition": `attachment; filename="${title}.mp4"`
        }
      });
    }
  } catch (error23) {
    set2.status = 500;
    return {
      success: false,
      error: error23.message || "Failed to download video",
      hint: "Make sure yt-dlp is installed: pip install yt-dlp"
    };
  }
}, {
  query: C.Object({
    url: C.String(),
    format: C.Optional(C.Union([C.Literal("mp4"), C.Literal("mp3")]))
  }),
  detail: {
    tags: ["YouTube Downloader"],
    summary: "Download YouTube video or audio",
    description: "Downloads video as MP4 or audio as MP3 format. Requires yt-dlp installed on the system."
  }
});

// src/api/controller/tools/getKodeWilayahPos.ts
var getKodeWilayahPos_default = createElysia().get("/postal-code/info", async () => {
  return {
    message: "Indonesian Postal Code (Kode Pos) API",
    endpoints: {
      provinces: "GET /provinces - Get all provinces",
      cities: "GET /cities/:provinceId - Get cities by province ID",
      districts: "GET /districts/:cityId - Get districts by city ID",
      villages: "GET /villages/:districtId - Get villages by district ID",
      search: "GET /search?q=location_name - Search postal code by location name",
      postalCode: "GET /postal/:code - Get location details by postal code"
    },
    usage: {
      "Get provinces": "/provinces",
      "Get cities": "/cities/31",
      "Search location": "/search?q=jakarta",
      "Get by postal code": "/postal/12345"
    }
  };
}, {
  detail: {
    tags: ["Indonesian Postal Code"],
    summary: "Indonesian Postal Code API Information"
  }
}).get("/provinces", async () => {
  try {
    const response4 = await fetch("https://wilayah.id/api/provinces.json");
    const data = await response4.json();
    return {
      success: true,
      data: data.data || data,
      total: data.data?.length || data.length || 0
    };
  } catch (error23) {
    return {
      success: false,
      error: "Failed to fetch provinces data"
    };
  }
}, {
  detail: {
    tags: ["Indonesian Postal Code"],
    summary: "Get all Indonesian provinces"
  }
}).get("/cities/:provinceId", async ({ params }) => {
  const { provinceId } = params;
  try {
    const response4 = await fetch(`https://wilayah.id/api/regencies/${provinceId}.json`);
    const data = await response4.json();
    return {
      success: true,
      data: data.data || data,
      total: data.data?.length || data.length || 0
    };
  } catch (error23) {
    return {
      success: false,
      error: "Failed to fetch cities data"
    };
  }
}, {
  params: C.Object({
    provinceId: C.String()
  }),
  detail: {
    tags: ["Indonesian Postal Code"],
    summary: "Get cities by province ID"
  }
}).get("/districts/:cityId", async ({ params }) => {
  const { cityId } = params;
  try {
    const response4 = await fetch(`https://wilayah.id/api/districts/${cityId}.json`);
    const data = await response4.json();
    return {
      success: true,
      data: data.data || data,
      total: data.data?.length || data.length || 0
    };
  } catch (error23) {
    return {
      success: false,
      error: "Failed to fetch districts data"
    };
  }
}, {
  params: C.Object({
    cityId: C.String()
  }),
  detail: {
    tags: ["Indonesian Postal Code"],
    summary: "Get districts by city ID"
  }
}).get("/villages/:districtId", async ({ params }) => {
  const { districtId } = params;
  try {
    const response4 = await fetch(`https://wilayah.id/api/villages/${districtId}.json`);
    const data = await response4.json();
    return {
      success: true,
      data: data.data || data,
      total: data.data?.length || data.length || 0
    };
  } catch (error23) {
    return {
      success: false,
      error: "Failed to fetch villages data"
    };
  }
}, {
  params: C.Object({
    districtId: C.String()
  }),
  detail: {
    tags: ["Indonesian Postal Code"],
    summary: "Get villages by district ID"
  }
}).post("/cari-kode-pos", async ({ body }) => {
  const { kode_pos } = body;
  try {
    const response4 = await fetch(`https://api.lincah.id/api/check/zipcode`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ search: kode_pos })
    });
    const data = await response4.json();
    console.log(data);
    return {
      success: true,
      data: data.data || data,
      total: data.data?.length || data.length || 0
    };
  } catch (error23) {
    return {
      success: false,
      error: "Failed to search postal code"
    };
  }
}, {
  body: C.Object({
    kode_pos: C.String()
  }),
  detail: {
    tags: ["Indonesian Postal Code"],
    summary: "Search postal code by location name"
  }
});

// src/api/controller/tools/getAnime.ts
var getAnime_default = createElysia().get("/anime/waifu", async () => {
  const res = await fetch("https://api.waifu.pics/sfw/waifu");
  const { url } = await res.json();
  const imgRes = await fetch(url);
  const contentType = imgRes.headers.get("content-type") ?? "image/jpeg";
  return new Response(imgRes.body, {
    status: 200,
    headers: {
      "Content-Type": contentType
    }
  });
}, {
  detail: { tags: ["Anime"] }
}).get("/anime/neko", async () => {
  const res = await fetch("https://api.waifu.pics/sfw/neko");
  const { url } = await res.json();
  const imgRes = await fetch(url);
  const contentType = imgRes.headers.get("content-type") ?? "image/jpeg";
  return new Response(imgRes.body, {
    status: 200,
    headers: {
      "Content-Type": contentType
    }
  });
}, {
  detail: { tags: ["Anime"] }
}).get("/anime/cringe", async () => {
  const res = await fetch("https://api.waifu.pics/sfw/cringe");
  const { url } = await res.json();
  const imgRes = await fetch(url);
  const contentType = imgRes.headers.get("content-type") ?? "image/jpeg";
  return new Response(imgRes.body, {
    status: 200,
    headers: {
      "Content-Type": contentType
    }
  });
}, {
  detail: { tags: ["Anime"] }
}).get("/anime/blush", async () => {
  const res = await fetch("https://api.waifu.pics/sfw/blush");
  const { url } = await res.json();
  const imgRes = await fetch(url);
  const contentType = imgRes.headers.get("content-type") ?? "image/jpeg";
  return new Response(imgRes.body, {
    status: 200,
    headers: {
      "Content-Type": contentType
    }
  });
}, {
  detail: { tags: ["Anime"] }
}).get("/anime/dance", async () => {
  const res = await fetch("https://api.waifu.pics/sfw/dance");
  const { url } = await res.json();
  const imgRes = await fetch(url);
  const contentType = imgRes.headers.get("content-type") ?? "image/jpeg";
  return new Response(imgRes.body, {
    status: 200,
    headers: {
      "Content-Type": contentType
    }
  });
}, {
  detail: { tags: ["Anime"] }
});

// src/api/controller/tools/getPokemon.ts
var getPokemon_default = createElysia().get("/pokemon", async ({ query }) => {
  const { cursor, limit } = paginationQuerySchema.parse(query);
  const offset = parseCursorToNumber(cursor) || 0;
  try {
    const response4 = await fetch(`https://pokeapi.co/api/v2/pokemon?offset=${offset}&limit=${limit + 1}`);
    if (!response4.ok) {
      throw new Error("Failed to fetch Pokemon data");
    }
    const data = await response4.json();
    const pokemonList = data.results;
    const detailedPokemon = await Promise.all(pokemonList.slice(0, limit).map(async (pokemon) => {
      try {
        const detailResponse = await fetch(pokemon.url);
        const detail = await detailResponse.json();
        return {
          id: detail.id,
          name: detail.name,
          sprites: detail.sprites,
          types: detail.types,
          height: detail.height,
          weight: detail.weight
        };
      } catch (error23) {
        lokiLogger_default.error({
          message: "Failed to fetch Pokemon detail",
          pokemon: pokemon.name,
          error: error23 instanceof Error ? error23.message : "Unknown error"
        });
        return {
          id: offset + pokemonList.indexOf(pokemon) + 1,
          name: pokemon.name,
          url: pokemon.url
        };
      }
    }));
    const hasMore = pokemonList.length > limit;
    const nextOffset = hasMore ? offset + limit : null;
    return {
      status: 200,
      message: "Success",
      data: detailedPokemon,
      nextCursor: nextOffset ? Buffer.from(String(nextOffset)).toString("base64") : null,
      hasMore,
      total: data.count
    };
  } catch (error23) {
    lokiLogger_default.error({
      message: "Failed to fetch Pokemon list",
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    throw error23;
  }
}, {
  query: C.Object({
    cursor: C.Optional(C.String()),
    limit: C.Optional(C.Number({ minimum: 1, maximum: 50, default: 10 }))
  }),
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String(),
      data: C.Array(C.Object({
        id: C.Number(),
        name: C.String(),
        sprites: C.Optional(C.Object({
          front_default: C.String(),
          front_shiny: C.String(),
          other: C.Object({
            "official-artwork": C.Object({
              front_default: C.String()
            })
          })
        })),
        types: C.Optional(C.Array(C.Object({
          type: C.Object({
            name: C.String()
          })
        }))),
        height: C.Optional(C.Number()),
        weight: C.Optional(C.Number()),
        url: C.Optional(C.String())
      })),
      nextCursor: C.Nullable(C.String()),
      hasMore: C.Boolean(),
      total: C.Optional(C.Number())
    })
  },
  detail: {
    tags: ["Pokemon"],
    summary: "Get paginated Pokemon list",
    description: "Retrieve a paginated list of Pokemon from PokeAPI with detailed information"
  }
}).get("/pokemon/:id", async ({ params: { id } }) => {
  try {
    const response4 = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
    if (!response4.ok) {
      throw new Error("Pokemon not found");
    }
    const data = await response4.json();
    return {
      status: 200,
      message: "Success",
      data
    };
  } catch (error23) {
    lokiLogger_default.error({
      message: "Failed to fetch Pokemon",
      id,
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    throw error23;
  }
}, {
  params: C.Object({
    id: C.Union([C.String(), C.Number()])
  }),
  detail: {
    tags: ["Pokemon"],
    summary: "Get Pokemon by ID or name",
    description: "Get detailed information about a specific Pokemon"
  }
});

// src/api/controller/tools/getSpotify.ts
async function getSpotifyToken() {
  const clientId = "79096724149948bcbb7f2be2b15dd778";
  const clientSecret = "dfe1932b15824e71ac796fb4b2219e65";
  if (!clientId || !clientSecret)
    throw new Error("Spotify credentials not configured");
  const credentials = `${clientId}:${clientSecret}`;
  const encodedCredentials = Buffer.from(credentials).toString("base64");
  const response4 = await fetch("https://accounts.spotify.com/api/token", {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Authorization: `Basic ${encodedCredentials}`
    },
    body: "grant_type=client_credentials"
  });
  if (!response4.ok)
    throw new Error("Failed to get Spotify access token");
  const data = await response4.json();
  return data.access_token;
}
async function getCurrentlyPlaying(accessToken) {
  const response4 = await fetch("https://api.spotify.com/v1/me/player/currently-playing", {
    headers: {
      Authorization: `Bearer ${accessToken}`
    }
  });
  if (response4.status === 204 || response4.status === 404)
    return null;
  if (!response4.ok)
    throw new Error("Failed to get currently playing track");
  return await response4.json();
}
async function getRecentlyPlayed(accessToken, limit = 10) {
  const response4 = await fetch(`https://api.spotify.com/v1/me/player/recently-played?limit=${limit}`, {
    headers: {
      Authorization: `Bearer ${accessToken}`
    }
  });
  if (!response4.ok)
    throw new Error("Failed to get recently played tracks");
  return await response4.json();
}
async function getTopTracks(accessToken, timeRange = "medium_term", limit = 10) {
  const response4 = await fetch(`https://api.spotify.com/v1/me/top/tracks?time_range=${timeRange}&limit=${limit}`, {
    headers: {
      Authorization: `Bearer ${accessToken}`
    }
  });
  if (!response4.ok)
    throw new Error("Failed to get top tracks");
  return await response4.json();
}
var getSpotify_default = createElysia().get("/", async () => {
  return {
    message: "Spotify API",
    endpoints: {
      nowPlaying: "GET /now-playing?token=USER_ACCESS_TOKEN - Get currently playing track",
      recentlyPlayed: "GET /recently-played?token=USER_ACCESS_TOKEN&limit=10 - Get recently played tracks",
      topTracks: "GET /top-tracks?token=USER_ACCESS_TOKEN&time_range=medium_term&limit=10 - Get top tracks",
      search: "GET /search?q=query&type=track,artist,album - Search Spotify catalog"
    },
    note: "You need to provide a user access token for personalized endpoints. Use Spotify OAuth2 flow to get one.",
    oauth: {
      authorizeUrl: "https://accounts.spotify.com/authorize",
      scopes: ["user-read-currently-playing", "user-read-recently-played", "user-top-read"]
    }
  };
}, {
  detail: {
    tags: ["Spotify"],
    summary: "Spotify API Information"
  }
}).get("/now-playing", async ({ query }) => {
  const { token } = query;
  if (!token) {
    return {
      success: false,
      error: "Access token is required",
      help: "Get your token from Spotify OAuth2 flow"
    };
  }
  try {
    const data = await getCurrentlyPlaying(token);
    if (!data?.item) {
      return {
        success: true,
        is_playing: false,
        message: "Nothing is currently playing"
      };
    }
    return {
      success: true,
      is_playing: data.is_playing,
      track: {
        name: data.item.name,
        artists: data.item.artists.map((artist) => artist.name),
        album: data.item.album.name,
        album_art: data.item.album.images[0]?.url,
        duration_ms: data.item.duration_ms,
        progress_ms: data.progress_ms,
        spotify_url: data.item.external_urls.spotify
      },
      context: data.context
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to get currently playing track"
    };
  }
}, {
  query: C.Object({
    token: C.String()
  }),
  detail: {
    tags: ["Spotify"],
    summary: "Get currently playing track",
    description: "Returns the track currently being played by the user"
  }
}).get("/recently-played", async ({ query }) => {
  const { token, limit = "10" } = query;
  if (!token) {
    return {
      success: false,
      error: "Access token is required"
    };
  }
  try {
    const data = await getRecentlyPlayed(token, parseInt(limit));
    return {
      success: true,
      items: data.items.map((item) => ({
        played_at: item.played_at,
        track: {
          name: item.track.name,
          artists: item.track.artists.map((artist) => artist.name),
          album: item.track.album.name,
          album_art: item.track.album.images[0]?.url,
          duration_ms: item.track.duration_ms,
          spotify_url: item.track.external_urls.spotify
        }
      })),
      total: data.items.length
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to get recently played tracks"
    };
  }
}, {
  query: C.Object({
    token: C.String(),
    limit: C.Optional(C.String())
  }),
  detail: {
    tags: ["Spotify"],
    summary: "Get recently played tracks",
    description: "Returns tracks recently played by the user"
  }
}).get("/top-tracks", async ({ query }) => {
  const { token, time_range = "medium_term", limit = "10" } = query;
  if (!token) {
    return {
      success: false,
      error: "Access token is required"
    };
  }
  try {
    const data = await getTopTracks(token, time_range, parseInt(limit));
    return {
      success: true,
      time_range,
      items: data.items.map((track) => ({
        name: track.name,
        artists: track.artists.map((artist) => artist.name),
        album: track.album.name,
        album_art: track.album.images[0]?.url,
        popularity: track.popularity,
        duration_ms: track.duration_ms,
        spotify_url: track.external_urls.spotify
      })),
      total: data.items.length
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to get top tracks"
    };
  }
}, {
  query: C.Object({
    token: C.String(),
    time_range: C.Optional(C.Union([
      C.Literal("short_term"),
      C.Literal("medium_term"),
      C.Literal("long_term")
    ])),
    limit: C.Optional(C.String())
  }),
  detail: {
    tags: ["Spotify"],
    summary: "Get user's top tracks",
    description: "Returns user's top tracks based on time range (short_term: 4 weeks, medium_term: 6 months, long_term: all time)"
  }
}).get("/search", async ({ query }) => {
  const { q, type: type50 = "track", limit = "10" } = query;
  if (!q) {
    return {
      success: false,
      error: "Search query is required"
    };
  }
  try {
    const token = await getSpotifyToken();
    const response4 = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=${type50}&limit=${limit}`, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    if (!response4.ok)
      throw new Error("Failed to search Spotify");
    const data = await response4.json();
    return {
      success: true,
      query: q,
      results: data
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to search Spotify"
    };
  }
}, {
  query: C.Object({
    q: C.String(),
    type: C.Optional(C.String()),
    limit: C.Optional(C.String())
  }),
  detail: {
    tags: ["Spotify"],
    summary: "Search Spotify catalog",
    description: "Search for tracks, artists, albums, or playlists"
  }
});

// src/constants/linkedin.ts
var LINKEDIN_RECOMMENDATIONS_DATA = [
  {
    id: 1,
    name: "Rafidhiya Bagus Farizki",
    image: "https://media.licdn.com/dms/image/v2/D5603AQGkERXPkHBNKA/profile-displayphoto-scale_100_100/B56Zn_rwmkIYAc-/0/1760931286050?e=1762992000&v=beta&t=9bisIbZ0Jdwxkqfyio_IH3XGiHBkVbzPiASh9q8iEB0",
    message: "I am Pleased to be working together with Rizky for the past 3 Years. As a friend and colleagues I can say that Rizky have the capability to learn something new in a few time and most importantly always willing to teach me or my other colleagues if we having a difficulties. Best of luck Rizky!"
  },
  {
    id: 2,
    name: "Mochammad Iqbal Arizki",
    image: "https://media.licdn.com/dms/image/v2/D5603AQE8418uHNtRQw/profile-displayphoto-scale_100_100/B56ZmkCxsqI0Ac-/0/1759393816055?e=1762992000&v=beta&t=zQSG3Fq_gI8YqP7PIdObZDUSrlFi9V0xvmjeKH6Qt7k",
    message: "I have worked with Rizky Haksono as a Web developer and can attest to their coding and technical skills. We\u2019ve joined our hands on several projects, and Rizky Haksono is one of the best people I had as a partner. Rizky Haksono is highly skilled in Laravel and has consistently developed high-quality, scalable software solutions for our team. Rizky Haksono is able to quickly learn and adapt to new technologies, making them a valuable asset in a rapidly evolving field."
  },
  {
    id: 3,
    name: "Jody Yuantoro",
    image: "https://media.licdn.com/dms/image/v2/D5603AQG-NUv8PNIMtw/profile-displayphoto-scale_100_100/B56Zf6S_rtHIAk-/0/1752250974180?e=1762992000&v=beta&t=JkfFqLcROjZzia0CMUrSrhNoaSC7Jzrm_HZNzf4QLKM",
    message: "I had the pleasure of working closely with Rizky Haksono on a few mobile app project. He consistently impressed the team with his deep expertise in mobile development, demonstrating a strong command of Android platforms. His ability to create elegant and user-friendly interfaces, coupled with his knack for troubleshooting and problem-solving, made his an invaluable asset to our team. Rizky Haksono was not only proactive in staying updated with the latest industry trends, but also collaborated seamlessly with cross-functional teams, ensuring the successful and timely delivery of our app. He consistently went above and beyond, and I wouldn't hesitate to recommend him for any mobile development role."
  }
];

// src/constants/certifications.ts
var LINKEDIN_CERTIFICATIONS_DATA = [
  {
    id: 1,
    title: "AWS Educate Introduction to Generative AI",
    provider: "Amazon Web Services (AWS)",
    issued: "Jul 2025",
    image: "https://media.licdn.com/dms/image/v2/D4E0BAQFqdm1TZ-RZKQ/company-logo_100_100/B4EZgOay6gHEAY-/0/1752588562343/amazon_web_services_logo?e=1764806400&v=beta&t=0Bl558x7P-znlVSDh5GuLFFM4ZYZeHDmf1o2hjP5ZbI",
    link: "https://www.linkedin.com/redir/redirect/?url=https%3A%2F%2Fwww.credly.com%2Fbadges%2F37f9767a-0a97-4d9e-a7fd-666edd600d4e%2Flinked_in_profile&urlhash=Yx1r&isSdui=true&lipi=urn%3Ali%3Apage%3Ad_flagship3_profile_view_base_certifications_details%3BXASxNdcxQ3euG267twECZQ%3D%3D"
  }
];

// src/api/controller/tools/getLinkedIn.ts
var getLinkedIn_default = createElysia().get("/recommendations", async () => {
  return {
    success: true,
    data: LINKEDIN_RECOMMENDATIONS_DATA,
    total: LINKEDIN_RECOMMENDATIONS_DATA.length
  };
}, {
  detail: {
    tags: ["LinkedIn"],
    summary: "Get LinkedIn recommendations",
    description: "Retrieves recommendations and endorsements from LinkedIn profile"
  }
}).get("/certifications", async () => {
  const data = LINKEDIN_CERTIFICATIONS_DATA;
  const url = new URLSearchParams;
  const page = parseInt(url.get("page") || "1");
  const limit = parseInt(url.get("limit") || "10");
  const start = (page - 1) * limit;
  const end = start + limit;
  return {
    success: true,
    data: data.slice(start, end),
    total: data.length,
    page,
    limit
  };
}, {
  detail: {
    tags: ["LinkedIn"],
    summary: "Get LinkedIn certifications",
    description: "Retrieves certifications from LinkedIn profile"
  }
});

// src/api/controller/tools/getDuolingo.ts
async function getDuolingoUserData(username) {
  try {
    const response4 = await fetch(`https://www.duolingo.com/2017-06-30/users?username=${username}`, {
      headers: {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
      }
    });
    if (!response4.ok)
      throw new Error("Failed to fetch Duolingo user data");
    const data = await response4.json();
    const user3 = data.users[0];
    if (!user3)
      throw new Error("User not found");
    return {
      username: user3.username,
      name: user3.name,
      streak: user3.streak,
      totalXp: user3.totalXp,
      lingots: user3.lingots || 0,
      gems: user3.gems || 0,
      courses: user3.courses?.map((course) => ({
        language: course.title,
        level: course.crowns || 0,
        xp: course.xp || 0,
        skills: course.skills?.length || 0,
        wordsLearned: course.wordsLearned || 0,
        progress: course.xp > 0 ? Math.round(course.xp / (course.crowns * 1000) * 100) : 0
      })) || []
    };
  } catch (error23) {
    throw new Error(error23?.message || "Failed to fetch Duolingo data");
  }
}
async function getDailyGoal(username) {
  try {
    const response4 = await fetch(`https://www.duolingo.com/2017-06-30/users?username=${username}`, {
      headers: {
        "User-Agent": "Mozilla/5.0"
      }
    });
    if (!response4.ok)
      throw new Error("Failed to fetch daily goal data");
    const data = await response4.json();
    const user3 = data.users[0];
    return {
      dailyGoal: user3.dailyGoal || 10,
      xpToday: user3.xpGains?.[0]?.xp || 0,
      goalMet: (user3.xpGains?.[0]?.xp || 0) >= (user3.dailyGoal || 10),
      streak: user3.streak
    };
  } catch (error23) {
    throw new Error(error23?.message || "Failed to fetch daily goal data");
  }
}
var getDuolingo_default = createElysia().get("/", async () => {
  return {
    message: "Duolingo Progress API",
    endpoints: {
      profile: "GET /profile?username=USERNAME - Get user profile and progress",
      dailyGoal: "GET /daily-goal?username=USERNAME - Get daily goal progress",
      streak: "GET /streak?username=USERNAME - Get current streak"
    },
    note: "This uses the unofficial Duolingo API. Rate limits may apply.",
    example: {
      username: "rizkyhaksono"
    }
  };
}, {
  detail: {
    tags: ["Duolingo"],
    summary: "Duolingo API Information"
  }
}).get("/profile", async ({ query }) => {
  const { username } = query;
  if (!username) {
    return {
      success: false,
      error: "Username is required"
    };
  }
  try {
    const userData = await getDuolingoUserData(username);
    return {
      success: true,
      data: userData
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to fetch Duolingo profile"
    };
  }
}, {
  query: C.Object({
    username: C.String()
  }),
  detail: {
    tags: ["Duolingo"],
    summary: "Get Duolingo user profile",
    description: "Retrieves user profile, streak, XP, and course progress"
  }
}).get("/daily-goal", async ({ query }) => {
  const { username } = query;
  if (!username) {
    return {
      success: false,
      error: "Username is required"
    };
  }
  try {
    const goalData = await getDailyGoal(username);
    return {
      success: true,
      data: goalData
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to fetch daily goal"
    };
  }
}, {
  query: C.Object({
    username: C.String()
  }),
  detail: {
    tags: ["Duolingo"],
    summary: "Get daily goal progress",
    description: "Retrieves daily XP goal and progress"
  }
}).get("/streak", async ({ query }) => {
  const { username } = query;
  if (!username) {
    return {
      success: false,
      error: "Username is required"
    };
  }
  try {
    const userData = await getDuolingoUserData(username);
    return {
      success: true,
      data: {
        username: userData.username,
        streak: userData.streak,
        totalXp: userData.totalXp
      }
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to fetch streak data"
    };
  }
}, {
  query: C.Object({
    username: C.String()
  }),
  detail: {
    tags: ["Duolingo"],
    summary: "Get current streak",
    description: "Retrieves current learning streak"
  }
});

// src/api/controller/tools/getJapaneseQuiz.ts
async function getVocabularyByLevel(level, limit = 10) {
  try {
    const response4 = await fetch(`https://jisho.org/api/v1/search/words?keyword=%23jlpt-${level.toLowerCase()}`);
    if (!response4.ok)
      throw new Error("Failed to fetch vocabulary");
    const data = await response4.json();
    return data.data.slice(0, limit).map((item) => ({
      word: item.japanese[0]?.word || item.japanese[0]?.reading,
      reading: item.japanese[0]?.reading,
      meaning: item.senses[0]?.english_definitions?.join(", "),
      level,
      partOfSpeech: item.senses[0]?.parts_of_speech?.join(", ")
    }));
  } catch (error23) {
    throw new Error(error23?.message || "Failed to fetch vocabulary data");
  }
}
function generateQuiz(words, count = 10) {
  const shuffled = words.sort(() => 0.5 - Math.random());
  const selected = shuffled.slice(0, count);
  return selected.map((word, index2) => {
    const wrongAnswers = shuffled.filter((w) => w.word !== word.word).slice(0, 3).map((w) => w.meaning);
    const options = [word.meaning, ...wrongAnswers].sort(() => 0.5 - Math.random());
    return {
      id: index2 + 1,
      word: word.word,
      reading: word.reading,
      options,
      correct: word.meaning,
      level: word.level
    };
  });
}
var getJapaneseQuiz_default = createElysia().get("/", async () => {
  return {
    message: "Japanese Kotoba (Vocabulary) Quiz API",
    endpoints: {
      vocabulary: "GET /vocabulary?level=N5&limit=20 - Get vocabulary by JLPT level",
      quiz: "GET /quiz?level=N5&count=10 - Generate quiz questions",
      random: "GET /random?level=N5 - Get random word",
      levels: "GET /levels - Get all JLPT levels"
    },
    levels: ["N5", "N4", "N3", "N2", "N1"],
    note: "Uses Jisho API for Japanese vocabulary data"
  };
}, {
  detail: {
    tags: ["Japanese Quiz"],
    summary: "Japanese Quiz API Information"
  }
}).get("/levels", async () => {
  return {
    success: true,
    levels: [
      { code: "N5", name: "Beginner", description: "Basic vocabulary (~700 words)" },
      { code: "N4", name: "Elementary", description: "Elementary vocabulary (~1,500 words)" },
      { code: "N3", name: "Intermediate", description: "Intermediate vocabulary (~3,000 words)" },
      { code: "N2", name: "Pre-Advanced", description: "Pre-advanced vocabulary (~6,000 words)" },
      { code: "N1", name: "Advanced", description: "Advanced vocabulary (~10,000 words)" }
    ]
  };
}, {
  detail: {
    tags: ["Japanese Quiz"],
    summary: "Get JLPT levels",
    description: "Returns all available JLPT proficiency levels"
  }
}).get("/vocabulary", async ({ query }) => {
  const { level = "N5", limit = "20" } = query;
  const validLevels = ["N5", "N4", "N3", "N2", "N1"];
  const upperLevel = level.toUpperCase();
  if (!validLevels.includes(upperLevel)) {
    return {
      success: false,
      error: "Invalid level. Use N5, N4, N3, N2, or N1"
    };
  }
  try {
    const words = await getVocabularyByLevel(upperLevel, parseInt(limit));
    return {
      success: true,
      level: upperLevel,
      count: words.length,
      words
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to fetch vocabulary"
    };
  }
}, {
  query: C.Object({
    level: C.Optional(C.String()),
    limit: C.Optional(C.String())
  }),
  detail: {
    tags: ["Japanese Quiz"],
    summary: "Get vocabulary by level",
    description: "Retrieves Japanese vocabulary words for specified JLPT level"
  }
}).get("/quiz", async ({ query }) => {
  const { level = "N5", count = "10" } = query;
  const validLevels = ["N5", "N4", "N3", "N2", "N1"];
  const upperLevel = level.toUpperCase();
  if (!validLevels.includes(upperLevel)) {
    return {
      success: false,
      error: "Invalid level. Use N5, N4, N3, N2, or N1"
    };
  }
  try {
    const quizCount = parseInt(count);
    const words = await getVocabularyByLevel(upperLevel, quizCount * 4);
    const quiz = generateQuiz(words, quizCount);
    return {
      success: true,
      level: upperLevel,
      count: quiz.length,
      questions: quiz
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to generate quiz"
    };
  }
}, {
  query: C.Object({
    level: C.Optional(C.String()),
    count: C.Optional(C.String())
  }),
  detail: {
    tags: ["Japanese Quiz"],
    summary: "Generate quiz questions",
    description: "Generates multiple choice quiz questions for Japanese vocabulary"
  }
}).get("/random", async ({ query }) => {
  const { level = "N5" } = query;
  const validLevels = ["N5", "N4", "N3", "N2", "N1"];
  const upperLevel = level.toUpperCase();
  if (!validLevels.includes(upperLevel)) {
    return {
      success: false,
      error: "Invalid level. Use N5, N4, N3, N2, or N1"
    };
  }
  try {
    const words = await getVocabularyByLevel(upperLevel, 1);
    if (words.length === 0) {
      return {
        success: false,
        error: "No vocabulary found for this level"
      };
    }
    return {
      success: true,
      level: upperLevel,
      word: words[0]
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to fetch random word"
    };
  }
}, {
  query: C.Object({
    level: C.Optional(C.String())
  }),
  detail: {
    tags: ["Japanese Quiz"],
    summary: "Get random word",
    description: "Returns a random Japanese word for specified JLPT level"
  }
}).post("/verify", async ({ body }) => {
  const { questionId, answer, correct } = body;
  const isCorrect = answer === correct;
  return {
    success: true,
    questionId,
    isCorrect,
    message: isCorrect ? "Correct! \u3088\u304F\u3067\u304D\u307E\u3057\u305F\uFF01" : "Incorrect. Try again!"
  };
}, {
  body: C.Object({
    questionId: C.Number(),
    answer: C.String(),
    correct: C.String()
  }),
  detail: {
    tags: ["Japanese Quiz"],
    summary: "Verify quiz answer",
    description: "Checks if the submitted answer is correct"
  }
});

// src/api/controller/tools/getFacebookDownloader.ts
var getFacebookDownloader_default = createElysia().get("/facebook/downloader", async ({ query, set: set2 }) => {
  const { url } = query;
  if (!url) {
    set2.status = 400;
    return {
      success: false,
      error: "URL parameter is required"
    };
  }
  try {
    const response4 = await fetch(`https://www.getfvid.com/downloader`, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: new URLSearchParams({ url })
    });
    if (!response4.ok) {
      throw new Error("Failed to fetch video info");
    }
    const html = await response4.text();
    const hdMatch = html.match(/href="([^"]+)"[^>]*>Download in Normal Quality/);
    const sdMatch = html.match(/href="([^"]+)"[^>]*>Download in HD Quality/);
    return {
      success: true,
      data: {
        url,
        downloads: {
          hd: hdMatch ? hdMatch[1] : null,
          sd: sdMatch ? sdMatch[1] : null
        },
        note: "Download links expire after some time. Use them quickly."
      }
    };
  } catch (error23) {
    lokiLogger_default.error({
      message: "Facebook downloader error",
      url,
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    set2.status = 500;
    return {
      success: false,
      error: "Failed to extract Facebook video. Make sure the URL is valid and the video is public."
    };
  }
}, {
  query: C.Object({
    url: C.String({ format: "uri" })
  }),
  detail: {
    tags: ["Social Media Downloaders"],
    summary: "Facebook video downloader",
    description: "Extract download links for Facebook videos"
  }
});

// src/api/controller/tools/getInstagramDownloader.ts
var getInstagramDownloader_default = createElysia().get("/instagram/downloader", async ({ query, set: set2 }) => {
  const { url } = query;
  if (!url) {
    set2.status = 400;
    return {
      success: false,
      error: "URL parameter is required"
    };
  }
  try {
    const rapidApiKey = Bun.env.RAPIDAPI_KEY || "demo";
    const response4 = await fetch(`https://instagram-downloader-download-instagram-videos-stories.p.rapidapi.com/index?url=${encodeURIComponent(url)}`, {
      headers: {
        "X-RapidAPI-Key": rapidApiKey,
        "X-RapidAPI-Host": "instagram-downloader-download-instagram-videos-stories.p.rapidapi.com"
      }
    });
    if (!response4.ok) {
      throw new Error("Failed to fetch Instagram media");
    }
    const data = await response4.json();
    return {
      success: true,
      data: {
        url,
        media: data,
        note: rapidApiKey === "demo" ? "Configure RAPIDAPI_KEY environment variable for full access" : "Media extracted successfully"
      }
    };
  } catch (error23) {
    lokiLogger_default.error({
      message: "Instagram downloader error",
      url,
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    try {
      const shortcode = url.match(/\/p\/([A-Za-z0-9_-]+)/) || url.match(/\/reel\/([A-Za-z0-9_-]+)/);
      if (shortcode) {
        return {
          success: true,
          data: {
            url,
            shortcode: shortcode[1],
            embedUrl: `https://www.instagram.com/p/${shortcode[1]}/embed/`,
            note: "Use embed URL or configure RAPIDAPI_KEY for direct downloads"
          }
        };
      }
    } catch {
    }
    set2.status = 500;
    return {
      success: false,
      error: "Failed to extract Instagram media. Configure RAPIDAPI_KEY or ensure URL is valid."
    };
  }
}, {
  query: C.Object({
    url: C.String({ format: "uri" })
  }),
  detail: {
    tags: ["Social Media Downloaders"],
    summary: "Instagram media downloader",
    description: "Download photos, videos, reels from Instagram"
  }
});

// src/api/controller/tools/getTiktokDownloader.ts
var getTiktokDownloader_default = createElysia().get("/tiktok/downloader", async ({ query, set: set2 }) => {
  const { url } = query;
  if (!url) {
    set2.status = 400;
    return {
      success: false,
      error: "URL parameter is required"
    };
  }
  try {
    const apiUrl = `https://www.tikwm.com/api/?url=${encodeURIComponent(url)}`;
    const response4 = await fetch(apiUrl, {
      headers: {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
      }
    });
    if (!response4.ok) {
      throw new Error("Failed to fetch TikTok video");
    }
    const data = await response4.json();
    if (data.code !== 0) {
      throw new Error(data.msg || "Failed to process TikTok URL");
    }
    return {
      success: true,
      data: {
        url,
        video: {
          title: data.data.title,
          duration: data.data.duration,
          author: data.data.author?.nickname,
          authorUsername: data.data.author?.unique_id,
          cover: data.data.cover,
          playCount: data.data.play_count,
          likeCount: data.data.digg_count,
          commentCount: data.data.comment_count,
          shareCount: data.data.share_count,
          downloads: {
            noWatermark: data.data.play,
            watermark: data.data.wmplay,
            music: data.data.music
          }
        }
      }
    };
  } catch (error23) {
    lokiLogger_default.error({
      message: "TikTok downloader error",
      url,
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    set2.status = 500;
    return {
      success: false,
      error: "Failed to extract TikTok video. Make sure the URL is valid."
    };
  }
}, {
  query: C.Object({
    url: C.String({ format: "uri" })
  }),
  detail: {
    tags: ["Social Media Downloaders"],
    summary: "TikTok video downloader",
    description: "Download TikTok videos without watermark"
  }
});

// src/api/controller/tools/getXDownloader.ts
var getXDownloader_default = createElysia().get("/x/downloader", async ({ query, set: set2 }) => {
  const { url } = query;
  if (!url) {
    set2.status = 400;
    return {
      success: false,
      error: "URL parameter is required"
    };
  }
  try {
    const apiUrl = `https://twitsave.com/info?url=${encodeURIComponent(url)}`;
    const response4 = await fetch(apiUrl, {
      headers: {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
      }
    });
    if (!response4.ok) {
      throw new Error("Failed to fetch X/Twitter media");
    }
    const html = await response4.text();
    const videoMatch = html.match(/<a[^>]+href="([^"]+)"[^>]*>Download<\/a>/g);
    const titleMatch = html.match(/<div class="origin-top-right[^>]*>([^<]+)<\/div>/);
    const downloads = [];
    if (videoMatch) {
      videoMatch.forEach((match) => {
        const urlMatch = match.match(/href="([^"]+)"/);
        if (urlMatch) {
          downloads.push(urlMatch[1]);
        }
      });
    }
    return {
      success: true,
      data: {
        url,
        title: titleMatch ? titleMatch[1].trim() : "X Post",
        downloads: downloads.length > 0 ? downloads : null,
        note: downloads.length === 0 ? "No video found. This may be a text-only post or images." : "Video links extracted successfully"
      }
    };
  } catch (error23) {
    lokiLogger_default.error({
      message: "X/Twitter downloader error",
      url,
      error: error23 instanceof Error ? error23.message : "Unknown error"
    });
    try {
      const tweetIdMatch = url.match(/status\/(\d+)/);
      if (tweetIdMatch) {
        return {
          success: true,
          data: {
            url,
            tweetId: tweetIdMatch[1],
            embedUrl: `https://platform.twitter.com/embed/Tweet.html?id=${tweetIdMatch[1]}`,
            note: "Use embed URL to view the content"
          }
        };
      }
    } catch {
    }
    set2.status = 500;
    return {
      success: false,
      error: "Failed to extract X/Twitter media. Make sure the URL is valid."
    };
  }
}, {
  query: C.Object({
    url: C.String({ format: "uri" })
  }),
  detail: {
    tags: ["Social Media Downloaders"],
    summary: "X (Twitter) media downloader",
    description: "Download videos and media from X/Twitter posts"
  }
}).get("/twitter/downloader", async ({ query, set: set2 }) => {
  const { url } = query;
  if (!url) {
    set2.status = 400;
    return {
      success: false,
      error: "URL parameter is required"
    };
  }
  return {
    success: true,
    note: "Use /x/downloader endpoint instead. Twitter is now X.",
    redirectTo: `/tools/x/downloader?url=${encodeURIComponent(url)}`
  };
}, {
  query: C.Object({
    url: C.String({ format: "uri" })
  }),
  detail: {
    tags: ["Social Media Downloaders"],
    summary: "Twitter media downloader (deprecated)",
    description: "Use /x/downloader instead",
    deprecated: true
  }
});

// src/models/publicChat.model.ts
var publicChatModel = new j0().model({
  "publicChat.post": C.Object({
    message: C.String({ minLength: 1, maxLength: 1000 }),
    replyToId: C.Optional(C.String())
  }),
  "publicChat.update": C.Object({
    message: C.String({ minLength: 1, maxLength: 1000 })
  }),
  "publicChat.user": C.Object({
    id: C.String(),
    name: C.String(),
    avatarUrl: C.Nullable(C.String()),
    headline: C.Nullable(C.String())
  }),
  "publicChat.replyTo": C.Object({
    id: C.String(),
    message: C.String(),
    userId: C.String(),
    user: C.Ref("publicChat.user"),
    createdAt: C.Date()
  }),
  "publicChat.response": C.Object({
    id: C.String(),
    message: C.String(),
    userId: C.String(),
    user: C.Ref("publicChat.user"),
    replyToId: C.Nullable(C.String()),
    replyTo: C.Nullable(C.Ref("publicChat.replyTo")),
    replyCount: C.Optional(C.Number()),
    createdAt: C.Date(),
    updatedAt: C.Date()
  })
});

// src/api/controller/publicChat/createPost.ts
var createPost_default = createElysia().use(publicChatModel).use(userGuard).post("/", async ({ body, user: user3 }) => {
  const { message, replyToId } = body;
  if (replyToId) {
    const parentMessage = await prisma.publicChatMessage.findFirst({
      where: {
        id: replyToId,
        deletedAt: null
      }
    });
    if (!parentMessage) {
      throw new NotFoundException("Parent message not found");
    }
  }
  if (!replyToId) {
    const today = new Date;
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const existingPost = await prisma.publicChatMessage.findFirst({
      where: {
        userId: user3.id,
        replyToId: null,
        createdAt: {
          gte: today,
          lt: tomorrow
        },
        deletedAt: null
      }
    });
    if (existingPost) {
      throw new ForbiddenException("You can only post once per day. You can edit your existing post instead.");
    }
  }
  const post = await prisma.publicChatMessage.create({
    data: {
      message,
      userId: user3.id,
      replyToId: replyToId || null
    },
    include: {
      user: {
        select: {
          id: true,
          name: true,
          avatarUrl: true,
          headline: true
        }
      },
      replyTo: {
        select: {
          id: true,
          message: true,
          userId: true,
          createdAt: true,
          user: {
            select: {
              id: true,
              name: true,
              avatarUrl: true,
              headline: true
            }
          }
        }
      }
    }
  });
  lokiLogger_default.info({
    message: "Public chat message created",
    userId: user3.id,
    postId: post.id,
    isReply: !!replyToId
  });
  return {
    status: 201,
    message: "Message created successfully",
    data: post
  };
}, {
  body: "publicChat.post",
  response: {
    201: C.Object({
      status: C.Number(),
      message: C.String(),
      data: C.Any()
    })
  },
  detail: {
    tags: ["Public Chat"],
    summary: "Create a public chat message",
    description: "Authenticated users can post once per day (top-level messages only). Replies to messages are unlimited."
  }
});

// src/api/controller/publicChat/getAllPosts.ts
var getAllPosts_default = createElysia().use(publicChatModel).get("/", async ({ query }) => {
  const { cursor, limit } = paginationQuerySchema.parse(query);
  const cursorDate = parseCursorToDate(cursor);
  const posts = await prisma.publicChatMessage.findMany({
    where: {
      deletedAt: null,
      replyToId: null,
      ...cursorDate && {
        createdAt: {
          lt: cursorDate
        }
      }
    },
    orderBy: {
      createdAt: "desc"
    },
    take: limit + 1,
    include: {
      user: {
        select: {
          id: true,
          name: true,
          avatarUrl: true,
          headline: true
        }
      },
      _count: {
        select: {
          replies: true
        }
      }
    }
  });
  const paginatedResponse = createPaginatedResponse(posts, limit, (post) => post.createdAt);
  const dataWithReplyCount = paginatedResponse.data.map((post) => {
    const { _count, ...rest4 } = post;
    return {
      ...rest4,
      replyCount: _count?.replies || 0
    };
  });
  return {
    status: 200,
    message: "Success",
    data: dataWithReplyCount,
    nextCursor: paginatedResponse.nextCursor,
    hasMore: paginatedResponse.hasMore
  };
}, {
  query: C.Object({
    cursor: C.Optional(C.String()),
    limit: C.Optional(C.Number({ minimum: 1, maximum: 50, default: 10 }))
  }),
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String(),
      data: C.Array(C.Any()),
      nextCursor: C.Nullable(C.String()),
      hasMore: C.Boolean()
    })
  },
  detail: {
    tags: ["Public Chat"],
    summary: "Get all public chat messages",
    description: "Retrieve paginated list of top-level public chat messages (public endpoint). Use /public-chat/:id/replies to get replies."
  }
});

// src/api/controller/publicChat/getReplies.ts
var getReplies_default = createElysia().use(publicChatModel).get("/:id/replies", async ({ params: { id }, query }) => {
  const { cursor, limit } = paginationQuerySchema.parse(query);
  const cursorDate = parseCursorToDate(cursor);
  const parentMessage = await prisma.publicChatMessage.findFirst({
    where: {
      id,
      deletedAt: null
    }
  });
  if (!parentMessage) {
    throw new NotFoundException("Message not found");
  }
  const replies = await prisma.publicChatMessage.findMany({
    where: {
      replyToId: id,
      deletedAt: null,
      ...cursorDate && {
        createdAt: {
          lt: cursorDate
        }
      }
    },
    orderBy: {
      createdAt: "desc"
    },
    take: limit + 1,
    include: {
      user: {
        select: {
          id: true,
          name: true,
          avatarUrl: true,
          headline: true
        }
      }
    }
  });
  const paginatedResponse = createPaginatedResponse(replies, limit, (reply) => reply.createdAt);
  return {
    status: 200,
    message: "Success",
    ...paginatedResponse
  };
}, {
  params: C.Object({
    id: C.String()
  }),
  query: C.Object({
    cursor: C.Optional(C.String()),
    limit: C.Optional(C.Number({ minimum: 1, maximum: 50, default: 10 }))
  }),
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String(),
      data: C.Array(C.Any()),
      nextCursor: C.Nullable(C.String()),
      hasMore: C.Boolean()
    })
  },
  detail: {
    tags: ["Public Chat"],
    summary: "Get replies for a message",
    description: "Retrieve paginated list of replies for a specific message (public endpoint)"
  }
});

// src/api/controller/publicChat/updatePost.ts
var updatePost_default = createElysia().use(publicChatModel).use(userGuard).patch("/:id", async ({ params: { id }, body, user: user3 }) => {
  const { message } = body;
  const post = await prisma.publicChatMessage.findUnique({
    where: { id }
  });
  if (!post || post.deletedAt) {
    throw new NotFoundException("Message not found");
  }
  if (post.userId !== user3.id) {
    throw new ForbiddenException("You can only edit your own messages");
  }
  const updatedPost = await prisma.publicChatMessage.update({
    where: { id },
    data: {
      message,
      updatedAt: new Date
    },
    include: {
      user: {
        select: {
          id: true,
          name: true,
          avatarUrl: true,
          headline: true
        }
      },
      replyTo: {
        select: {
          id: true,
          message: true,
          userId: true,
          createdAt: true,
          user: {
            select: {
              id: true,
              name: true,
              avatarUrl: true,
              headline: true
            }
          }
        }
      }
    }
  });
  lokiLogger_default.info({
    message: "Public chat message updated",
    userId: user3.id,
    messageId: id
  });
  return {
    status: 200,
    message: "Message updated successfully",
    data: updatedPost
  };
}, {
  params: C.Object({
    id: C.String()
  }),
  body: C.Object({
    message: C.String()
  }),
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String(),
      data: C.Any()
    })
  },
  detail: {
    tags: ["Public Chat"],
    summary: "Update a public chat message",
    description: "Users can edit their own messages"
  }
});

// src/api/controller/publicChat/deletePost.ts
var deletePost_default = createElysia().use(userGuard).delete("/:id", async ({ params: { id }, user: user3 }) => {
  const post = await prisma.publicChatMessage.findUnique({
    where: { id }
  });
  if (!post || post.deletedAt) {
    throw new NotFoundException("Message not found");
  }
  if (post.userId !== user3.id && user3.role !== "ADMIN") {
    throw new ForbiddenException("You can only delete your own messages");
  }
  await prisma.publicChatMessage.update({
    where: { id },
    data: {
      deletedAt: new Date
    }
  });
  lokiLogger_default.info({
    message: "Public chat message deleted",
    userId: user3.id,
    messageId: id
  });
  return {
    status: 200,
    message: "Message deleted successfully"
  };
}, {
  params: C.Object({
    id: C.String()
  }),
  response: {
    200: C.Object({
      status: C.Number(),
      message: C.String()
    })
  },
  detail: {
    tags: ["Public Chat"],
    summary: "Delete a public chat message",
    description: "Users can delete their own messages (soft delete). Admins can delete any message."
  }
});

// src/api/controller/publicChat/index.ts
var publicChat_default = createElysia({ prefix: "/public-chat" }).use(createPost_default).use(getAllPosts_default).use(getReplies_default).use(updatePost_default).use(deletePost_default);

// src/api/controller/analytics/index.ts
var pageViews = new Map;
var analytics_default = createElysia().get("/", async () => {
  return {
    message: "Analytics & Performance Metrics API",
    endpoints: {
      track: "POST /track - Track page view",
      stats: "GET /stats - Get analytics statistics",
      pageViews: "GET /page-views?path=/page - Get page view count",
      topPages: "GET /top-pages?limit=10 - Get most visited pages"
    },
    recommendations: {
      selfHosted: [
        "Umami - Simple, privacy-focused analytics (https://umami.is)",
        "Plausible Analytics - Lightweight, privacy-friendly (https://plausible.io)",
        "Matomo - Full-featured, GDPR compliant (https://matomo.org)",
        "GoatCounter - Simple web statistics (https://www.goatcounter.com)",
        "Ackee - Self-hosted analytics tool (https://ackee.electerious.com)"
      ],
      cloudBased: [
        "Vercel Analytics - Integrated with Vercel deployments",
        "Cloudflare Web Analytics - Privacy-first, free tier available",
        "Fathom Analytics - Simple, privacy-focused (paid)"
      ],
      openSource: {
        umami: {
          name: "Umami",
          description: "Simple, fast, privacy-focused analytics",
          features: ["No cookies", "GDPR compliant", "Self-hosted", "Real-time data"],
          installation: "npm install umami or docker run"
        },
        plausible: {
          name: "Plausible",
          description: "Lightweight and open-source website analytics",
          features: ["< 1KB script", "No cookies", "EU servers", "Open source"],
          installation: "Docker compose or managed hosting"
        }
      }
    },
    note: "For production, integrate with external analytics services or use a database to persist data"
  };
}, {
  detail: {
    tags: ["Analytics"],
    summary: "Analytics API Information"
  }
}).post("/track", async ({ body, headers }) => {
  const { path: path2 } = body;
  const userAgent = headers["user-agent"];
  const ip = headers["x-forwarded-for"] || headers["x-real-ip"];
  const referer = headers["referer"];
  const pageView = {
    path: path2,
    timestamp: new Date,
    userAgent,
    ip,
    referer
  };
  if (!pageViews.has(path2)) {
    pageViews.set(path2, []);
  }
  pageViews.get(path2)?.push(pageView);
  return {
    success: true,
    message: "Page view tracked",
    data: {
      path: path2,
      timestamp: pageView.timestamp
    }
  };
}, {
  body: C.Object({
    path: C.String(),
    metadata: C.Optional(C.Object({
      title: C.Optional(C.String()),
      referrer: C.Optional(C.String())
    }))
  }),
  detail: {
    tags: ["Analytics"],
    summary: "Track page view",
    description: "Records a page view event with metadata"
  }
}).get("/stats", async () => {
  const totalViews = Array.from(pageViews.values()).reduce((sum, views) => sum + views.length, 0);
  const uniquePaths = pageViews.size;
  const pathStats = Array.from(pageViews.entries()).map(([path2, views]) => ({
    path: path2,
    views: views.length,
    lastViewed: views[views.length - 1]?.timestamp
  }));
  const sortedPaths = pathStats.toSorted((a, b) => b.views - a.views);
  return {
    success: true,
    data: {
      totalViews,
      uniquePaths,
      paths: sortedPaths
    }
  };
}, {
  detail: {
    tags: ["Analytics"],
    summary: "Get analytics statistics",
    description: "Returns overall analytics statistics"
  }
}).get("/page-views", async ({ query }) => {
  const { path: path2 } = query;
  if (!path2) {
    return {
      success: false,
      error: "Path parameter is required"
    };
  }
  const views = pageViews.get(path2) || [];
  return {
    success: true,
    data: {
      path: path2,
      totalViews: views.length,
      views: views.map((v3) => ({
        timestamp: v3.timestamp,
        referer: v3.referer
      }))
    }
  };
}, {
  query: C.Object({
    path: C.String()
  }),
  detail: {
    tags: ["Analytics"],
    summary: "Get page view count",
    description: "Returns view count and details for a specific page"
  }
}).get("/top-pages", async ({ query }) => {
  const { limit = "10" } = query;
  const pathStats = Array.from(pageViews.entries()).map(([path2, views]) => ({
    path: path2,
    views: views.length,
    lastViewed: views[views.length - 1]?.timestamp
  })).sort((a, b) => b.views - a.views).slice(0, parseInt(limit));
  return {
    success: true,
    data: {
      topPages: pathStats,
      total: pathStats.length
    }
  };
}, {
  query: C.Object({
    limit: C.Optional(C.String())
  }),
  detail: {
    tags: ["Analytics"],
    summary: "Get most visited pages",
    description: "Returns the most visited pages ordered by view count"
  }
}).get("/realtime", async () => {
  const now = new Date;
  const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);
  const recentViews = Array.from(pageViews.entries()).flatMap(([pagePath, views]) => views.filter((v3) => v3.timestamp >= fiveMinutesAgo).map((v3) => ({ ...v3, path: pagePath }))).sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
  return {
    success: true,
    data: {
      activeViewers: recentViews.length,
      recentViews: recentViews.slice(0, 20)
    }
  };
}, {
  detail: {
    tags: ["Analytics"],
    summary: "Get real-time analytics",
    description: "Returns recent page views in the last 5 minutes"
  }
}).delete("/reset", async () => {
  pageViews.clear();
  return {
    success: true,
    message: "Analytics data reset successfully"
  };
}, {
  detail: {
    tags: ["Analytics"],
    summary: "Reset analytics data",
    description: "Clears all analytics data (development only)"
  }
});

// node_modules/ethers/lib.esm/ethers.js
var exports_ethers = {};
__export(exports_ethers, {
  zeroPadValue: () => zeroPadValue,
  zeroPadBytes: () => zeroPadBytes,
  wordlists: () => wordlists2,
  version: () => version,
  verifyTypedData: () => verifyTypedData,
  verifyMessage: () => verifyMessage,
  verifyAuthorization: () => verifyAuthorization,
  uuidV4: () => uuidV4,
  toUtf8String: () => toUtf8String,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8Bytes: () => toUtf8Bytes,
  toTwos: () => toTwos,
  toQuantity: () => toQuantity,
  toNumber: () => toNumber,
  toBigInt: () => toBigInt,
  toBeHex: () => toBeHex,
  toBeArray: () => toBeArray,
  stripZerosLeft: () => stripZerosLeft,
  solidityPackedSha256: () => solidityPackedSha256,
  solidityPackedKeccak256: () => solidityPackedKeccak256,
  solidityPacked: () => solidityPacked,
  showThrottleMessage: () => showThrottleMessage,
  sha512: () => sha5126,
  sha256: () => sha2565,
  scryptSync: () => scryptSync,
  scrypt: () => scrypt5,
  ripemd160: () => ripemd1603,
  resolveProperties: () => resolveProperties,
  resolveAddress: () => resolveAddress,
  recoverAddress: () => recoverAddress,
  randomBytes: () => randomBytes3,
  pbkdf2: () => pbkdf2,
  parseUnits: () => parseUnits,
  parseEther: () => parseEther,
  namehash: () => namehash,
  mask: () => mask,
  makeError: () => makeError,
  lock: () => lock,
  keccak256: () => keccak256,
  isValidName: () => isValidName,
  isKeystoreJson: () => isKeystoreJson,
  isHexString: () => isHexString,
  isError: () => isError,
  isCrowdsaleJson: () => isCrowdsaleJson,
  isCallException: () => isCallException,
  isBytesLike: () => isBytesLike,
  isAddressable: () => isAddressable,
  isAddress: () => isAddress,
  id: () => id,
  hexlify: () => hexlify,
  hashMessage: () => hashMessage,
  hashAuthorization: () => hashAuthorization,
  getUint: () => getUint,
  getNumber: () => getNumber,
  getIndexedAccountPath: () => getIndexedAccountPath,
  getIcapAddress: () => getIcapAddress,
  getDefaultProvider: () => getDefaultProvider,
  getCreateAddress: () => getCreateAddress,
  getCreate2Address: () => getCreate2Address,
  getBytesCopy: () => getBytesCopy,
  getBytes: () => getBytes,
  getBigInt: () => getBigInt,
  getAddress: () => getAddress,
  getAccountPath: () => getAccountPath,
  fromTwos: () => fromTwos,
  formatUnits: () => formatUnits,
  formatEther: () => formatEther,
  ensNormalize: () => ensNormalize,
  encryptKeystoreJsonSync: () => encryptKeystoreJsonSync,
  encryptKeystoreJson: () => encryptKeystoreJson,
  encodeRlp: () => encodeRlp,
  encodeBytes32String: () => encodeBytes32String,
  encodeBase64: () => encodeBase644,
  encodeBase58: () => encodeBase58,
  dnsEncode: () => dnsEncode,
  defineProperties: () => defineProperties,
  defaultPath: () => defaultPath2,
  decryptKeystoreJsonSync: () => decryptKeystoreJsonSync,
  decryptKeystoreJson: () => decryptKeystoreJson,
  decryptCrowdsaleJson: () => decryptCrowdsaleJson,
  decodeRlp: () => decodeRlp,
  decodeBytes32String: () => decodeBytes32String,
  decodeBase64: () => decodeBase644,
  decodeBase58: () => decodeBase58,
  dataSlice: () => dataSlice,
  dataLength: () => dataLength,
  copyRequest: () => copyRequest,
  concat: () => concat2,
  computeHmac: () => computeHmac,
  computeAddress: () => computeAddress,
  checkResultErrors: () => checkResultErrors,
  authorizationify: () => authorizationify,
  assertPrivate: () => assertPrivate,
  assertNormalize: () => assertNormalize,
  assertArgumentCount: () => assertArgumentCount,
  assertArgument: () => assertArgument,
  assert: () => assert,
  accessListify: () => accessListify,
  ZeroHash: () => ZeroHash,
  ZeroAddress: () => ZeroAddress,
  WordlistOwlA: () => WordlistOwlA,
  WordlistOwl: () => WordlistOwl,
  Wordlist: () => Wordlist,
  WeiPerEther: () => WeiPerEther,
  WebSocketProvider: () => WebSocketProvider,
  Wallet: () => Wallet,
  VoidSigner: () => VoidSigner,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  UnmanagedSubscriber: () => UnmanagedSubscriber,
  UndecodedEventLog: () => UndecodedEventLog,
  TypedDataEncoder: () => TypedDataEncoder,
  Typed: () => Typed,
  TransactionResponse: () => TransactionResponse,
  TransactionReceipt: () => TransactionReceipt,
  TransactionDescription: () => TransactionDescription,
  Transaction: () => Transaction,
  StructFragment: () => StructFragment,
  SocketSubscriber: () => SocketSubscriber,
  SocketProvider: () => SocketProvider,
  SocketPendingSubscriber: () => SocketPendingSubscriber,
  SocketEventSubscriber: () => SocketEventSubscriber,
  SocketBlockSubscriber: () => SocketBlockSubscriber,
  SigningKey: () => SigningKey,
  Signature: () => Signature2,
  Result: () => Result,
  QuickNodeProvider: () => QuickNodeProvider,
  PocketProvider: () => PocketProvider,
  ParamType: () => ParamType,
  NonceManager: () => NonceManager,
  NetworkPlugin: () => NetworkPlugin,
  Network: () => Network,
  NamedFragment: () => NamedFragment,
  N: () => N,
  MulticoinProviderPlugin: () => MulticoinProviderPlugin,
  Mnemonic: () => Mnemonic,
  MinInt256: () => MinInt256,
  MessagePrefix: () => MessagePrefix,
  MaxUint256: () => MaxUint256,
  MaxInt256: () => MaxInt256,
  LogDescription: () => LogDescription,
  Log: () => Log,
  LangEn: () => LangEn,
  JsonRpcSigner: () => JsonRpcSigner,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcApiProvider: () => JsonRpcApiProvider,
  IpcSocketProvider: () => IpcSocketProvider,
  Interface: () => Interface,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  InfuraProvider: () => InfuraProvider,
  Indexed: () => Indexed,
  HDNodeWallet: () => HDNodeWallet,
  HDNodeVoidWallet: () => HDNodeVoidWallet,
  GasCostPlugin: () => GasCostPlugin,
  FunctionFragment: () => FunctionFragment,
  Fragment: () => Fragment,
  FixedNumber: () => FixedNumber,
  FetchUrlFeeDataNetworkPlugin: () => FetchUrlFeeDataNetworkPlugin,
  FetchResponse: () => FetchResponse,
  FetchRequest: () => FetchRequest,
  FetchCancelSignal: () => FetchCancelSignal,
  FeeDataNetworkPlugin: () => FeeDataNetworkPlugin,
  FeeData: () => FeeData,
  FallbackProvider: () => FallbackProvider,
  FallbackFragment: () => FallbackFragment,
  EventPayload: () => EventPayload,
  EventLog: () => EventLog,
  EventFragment: () => EventFragment,
  EtherscanProvider: () => EtherscanProvider,
  EtherscanPlugin: () => EtherscanPlugin,
  EtherSymbol: () => EtherSymbol,
  ErrorFragment: () => ErrorFragment,
  ErrorDescription: () => ErrorDescription,
  EnsResolver: () => EnsResolver,
  EnsPlugin: () => EnsPlugin,
  ContractUnknownEventPayload: () => ContractUnknownEventPayload,
  ContractTransactionResponse: () => ContractTransactionResponse,
  ContractTransactionReceipt: () => ContractTransactionReceipt,
  ContractFactory: () => ContractFactory,
  ContractEventPayload: () => ContractEventPayload,
  Contract: () => Contract,
  ConstructorFragment: () => ConstructorFragment,
  CloudflareProvider: () => CloudflareProvider,
  ChainstackProvider: () => ChainstackProvider,
  BrowserProvider: () => BrowserProvider,
  BlockscoutProvider: () => BlockscoutProvider,
  Block: () => Block,
  BaseWallet: () => BaseWallet,
  BaseContract: () => BaseContract,
  AnkrProvider: () => AnkrProvider,
  AlchemyProvider: () => AlchemyProvider,
  AbstractSigner: () => AbstractSigner,
  AbstractProvider: () => AbstractProvider,
  AbiCoder: () => AbiCoder
});

// node_modules/ethers/lib.esm/_version.js
var version = "6.15.0";
// node_modules/ethers/lib.esm/utils/properties.js
function checkType(value15, type50, name) {
  const types = type50.split("|").map((t3) => t3.trim());
  for (let i3 = 0;i3 < types.length; i3++) {
    switch (type50) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value15 === type50) {
          return;
        }
    }
  }
  const error23 = new Error(`invalid value for type ${type50}`);
  error23.code = "INVALID_ARGUMENT";
  error23.argument = `value.${name}`;
  error23.value = value15;
  throw error23;
}
async function resolveProperties(value15) {
  const keys = Object.keys(value15);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value15[k])));
  return results.reduce((accum, v3, index2) => {
    accum[keys[index2]] = v3;
    return accum;
  }, {});
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value15 = values[key];
    const type50 = types ? types[key] : null;
    if (type50) {
      checkType(value15, type50, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value: value15, writable: false });
  }
}

// node_modules/ethers/lib.esm/utils/errors.js
function stringify(value15, seen) {
  if (value15 == null) {
    return "null";
  }
  if (seen == null) {
    seen = new Set;
  }
  if (typeof value15 === "object") {
    if (seen.has(value15)) {
      return "[Circular]";
    }
    seen.add(value15);
  }
  if (Array.isArray(value15)) {
    return "[ " + value15.map((v3) => stringify(v3, seen)).join(", ") + " ]";
  }
  if (value15 instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i3 = 0;i3 < value15.length; i3++) {
      result += HEX[value15[i3] >> 4];
      result += HEX[value15[i3] & 15];
    }
    return result;
  }
  if (typeof value15 === "object" && typeof value15.toJSON === "function") {
    return stringify(value15.toJSON(), seen);
  }
  switch (typeof value15) {
    case "boolean":
    case "number":
    case "symbol":
      return value15.toString();
    case "bigint":
      return BigInt(value15).toString();
    case "string":
      return JSON.stringify(value15);
    case "object": {
      const keys = Object.keys(value15);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k, seen)}: ${stringify(value15[k], seen)}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error23, code) {
  return error23 && error23.code === code;
}
function isCallException(error23) {
  return isError(error23, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value15 = info[key];
        details.push(key + "=" + stringify(value15));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error23;
  switch (code) {
    case "INVALID_ARGUMENT":
      error23 = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error23 = new RangeError(message);
      break;
    default:
      error23 = new Error(message);
  }
  defineProperties(error23, { code });
  if (info) {
    Object.assign(error23, info);
  }
  if (error23.shortMessage == null) {
    defineProperties(error23, { shortMessage });
  }
  return error23;
}
function assert(check11, message, code, info) {
  if (!check11) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check11, message, name, value15) {
  assert(check11, message, "INVALID_ARGUMENT", { argument: name, value: value15 });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard22, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard22) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    if (form === "NFD") {
      const check11 = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check11 !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error23) {
  }
  return accum;
}, []);

// node_modules/ethers/lib.esm/utils/data.js
function _getBytes(value15, name, copy) {
  if (value15 instanceof Uint8Array) {
    if (copy) {
      return new Uint8Array(value15);
    }
    return value15;
  }
  if (typeof value15 === "string" && value15.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value15.length - 2) / 2);
    let offset = 2;
    for (let i3 = 0;i3 < result.length; i3++) {
      result[i3] = parseInt(value15.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value15);
}
function getBytes(value15, name) {
  return _getBytes(value15, name, false);
}
function getBytesCopy(value15, name) {
  return _getBytes(value15, name, true);
}
function isHexString(value15, length) {
  if (typeof value15 !== "string" || !value15.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value15.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value15.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value15) {
  return isHexString(value15, true) || value15 instanceof Uint8Array;
}
function hexlify(data) {
  const bytes2 = getBytes(data);
  let result = "0x";
  for (let i3 = 0;i3 < bytes2.length; i3++) {
    const v3 = bytes2[i3];
    result += HexCharacters[(v3 & 240) >> 4] + HexCharacters[v3 & 15];
  }
  return result;
}
function concat2(datas) {
  return "0x" + datas.map((d3) => hexlify(d3).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes2 = getBytes(data);
  if (end != null && end > bytes2.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes2,
      length: bytes2.length,
      offset: end
    });
  }
  return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
}
function stripZerosLeft(data) {
  let bytes2 = hexlify(data).substring(2);
  while (bytes2.startsWith("00")) {
    bytes2 = bytes2.substring(2);
  }
  return "0x" + bytes2;
}
function zeroPad(data, length, left) {
  const bytes2 = getBytes(data);
  assert(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}
var HexCharacters = "0123456789abcdef";

// node_modules/ethers/lib.esm/utils/maths.js
function fromTwos(_value, _width) {
  const value15 = getUint(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value15 >> width === BN_0, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  if (value15 >> width - BN_1) {
    const mask = (BN_1 << width) - BN_1;
    return -((~value15 & mask) + BN_1);
  }
  return value15;
}
function toTwos(_value, _width) {
  let value15 = getBigInt(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1 << width - BN_1;
  if (value15 < BN_0) {
    value15 = -value15;
    assert(value15 <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    const mask = (BN_1 << width) - BN_1;
    return (~value15 & mask) + BN_1;
  } else {
    assert(value15 < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value15;
}
function mask(_value, _bits) {
  const value15 = getUint(_value, "value");
  const bits2 = BigInt(getNumber(_bits, "bits"));
  return value15 & (BN_1 << bits2) - BN_1;
}
function getBigInt(value15, name) {
  switch (typeof value15) {
    case "bigint":
      return value15;
    case "number":
      assertArgument(Number.isInteger(value15), "underflow", name || "value", value15);
      assertArgument(value15 >= -maxValue && value15 <= maxValue, "overflow", name || "value", value15);
      return BigInt(value15);
    case "string":
      try {
        if (value15 === "") {
          throw new Error("empty string");
        }
        if (value15[0] === "-" && value15[1] !== "-") {
          return -BigInt(value15.substring(1));
        }
        return BigInt(value15);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value15);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value15);
}
function getUint(value15, name) {
  const result = getBigInt(value15, name);
  assert(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: value15
  });
  return result;
}
function toBigInt(value15) {
  if (value15 instanceof Uint8Array) {
    let result = "0x0";
    for (const v3 of value15) {
      result += Nibbles[v3 >> 4];
      result += Nibbles[v3 & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value15);
}
function getNumber(value15, name) {
  switch (typeof value15) {
    case "bigint":
      assertArgument(value15 >= -maxValue && value15 <= maxValue, "overflow", name || "value", value15);
      return Number(value15);
    case "number":
      assertArgument(Number.isInteger(value15), "underflow", name || "value", value15);
      assertArgument(value15 >= -maxValue && value15 <= maxValue, "overflow", name || "value", value15);
      return value15;
    case "string":
      try {
        if (value15 === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value15), name);
      } catch (e) {
        assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value15);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value15);
}
function toNumber(value15) {
  return getNumber(toBigInt(value15));
}
function toBeHex(_value, _width) {
  const value15 = getUint(_value, "value");
  let result = value15.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value) {
  const value15 = getUint(_value, "value");
  if (value15 === BN_0) {
    return new Uint8Array([]);
  }
  let hex = value15.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i3 = 0;i3 < result.length; i3++) {
    const offset = i3 * 2;
    result[i3] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value15) {
  let result = hexlify(isBytesLike(value15) ? value15 : toBeArray(value15)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var maxValue = 9007199254740991;
var Nibbles = "0123456789abcdef";

// node_modules/ethers/lib.esm/utils/base58.js
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i3 = 0;i3 < Alphabet.length; i3++) {
      Lookup[Alphabet[i3]] = BigInt(i3);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
function encodeBase58(_value) {
  const bytes2 = getBytes(_value);
  let value15 = toBigInt(bytes2);
  let result = "";
  while (value15) {
    result = Alphabet[Number(value15 % BN_58)] + result;
    value15 /= BN_58;
  }
  for (let i3 = 0;i3 < bytes2.length; i3++) {
    if (bytes2[i3]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value15) {
  let result = BN_02;
  for (let i3 = 0;i3 < value15.length; i3++) {
    result *= BN_58;
    result += getAlpha(value15[i3]);
  }
  return result;
}
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
var BN_02 = BigInt(0);
var BN_58 = BigInt(58);
// node_modules/ethers/lib.esm/utils/base64.js
function decodeBase644(value15) {
  return getBytesCopy(Buffer.from(value15, "base64"));
}
function encodeBase644(data4) {
  return Buffer.from(getBytes(data4)).toString("base64");
}
// node_modules/ethers/lib.esm/utils/events.js
class EventPayload {
  filter;
  emitter;
  #listener;
  constructor(emitter, listener, filter2) {
    this.#listener = listener;
    defineProperties(this, { emitter, filter: filter2 });
  }
  async removeListener() {
    if (this.#listener == null) {
      return;
    }
    await this.emitter.off(this.filter, this.#listener);
  }
}
// node_modules/ethers/lib.esm/utils/utf8.js
function errorFunc(reason, offset, bytes2, output, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset, bytes2, output, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i3 = 0;
    for (let o3 = offset + 1;o3 < bytes2.length; o3++) {
      if (bytes2[o3] >> 6 !== 2) {
        break;
      }
      i3++;
    }
    return i3;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes2, output, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes2, output, badCodepoint);
}
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes2 = getBytes(_bytes, "bytes");
  const result = [];
  let i3 = 0;
  while (i3 < bytes2.length) {
    const c3 = bytes2[i3++];
    if (c3 >> 7 === 0) {
      result.push(c3);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c3 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c3 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c3 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c3 & 192) === 128) {
        i3 += onError("UNEXPECTED_CONTINUE", i3 - 1, bytes2, result);
      } else {
        i3 += onError("BAD_PREFIX", i3 - 1, bytes2, result);
      }
      continue;
    }
    if (i3 - 1 + extraLength >= bytes2.length) {
      i3 += onError("OVERRUN", i3 - 1, bytes2, result);
      continue;
    }
    let res = c3 & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0;j < extraLength; j++) {
      let nextChar = bytes2[i3];
      if ((nextChar & 192) != 128) {
        i3 += onError("MISSING_CONTINUE", i3, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i3++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i3 += onError("OUT_OF_RANGE", i3 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i3 += onError("UTF16_SURROGATE", i3 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i3 += onError("OVERLONG", i3 - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i3 = 0;i3 < str.length; i3++) {
    const c3 = str.charCodeAt(i3);
    if (c3 < 128) {
      result.push(c3);
    } else if (c3 < 2048) {
      result.push(c3 >> 6 | 192);
      result.push(c3 & 63 | 128);
    } else if ((c3 & 64512) == 55296) {
      i3++;
      const c22 = str.charCodeAt(i3);
      assertArgument(i3 < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c3 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c3 >> 12 | 224);
      result.push(c3 >> 6 & 63 | 128);
      result.push(c3 & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});

// node_modules/ethers/lib.esm/utils/geturl.js
import http2 from "http";
import https2 from "https";
import {gunzipSync as gunzipSync2} from "zlib";
function createGetUrl(options) {
  async function getUrl(req, signal) {
    assert(signal == null || !signal.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    const method = req.method;
    const headers = Object.assign({}, req.headers);
    const reqOptions = { method, headers };
    if (options) {
      if (options.agent) {
        reqOptions.agent = options.agent;
      }
    }
    let abort = null;
    try {
      abort = new AbortController;
      reqOptions.abort = abort.signal;
    } catch (e) {
      console.log(e);
    }
    const request27 = (protocol === "http" ? http2 : https2).request(req.url, reqOptions);
    request27.setTimeout(req.timeout);
    const body = req.body;
    if (body) {
      request27.write(Buffer.from(body));
    }
    request27.end();
    return new Promise((resolve, reject2) => {
      if (signal) {
        signal.addListener(() => {
          if (abort) {
            abort.abort();
          }
          reject2(makeError("request cancelled", "CANCELLED"));
        });
      }
      request27.on("timeout", () => {
        reject2(makeError("request timeout", "TIMEOUT"));
      });
      request27.once("response", (resp) => {
        const statusCode = resp.statusCode || 0;
        const statusMessage = resp.statusMessage || "";
        const headers2 = Object.keys(resp.headers || {}).reduce((accum, name) => {
          let value15 = resp.headers[name] || "";
          if (Array.isArray(value15)) {
            value15 = value15.join(", ");
          }
          accum[name] = value15;
          return accum;
        }, {});
        let body2 = null;
        resp.on("data", (chunk) => {
          if (signal) {
            try {
              signal.checkSignal();
            } catch (error23) {
              return reject2(error23);
            }
          }
          if (body2 == null) {
            body2 = chunk;
          } else {
            const newBody = new Uint8Array(body2.length + chunk.length);
            newBody.set(body2, 0);
            newBody.set(chunk, body2.length);
            body2 = newBody;
          }
        });
        resp.on("end", () => {
          try {
            if (headers2["content-encoding"] === "gzip" && body2) {
              body2 = getBytes(gunzipSync2(body2));
            }
            resolve({ statusCode, statusMessage, headers: headers2, body: body2 });
          } catch (error23) {
            reject2(makeError("bad response data", "SERVER_ERROR", {
              request: req,
              info: { response: resp, error: error23 }
            }));
          }
        });
        resp.on("error", (error23) => {
          error23.response = { statusCode, statusMessage, headers: headers2, body: body2 };
          reject2(error23);
        });
      });
      request27.on("error", (error23) => {
        reject2(error23);
      });
    });
  }
  return getUrl;
}
var defaultGetUrl = createGetUrl({});

// node_modules/ethers/lib.esm/utils/fetch.js
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase644(match[3]) : unpercent(match[3]));
  } catch (error23) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error23) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
function getTime() {
  return new Date().getTime();
}
function unpercent(value15) {
  return toUtf8Bytes(value15.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
var MAX_ATTEMPTS = 12;
var SLOT_INTERVAL = 250;
var defaultGetUrlFunc = createGetUrl();
var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
var reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
var locked = false;
var Gateways = {
  data: dataGatewayFunc,
  ipfs: getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
var fetchSignals = new WeakMap;

class FetchCancelSignal {
  #listeners;
  #cancelled;
  constructor(request27) {
    this.#listeners = [];
    this.#cancelled = false;
    fetchSignals.set(request27, () => {
      if (this.#cancelled) {
        return;
      }
      this.#cancelled = true;
      for (const listener of this.#listeners) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      this.#listeners = [];
    });
  }
  addListener(listener) {
    assert(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    this.#listeners.push(listener);
  }
  get cancelled() {
    return this.#cancelled;
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}

class FetchRequest {
  #allowInsecure;
  #gzip;
  #headers;
  #method;
  #timeout;
  #url;
  #body;
  #bodyType;
  #creds;
  #preflight;
  #process;
  #retry;
  #signal;
  #throttle;
  #getUrlFunc;
  get url() {
    return this.#url;
  }
  set url(url) {
    this.#url = String(url);
  }
  get body() {
    if (this.#body == null) {
      return null;
    }
    return new Uint8Array(this.#body);
  }
  set body(body) {
    if (body == null) {
      this.#body = undefined;
      this.#bodyType = undefined;
    } else if (typeof body === "string") {
      this.#body = toUtf8Bytes(body);
      this.#bodyType = "text/plain";
    } else if (body instanceof Uint8Array) {
      this.#body = body;
      this.#bodyType = "application/octet-stream";
    } else if (typeof body === "object") {
      this.#body = toUtf8Bytes(JSON.stringify(body));
      this.#bodyType = "application/json";
    } else {
      throw new Error("invalid body");
    }
  }
  hasBody() {
    return this.#body != null;
  }
  get method() {
    if (this.#method) {
      return this.#method;
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    this.#method = String(method).toUpperCase();
  }
  get headers() {
    const headers = Object.assign({}, this.#headers);
    if (this.#creds) {
      headers["authorization"] = `Basic ${encodeBase644(toUtf8Bytes(this.#creds))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && this.#bodyType) {
      headers["content-type"] = this.#bodyType;
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  setHeader(key, value15) {
    this.#headers[String(key).toLowerCase()] = String(value15);
  }
  clearHeaders() {
    this.#headers = {};
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index2 = 0;
    return {
      next: () => {
        if (index2 < keys.length) {
          const key = keys[index2++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: undefined, done: true };
      }
    };
  }
  get credentials() {
    return this.#creds || null;
  }
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    this.#creds = `${username}:${password}`;
  }
  get allowGzip() {
    return this.#gzip;
  }
  set allowGzip(value15) {
    this.#gzip = !!value15;
  }
  get allowInsecureAuthentication() {
    return !!this.#allowInsecure;
  }
  set allowInsecureAuthentication(value15) {
    this.#allowInsecure = !!value15;
  }
  get timeout() {
    return this.#timeout;
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    this.#timeout = timeout;
  }
  get preflightFunc() {
    return this.#preflight || null;
  }
  set preflightFunc(preflight) {
    this.#preflight = preflight;
  }
  get processFunc() {
    return this.#process || null;
  }
  set processFunc(process3) {
    this.#process = process3;
  }
  get retryFunc() {
    return this.#retry || null;
  }
  set retryFunc(retry) {
    this.#retry = retry;
  }
  get getUrlFunc() {
    return this.#getUrlFunc || defaultGetUrlFunc;
  }
  set getUrlFunc(value15) {
    this.#getUrlFunc = value15;
  }
  constructor(url) {
    this.#url = String(url);
    this.#allowInsecure = false;
    this.#gzip = true;
    this.#headers = {};
    this.#method = "";
    this.#timeout = 300000;
    this.#throttle = {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    };
    this.#getUrlFunc = null;
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      this.#throttle.slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      this.#throttle.maxAttempts = params.maxAttempts;
    }
  }
  async#send(attempt, expires, delay, _request, _response) {
    if (attempt >= this.#throttle.maxAttempts) {
      return _response.makeServerError("exceeded maximum retry limit");
    }
    assert(getTime() <= expires, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: _request
    });
    if (delay > 0) {
      await wait(delay);
    }
    let req = this.clone();
    const scheme = (req.url.split(":")[0] || "").toLowerCase();
    if (scheme in Gateways) {
      const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
      if (result instanceof FetchResponse) {
        let response5 = result;
        if (this.processFunc) {
          checkSignal(_request.#signal);
          try {
            response5 = await this.processFunc(req, response5);
          } catch (error23) {
            if (error23.throttle == null || typeof error23.stall !== "number") {
              response5.makeServerError("error in post-processing function", error23).assertOk();
            }
          }
        }
        return response5;
      }
      req = result;
    }
    if (this.preflightFunc) {
      req = await this.preflightFunc(req);
    }
    const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));
    let response4 = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
    if (response4.statusCode === 301 || response4.statusCode === 302) {
      try {
        const location = response4.headers.location || "";
        return req.redirect(location).#send(attempt + 1, expires, 0, _request, response4);
      } catch (error23) {
      }
      return response4;
    } else if (response4.statusCode === 429) {
      if (this.retryFunc == null || await this.retryFunc(req, response4, attempt)) {
        const retryAfter = response4.headers["retry-after"];
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
          delay2 = parseInt(retryAfter);
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response4);
      }
    }
    if (this.processFunc) {
      checkSignal(_request.#signal);
      try {
        response4 = await this.processFunc(req, response4);
      } catch (error23) {
        if (error23.throttle == null || typeof error23.stall !== "number") {
          response4.makeServerError("error in post-processing function", error23).assertOk();
        }
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (error23.stall >= 0) {
          delay2 = error23.stall;
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response4);
      }
    }
    return response4;
  }
  send() {
    assert(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    this.#signal = new FetchCancelSignal(this);
    return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  cancel() {
    assert(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    req.#headers = Object.assign({}, this.#headers);
    if (this.#body) {
      req.#body = new Uint8Array(this.#body);
    }
    req.#bodyType = this.#bodyType;
    return req;
  }
  clone() {
    const clone13 = new FetchRequest(this.url);
    clone13.#method = this.#method;
    if (this.#body) {
      clone13.#body = this.#body;
    }
    clone13.#bodyType = this.#bodyType;
    clone13.#headers = Object.assign({}, this.#headers);
    clone13.#creds = this.#creds;
    if (this.allowGzip) {
      clone13.allowGzip = true;
    }
    clone13.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone13.allowInsecureAuthentication = true;
    }
    clone13.#preflight = this.#preflight;
    clone13.#process = this.#process;
    clone13.#retry = this.#retry;
    clone13.#throttle = Object.assign({}, this.#throttle);
    clone13.#getUrlFunc = this.#getUrlFunc;
    return clone13;
  }
  static lockConfig() {
    locked = true;
  }
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  static registerGetUrl(getUrl) {
    if (locked) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl;
  }
  static createGetUrlFunc(options) {
    return createGetUrl(options);
  }
  static createDataGateway() {
    return dataGatewayFunc;
  }
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
}

class FetchResponse {
  #statusCode;
  #statusMessage;
  #headers;
  #body;
  #request;
  #error;
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  get statusCode() {
    return this.#statusCode;
  }
  get statusMessage() {
    return this.#statusMessage;
  }
  get headers() {
    return Object.assign({}, this.#headers);
  }
  get body() {
    return this.#body == null ? null : new Uint8Array(this.#body);
  }
  get bodyText() {
    try {
      return this.#body == null ? "" : toUtf8String(this.#body);
    } catch (error23) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error23) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index2 = 0;
    return {
      next: () => {
        if (index2 < keys.length) {
          const key = keys[index2++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: undefined, done: true };
      }
    };
  }
  constructor(statusCode, statusMessage, headers, body, request27) {
    this.#statusCode = statusCode;
    this.#statusMessage = statusMessage;
    this.#headers = Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {});
    this.#body = body == null ? null : new Uint8Array(body);
    this.#request = request27 || null;
    this.#error = { message: "" };
  }
  makeServerError(message, error23) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response4 = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);
    response4.#error = { message, error: error23 };
    return response4;
  }
  throwThrottleError(message, stall) {
    if (stall == null) {
      stall = -1;
    } else {
      assertArgument(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
    }
    const error23 = new Error(message || "throttling requests");
    defineProperties(error23, { stall, throttle: true });
    throw error23;
  }
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  hasBody() {
    return this.#body != null;
  }
  get request() {
    return this.#request;
  }
  ok() {
    return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error: error23 } = this.#error;
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (this.#body) {
        responseBody = toUtf8String(this.#body);
      }
    } catch (e) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: error23,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
}
// node_modules/ethers/lib.esm/utils/fixednumber.js
function getTens(decimals) {
  let result = Zeros;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format, safeOp) {
  const width = BigInt(format.width);
  if (format.signed) {
    const limit = BN_12 << width - BN_12;
    assert(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_03) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_12 << width;
    assert(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_12;
  }
  return val;
}
function getFormat(value15) {
  if (typeof value15 === "number") {
    value15 = `fixed128x${value15}`;
  }
  let signed = true;
  let width = 128;
  let decimals = 18;
  if (typeof value15 === "string") {
    if (value15 === "fixed") {
    } else if (value15 === "ufixed") {
      signed = false;
    } else {
      const match = value15.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value15);
      signed = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value15) {
    const v3 = value15;
    const check11 = (key, type50, defaultValue) => {
      if (v3[key] == null) {
        return defaultValue;
      }
      assertArgument(typeof v3[key] === type50, "invalid fixed format (" + key + " not " + type50 + ")", "format." + key, v3[key]);
      return v3[key];
    };
    signed = check11("signed", "boolean", signed);
    width = check11("width", "number", width);
    decimals = check11("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed, width, decimals, name };
}
function toString(val, decimals) {
  let negative = "";
  if (val < BN_03) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros + str;
  }
  const index2 = str.length - decimals;
  str = str.substring(0, index2) + "." + str.substring(index2);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
var BN_N1 = BigInt(-1);
var BN_03 = BigInt(0);
var BN_12 = BigInt(1);
var BN_5 = BigInt(5);
var _guard = {};
var Zeros = "0000";
while (Zeros.length < 80) {
  Zeros += Zeros;
}

class FixedNumber {
  format;
  #format;
  #val;
  #tens;
  _value;
  constructor(guard22, value15, format) {
    assertPrivate(guard22, _guard, "FixedNumber");
    this.#val = value15;
    this.#format = format;
    const _value = toString(value15, format.decimals);
    defineProperties(this, { format: format.name, _value });
    this.#tens = getTens(format.decimals);
  }
  get signed() {
    return this.#format.signed;
  }
  get width() {
    return this.#format.width;
  }
  get decimals() {
    return this.#format.decimals;
  }
  get value() {
    return this.#val;
  }
  #checkFormat(other) {
    assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
  }
  #checkValue(val, safeOp) {
    val = checkValue(val, this.#format, safeOp);
    return new FixedNumber(_guard, val, this.#format);
  }
  #add(o3, safeOp) {
    this.#checkFormat(o3);
    return this.#checkValue(this.#val + o3.#val, safeOp);
  }
  addUnsafe(other) {
    return this.#add(other);
  }
  add(other) {
    return this.#add(other, "add");
  }
  #sub(o3, safeOp) {
    this.#checkFormat(o3);
    return this.#checkValue(this.#val - o3.#val, safeOp);
  }
  subUnsafe(other) {
    return this.#sub(other);
  }
  sub(other) {
    return this.#sub(other, "sub");
  }
  #mul(o3, safeOp) {
    this.#checkFormat(o3);
    return this.#checkValue(this.#val * o3.#val / this.#tens, safeOp);
  }
  mulUnsafe(other) {
    return this.#mul(other);
  }
  mul(other) {
    return this.#mul(other, "mul");
  }
  mulSignal(other) {
    this.#checkFormat(other);
    const value15 = this.#val * other.#val;
    assert(value15 % this.#tens === BN_03, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value15 / this.#tens, "mulSignal");
  }
  #div(o3, safeOp) {
    assert(o3.#val !== BN_03, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(o3);
    return this.#checkValue(this.#val * this.#tens / o3.#val, safeOp);
  }
  divUnsafe(other) {
    return this.#div(other);
  }
  div(other) {
    return this.#div(other, "div");
  }
  divSignal(other) {
    assert(other.#val !== BN_03, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(other);
    const value15 = this.#val * this.#tens;
    assert(value15 % other.#val === BN_03, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value15 / other.#val, "divSignal");
  }
  cmp(other) {
    let a = this.value, b = other.value;
    const delta4 = this.decimals - other.decimals;
    if (delta4 > 0) {
      b *= getTens(delta4);
    } else if (delta4 < 0) {
      a *= getTens(-delta4);
    }
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  }
  eq(other) {
    return this.cmp(other) === 0;
  }
  lt(other) {
    return this.cmp(other) < 0;
  }
  lte(other) {
    return this.cmp(other) <= 0;
  }
  gt(other) {
    return this.cmp(other) > 0;
  }
  gte(other) {
    return this.cmp(other) >= 0;
  }
  floor() {
    let val = this.#val;
    if (this.#val < BN_03) {
      val -= this.#tens - BN_12;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "floor");
  }
  ceiling() {
    let val = this.#val;
    if (this.#val > BN_03) {
      val += this.#tens - BN_12;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "ceiling");
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta4 = this.decimals - decimals;
    const bump = BN_5 * getTens(delta4 - 1);
    let value15 = this.value + bump;
    const tens = getTens(delta4);
    value15 = value15 / tens * tens;
    checkValue(value15, this.#format, "round");
    return new FixedNumber(_guard, value15, this.#format);
  }
  isZero() {
    return this.#val === BN_03;
  }
  isNegative() {
    return this.#val < BN_03;
  }
  toString() {
    return this._value;
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this.toString(), format);
  }
  static fromValue(_value, _decimals, _format) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format = getFormat(_format);
    let value15 = getBigInt(_value, "value");
    const delta4 = decimals - format.decimals;
    if (delta4 > 0) {
      const tens = getTens(delta4);
      assert(value15 % tens === BN_03, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value
      });
      value15 /= tens;
    } else if (delta4 < 0) {
      value15 *= getTens(-delta4);
    }
    checkValue(value15, format, "fromValue");
    return new FixedNumber(_guard, value15, format);
  }
  static fromString(_value, _format) {
    const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
    const format = getFormat(_format);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format.decimals) {
      decimal += Zeros;
    }
    assert(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value
    });
    decimal = decimal.substring(0, format.decimals);
    const value15 = BigInt(match[1] + whole + decimal);
    checkValue(value15, format, "fromString");
    return new FixedNumber(_guard, value15, format);
  }
  static fromBytes(_value, _format) {
    let value15 = toBigInt(getBytes(_value, "value"));
    const format = getFormat(_format);
    if (format.signed) {
      value15 = fromTwos(value15, format.width);
    }
    checkValue(value15, format, "fromBytes");
    return new FixedNumber(_guard, value15, format);
  }
}
// node_modules/ethers/lib.esm/utils/rlp-decode.js
function hexlifyByte(value15) {
  let result = value15.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data10, offset, length) {
  let result = 0;
  for (let i3 = 0;i3 < length; i3++) {
    result = result * 256 + data10[offset + i3];
  }
  return result;
}
function _decodeChildren(data10, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data10, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data10,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data10, offset) {
  assert(data10.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data10,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert(offset2 <= data10.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data10,
      length: data10.length,
      offset: offset2
    });
  };
  if (data10[offset] >= 248) {
    const lengthLength = data10[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data10, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data10, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data10[offset] >= 192) {
    const length = data10[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data10, offset, offset + 1, length);
  } else if (data10[offset] >= 184) {
    const lengthLength = data10[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data10, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data10.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data10[offset] >= 128) {
    const length = data10[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data10.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data10[offset]) };
}
function decodeRlp(_data) {
  const data10 = getBytes(_data, "data");
  const decoded = _decode(data10, 0);
  assertArgument(decoded.consumed === data10.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}
// node_modules/ethers/lib.esm/utils/rlp-encode.js
function arrayifyInteger(value15) {
  const result = [];
  while (value15) {
    result.unshift(value15 & 255);
    value15 >>= 8;
  }
  return result;
}
function _encode(object13) {
  if (Array.isArray(object13)) {
    let payload = [];
    object13.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data11 = Array.prototype.slice.call(getBytes(object13, "object"));
  if (data11.length === 1 && data11[0] <= 127) {
    return data11;
  } else if (data11.length <= 55) {
    data11.unshift(128 + data11.length);
    return data11;
  }
  const length = arrayifyInteger(data11.length);
  length.unshift(183 + length.length);
  return length.concat(data11);
}
function encodeRlp(object13) {
  let result = "0x";
  for (const v3 of _encode(object13)) {
    result += nibbles[v3 >> 4];
    result += nibbles[v3 & 15];
  }
  return result;
}
var nibbles = "0123456789abcdef";
// node_modules/ethers/lib.esm/utils/units.js
function formatUnits(value15, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index2 = names.indexOf(unit);
    assertArgument(index2 >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index2;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value15, decimals, { decimals, width: 512 }).toString();
}
function parseUnits(value15, unit) {
  assertArgument(typeof value15 === "string", "value must be a string", "value", value15);
  let decimals = 18;
  if (typeof unit === "string") {
    const index2 = names.indexOf(unit);
    assertArgument(index2 >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index2;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value15, { decimals, width: 512 }).value;
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
// node_modules/ethers/lib.esm/utils/uuid.js
function uuidV4(randomBytes) {
  const bytes2 = getBytes(randomBytes, "randomBytes");
  bytes2[6] = bytes2[6] & 15 | 64;
  bytes2[8] = bytes2[8] & 63 | 128;
  const value15 = hexlify(bytes2);
  return [
    value15.substring(2, 10),
    value15.substring(10, 14),
    value15.substring(14, 18),
    value15.substring(18, 22),
    value15.substring(22, 34)
  ].join("-");
}
// node_modules/ethers/lib.esm/abi/coders/abstract-coder.js
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names2) {
  resultNames.set(result, names2);
}
function throwError(name, error23) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error23;
  throw wrapped;
}
function toObject(names2, items, deep) {
  if (names2.indexOf(null) >= 0) {
    return items.map((item, index2) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names2.reduce((accum, name, index2) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
function checkResultErrors(result) {
  const errors15 = [];
  const checkErrors = function(path2, object13) {
    if (!Array.isArray(object13)) {
      return;
    }
    for (let key in object13) {
      const childPath = path2.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object13[key]);
      } catch (error23) {
        errors15.push({ path: childPath, error: error23 });
      }
    }
  };
  checkErrors([], result);
  return errors15;
}
function getValue(value15) {
  let bytes2 = toBeArray(value15);
  assert(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
  if (bytes2.length !== WordSize) {
    bytes2 = getBytesCopy(concat2([Padding.slice(bytes2.length % WordSize), bytes2]));
  }
  return bytes2;
}
var WordSize = 32;
var Padding = new Uint8Array(WordSize);
var passProperties = ["then"];
var _guard2 = {};
var resultNames = new WeakMap;

class Result extends Array {
  #names;
  constructor(...args) {
    const guard22 = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap2 = true;
    if (guard22 !== _guard2) {
      items = args;
      names2 = [];
      wrap2 = false;
    }
    super(items.length);
    items.forEach((item, index2) => {
      this[index2] = item;
    });
    const nameCounts = names2.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, new Map);
    setNames(this, Object.freeze(items.map((item, index2) => {
      const name = names2[index2];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    this.#names = [];
    if (this.#names == null) {
      this.#names;
    }
    if (!wrap2) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index2 = getNumber(prop, "%index");
            if (index2 < 0 || index2 >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index2];
            if (item instanceof Error) {
              throwError(`index ${index2}`, item);
            }
            return item;
          }
          if (passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value15 = target[prop];
          if (value15 instanceof Function) {
            return function(...args2) {
              return value15.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  toArray(deep) {
    const result = [];
    this.forEach((item, index2) => {
      if (item instanceof Error) {
        throwError(`index ${index2}`, item);
      }
      if (deep && item instanceof Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  toObject(deep) {
    const names2 = getNames(this);
    return names2.reduce((accum, name, index2) => {
      assert(name != null, `value at index ${index2} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names2, this, deep);
    }, {});
  }
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names = getNames(this);
    const result = [], names2 = [];
    for (let i3 = start;i3 < end; i3++) {
      result.push(this[i3]);
      names2.push(_names[i3]);
    }
    return new Result(_guard2, result, names2);
  }
  filter(callback, thisArg) {
    const _names = getNames(this);
    const result = [], names2 = [];
    for (let i3 = 0;i3 < this.length; i3++) {
      const item = this[i3];
      if (item instanceof Error) {
        throwError(`index ${i3}`, item);
      }
      if (callback.call(thisArg, item, i3, this)) {
        result.push(item);
        names2.push(_names[i3]);
      }
    }
    return new Result(_guard2, result, names2);
  }
  map(callback, thisArg) {
    const result = [];
    for (let i3 = 0;i3 < this.length; i3++) {
      const item = this[i3];
      if (item instanceof Error) {
        throwError(`index ${i3}`, item);
      }
      result.push(callback.call(thisArg, item, i3, this));
    }
    return result;
  }
  getValue(name) {
    const index2 = getNames(this).indexOf(name);
    if (index2 === -1) {
      return;
    }
    const value15 = this[index2];
    if (value15 instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value15.error);
    }
    return value15;
  }
  static fromItems(items, keys) {
    return new Result(_guard2, items, keys);
  }
}

class Coder {
  name;
  type;
  localName;
  dynamic;
  constructor(name, type50, localName, dynamic) {
    defineProperties(this, { name, type: type50, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value15) {
    assertArgument(false, message, this.localName, value15);
  }
}

class Writer {
  #data;
  #dataLength;
  constructor() {
    this.#data = [];
    this.#dataLength = 0;
  }
  get data() {
    return concat2(this.#data);
  }
  get length() {
    return this.#dataLength;
  }
  #writeData(data12) {
    this.#data.push(data12);
    this.#dataLength += data12.length;
    return data12.length;
  }
  appendWriter(writer) {
    return this.#writeData(getBytesCopy(writer.data));
  }
  writeBytes(value15) {
    let bytes2 = getBytesCopy(value15);
    const paddingOffset = bytes2.length % WordSize;
    if (paddingOffset) {
      bytes2 = getBytesCopy(concat2([bytes2, Padding.slice(paddingOffset)]));
    }
    return this.#writeData(bytes2);
  }
  writeValue(value15) {
    return this.#writeData(getValue(value15));
  }
  writeUpdatableValue() {
    const offset = this.#data.length;
    this.#data.push(Padding);
    this.#dataLength += WordSize;
    return (value15) => {
      this.#data[offset] = getValue(value15);
    };
  }
}

class Reader {
  allowLoose;
  #data;
  #offset;
  #bytesRead;
  #parent;
  #maxInflation;
  constructor(data12, allowLoose, maxInflation) {
    defineProperties(this, { allowLoose: !!allowLoose });
    this.#data = getBytesCopy(data12);
    this.#bytesRead = 0;
    this.#parent = null;
    this.#maxInflation = maxInflation != null ? maxInflation : 1024;
    this.#offset = 0;
  }
  get data() {
    return hexlify(this.#data);
  }
  get dataLength() {
    return this.#data.length;
  }
  get consumed() {
    return this.#offset;
  }
  get bytes() {
    return new Uint8Array(this.#data);
  }
  #incrementBytesRead(count) {
    if (this.#parent) {
      return this.#parent.#incrementBytesRead(count);
    }
    this.#bytesRead += count;
    assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
      buffer: getBytesCopy(this.#data),
      offset: this.#offset,
      length: count,
      info: {
        bytesRead: this.#bytesRead,
        dataLength: this.dataLength
      }
    });
  }
  #peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / WordSize) * WordSize;
    if (this.#offset + alignedLength > this.#data.length) {
      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
        alignedLength = length;
      } else {
        assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: getBytesCopy(this.#data),
          length: this.#data.length,
          offset: this.#offset + alignedLength
        });
      }
    }
    return this.#data.slice(this.#offset, this.#offset + alignedLength);
  }
  subReader(offset) {
    const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
    reader.#parent = this;
    return reader;
  }
  readBytes(length, loose) {
    let bytes2 = this.#peekBytes(0, length, !!loose);
    this.#incrementBytesRead(length);
    this.#offset += bytes2.length;
    return bytes2.slice(0, length);
  }
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
}

// node_modules/ethers/lib.esm/crypto/crypto.js
import {createHash as createHash4, createHmac as createHmac2, pbkdf2Sync, randomBytes} from "crypto";

// node_modules/ethers/lib.esm/crypto/hmac.js
function computeHmac(algorithm, _key, _data) {
  const key = getBytes(_key, "key");
  const data12 = getBytes(_data, "data");
  return hexlify(__computeHmac(algorithm, key, data12));
}
var locked2 = false;
var _computeHmac = function(algorithm, key, data12) {
  return createHmac2(algorithm, key).update(data12).digest();
};
var __computeHmac = _computeHmac;
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked2 = true;
};
computeHmac.register = function(func) {
  if (locked2) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);

// node_modules/@noble/hashes/esm/_assert.js
function number7(n3) {
  if (!Number.isSafeInteger(n3) || n3 < 0)
    throw new Error(`Wrong positive integer: ${n3}`);
}
function bytes2(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash7(hash8) {
  if (typeof hash8 !== "function" || typeof hash8.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number7(hash8.outputLen);
  number7(hash8.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/hashes/esm/_u64.js
function fromBig(n3, le = false) {
  if (le)
    return { h: Number(n3 & U32_MASK64), l: Number(n3 >> _32n & U32_MASK64) };
  return { h: Number(n3 >> _32n & U32_MASK64) | 0, l: Number(n3 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i3 = 0;i3 < lst.length; i3++) {
    const { h, l: l3 } = fromBig(lst[i3], le);
    [Ah[i3], Al[i3]] = [h, l3];
  }
  return [Ah, Al];
}
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
var rotlSH = (h, l3, s3) => h << s3 | l3 >>> 32 - s3;
var rotlSL = (h, l3, s3) => l3 << s3 | h >>> 32 - s3;
var rotlBH = (h, l3, s3) => l3 << s3 - 32 | h >>> 64 - s3;
var rotlBL = (h, l3, s3) => h << s3 - 32 | l3 >>> 64 - s3;

// node_modules/@noble/hashes/esm/cryptoNode.js
import * as nc from "crypto";
var crypto9 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : undefined;

// node_modules/@noble/hashes/esm/utils.js
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i3 = 0;i3 < iters; i3++) {
    cb(i3);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick2();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data12) {
  if (typeof data12 === "string")
    data12 = utf8ToBytes(data12);
  if (!u8a(data12))
    throw new Error(`expected Uint8Array, got ${typeof data12}`);
  return data12;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function checkOpts(defaults, opts) {
  if (opts !== undefined && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto9 && typeof crypto9.getRandomValues === "function") {
    return crypto9.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var u8a = (a) => a instanceof Uint8Array;
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var nextTick2 = async () => {
};

class Hash3 {
  clone() {
    return this._cloneInto();
  }
}
var toStr = {}.toString;

// node_modules/@noble/hashes/esm/sha3.js
function keccakP(s3, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x3 = 0;x3 < 10; x3++)
      B[x3] = s3[x3] ^ s3[x3 + 10] ^ s3[x3 + 20] ^ s3[x3 + 30] ^ s3[x3 + 40];
    for (let x3 = 0;x3 < 10; x3 += 2) {
      const idx1 = (x3 + 8) % 10;
      const idx0 = (x3 + 2) % 10;
      const B02 = B[idx0];
      const B12 = B[idx0 + 1];
      const Th = rotlH(B02, B12, 1) ^ B[idx1];
      const Tl = rotlL(B02, B12, 1) ^ B[idx1 + 1];
      for (let y3 = 0;y3 < 50; y3 += 10) {
        s3[x3 + y3] ^= Th;
        s3[x3 + y3 + 1] ^= Tl;
      }
    }
    let curH = s3[2];
    let curL = s3[3];
    for (let t3 = 0;t3 < 24; t3++) {
      const shift = SHA3_ROTL[t3];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t3];
      curH = s3[PI];
      curL = s3[PI + 1];
      s3[PI] = Th;
      s3[PI + 1] = Tl;
    }
    for (let y3 = 0;y3 < 50; y3 += 10) {
      for (let x3 = 0;x3 < 10; x3++)
        B[x3] = s3[y3 + x3];
      for (let x3 = 0;x3 < 10; x3++)
        s3[y3 + x3] ^= ~B[(x3 + 2) % 10] & B[(x3 + 4) % 10];
    }
    s3[0] ^= SHA3_IOTA_H[round];
    s3[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
var _7n = /* @__PURE__ */ BigInt(7);
var _256n = /* @__PURE__ */ BigInt(256);
var _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R = _1n, x3 = 1, y3 = 0;round < 24; round++) {
  [x3, y3] = [y3, (2 * x3 + 3 * y3) % 5];
  SHA3_PI.push(2 * (5 * y3 + x3));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t3 = _0n;
  for (let j = 0;j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t3 ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t3);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
var rotlH = (h, l3, s3) => s3 > 32 ? rotlBH(h, l3, s3) : rotlSH(h, l3, s3);
var rotlL = (h, l3, s3) => s3 > 32 ? rotlBL(h, l3, s3) : rotlSL(h, l3, s3);

class Keccak extends Hash3 {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number7(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data12) {
    exists(this);
    const { blockLen, state } = this;
    data12 = toBytes(data12);
    const len = data12.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i3 = 0;i3 < take; i3++)
        state[this.pos++] ^= data12[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes2(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length;pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    number7(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

// node_modules/ethers/lib.esm/crypto/keccak.js
function keccak256(_data) {
  const data12 = getBytes(_data, "data");
  return hexlify(__keccak256(data12));
}
var locked3 = false;
var _keccak256 = function(data12) {
  return keccak_256(data12);
};
var __keccak256 = _keccak256;
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked3 = true;
};
keccak256.register = function(func) {
  if (locked3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value15, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value15, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value15 >> _32n2 & _u32_max);
  const wl = Number(value15 & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l3 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l3, wl, isLE2);
}

class SHA2 extends Hash3 {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data12) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data12 = toBytes(data12);
    const len = data12.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data12);
        for (;blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data12.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data12.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i3 = pos;i3 < blockLen; i3++)
      buffer[i3] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i3 = 0;i3 < outLen; i3++)
      oview.setUint32(4 * i3, state[i3], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}

// node_modules/@noble/hashes/esm/ripemd160.js
function f3(group, x3, y3, z4) {
  if (group === 0)
    return x3 ^ y3 ^ z4;
  else if (group === 1)
    return x3 & y3 | ~x3 & z4;
  else if (group === 2)
    return (x3 | ~y3) ^ z4;
  else if (group === 3)
    return x3 & z4 | y3 & ~z4;
  else
    return x3 ^ (y3 | ~z4);
}
var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_5, i3) => i3);
var Pi = /* @__PURE__ */ Id.map((i3) => (9 * i3 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i3 = 0;i3 < 4; i3++)
  for (let j of [idxL, idxR])
    j.push(j[i3].map((k) => Rho[k]));
var shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i3) => new Uint8Array(i3));
var shiftsL = /* @__PURE__ */ idxL.map((idx, i3) => idx.map((j) => shifts[i3][j]));
var shiftsR = /* @__PURE__ */ idxR.map((idx, i3) => idx.map((j) => shifts[i3][j]));
var Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
var BUF = /* @__PURE__ */ new Uint32Array(16);

class RIPEMD160 extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0: h02, h1: h12, h2: h22, h3, h4 } = this;
    return [h02, h12, h22, h3, h4];
  }
  set(h02, h12, h22, h3, h4) {
    this.h0 = h02 | 0;
    this.h1 = h12 | 0;
    this.h2 = h22 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i3 = 0;i3 < 16; i3++, offset += 4)
      BUF[i3] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0;group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i3 = 0;i3 < 16; i3++) {
        const tl = rotl(al + f3(group, bl, cl, dl) + BUF[rl[i3]] + hbl, sl[i3]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i3 = 0;i3 < 16; i3++) {
        const tr = rotl(ar + f3(rGroup, br, cr, dr) + BUF[rr[i3]] + hbr, sr[i3]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
var ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160);

// node_modules/ethers/lib.esm/crypto/ripemd160.js
function ripemd1603(_data) {
  const data12 = getBytes(_data, "data");
  return hexlify(__ripemd160(data12));
}
var locked4 = false;
var _ripemd160 = function(data12) {
  return ripemd160(data12);
};
var __ripemd160 = _ripemd160;
ripemd1603._ = _ripemd160;
ripemd1603.lock = function() {
  locked4 = true;
};
ripemd1603.register = function(func) {
  if (locked4) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd1603);

// node_modules/ethers/lib.esm/crypto/pbkdf2.js
function pbkdf2(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
var locked5 = false;
var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
var __pbkdf2 = _pbkdf2;
pbkdf2._ = _pbkdf2;
pbkdf2.lock = function() {
  locked5 = true;
};
pbkdf2.register = function(func) {
  if (locked5) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf2);

// node_modules/ethers/lib.esm/crypto/random.js
function randomBytes3(length) {
  return __randomBytes(length);
}
var locked6 = false;
var _randomBytes = function(length) {
  return new Uint8Array(randomBytes(length));
};
var __randomBytes = _randomBytes;
randomBytes3._ = _randomBytes;
randomBytes3.lock = function() {
  locked6 = true;
};
randomBytes3.register = function(func) {
  if (locked6) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes3);

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c3) => a & b ^ ~a & c3;
var Maj = (a, b, c3) => a & b ^ a & c3 ^ b & c3;
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);

class SHA2562 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C: C4, D, E, F, G, H } = this;
    return [A, B, C4, D, E, F, G, H];
  }
  set(A, B, C4, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C4 | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i3 = 0;i3 < 16; i3++, offset += 4)
      SHA256_W[i3] = view.getUint32(offset, false);
    for (let i3 = 16;i3 < 64; i3++) {
      const W15 = SHA256_W[i3 - 15];
      const W22 = SHA256_W[i3 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s12 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W[i3] = s12 + SHA256_W[i3 - 7] + s0 + SHA256_W[i3 - 16] | 0;
    }
    let { A, B, C: C4, D, E, F, G, H } = this;
    for (let i3 = 0;i3 < 64; i3++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T12 = H + sigma1 + Chi(E, F, G) + SHA256_K[i3] + SHA256_W[i3] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T22 = sigma0 + Maj(A, B, C4) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T12 | 0;
      D = C4;
      C4 = B;
      B = A;
      A = T12 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C4 = C4 + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C4, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
var sha2563 = /* @__PURE__ */ wrapConstructor(() => new SHA2562);

// node_modules/@noble/hashes/esm/hmac.js
class HMAC2 extends Hash3 {
  constructor(hash8, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash7(hash8);
    const key = toBytes(_key);
    this.iHash = hash8.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash8.create().update(key).digest() : key);
    for (let i3 = 0;i3 < pad.length; i3++)
      pad[i3] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash8.create();
    for (let i3 = 0;i3 < pad.length; i3++)
      pad[i3] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac = (hash8, key, message) => new HMAC2(hash8, key).update(message).digest();
hmac.create = (hash8, key) => new HMAC2(hash8, key);

// node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash8, _password, _salt, _opts) {
  hash7(hash8);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c3, dkLen, asyncTick } = opts;
  number7(c3);
  number7(dkLen);
  number7(asyncTick);
  if (c3 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash8, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c3, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u3) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u3.fill(0);
  return DK;
}
function pbkdf22(hash8, password, salt, opts) {
  const { c: c3, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash8, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u3 = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0;pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u3);
    Ti.set(u3.subarray(0, Ti.length));
    for (let ui = 1;ui < c3; ui++) {
      PRF._cloneInto(prfW).update(u3).digestInto(u3);
      for (let i3 = 0;i3 < Ti.length; i3++)
        Ti[i3] ^= u3[i3];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u3);
}

// node_modules/@noble/hashes/esm/scrypt.js
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i3 = 0;i3 < 8; i3 += 2) {
    x04 ^= rotl2(x00 + x12 | 0, 7);
    x08 ^= rotl2(x04 + x00 | 0, 9);
    x12 ^= rotl2(x08 + x04 | 0, 13);
    x00 ^= rotl2(x12 + x08 | 0, 18);
    x09 ^= rotl2(x05 + x01 | 0, 7);
    x13 ^= rotl2(x09 + x05 | 0, 9);
    x01 ^= rotl2(x13 + x09 | 0, 13);
    x05 ^= rotl2(x01 + x13 | 0, 18);
    x14 ^= rotl2(x10 + x06 | 0, 7);
    x02 ^= rotl2(x14 + x10 | 0, 9);
    x06 ^= rotl2(x02 + x14 | 0, 13);
    x10 ^= rotl2(x06 + x02 | 0, 18);
    x03 ^= rotl2(x15 + x11 | 0, 7);
    x07 ^= rotl2(x03 + x15 | 0, 9);
    x11 ^= rotl2(x07 + x03 | 0, 13);
    x15 ^= rotl2(x11 + x07 | 0, 18);
    x01 ^= rotl2(x00 + x03 | 0, 7);
    x02 ^= rotl2(x01 + x00 | 0, 9);
    x03 ^= rotl2(x02 + x01 | 0, 13);
    x00 ^= rotl2(x03 + x02 | 0, 18);
    x06 ^= rotl2(x05 + x04 | 0, 7);
    x07 ^= rotl2(x06 + x05 | 0, 9);
    x04 ^= rotl2(x07 + x06 | 0, 13);
    x05 ^= rotl2(x04 + x07 | 0, 18);
    x11 ^= rotl2(x10 + x09 | 0, 7);
    x08 ^= rotl2(x11 + x10 | 0, 9);
    x09 ^= rotl2(x08 + x11 | 0, 13);
    x10 ^= rotl2(x09 + x08 | 0, 18);
    x12 ^= rotl2(x15 + x14 | 0, 7);
    x13 ^= rotl2(x12 + x15 | 0, 9);
    x14 ^= rotl2(x13 + x12 | 0, 13);
    x15 ^= rotl2(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i3 = 0;i3 < 16; i3++)
    out[tail + i3] = input[ii + (2 * r - 1) * 16 + i3];
  for (let i3 = 0;i3 < r; i3++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i3 > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number7(N);
  number7(r);
  number7(p);
  number7(dkLen);
  number7(asyncTick);
  number7(maxmem);
  if (onProgress !== undefined && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf22(sha2563, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf22(sha2563, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt3(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0;pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i3 = 0;i3 < blockSize32; i3++)
      V[i3] = B32[Pi2 + i3];
    for (let i3 = 0, pos = 0;i3 < N - 1; i3++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    for (let i3 = 0;i3 < N; i3++) {
      const j = B32[Pi2 + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi = 0;pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i3 = 0;i3 < blockSize32; i3++)
      V[i3] = B32[Pi2 + i3];
    let pos = 0;
    await asyncLoop(N - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V, (N - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    await asyncLoop(N, asyncTick, () => {
      const j = B32[Pi2 + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
var rotl2 = (a, b) => a << b | a >>> 32 - b;

// node_modules/ethers/lib.esm/crypto/scrypt.js
async function scrypt5(_passwd, _salt, N, r, p, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));
}
function scryptSync(_passwd, _salt, N, r, p, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N, r, p, dkLen));
}
var lockedSync = false;
var lockedAsync = false;
var _scryptAsync = async function(passwd, salt, N, r, p, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N, r, p, dkLen, onProgress });
};
var _scryptSync = function(passwd, salt, N, r, p, dkLen) {
  return scrypt3(passwd, salt, { N, r, p, dkLen });
};
var __scryptAsync = _scryptAsync;
var __scryptSync = _scryptSync;
scrypt5._ = _scryptAsync;
scrypt5.lock = function() {
  lockedAsync = true;
};
scrypt5.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt5);
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);

// node_modules/ethers/lib.esm/crypto/sha2.js
function sha2565(_data) {
  const data12 = getBytes(_data, "data");
  return hexlify(__sha256(data12));
}
function sha5126(_data) {
  const data12 = getBytes(_data, "data");
  return hexlify(__sha512(data12));
}
var _sha256 = function(data12) {
  return createHash4("sha256").update(data12).digest();
};
var _sha512 = function(data12) {
  return createHash4("sha512").update(data12).digest();
};
var __sha256 = _sha256;
var __sha512 = _sha512;
var locked256 = false;
var locked512 = false;
sha2565._ = _sha256;
sha2565.lock = function() {
  locked256 = true;
};
sha2565.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha2565);
sha5126._ = _sha512;
sha5126.lock = function() {
  locked512 = true;
};
sha5126.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha2565);

// node_modules/@noble/curves/esm/abstract/utils.js
var exports_utils = {};
__export(exports_utils, {
  validateObject: () => validateObject,
  utf8ToBytes: () => utf8ToBytes2,
  numberToVarBytesBE: () => numberToVarBytesBE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToBytesLE: () => numberToBytesLE,
  numberToBytesBE: () => numberToBytesBE,
  hexToNumber: () => hexToNumber,
  hexToBytes: () => hexToBytes,
  equalBytes: () => equalBytes,
  ensureBytes: () => ensureBytes,
  createHmacDrbg: () => createHmacDrbg,
  concatBytes: () => concatBytes2,
  bytesToNumberLE: () => bytesToNumberLE,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToHex: () => bytesToHex,
  bitSet: () => bitSet,
  bitMask: () => bitMask,
  bitLen: () => bitLen,
  bitGet: () => bitGet
});
function bytesToHex(bytes3) {
  if (!u8a2(bytes3))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i3 = 0;i3 < bytes3.length; i3++) {
    hex += hexes[bytes3[i3]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array5 = new Uint8Array(len / 2);
  for (let i3 = 0;i3 < array5.length; i3++) {
    const j = i3 * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array5[i3] = byte;
  }
  return array5;
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex(bytes3));
}
function bytesToNumberLE(bytes3) {
  if (!u8a2(bytes3))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n3, len) {
  return hexToBytes(n3.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n3, len) {
  return numberToBytesBE(n3, len).reverse();
}
function numberToVarBytesBE(n3) {
  return hexToBytes(numberToHexUnpadded(n3));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a2(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b12, b22) {
  if (b12.length !== b22.length)
    return false;
  for (let i3 = 0;i3 < b12.length; i3++)
    if (b12[i3] !== b22[i3])
      return false;
  return true;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n3) {
  let len;
  for (len = 0;n3 > _0n2; n3 >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n3, pos) {
  return n3 >> BigInt(pos) & _1n2;
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v3 = u8n(hashLen);
  let k = u8n(hashLen);
  let i3 = 0;
  const reset = () => {
    v3.fill(1);
    k.fill(0);
    i3 = 0;
  };
  const h = (...b) => hmacFn(k, v3, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v3 = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v3 = h();
  };
  const gen2 = () => {
    if (i3++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v3 = h();
      const sl = v3.slice();
      out.push(sl);
      len += v3.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = undefined;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object13, validators, optValidators = {}) {
  const checkField = (fieldName, type50, isOptional) => {
    const checkVal = validatorFns[type50];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type50}", expected function`);
    const val = object13[fieldName];
    if (isOptional && val === undefined)
      return;
    if (!checkVal(val, object13)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type50}`);
    }
  };
  for (const [fieldName, type50] of Object.entries(validators))
    checkField(fieldName, type50, false);
  for (const [fieldName, type50] of Object.entries(optValidators))
    checkField(fieldName, type50, true);
  return object13;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var u8a2 = (a) => a instanceof Uint8Array;
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_5, i3) => i3.toString(16).padStart(2, "0"));
var bitSet = (n3, pos, value15) => {
  return n3 | (value15 ? _1n2 : _0n2) << BigInt(pos);
};
var bitMask = (n3) => (_2n2 << BigInt(n3 - 1)) - _1n2;
var u8n = (data12) => new Uint8Array(data12);
var u8fr = (arr) => Uint8Array.from(arr);
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object13) => object13.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};

// node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x3, power, modulo) {
  let res = x3;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number8, modulo) {
  if (number8 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number8} mod=${modulo}`);
  }
  let a = mod(number8, modulo);
  let b = modulo;
  let x3 = _0n3, y3 = _1n3, u3 = _1n3, v3 = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m3 = x3 - u3 * q;
    const n3 = y3 - v3 * q;
    b = a, a = r, x3 = u3, y3 = v3, u3 = m3, v3 = n3;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x3, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q, S, Z;
  for (Q = P - _1n3, S = 0;Q % _2n3 === _0n3; Q /= _2n3, S++)
    ;
  for (Z = _2n3;Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp, n3) {
      const root = Fp.pow(n3, p1div4);
      if (!Fp.eql(Fp.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp, n3) {
    if (Fp.pow(n3, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x3 = Fp.pow(n3, Q1div2);
    let b = Fp.pow(n3, Q);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m3 = 1;
      for (let t22 = Fp.sqr(b);m3 < r; m3++) {
        if (Fp.eql(t22, Fp.ONE))
          break;
        t22 = Fp.sqr(t22);
      }
      const ge = Fp.pow(g, _1n3 << BigInt(r - m3 - 1));
      g = Fp.sqr(ge);
      x3 = Fp.mul(x3, ge);
      b = Fp.mul(b, g);
      r = m3;
    }
    return x3;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp, n3) {
      const root = Fp.pow(n3, p1div4);
      if (!Fp.eql(Fp.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c12 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp, n3) {
      const n22 = Fp.mul(n3, _2n3);
      const v3 = Fp.pow(n22, c12);
      const nv = Fp.mul(n3, v3);
      const i3 = Fp.mul(Fp.mul(nv, _2n3), v3);
      const root = Fp.mul(nv, Fp.sub(i3, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n3))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map4, val) => {
    map4[val] = "function";
    return map4;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f4, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f4.ONE;
  if (power === _1n3)
    return num;
  let p = f4.ONE;
  let d3 = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f4.mul(p, d3);
    d3 = f4.sqr(d3);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f4, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i3) => {
    if (f4.is0(num))
      return acc;
    tmp[i3] = acc;
    return f4.mul(acc, num);
  }, f4.ONE);
  const inverted = f4.inv(lastMultiplied);
  nums.reduceRight((acc, num, i3) => {
    if (f4.is0(num))
      return acc;
    tmp[i3] = f4.mul(acc, tmp[i3]);
    return f4.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n3, nBitLength) {
  const _nBitLength = nBitLength !== undefined ? nBitLength : n3.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f4 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f4, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n3) => sqrtP(f4, n3)),
    invertBatch: (lst) => FpInvertBatch(f4, lst),
    cmov: (a, b, c3) => c3 ? b : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE2 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f4);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];

// node_modules/@noble/curves/esm/abstract/curve.js
function wNAF(c3, bits2) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits2 / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    unsafeLadder(elm, n3) {
      let p = c3.ZERO;
      let d3 = elm;
      while (n3 > _0n4) {
        if (n3 & _1n4)
          p = p.add(d3);
        d3 = d3.double();
        n3 >>= _1n4;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i3 = 1;i3 < windowSize; i3++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    wNAF(W, precomputes, n3) {
      const { windows, windowSize } = opts(W);
      let p = c3.ZERO;
      let f4 = c3.BASE;
      const mask2 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n3 & mask2);
        n3 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n3 += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f4 = f4.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f4 };
    },
    wNAFCached(P, precomputesMap, n3, transform7) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform7(comp));
        }
      }
      return this.wNAF(W, comp, n3);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve2) {
  const opts = validateBasic(curve2);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp, a } = opts;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x3 = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y3 = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x: x3, y: y3 };
  });
  function weierstrassEquation(x3) {
    const { a, b } = CURVE;
    const x22 = Fp.sqr(x3);
    const x32 = Fp.mul(x22, x3);
    return Fp.add(Fp.add(x32, Fp.mul(x3, a)), b);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n3 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error23) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n3);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = new Map;
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }

  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
    }
    static fromAffine(p) {
      const { x: x3, y: y3 } = p || {};
      if (!p || !Fp.isValid(x3) || !Fp.isValid(y3))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i3) => Fp.eql(i3, Fp.ZERO);
      if (is0(x3) && is0(y3))
        return Point.ZERO;
      return new Point(x3, y3, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map((p) => p.pz));
      return points.map((p, i3) => p.toAffine(toInv[i3])).map(Point.fromAffine);
    }
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x3, y: y3 } = this.toAffine();
      if (!Fp.isValid(x3) || !Fp.isValid(y3))
        throw new Error("bad point: x or y not FE");
      const left = Fp.sqr(y3);
      const right = weierstrassEquation(x3);
      if (!Fp.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y3 } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y3);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X12, py: Y12, pz: Z12 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      const U1 = Fp.eql(Fp.mul(X12, Z22), Fp.mul(X22, Z12));
      const U22 = Fp.eql(Fp.mul(Y12, Z22), Fp.mul(Y22, Z12));
      return U1 && U22;
    }
    negate() {
      return new Point(this.px, Fp.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { px: X12, py: Y12, pz: Z12 } = this;
      let { ZERO: X32, ZERO: Y32, ZERO: Z32 } = Fp;
      let t0 = Fp.mul(X12, X12);
      let t12 = Fp.mul(Y12, Y12);
      let t22 = Fp.mul(Z12, Z12);
      let t3 = Fp.mul(X12, Y12);
      t3 = Fp.add(t3, t3);
      Z32 = Fp.mul(X12, Z12);
      Z32 = Fp.add(Z32, Z32);
      X32 = Fp.mul(a, Z32);
      Y32 = Fp.mul(b3, t22);
      Y32 = Fp.add(X32, Y32);
      X32 = Fp.sub(t12, Y32);
      Y32 = Fp.add(t12, Y32);
      Y32 = Fp.mul(X32, Y32);
      X32 = Fp.mul(t3, X32);
      Z32 = Fp.mul(b3, Z32);
      t22 = Fp.mul(a, t22);
      t3 = Fp.sub(t0, t22);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z32);
      Z32 = Fp.add(t0, t0);
      t0 = Fp.add(Z32, t0);
      t0 = Fp.add(t0, t22);
      t0 = Fp.mul(t0, t3);
      Y32 = Fp.add(Y32, t0);
      t22 = Fp.mul(Y12, Z12);
      t22 = Fp.add(t22, t22);
      t0 = Fp.mul(t22, t3);
      X32 = Fp.sub(X32, t0);
      Z32 = Fp.mul(t22, t12);
      Z32 = Fp.add(Z32, Z32);
      Z32 = Fp.add(Z32, Z32);
      return new Point(X32, Y32, Z32);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X12, py: Y12, pz: Z12 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      let { ZERO: X32, ZERO: Y32, ZERO: Z32 } = Fp;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X12, X22);
      let t12 = Fp.mul(Y12, Y22);
      let t22 = Fp.mul(Z12, Z22);
      let t3 = Fp.add(X12, Y12);
      let t4 = Fp.add(X22, Y22);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t12);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X12, Z12);
      let t5 = Fp.add(X22, Z22);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t22);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y12, Z12);
      X32 = Fp.add(Y22, Z22);
      t5 = Fp.mul(t5, X32);
      X32 = Fp.add(t12, t22);
      t5 = Fp.sub(t5, X32);
      Z32 = Fp.mul(a, t4);
      X32 = Fp.mul(b3, t22);
      Z32 = Fp.add(X32, Z32);
      X32 = Fp.sub(t12, Z32);
      Z32 = Fp.add(t12, Z32);
      Y32 = Fp.mul(X32, Z32);
      t12 = Fp.add(t0, t0);
      t12 = Fp.add(t12, t0);
      t22 = Fp.mul(a, t22);
      t4 = Fp.mul(b3, t4);
      t12 = Fp.add(t12, t22);
      t22 = Fp.sub(t0, t22);
      t22 = Fp.mul(a, t22);
      t4 = Fp.add(t4, t22);
      t0 = Fp.mul(t12, t4);
      Y32 = Fp.add(Y32, t0);
      t0 = Fp.mul(t5, t4);
      X32 = Fp.mul(t3, X32);
      X32 = Fp.sub(X32, t0);
      t0 = Fp.mul(t3, t12);
      Z32 = Fp.mul(t5, Z32);
      Z32 = Fp.add(Z32, t0);
      return new Point(X32, Y32, Z32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n3) {
      return wnaf.wNAFCached(this, pointPrecomputes, n3, (comp) => {
        const toInv = Fp.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i3) => p.toAffine(toInv[i3])).map(Point.fromAffine);
      });
    }
    multiplyUnsafe(n3) {
      const I = Point.ZERO;
      if (n3 === _0n5)
        return I;
      assertGE(n3);
      if (n3 === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n3);
      let { k1neg, k1: k12, k2neg, k2: k22 } = endo.splitScalar(n3);
      let k1p = I;
      let k2p = I;
      let d3 = this;
      while (k12 > _0n5 || k22 > _0n5) {
        if (k12 & _1n5)
          k1p = k1p.add(d3);
        if (k22 & _1n5)
          k2p = k2p.add(d3);
        d3 = d3.double();
        k12 >>= _1n5;
        k22 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      assertGE(scalar);
      let n3 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1: k12, k2neg, k2: k22 } = endo.splitScalar(n3);
        let { p: k1p, f: f1p } = this.wNAF(k12);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f4 } = this.wNAF(n3);
        point = p;
        fake = f4;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point.BASE;
      const mul = (P, a3) => a3 === _0n5 || a3 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a3) : P.multiply(a3);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? undefined : sum;
    }
    toAffine(iz) {
      const { px: x3, py: y3, pz: z4 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp.ONE : Fp.inv(z4);
      const ax = Fp.mul(x3, iz);
      const ay = Fp.mul(y3, iz);
      const zz = Fp.mul(z4, iz);
      if (is0)
        return { x: Fp.ZERO, y: Fp.ZERO };
      if (!Fp.eql(zz, Fp.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve2) {
  const opts = validateBasic(curve2);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp.BYTES + 1;
  const uncompressedLen = 2 * Fp.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x3 = Fp.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x3);
      } else {
        return cat(Uint8Array.from([4]), x3, Fp.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x3 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x3))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x3);
        let y3 = Fp.sqrt(y22);
        const isYOdd = (y3 & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp.neg(y3);
        return { x: x3, y: y3 };
      } else if (len === uncompressedLen && head === 4) {
        const x3 = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y3 = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x: x3, y: y3 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number8) {
    const HALF = CURVE_ORDER >> _1n5;
    return number8 > HALF;
  }
  function normalizeS(s3) {
    return isBiggerThanHalfOrder(s3) ? modN(-s3) : s3;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));

  class Signature2 {
    constructor(r, s3, recovery) {
      this.r = r;
      this.s = s3;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l3 = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l3 * 2);
      return new Signature2(slcNum(hex, 0, l3), slcNum(hex, l3, 2 * l3));
    }
    static fromDER(hex) {
      const { r, s: s3 } = DER.toSig(ensureBytes("DER", hex));
      return new Signature2(r, s3);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s: s3, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u12 = modN(-h * ir);
      const u22 = modN(s3 * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u12, u22);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils18 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error23) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    const num = bytesToNumberBE(bytes3);
    const delta4 = bytes3.length * 8 - CURVE.nBitLength;
    return delta4 > 0 ? num >> BigInt(delta4) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => (k in opts)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash8, randomBytes: randomBytes4 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash8(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d3 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d3), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes4(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m3 = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n5)
        return;
      const s3 = modN(ik * modN(m3 + r * d3));
      if (s3 === _0n5)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
      let normS = s3;
      if (lowS && isBiggerThanHalfOrder(s3)) {
        normS = normalizeS(s3);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C4 = CURVE;
    const drbg = createHmacDrbg(C4.hash.outputLen, C4.nByteLength, C4.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = undefined;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r3, s: s4 } = sg;
        _sig = new Signature2(r3, s4);
      } else {
        throw new Error("PARSE");
      }
      P = Point.fromHex(publicKey);
    } catch (error23) {
      if (error23.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s: s3 } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s3);
    const u12 = modN(h * is);
    const u22 = modN(r * is);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u12, u22)?.toAffine();
    if (!R)
      return false;
    const v3 = modN(R.x);
    return v3 === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature: Signature2,
    utils: utils18
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var { bytesToNumberBE: b2n, hexToBytes: h2b } = exports_utils;
var DER = {
  Err: class DERErr extends Error {
    constructor(m3 = "") {
      super(m3);
    }
  },
  _parseInt(data12) {
    const { Err: E } = DER;
    if (data12.length < 2 || data12[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data12[1];
    const res = data12.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data12.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data12 = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data12 instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l3 = data12.length;
    if (l3 < 2 || data12[0] != 48)
      throw new E("Invalid signature tag");
    if (data12[1] !== l3 - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data12.subarray(2));
    const { d: s3, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s: s3 };
  },
  hexFromSig(sig) {
    const slice = (s4) => Number.parseInt(s4[0], 16) & 8 ? "00" + s4 : s4;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s3 = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s3.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s3}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash8) {
  return {
    hash: hash8,
    hmac: (key, ...msgs) => hmac(hash8, key, concatBytes(...msgs)),
    randomBytes: randomBytes2
  };
}
function createCurve(curveDef, defHash) {
  const create5 = (hash8) => weierstrass({ ...curveDef, ...getHash(hash8) });
  return Object.freeze({ ...create5(defHash), create: create5 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */

// node_modules/@noble/curves/esm/secp256k1.js
function sqrtMod(y3) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y3 * y3 * y3 % P;
  const b3 = b22 * b22 * y3 % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b22 % P;
  const b222 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b222, _22n, P) * b222 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t12 = pow2(b223, _23n, P) * b222 % P;
  const t22 = pow2(t12, _6n, P) * b22 % P;
  const root = pow2(t22, _2n5, P);
  if (!Fp.eql(Fp.sqr(root), y3))
    throw new Error("Cannot find square root");
  return root;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n5) / b;
var Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n3 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b12 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c12 = divNearest(b22 * k, n3);
      const c22 = divNearest(-b12 * k, n3);
      let k12 = mod(k - c12 * a1 - c22 * a22, n3);
      let k22 = mod(-c12 * b12 - c22 * b22, n3);
      const k1neg = k12 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k12 = n3 - k12;
      if (k2neg)
        k22 = n3 - k22;
      if (k12 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1: k12, k2neg, k2: k22 };
    }
  }
}, sha2563);
var _0n6 = BigInt(0);
var Point = secp256k1.ProjectivePoint;

// node_modules/ethers/lib.esm/constants/addresses.js
var ZeroAddress = "0x0000000000000000000000000000000000000000";
// node_modules/ethers/lib.esm/constants/hashes.js
var ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
// node_modules/ethers/lib.esm/constants/numbers.js
var N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var WeiPerEther = BigInt("1000000000000000000");
var MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
var MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
// node_modules/ethers/lib.esm/constants/strings.js
var EtherSymbol = "\u039E";
var MessagePrefix = `\x19Ethereum Signed Message:
`;
// node_modules/ethers/lib.esm/crypto/signature.js
function toUint256(value15) {
  return zeroPadValue(toBeArray(value15), 32);
}
var BN_04 = BigInt(0);
var BN_13 = BigInt(1);
var BN_2 = BigInt(2);
var BN_27 = BigInt(27);
var BN_28 = BigInt(28);
var BN_35 = BigInt(35);
var _guard3 = {};

class Signature2 {
  #r;
  #s;
  #v;
  #networkV;
  get r() {
    return this.#r;
  }
  set r(value15) {
    assertArgument(dataLength(value15) === 32, "invalid r", "value", value15);
    this.#r = hexlify(value15);
  }
  get s() {
    assertArgument(parseInt(this.#s.substring(0, 3)) < 8, "non-canonical s; use ._s", "s", this.#s);
    return this.#s;
  }
  set s(_value) {
    assertArgument(dataLength(_value) === 32, "invalid s", "value", _value);
    this.#s = hexlify(_value);
  }
  get _s() {
    return this.#s;
  }
  isValid() {
    return parseInt(this.#s.substring(0, 3)) < 8;
  }
  get v() {
    return this.#v;
  }
  set v(value15) {
    const v3 = getNumber(value15, "value");
    assertArgument(v3 === 27 || v3 === 28, "invalid v", "v", value15);
    this.#v = v3;
  }
  get networkV() {
    return this.#networkV;
  }
  get legacyChainId() {
    const v3 = this.networkV;
    if (v3 == null) {
      return null;
    }
    return Signature2.getChainId(v3);
  }
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  get compactSerialized() {
    return concat2([this.r, this.yParityAndS]);
  }
  get serialized() {
    return concat2([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  constructor(guard22, r, s3, v3) {
    assertPrivate(guard22, _guard3, "Signature");
    this.#r = r;
    this.#s = s3;
    this.#v = v3;
    this.#networkV = null;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  clone() {
    const clone13 = new Signature2(_guard3, this.r, this._s, this.v);
    if (this.networkV) {
      clone13.#networkV = this.networkV;
    }
    return clone13;
  }
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this._s,
      v: this.v
    };
  }
  static getChainId(v3) {
    const bv = getBigInt(v3, "v");
    if (bv == BN_27 || bv == BN_28) {
      return BN_04;
    }
    assertArgument(bv >= BN_35, "invalid EIP-155 v", "v", v3);
    return (bv - BN_35) / BN_2;
  }
  static getChainIdV(chainId, v3) {
    return getBigInt(chainId) * BN_2 + BigInt(35 + v3 - 27);
  }
  static getNormalizedV(v3) {
    const bv = getBigInt(v3);
    if (bv === BN_04 || bv === BN_27) {
      return 27;
    }
    if (bv === BN_13 || bv === BN_28) {
      return 28;
    }
    assertArgument(bv >= BN_35, "invalid v", "v", v3);
    return bv & BN_13 ? 27 : 28;
  }
  static from(sig) {
    function assertError(check11, message) {
      assertArgument(check11, message, "signature", sig);
    }
    if (sig == null) {
      return new Signature2(_guard3, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes3 = getBytes(sig, "signature");
      if (bytes3.length === 64) {
        const r3 = hexlify(bytes3.slice(0, 32));
        const s4 = bytes3.slice(32, 64);
        const v4 = s4[0] & 128 ? 28 : 27;
        s4[0] &= 127;
        return new Signature2(_guard3, r3, hexlify(s4), v4);
      }
      if (bytes3.length === 65) {
        const r3 = hexlify(bytes3.slice(0, 32));
        const s4 = hexlify(bytes3.slice(32, 64));
        const v4 = Signature2.getNormalizedV(bytes3[64]);
        return new Signature2(_guard3, r3, s4, v4);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof Signature2) {
      return sig.clone();
    }
    const _r = sig.r;
    assertError(_r != null, "missing r");
    const r = toUint256(_r);
    const s3 = function(s4, yParityAndS) {
      if (s4 != null) {
        return toUint256(s4);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes3 = getBytes(yParityAndS);
        bytes3[0] &= 127;
        return hexlify(bytes3);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    const { networkV, v: v3 } = function(_v, yParityAndS, yParity) {
      if (_v != null) {
        const v4 = getBigInt(_v);
        return {
          networkV: v4 >= BN_35 ? v4 : undefined,
          v: Signature2.getNormalizedV(v4)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new Signature2(_guard3, r, s3, v3);
    if (networkV) {
      result.#networkV = networkV;
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
}

// node_modules/ethers/lib.esm/crypto/signing-key.js
class SigningKey {
  #privateKey;
  constructor(privateKey) {
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    this.#privateKey = hexlify(privateKey);
  }
  get privateKey() {
    return this.#privateKey;
  }
  get publicKey() {
    return SigningKey.computePublicKey(this.#privateKey);
  }
  get compressedPublicKey() {
    return SigningKey.computePublicKey(this.#privateKey, true);
  }
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {
      lowS: true
    });
    return Signature2.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  computeSharedSecret(other) {
    const pubKey = SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));
  }
  static computePublicKey(key, compressed) {
    let bytes3 = getBytes(key, "key");
    if (bytes3.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes3, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes3.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes3, 1);
      bytes3 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes3);
    return hexlify(point.toRawBytes(compressed));
  }
  static recoverPublicKey(digest, signature2) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature2.from(signature2);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat2([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signature for digest", "signature", signature2);
    return "0x" + pubKey.toHex(false);
  }
  static addPoints(p02, p12, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p02).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p12).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
}

// node_modules/ethers/lib.esm/crypto/index.js
function lock() {
  computeHmac.lock();
  keccak256.lock();
  pbkdf2.lock();
  randomBytes3.lock();
  ripemd1603.lock();
  scrypt5.lock();
  scryptSync.lock();
  sha2565.lock();
  sha5126.lock();
  randomBytes3.lock();
}

// node_modules/ethers/lib.esm/address/address.js
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i3 = 0;i3 < 40; i3++) {
    expanded[i3] = chars[i3].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i3 = 0;i3 < 40; i3 += 2) {
    if (hashed[i3 >> 1] >> 4 >= 8) {
      chars[i3] = chars[i3].toUpperCase();
    }
    if ((hashed[i3 >> 1] & 15) >= 8) {
      chars[i3 + 1] = chars[i3 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c3) => {
    return ibanLookup[c3];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function fromBase36(value15) {
  value15 = value15.toLowerCase();
  let result = BN_05;
  for (let i3 = 0;i3 < value15.length; i3++) {
    result = result * BN_36 + Base36[value15[i3]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getIcapAddress(address) {
  let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
var BN_05 = BigInt(0);
var BN_36 = BigInt(36);
var ibanLookup = {};
for (let i3 = 0;i3 < 10; i3++) {
  ibanLookup[String(i3)] = String(i3);
}
for (let i3 = 0;i3 < 26; i3++) {
  ibanLookup[String.fromCharCode(65 + i3)] = String(10 + i3);
}
var safeDigits = 15;
var Base36 = function() {
  const result = {};
  for (let i3 = 0;i3 < 36; i3++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i3];
    result[key] = BigInt(i3);
  }
  return result;
}();
// node_modules/ethers/lib.esm/address/contract-address.js
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function getCreate2Address(_from, _salt, _initCodeHash) {
  const from = getAddress(_from);
  const salt = getBytes(_salt, "salt");
  const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
  assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress(dataSlice(keccak256(concat2(["0xff", from, salt, initCodeHash])), 12));
}
// node_modules/ethers/lib.esm/address/checks.js
function isAddressable(value15) {
  return value15 && typeof value15.getAddress === "function";
}
function isAddress(value15) {
  try {
    getAddress(value15);
    return true;
  } catch (error23) {
  }
  return false;
}
async function checkAddress(target, promise5) {
  const result = await promise5;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
// node_modules/ethers/lib.esm/abi/typed.js
function n3(value15, width) {
  let signed = false;
  if (width < 0) {
    signed = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value15, { signed, width });
}
function b(value15, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value15, { size });
}
var _gaurd = {};
var _typedSymbol = Symbol.for("_ethers_typed");

class Typed {
  type;
  value;
  #options;
  _typedSymbol;
  constructor(gaurd, type50, value15, options) {
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type: type50, value: value15 });
    this.#options = options;
    this.format();
  }
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v3) => v3.format()).join(",")})`;
    }
    return this.type;
  }
  defaultValue() {
    return 0;
  }
  minValue() {
    return 0;
  }
  maxValue() {
    return 0;
  }
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  isData() {
    return this.type.startsWith("bytes");
  }
  isString() {
    return this.type === "string";
  }
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return this.#options;
  }
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (this.#options === true) {
      return -1;
    }
    if (this.#options === false) {
      return this.value.length;
    }
    return null;
  }
  static from(type50, value15) {
    return new Typed(_gaurd, type50, value15);
  }
  static uint8(v3) {
    return n3(v3, 8);
  }
  static uint16(v3) {
    return n3(v3, 16);
  }
  static uint24(v3) {
    return n3(v3, 24);
  }
  static uint32(v3) {
    return n3(v3, 32);
  }
  static uint40(v3) {
    return n3(v3, 40);
  }
  static uint48(v3) {
    return n3(v3, 48);
  }
  static uint56(v3) {
    return n3(v3, 56);
  }
  static uint64(v3) {
    return n3(v3, 64);
  }
  static uint72(v3) {
    return n3(v3, 72);
  }
  static uint80(v3) {
    return n3(v3, 80);
  }
  static uint88(v3) {
    return n3(v3, 88);
  }
  static uint96(v3) {
    return n3(v3, 96);
  }
  static uint104(v3) {
    return n3(v3, 104);
  }
  static uint112(v3) {
    return n3(v3, 112);
  }
  static uint120(v3) {
    return n3(v3, 120);
  }
  static uint128(v3) {
    return n3(v3, 128);
  }
  static uint136(v3) {
    return n3(v3, 136);
  }
  static uint144(v3) {
    return n3(v3, 144);
  }
  static uint152(v3) {
    return n3(v3, 152);
  }
  static uint160(v3) {
    return n3(v3, 160);
  }
  static uint168(v3) {
    return n3(v3, 168);
  }
  static uint176(v3) {
    return n3(v3, 176);
  }
  static uint184(v3) {
    return n3(v3, 184);
  }
  static uint192(v3) {
    return n3(v3, 192);
  }
  static uint200(v3) {
    return n3(v3, 200);
  }
  static uint208(v3) {
    return n3(v3, 208);
  }
  static uint216(v3) {
    return n3(v3, 216);
  }
  static uint224(v3) {
    return n3(v3, 224);
  }
  static uint232(v3) {
    return n3(v3, 232);
  }
  static uint240(v3) {
    return n3(v3, 240);
  }
  static uint248(v3) {
    return n3(v3, 248);
  }
  static uint256(v3) {
    return n3(v3, 256);
  }
  static uint(v3) {
    return n3(v3, 256);
  }
  static int8(v3) {
    return n3(v3, -8);
  }
  static int16(v3) {
    return n3(v3, -16);
  }
  static int24(v3) {
    return n3(v3, -24);
  }
  static int32(v3) {
    return n3(v3, -32);
  }
  static int40(v3) {
    return n3(v3, -40);
  }
  static int48(v3) {
    return n3(v3, -48);
  }
  static int56(v3) {
    return n3(v3, -56);
  }
  static int64(v3) {
    return n3(v3, -64);
  }
  static int72(v3) {
    return n3(v3, -72);
  }
  static int80(v3) {
    return n3(v3, -80);
  }
  static int88(v3) {
    return n3(v3, -88);
  }
  static int96(v3) {
    return n3(v3, -96);
  }
  static int104(v3) {
    return n3(v3, -104);
  }
  static int112(v3) {
    return n3(v3, -112);
  }
  static int120(v3) {
    return n3(v3, -120);
  }
  static int128(v3) {
    return n3(v3, -128);
  }
  static int136(v3) {
    return n3(v3, -136);
  }
  static int144(v3) {
    return n3(v3, -144);
  }
  static int152(v3) {
    return n3(v3, -152);
  }
  static int160(v3) {
    return n3(v3, -160);
  }
  static int168(v3) {
    return n3(v3, -168);
  }
  static int176(v3) {
    return n3(v3, -176);
  }
  static int184(v3) {
    return n3(v3, -184);
  }
  static int192(v3) {
    return n3(v3, -192);
  }
  static int200(v3) {
    return n3(v3, -200);
  }
  static int208(v3) {
    return n3(v3, -208);
  }
  static int216(v3) {
    return n3(v3, -216);
  }
  static int224(v3) {
    return n3(v3, -224);
  }
  static int232(v3) {
    return n3(v3, -232);
  }
  static int240(v3) {
    return n3(v3, -240);
  }
  static int248(v3) {
    return n3(v3, -248);
  }
  static int256(v3) {
    return n3(v3, -256);
  }
  static int(v3) {
    return n3(v3, -256);
  }
  static bytes1(v3) {
    return b(v3, 1);
  }
  static bytes2(v3) {
    return b(v3, 2);
  }
  static bytes3(v3) {
    return b(v3, 3);
  }
  static bytes4(v3) {
    return b(v3, 4);
  }
  static bytes5(v3) {
    return b(v3, 5);
  }
  static bytes6(v3) {
    return b(v3, 6);
  }
  static bytes7(v3) {
    return b(v3, 7);
  }
  static bytes8(v3) {
    return b(v3, 8);
  }
  static bytes9(v3) {
    return b(v3, 9);
  }
  static bytes10(v3) {
    return b(v3, 10);
  }
  static bytes11(v3) {
    return b(v3, 11);
  }
  static bytes12(v3) {
    return b(v3, 12);
  }
  static bytes13(v3) {
    return b(v3, 13);
  }
  static bytes14(v3) {
    return b(v3, 14);
  }
  static bytes15(v3) {
    return b(v3, 15);
  }
  static bytes16(v3) {
    return b(v3, 16);
  }
  static bytes17(v3) {
    return b(v3, 17);
  }
  static bytes18(v3) {
    return b(v3, 18);
  }
  static bytes19(v3) {
    return b(v3, 19);
  }
  static bytes20(v3) {
    return b(v3, 20);
  }
  static bytes21(v3) {
    return b(v3, 21);
  }
  static bytes22(v3) {
    return b(v3, 22);
  }
  static bytes23(v3) {
    return b(v3, 23);
  }
  static bytes24(v3) {
    return b(v3, 24);
  }
  static bytes25(v3) {
    return b(v3, 25);
  }
  static bytes26(v3) {
    return b(v3, 26);
  }
  static bytes27(v3) {
    return b(v3, 27);
  }
  static bytes28(v3) {
    return b(v3, 28);
  }
  static bytes29(v3) {
    return b(v3, 29);
  }
  static bytes30(v3) {
    return b(v3, 30);
  }
  static bytes31(v3) {
    return b(v3, 31);
  }
  static bytes32(v3) {
    return b(v3, 32);
  }
  static address(v3) {
    return new Typed(_gaurd, "address", v3);
  }
  static bool(v3) {
    return new Typed(_gaurd, "bool", !!v3);
  }
  static bytes(v3) {
    return new Typed(_gaurd, "bytes", v3);
  }
  static string(v3) {
    return new Typed(_gaurd, "string", v3);
  }
  static array(v3, dynamic) {
    throw new Error("not implemented yet");
    return new Typed(_gaurd, "array", v3, dynamic);
  }
  static tuple(v3, name) {
    throw new Error("not implemented yet");
    return new Typed(_gaurd, "tuple", v3, name);
  }
  static overrides(v3) {
    return new Typed(_gaurd, "overrides", Object.assign({}, v3));
  }
  static isTyped(value15) {
    return value15 && typeof value15 === "object" && "_typedSymbol" in value15 && value15._typedSymbol === _typedSymbol;
  }
  static dereference(value15, type50) {
    if (Typed.isTyped(value15)) {
      if (value15.type !== type50) {
        throw new Error(`invalid type: expecetd ${type50}, got ${value15.type}`);
      }
      return value15.value;
    }
    return value15;
  }
}

// node_modules/ethers/lib.esm/abi/coders/address.js
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value) {
    let value15 = Typed.dereference(_value, "string");
    try {
      value15 = getAddress(value15);
    } catch (error23) {
      return this._throwError(error23.message, _value);
    }
    return writer.writeValue(value15);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
}

// node_modules/ethers/lib.esm/abi/coders/anonymous.js
class AnonymousCoder extends Coder {
  coder;
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value15) {
    return this.coder.encode(writer, value15);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}

// node_modules/ethers/lib.esm/abi/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer;
  let dynamicWriter = new Writer;
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value15 = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value15);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value15);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value15 = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value15 = coder.decode(offsetReader);
      } catch (error23) {
        if (isError(error23, "BUFFER_OVERRUN")) {
          throw error23;
        }
        value15 = error23;
        value15.baseType = coder.name;
        value15.name = coder.localName;
        value15.type = coder.type;
      }
    } else {
      try {
        value15 = coder.decode(reader);
      } catch (error23) {
        if (isError(error23, "BUFFER_OVERRUN")) {
          throw error23;
        }
        value15 = error23;
        value15.baseType = coder.name;
        value15.name = coder.localName;
        value15.type = coder.type;
      }
    }
    if (value15 == undefined) {
      throw new Error("investigate");
    }
    values.push(value15);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}

class ArrayCoder extends Coder {
  coder;
  length;
  constructor(coder, length, localName) {
    const type50 = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type50, localName, dynamic);
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i3 = 0;i3 < this.length; i3++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value) {
    const value15 = Typed.dereference(_value, "array");
    if (!Array.isArray(value15)) {
      this._throwError("expected array value", value15);
    }
    let count = this.length;
    if (count === -1) {
      count = value15.length;
      writer.writeValue(value15.length);
    }
    assertArgumentCount(value15.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i3 = 0;i3 < value15.length; i3++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value15);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i3 = 0;i3 < count; i3++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}

// node_modules/ethers/lib.esm/abi/coders/boolean.js
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value) {
    const value15 = Typed.dereference(_value, "bool");
    return writer.writeValue(value15 ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}

// node_modules/ethers/lib.esm/abi/coders/bytes.js
class DynamicBytesCoder extends Coder {
  constructor(type50, localName) {
    super(type50, type50, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value15) {
    value15 = getBytesCopy(value15);
    let length = writer.writeValue(value15.length);
    length += writer.writeBytes(value15);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}

class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}

// node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js
class FixedBytesCoder extends Coder {
  size;
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value) {
    let data12 = getBytesCopy(Typed.dereference(_value, this.type));
    if (data12.length !== this.size) {
      this._throwError("incorrect data length", _value);
    }
    return writer.writeBytes(data12);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}

// node_modules/ethers/lib.esm/abi/coders/null.js
var Empty = new Uint8Array([]);

class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value15) {
    if (value15 != null) {
      this._throwError("not null", value15);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}

// node_modules/ethers/lib.esm/abi/coders/number.js
var BN_06 = BigInt(0);
var BN_14 = BigInt(1);
var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

class NumberCoder extends Coder {
  size;
  signed;
  constructor(size, signed, localName) {
    const name = (signed ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    defineProperties(this, { size, signed }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value) {
    let value15 = getBigInt(Typed.dereference(_value, this.type));
    let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value15 > bounds || value15 < -(bounds + BN_14)) {
        this._throwError("value out-of-bounds", _value);
      }
      value15 = toTwos(value15, 8 * WordSize);
    } else if (value15 < BN_06 || value15 > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value);
    }
    return writer.writeValue(value15);
  }
  decode(reader) {
    let value15 = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value15 = fromTwos(value15, this.size * 8);
    }
    return value15;
  }
}

// node_modules/ethers/lib.esm/abi/coders/string.js
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}

// node_modules/ethers/lib.esm/abi/coders/tuple.js
class TupleCoder extends Coder {
  coders;
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type50 = "tuple(" + types.join(",") + ")";
    super("tuple", type50, localName, dynamic);
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer, _value) {
    const value15 = Typed.dereference(_value, "tuple");
    return pack(writer, this.coders, value15);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}

// node_modules/ethers/lib.esm/transaction/accesslist.js
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index2) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index2}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value15) {
  if (Array.isArray(value15)) {
    return value15.map((set2, index2) => {
      if (Array.isArray(set2)) {
        assertArgument(set2.length === 2, "invalid slot set", `value[${index2}]`, set2);
        return accessSetify(set2[0], set2[1]);
      }
      assertArgument(set2 != null && typeof set2 === "object", "invalid address-slot set", "value", value15);
      return accessSetify(set2.address, set2.storageKeys);
    });
  }
  assertArgument(value15 != null && typeof value15 === "object", "invalid access list", "value", value15);
  const result = Object.keys(value15).map((addr) => {
    const storageKeys = value15[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b3) => a.address.localeCompare(b3.address));
  return result;
}
// node_modules/ethers/lib.esm/transaction/authorization.js
function authorizationify(auth3) {
  return {
    address: getAddress(auth3.address),
    nonce: getBigInt(auth3.nonce != null ? auth3.nonce : 0),
    chainId: getBigInt(auth3.chainId != null ? auth3.chainId : 0),
    signature: Signature2.from(auth3.signature)
  };
}
// node_modules/ethers/lib.esm/transaction/address.js
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature2) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature2));
}
// node_modules/ethers/lib.esm/transaction/transaction.js
function getKzgLibrary(kzg) {
  const blobToKzgCommitment = (blob) => {
    if ("computeBlobProof" in kzg) {
      if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
        return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));
      }
    } else if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
      return getBytes(kzg.blobToKzgCommitment(blob));
    }
    if ("blobToKZGCommitment" in kzg && typeof kzg.blobToKZGCommitment === "function") {
      return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  const computeBlobKzgProof = (blob, commitment) => {
    if ("computeBlobProof" in kzg && typeof kzg.computeBlobProof === "function") {
      return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));
    }
    if ("computeBlobKzgProof" in kzg && typeof kzg.computeBlobKzgProof === "function") {
      return kzg.computeBlobKzgProof(blob, commitment);
    }
    if ("computeBlobKZGProof" in kzg && typeof kzg.computeBlobKZGProof === "function") {
      return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  return { blobToKzgCommitment, computeBlobKzgProof };
}
function getVersionedHash(version2, hash8) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha2565(hash8).substring(4);
  return "0x" + versioned;
}
function handleAddress(value15) {
  if (value15 === "0x") {
    return null;
  }
  return getAddress(value15);
}
function handleAccessList(value15, param) {
  try {
    return accessListify(value15);
  } catch (error23) {
    assertArgument(false, error23.message, param, value15);
  }
}
function handleAuthorizationList(value15, param) {
  try {
    if (!Array.isArray(value15)) {
      throw new Error("authorizationList: invalid array");
    }
    const result = [];
    for (let i3 = 0;i3 < value15.length; i3++) {
      const auth3 = value15[i3];
      if (!Array.isArray(auth3)) {
        throw new Error(`authorization[${i3}]: invalid array`);
      }
      if (auth3.length !== 6) {
        throw new Error(`authorization[${i3}]: wrong length`);
      }
      if (!auth3[1]) {
        throw new Error(`authorization[${i3}]: null address`);
      }
      result.push({
        address: handleAddress(auth3[1]),
        nonce: handleUint(auth3[2], "nonce"),
        chainId: handleUint(auth3[0], "chainId"),
        signature: Signature2.from({
          yParity: handleNumber(auth3[3], "yParity"),
          r: zeroPadValue(auth3[4], 32),
          s: zeroPadValue(auth3[5], 32)
        })
      });
    }
    return result;
  } catch (error23) {
    assertArgument(false, error23.message, param, value15);
  }
}
function handleNumber(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return getNumber(_value, param);
}
function handleUint(_value, param) {
  if (_value === "0x") {
    return BN_07;
  }
  const value15 = getBigInt(_value, param);
  assertArgument(value15 <= BN_MAX_UINT, "value exceeds uint size", param, value15);
  return value15;
}
function formatNumber(_value, name) {
  const value15 = getBigInt(_value, "value");
  const result = toBeArray(value15);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value15);
  return result;
}
function formatAccessList(value15) {
  return accessListify(value15).map((set2) => [set2.address, set2.storageKeys]);
}
function formatAuthorizationList(value15) {
  return value15.map((a) => {
    return [
      formatNumber(a.chainId, "chainId"),
      a.address,
      formatNumber(a.nonce, "nonce"),
      formatNumber(a.signature.yParity, "yParity"),
      toBeArray(a.signature.r),
      toBeArray(a.signature.s)
    ];
  });
}
function formatHashes(value15, param) {
  assertArgument(Array.isArray(value15), `invalid ${param}`, "value", value15);
  for (let i3 = 0;i3 < value15.length; i3++) {
    assertArgument(isHexString(value15[i3], 32), "invalid ${ param } hash", `value[${i3}]`, value15[i3]);
  }
  return value15;
}
function _parseLegacy(data12) {
  const fields = decodeRlp(data12);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data12);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_07
  };
  if (fields.length === 6) {
    return tx;
  }
  const v3 = handleUint(fields[6], "v");
  const r = handleUint(fields[7], "r");
  const s3 = handleUint(fields[8], "s");
  if (r === BN_07 && s3 === BN_07) {
    tx.chainId = v3;
  } else {
    let chainId = (v3 - BN_352) / BN_22;
    if (chainId < BN_07) {
      chainId = BN_07;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_07 || (v3 === BN_272 || v3 === BN_282), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature2.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v: v3
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_07;
  if (tx.chainId != BN_07) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_07) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v3 = BigInt(27 + sig.yParity);
  if (chainId !== BN_07) {
    v3 = Signature2.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v3) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v3));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error23) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r = zeroPadValue(fields[1], 32);
  const s3 = zeroPadValue(fields[2], 32);
  const signature2 = Signature2.from({ r, s: s3, yParity });
  tx.signature = signature2;
}
function _parseEip1559(data12) {
  const fields = decodeRlp(getBytes(data12).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data12));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat2(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data12) {
  const fields = decodeRlp(getBytes(data12).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data12));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat2(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data12) {
  let fields = decodeRlp(getBytes(data12).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i3 = 0;i3 < fields[1].length; i3++) {
      blobs.push({
        data: fBlobs[i3],
        commitment: fCommits[i3],
        proof: fProofs[i3]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data12));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data12);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data12);
  for (let i3 = 0;i3 < tx.blobVersionedHashes.length; i3++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i3], 32), `invalid blobVersionedHash at index ${i3}: must be length 32`, "data", data12);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat2([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b3) => b3.data),
          blobs.map((b3) => b3.commitment),
          blobs.map((b3) => b3.proof)
        ])
      ]);
    }
  }
  return concat2(["0x03", encodeRlp(fields)]);
}
function _parseEip7702(data12) {
  const fields = decodeRlp(getBytes(data12).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), "invalid field count for transaction type: 4", "data", hexlify(data12));
  const tx = {
    type: 4,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    authorizationList: handleAuthorizationList(fields[9], "authorizationList")
  };
  if (fields.length === 10) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(10));
  return tx;
}
function _serializeEip7702(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatAuthorizationList(tx.authorizationList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat2(["0x04", encodeRlp(fields)]);
}
var BN_07 = BigInt(0);
var BN_22 = BigInt(2);
var BN_272 = BigInt(27);
var BN_282 = BigInt(28);
var BN_352 = BigInt(35);
var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var BLOB_SIZE = 4096 * 32;

class Transaction {
  #type;
  #to;
  #data;
  #nonce;
  #gasLimit;
  #gasPrice;
  #maxPriorityFeePerGas;
  #maxFeePerGas;
  #value;
  #chainId;
  #sig;
  #accessList;
  #maxFeePerBlobGas;
  #blobVersionedHashes;
  #kzg;
  #blobs;
  #auths;
  get type() {
    return this.#type;
  }
  set type(value15) {
    switch (value15) {
      case null:
        this.#type = null;
        break;
      case 0:
      case "legacy":
        this.#type = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#type = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#type = 2;
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        this.#type = 3;
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        this.#type = 4;
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value15);
    }
  }
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  get to() {
    const value15 = this.#to;
    if (value15 == null && this.type === 3) {
      return ZeroAddress;
    }
    return value15;
  }
  set to(value15) {
    this.#to = value15 == null ? null : getAddress(value15);
  }
  get nonce() {
    return this.#nonce;
  }
  set nonce(value15) {
    this.#nonce = getNumber(value15, "value");
  }
  get gasLimit() {
    return this.#gasLimit;
  }
  set gasLimit(value15) {
    this.#gasLimit = getBigInt(value15);
  }
  get gasPrice() {
    const value15 = this.#gasPrice;
    if (value15 == null && (this.type === 0 || this.type === 1)) {
      return BN_07;
    }
    return value15;
  }
  set gasPrice(value15) {
    this.#gasPrice = value15 == null ? null : getBigInt(value15, "gasPrice");
  }
  get maxPriorityFeePerGas() {
    const value15 = this.#maxPriorityFeePerGas;
    if (value15 == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_07;
      }
      return null;
    }
    return value15;
  }
  set maxPriorityFeePerGas(value15) {
    this.#maxPriorityFeePerGas = value15 == null ? null : getBigInt(value15, "maxPriorityFeePerGas");
  }
  get maxFeePerGas() {
    const value15 = this.#maxFeePerGas;
    if (value15 == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_07;
      }
      return null;
    }
    return value15;
  }
  set maxFeePerGas(value15) {
    this.#maxFeePerGas = value15 == null ? null : getBigInt(value15, "maxFeePerGas");
  }
  get data() {
    return this.#data;
  }
  set data(value15) {
    this.#data = hexlify(value15);
  }
  get value() {
    return this.#value;
  }
  set value(value15) {
    this.#value = getBigInt(value15, "value");
  }
  get chainId() {
    return this.#chainId;
  }
  set chainId(value15) {
    this.#chainId = getBigInt(value15);
  }
  get signature() {
    return this.#sig || null;
  }
  set signature(value15) {
    this.#sig = value15 == null ? null : Signature2.from(value15);
  }
  get accessList() {
    const value15 = this.#accessList || null;
    if (value15 == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value15;
  }
  set accessList(value15) {
    this.#accessList = value15 == null ? null : accessListify(value15);
  }
  get authorizationList() {
    const value15 = this.#auths || null;
    if (value15 == null) {
      if (this.type === 4) {
        return [];
      }
    }
    return value15;
  }
  set authorizationList(auths) {
    this.#auths = auths == null ? null : auths.map((a) => authorizationify(a));
  }
  get maxFeePerBlobGas() {
    const value15 = this.#maxFeePerBlobGas;
    if (value15 == null && this.type === 3) {
      return BN_07;
    }
    return value15;
  }
  set maxFeePerBlobGas(value15) {
    this.#maxFeePerBlobGas = value15 == null ? null : getBigInt(value15, "maxFeePerBlobGas");
  }
  get blobVersionedHashes() {
    let value15 = this.#blobVersionedHashes;
    if (value15 == null && this.type === 3) {
      return [];
    }
    return value15;
  }
  set blobVersionedHashes(value15) {
    if (value15 != null) {
      assertArgument(Array.isArray(value15), "blobVersionedHashes must be an Array", "value", value15);
      value15 = value15.slice();
      for (let i3 = 0;i3 < value15.length; i3++) {
        assertArgument(isHexString(value15[i3], 32), "invalid blobVersionedHash", `value[${i3}]`, value15[i3]);
      }
    }
    this.#blobVersionedHashes = value15;
  }
  get blobs() {
    if (this.#blobs == null) {
      return null;
    }
    return this.#blobs.map((b3) => Object.assign({}, b3));
  }
  set blobs(_blobs) {
    if (_blobs == null) {
      this.#blobs = null;
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i3 = 0;i3 < _blobs.length; i3++) {
      const blob = _blobs[i3];
      if (isBytesLike(blob)) {
        assert(this.#kzg, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data12 = getBytes(blob);
        assertArgument(data12.length <= BLOB_SIZE, "blob is too large", `blobs[${i3}]`, blob);
        if (data12.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data12);
          data12 = padded;
        }
        const commit = this.#kzg.blobToKzgCommitment(data12);
        const proof = hexlify(this.#kzg.computeBlobKzgProof(data12, commit));
        blobs.push({
          data: hexlify(data12),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    this.#blobs = blobs;
    this.#blobVersionedHashes = versionedHashes;
  }
  get kzg() {
    return this.#kzg;
  }
  set kzg(kzg) {
    if (kzg == null) {
      this.#kzg = null;
    } else {
      this.#kzg = getKzgLibrary(kzg);
    }
  }
  constructor() {
    this.#type = null;
    this.#to = null;
    this.#nonce = 0;
    this.#gasLimit = BN_07;
    this.#gasPrice = null;
    this.#maxPriorityFeePerGas = null;
    this.#maxFeePerGas = null;
    this.#data = "0x";
    this.#value = BN_07;
    this.#chainId = BN_07;
    this.#sig = null;
    this.#accessList = null;
    this.#maxFeePerBlobGas = null;
    this.#blobVersionedHashes = null;
    this.#kzg = null;
    this.#blobs = null;
    this.#auths = null;
  }
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(this.#getSerialized(true, false));
  }
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  isSigned() {
    return this.signature != null;
  }
  #getSerialized(signed, sidecar) {
    assert(!signed || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    const sig = signed ? this.signature : null;
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy(this, sig);
      case 1:
        return _serializeEip2930(this, sig);
      case 2:
        return _serializeEip1559(this, sig);
      case 3:
        return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
      case 4:
        return _serializeEip7702(this, sig);
    }
    assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  get serialized() {
    return this.#getSerialized(true, true);
  }
  get unsignedSerialized() {
    return this.#getSerialized(false, false);
  }
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (this.authorizationList && this.authorizationList.length) {
        types.push(4);
      } else if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  isLegacy() {
    return this.type === 0;
  }
  isBerlin() {
    return this.type === 1;
  }
  isLondon() {
    return this.type === 2;
  }
  isCancun() {
    return this.type === 3;
  }
  clone() {
    return Transaction.from(this);
  }
  toJSON() {
    const s3 = (v3) => {
      if (v3 == null) {
        return null;
      }
      return v3.toString();
    };
    return {
      type: this.type,
      to: this.to,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s3(this.gasLimit),
      gasPrice: s3(this.gasPrice),
      maxPriorityFeePerGas: s3(this.maxPriorityFeePerGas),
      maxFeePerGas: s3(this.maxFeePerGas),
      value: s3(this.value),
      chainId: s3(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  static from(tx) {
    if (tx == null) {
      return new Transaction;
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return Transaction.from(_parseEip2930(payload));
        case 2:
          return Transaction.from(_parseEip1559(payload));
        case 3:
          return Transaction.from(_parseEip4844(payload));
        case 4:
          return Transaction.from(_parseEip7702(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new Transaction;
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature2.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.authorizationList != null) {
      result.authorizationList = tx.authorizationList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
}
// node_modules/ethers/lib.esm/hash/authorization.js
function hashAuthorization(auth3) {
  assertArgument(typeof auth3.address === "string", "invalid address for hashAuthorization", "auth.address", auth3);
  return keccak256(concat2([
    "0x05",
    encodeRlp([
      auth3.chainId != null ? toBeArray(auth3.chainId) : "0x",
      getAddress(auth3.address),
      auth3.nonce != null ? toBeArray(auth3.nonce) : "0x"
    ])
  ]));
}
function verifyAuthorization(auth3, sig) {
  return recoverAddress(hashAuthorization(auth3), sig);
}
// node_modules/ethers/lib.esm/hash/id.js
function id(value15) {
  return keccak256(toUtf8Bytes(value15));
}
// node_modules/@adraffy/ens-normalize/dist/index.mjs
function decode_arithmetic(bytes4) {
  let pos = 0;
  function u162() {
    return bytes4[pos++] << 8 | bytes4[pos++];
  }
  let symbol_count = u162();
  let total = 1;
  let acc = [0, 1];
  for (let i3 = 1;i3 < symbol_count; i3++) {
    acc.push(total += u162());
  }
  let skip2 = u162();
  let pos_payload = pos;
  pos += skip2;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes4[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N4 = 31;
  const FULL = 2 ** N4;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i3 = 0;i3 < N4; i3++)
    register = register << 1 | read_bit();
  let symbols70 = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value15 = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value15 < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols70.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b3 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b3) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b3 = b3 << 1 & MASK | 1;
    }
    while (a & ~b3 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b3 = (b3 ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b3 - a;
  }
  let offset = symbol_count - 4;
  return symbols70.map((x3) => {
    switch (x3 - offset) {
      case 3:
        return offset + 65792 + (bytes4[pos_payload++] << 16 | bytes4[pos_payload++] << 8 | bytes4[pos_payload++]);
      case 2:
        return offset + 256 + (bytes4[pos_payload++] << 8 | bytes4[pos_payload++]);
      case 1:
        return offset + bytes4[pos_payload++];
      default:
        return x3 - 1;
    }
  });
}
function read_payload(v3) {
  let pos = 0;
  return () => v3[pos++];
}
function read_compressed_payload(s3) {
  return read_payload(decode_arithmetic(unsafe_atob(s3)));
}
function unsafe_atob(s3) {
  let lookup2 = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c3, i3) => lookup2[c3.charCodeAt(0)] = i3);
  let n4 = s3.length;
  let ret = new Uint8Array(6 * n4 >> 3);
  for (let i3 = 0, pos = 0, width = 0, carry = 0;i3 < n4; i3++) {
    carry = carry << 6 | lookup2[s3.charCodeAt(i3)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i3) {
  return i3 & 1 ? ~i3 >> 1 : i3 >> 1;
}
function read_deltas(n4, next) {
  let v3 = Array(n4);
  for (let i3 = 0, x3 = 0;i3 < n4; i3++)
    v3[i3] = x3 += signed(next());
  return v3;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x3 = next();
    let n4 = next();
    if (!n4)
      break;
    prev += x3;
    for (let i3 = 0;i3 < n4; i3++) {
      ret.push(prev + i3);
    }
    prev += n4 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v3 = read_sorted(next);
    if (v3.length)
      return v3;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v3 = [];
  while (true) {
    let x3 = next(v3.length);
    if (!x3)
      break;
    v3.push(x3);
  }
  return v3;
}
function read_transposed(n4, w, next) {
  let m3 = Array(n4).fill().map(() => []);
  for (let i3 = 0;i3 < w; i3++) {
    read_deltas(n4, next).forEach((x3, j) => m3[j].push(x3));
  }
  return m3;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m3 = read_transposed(vN.length, 1 + w, next);
  return m3.flatMap((v3, i3) => {
    let [x3, ...ys] = v3;
    return Array(vN[i3]).fill().map((_5, j) => {
      let j_dy = j * dy;
      return [x3 + j * dx, ys.map((y3) => y3 + j_dy)];
    });
  });
}
function read_replacement_table(w, next) {
  let n4 = 1 + next();
  let m3 = read_transposed(n4, 1 + w, next);
  return m3.map((v3) => [v3[0], v3.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode2([]), []);
  return ret;
  function decode2(Q) {
    let S = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i3) => sorted[i3]);
      if (cps.length)
        return decode2(cps);
    });
    return { S, B, Q };
  }
  function expand({ S, B }, cps, saved) {
    if (S & 4 && saved === cps[cps.length - 1])
      return;
    if (S & 2)
      saved = cps[cps.length - 1];
    if (S & 1)
      ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s3) {
  let cps = [];
  for (let pos = 0, len = s3.length;pos < len; ) {
    let cp = s3.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk)
    return String.fromCodePoint(...cps);
  let buf = [];
  for (let i3 = 0;i3 < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i3, i3 += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a, b3) {
  let n4 = a.length;
  let c3 = n4 - b3.length;
  for (let i3 = 0;c3 == 0 && i3 < n4; i3++)
    c3 = a[i3] - b3[i3];
  return c3;
}
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
function init$1() {
  let r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v3, i3) => v3.map((x3) => [x3, i3 + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = new Map;
  RECOMP = new Map;
  for (let [cp, cps] of read_mapped(r)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b3] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = new Map;
        RECOMP.set(a, bucket);
      }
      bucket.set(b3, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S02 && cp < S12;
}
function compose_pair(a, b3) {
  if (a >= L02 && a < L12 && b3 >= V02 && b3 < V12) {
    return S02 + (a - L02) * N_COUNT + (b3 - V02) * T_COUNT;
  } else if (is_hangul(a) && b3 > T0 && b3 < T12 && (a - S02) % T_COUNT == 0) {
    return a + (b3 - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b3);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK)
    init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S02;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add(L02 + l_index);
        add(V02 + v_index);
        if (t_index > 0)
          add(T0 + t_index);
      } else {
        let mapped20 = DECOMP.get(cp);
        if (mapped20) {
          buf.push(...mapped20);
        } else {
          add(cp);
        }
      }
      if (!buf.length)
        break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i3 = 1;i3 < ret.length; i3++) {
      let cc = unpack_cc(ret[i3]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i3 - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j)
          break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc)
          break;
      }
      prev_cc = unpack_cc(ret[i3]);
    }
  }
  return ret;
}
function composed_from_decomposed(v3) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v3) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
function group_has_cp(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
}
function init() {
  if (MAPPED)
    return;
  let r = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set2, v3) => v3.forEach((x3) => set2.add(x3));
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i3) => CM[i3]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks = read_sorted_arrays(r);
  let unrestricted = r();
  const read_chunked = () => {
    let set2 = new Set;
    read_sorted_array().forEach((i3) => set_add_many(set2, chunks[i3]));
    set_add_many(set2, read_sorted_array());
    return set2;
  };
  GROUPS = read_array_while((i3) => {
    let N4 = read_array_while(r).map((x3) => x3 + 96);
    if (N4.length) {
      let R = i3 >= unrestricted;
      N4[0] -= 32;
      N4 = str_from_cps(N4);
      if (R)
        N4 = `Restricted[${N4}]`;
      let P = read_chunked();
      let Q = read_chunked();
      let M = !r();
      return { N: N4, P, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = new Map;
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b3) => a - b3);
  wholes.forEach((cp, i3) => {
    let d3 = r();
    let w = wholes[i3] = d3 ? wholes[i3 - d3] : { V: [], M: new Map };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
      if (!rec) {
        rec = { G: new Set, V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union22 = recs.flatMap((x3) => Array_from(x3.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union22.filter((g) => !G.has(g)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  VALID = new Set;
  let multi = new Set;
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P)
      add_to_union(cp);
    for (let cp of g.Q)
      add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r).map((v3) => Emoji.from(v3)).sort(compare_arrays);
  EMOJI_ROOT = new Map;
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = new Map;
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x3 of prev) {
      x3.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s3) {
  return `"${s3}"\u200E`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i3 = cps.lastIndexOf(UNDERSCORE);i3 > 0; ) {
    if (cps[--i3] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev)
    throw error_placement(`leading ${prev}`);
  let n4 = cps.length;
  let last = -1;
  for (let i3 = 1;i3 < n4; i3++) {
    cp = cps[i3];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i3)
        throw error_placement(`${prev} + ${match}`);
      last = i3 + 1;
      prev = match;
    }
  }
  if (last == n4)
    throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max2 = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0]))
    buf.push("\u25CC");
  if (cps.length > max2) {
    max2 >>= 1;
    cps = [...cps.slice(0, max2), 8230, ...cps.slice(-max2)];
  }
  let prev = 0;
  let n4 = cps.length;
  for (let i3 = 0;i3 < n4; i3++) {
    let cp = cps[i3];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i3)));
      buf.push(quoter(cp));
      prev = i3 + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n4)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten(split2(name, nfc, filter_fe0f));
}
function split2(name, nf, ef) {
  if (!name)
    return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type50;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type50 = "ASCII";
      } else {
        let chars = tokens.flatMap((x3) => x3.is_emoji ? [] : x3);
        if (!chars.length) {
          type50 = "Emoji";
        } else {
          if (CM.has(norm[0]))
            throw error_placement("leading combining mark");
          for (let i3 = 1;i3 < token_count; i3++) {
            let cps = tokens[i3];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i3 - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g] = determine_group(unique);
          check_group(g, chars);
          check_whole(g, unique);
          type50 = g.N;
        }
      }
      info.type = type50;
    } catch (err2) {
      info.error = err2;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH)
      return;
    if (whole) {
      let set2 = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set2.has(g)) : Array_from(set2);
      if (!maker.length)
        return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1)
      break;
  }
  return groups;
}
function flatten(split3) {
  return split3.map(({ input, error: error23, output: output2 }) => {
    if (error23) {
      let msg = error23.message;
      throw new Error(split3.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g3) => g3.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i3 = 1, e = decomposed2.length;i3 < e; i3++) {
      if (NSM.has(decomposed2[i3])) {
        let j = i3 + 1;
        for (let cp;j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i3;k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i3 > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i3 - 1, j)))} (${j - i3}/${NSM_MAX})`);
        }
        i3 = j;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node)
      break;
    let { V } = node;
    if (V) {
      emoji = V;
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
var COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
var FENCED = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX = 4;
var COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
var S02 = 44032;
var L02 = 4352;
var V02 = 4449;
var T0 = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S12 = S02 + S_COUNT;
var L12 = L02 + L_COUNT;
var V12 = V02 + V_COUNT;
var T12 = T0 + T_COUNT;
var SHIFTED_RANK;
var EXCLUSIONS;
var DECOMP;
var RECOMP;
var HYPHEN = 45;
var STOP_CH = ".";
var FE0F = 65039;
var UNIQUE_PH = 1;
var Array_from = (x3) => Array.from(x3);

class Emoji extends Array {
  get is_emoji() {
    return true;
  }
}
var MAPPED;
var IGNORED;
var CM;
var NSM;
var ESCAPE;
var NFC_CHECK;
var GROUPS;
var WHOLE_VALID;
var WHOLE_MAP;
var VALID;
var EMOJI_LIST;
var EMOJI_ROOT;

// node_modules/ethers/lib.esm/hash/namehash.js
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  const bytes4 = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i3 = 0;i3 < bytes4.length; i3++) {
    const d3 = bytes4[i3];
    if (d3 === 46) {
      comps.push(checkComponent(bytes4.slice(last, i3)));
      last = i3 + 1;
    }
  }
  assertArgument(last < bytes4.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes4.slice(last)));
  return comps;
}
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error23) {
    assertArgument(false, `invalid ENS name (${error23.message})`, "name", name);
  }
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error23) {
  }
  return false;
}
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros2;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat2([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name, _maxLength) {
  const length = _maxLength != null ? _maxLength : 63;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat2(ensNameSplit(name).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes4 = new Uint8Array(comp.length + 1);
    bytes4.set(comp, 1);
    bytes4[0] = bytes4.length - 1;
    return bytes4;
  }))) + "00";
}
var Zeros2 = new Uint8Array(32);
Zeros2.fill(0);
// node_modules/ethers/lib.esm/hash/message.js
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat2([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
function verifyMessage(message, sig) {
  const digest = hashMessage(message);
  return recoverAddress(digest, sig);
}
// node_modules/ethers/lib.esm/hash/solidity.js
function _pack(type50, value15, isArray) {
  switch (type50) {
    case "address":
      if (isArray) {
        return getBytes(zeroPadValue(value15, 32));
      }
      return getBytes(getAddress(value15));
    case "string":
      return toUtf8Bytes(value15);
    case "bytes":
      return getBytes(value15);
    case "bool":
      value15 = value15 ? "0x01" : "0x00";
      if (isArray) {
        return getBytes(zeroPadValue(value15, 32));
      }
      return getBytes(value15);
  }
  let match = type50.match(regexNumber);
  if (match) {
    let signed2 = match[1] === "int";
    let size = parseInt(match[2] || "256");
    assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type50);
    if (isArray) {
      size = 256;
    }
    if (signed2) {
      value15 = toTwos(value15, size);
    }
    return getBytes(zeroPadValue(toBeArray(value15), size / 8));
  }
  match = type50.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    assertArgument(String(size) === match[1] && size !== 0 && size <= 32, "invalid bytes type", "type", type50);
    assertArgument(dataLength(value15) === size, `invalid value for ${type50}`, "value", value15);
    if (isArray) {
      return getBytes(zeroPadBytes(value15, 32));
    }
    return value15;
  }
  match = type50.match(regexArray);
  if (match && Array.isArray(value15)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value15.length));
    assertArgument(count === value15.length, `invalid array length for ${type50}`, "value", value15);
    const result = [];
    value15.forEach(function(value16) {
      result.push(_pack(baseType, value16, true));
    });
    return getBytes(concat2(result));
  }
  assertArgument(false, "invalid type", "type", type50);
}
function solidityPacked(types, values) {
  assertArgument(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  const tight = [];
  types.forEach(function(type50, index2) {
    tight.push(_pack(type50, values[index2]));
  });
  return hexlify(concat2(tight));
}
function solidityPackedKeccak256(types, values) {
  return keccak256(solidityPacked(types, values));
}
function solidityPackedSha256(types, values) {
  return sha2565(solidityPacked(types, values));
}
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
// node_modules/ethers/lib.esm/hash/typed-data.js
function hexPadRight(value15) {
  const bytes4 = getBytes(value15);
  const padOffset = bytes4.length % 32;
  if (padOffset) {
    return concat2([bytes4, padding.slice(padOffset)]);
  }
  return hexlify(bytes4);
}
function checkString(key) {
  return function(value15) {
    assertArgument(typeof value15 === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value15);
    return value15;
  };
}
function getBaseEncoder(type50) {
  {
    const match = type50.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type50);
      const boundsUpper = mask(BN_MAX_UINT2562, signed2 ? width - 1 : width);
      const boundsLower = signed2 ? (boundsUpper + BN_15) * BN__1 : BN_08;
      return function(_value) {
        const value15 = getBigInt(_value, "value");
        assertArgument(value15 >= boundsLower && value15 <= boundsUpper, `value out-of-bounds for ${type50}`, "value", value15);
        return toBeHex(signed2 ? toTwos(value15, 256) : value15, 32);
      };
    }
  }
  {
    const match = type50.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type50);
      return function(value15) {
        const bytes4 = getBytes(value15);
        assertArgument(bytes4.length === width, `invalid length for ${type50}`, "value", value15);
        return hexPadRight(value15);
      };
    }
  }
  switch (type50) {
    case "address":
      return function(value15) {
        return zeroPadValue(getAddress(value15), 32);
      };
    case "bool":
      return function(value15) {
        return !value15 ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value15) {
        return keccak256(value15);
      };
    case "string":
      return function(value15) {
        return id(value15);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type: type50 }) => type50 + " " + name2).join(",")})`;
}
function splitArray(type50) {
  const match = type50.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type50 };
}
function verifyTypedData(domain, types, value15, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value15), signature2);
}
var padding = new Uint8Array(32);
padding.fill(0);
var BN__1 = BigInt(-1);
var BN_08 = BigInt(0);
var BN_15 = BigInt(1);
var BN_MAX_UINT2562 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue = toBeHex(BN_15, 32);
var hexFalse = toBeHex(BN_08, 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value) {
    const value15 = getBigInt(_value, "domain.chainId");
    assertArgument(value15 >= 0, "invalid chain ID", "domain.chainId", _value);
    if (Number.isSafeInteger(value15)) {
      return Number(value15);
    }
    return toQuantity(value15);
  },
  verifyingContract: function(value15) {
    try {
      return getAddress(value15).toLowerCase();
    } catch (error23) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value15);
  },
  salt: function(value15) {
    const bytes4 = getBytes(value15, "domain.salt");
    assertArgument(bytes4.length === 32, `invalid domain value "salt"`, "domain.salt", value15);
    return hexlify(bytes4);
  }
};

class TypedDataEncoder {
  primaryType;
  #types;
  get types() {
    return JSON.parse(this.#types);
  }
  #fullTypes;
  #encoderCache;
  constructor(_types) {
    this.#fullTypes = new Map;
    this.#encoderCache = new Map;
    const links = new Map;
    const parents = new Map;
    const subtypes = new Map;
    const types = {};
    Object.keys(_types).forEach((type50) => {
      types[type50] = _types[type50].map(({ name, type: type51 }) => {
        let { base, index: index2 } = splitArray(type51);
        if (base === "int" && !_types["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types["uint"]) {
          base = "uint256";
        }
        return { name, type: base + (index2 || "") };
      });
      links.set(type50, new Set);
      parents.set(type50, []);
      subtypes.set(type50, new Set);
    });
    this.#types = JSON.stringify(types);
    for (const name in types) {
      const uniqueNames = new Set;
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n4) => parents.get(n4).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t3) => JSON.stringify(t3)).join(", ")}`, "types", _types);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type50, found) {
      assertArgument(!found.has(type50), `circular type reference to ${JSON.stringify(type50)}`, "types", _types);
      found.add(type50);
      for (const child of links.get(type50)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type50);
    }
    checkCircular(this.primaryType, new Set);
    for (const [name, set2] of subtypes) {
      const st = Array.from(set2);
      st.sort();
      this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t3) => encodeType(t3, types[t3])).join(""));
    }
  }
  getEncoder(type50) {
    let encoder = this.#encoderCache.get(type50);
    if (!encoder) {
      encoder = this.#getEncoder(type50);
      this.#encoderCache.set(type50, encoder);
    }
    return encoder;
  }
  #getEncoder(type50) {
    {
      const encoder = getBaseEncoder(type50);
      if (encoder) {
        return encoder;
      }
    }
    const array6 = splitArray(type50).array;
    if (array6) {
      const subtype = array6.prefix;
      const subEncoder = this.getEncoder(subtype);
      return (value15) => {
        assertArgument(array6.count === -1 || array6.count === value15.length, `array length mismatch; expected length ${array6.count}`, "value", value15);
        let result = value15.map(subEncoder);
        if (this.#fullTypes.has(subtype)) {
          result = result.map(keccak256);
        }
        return keccak256(concat2(result));
      };
    }
    const fields = this.types[type50];
    if (fields) {
      const encodedType = id(this.#fullTypes.get(type50));
      return (value15) => {
        const values = fields.map(({ name, type: type51 }) => {
          const result = this.getEncoder(type51)(value15[name]);
          if (this.#fullTypes.has(type51)) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return concat2(values);
      };
    }
    assertArgument(false, `unknown type: ${type50}`, "type", type50);
  }
  encodeType(name) {
    const result = this.#fullTypes.get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  encodeData(type50, value15) {
    return this.getEncoder(type50)(value15);
  }
  hashStruct(name, value15) {
    return keccak256(this.encodeData(name, value15));
  }
  encode(value15) {
    return this.encodeData(this.primaryType, value15);
  }
  hash(value15) {
    return this.hashStruct(this.primaryType, value15);
  }
  _visit(type50, value15, callback) {
    {
      const encoder = getBaseEncoder(type50);
      if (encoder) {
        return callback(type50, value15);
      }
    }
    const array6 = splitArray(type50).array;
    if (array6) {
      assertArgument(array6.count === -1 || array6.count === value15.length, `array length mismatch; expected length ${array6.count}`, "value", value15);
      return value15.map((v3) => this._visit(array6.prefix, v3, callback));
    }
    const fields = this.types[type50];
    if (fields) {
      return fields.reduce((accum, { name, type: type51 }) => {
        accum[name] = this._visit(type51, value15[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type50}`, "type", type50);
  }
  visit(value15, callback) {
    return this._visit(this.primaryType, value15, callback);
  }
  static from(types) {
    return new TypedDataEncoder(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }
  static hashStruct(name, types, value15) {
    return TypedDataEncoder.from(types).hashStruct(name, value15);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type50 = domainFieldTypes[name];
      assertArgument(type50, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type: type50 });
    }
    domainFields.sort((a, b3) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b3.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types, value15) {
    return concat2([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types).hash(value15)
    ]);
  }
  static hash(domain, types, value15) {
    return keccak256(TypedDataEncoder.encode(domain, types, value15));
  }
  static async resolveNames(domain, types, value15, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = TypedDataEncoder.from(types);
    encoder.visit(value15, (type50, value16) => {
      if (type50 === "address" && !isHexString(value16, 20)) {
        ensCache[value16] = "0x";
      }
      return value16;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value15 = encoder.visit(value15, (type50, value16) => {
      if (type50 === "address" && ensCache[value16]) {
        return ensCache[value16];
      }
      return value16;
    });
    return { domain, value: value15 };
  }
  static getPayload(domain, types, value15) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value16 = domain[name];
      if (value16 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value16);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value15);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value15, (type50, value16) => {
        if (type50.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value16));
        }
        if (type50.match(/^u?int/)) {
          return getBigInt(value16).toString();
        }
        switch (type50) {
          case "address":
            return value16.toLowerCase();
          case "bool":
            return !!value16;
          case "string":
            assertArgument(typeof value16 === "string", "invalid string", "value", value16);
            return value16;
        }
        assertArgument(false, "unsupported type", "type", type50);
      })
    };
  }
}
// node_modules/ethers/lib.esm/abi/fragments.js
function setify(items) {
  const result = new Set;
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type50 = SimpleTokens[cur[0]] || "";
    if (type50) {
      token.type = type50;
      token.text = cur[0];
      offset++;
      if (type50 === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type50 == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type50 === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type50 === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type50 === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value15 = tokens.pop().text;
          suffix = value15 + suffix;
          tokens[tokens.length - 1].value = getNumber(value15);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t3) => Object.freeze(t3)));
}
function allowSingle(set2, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set2.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type50, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type50) {
      throw new Error(`expected ${type50}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = new Set;
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t3) => ParamType.from(t3, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
function verifyBasicType(type50) {
  const match = type50.match(regexType);
  assertArgument(match, "invalid type", "type", type50);
  if (type50 === "uint") {
    return "uint256";
  }
  if (type50 === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type50);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type50);
  }
  return type50;
}
function joinParams(format, params) {
  return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
}
var _kwVisibDeploy = "external public payable override";
var KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
var _kwVisib = "constant external internal payable private public pure view override";
var KwVisib = setify(_kwVisib.split(" "));
var _kwTypes = "constructor error event fallback function receive struct";
var KwTypes = setify(_kwTypes.split(" "));
var _kwModifiers = "calldata memory storage payable indexed";
var KwModifiers = setify(_kwModifiers.split(" "));
var _kwOther = "tuple returns";
var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
var Keywords = setify(_keywords.split(" "));
var SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
var regexWhitespacePrefix = new RegExp("^(\\s*)");
var regexNumberPrefix = new RegExp("^([0-9]+)");
var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");

class TokenString {
  #offset;
  #tokens;
  get offset() {
    return this.#offset;
  }
  get length() {
    return this.#tokens.length - this.#offset;
  }
  constructor(tokens) {
    this.#offset = 0;
    this.#tokens = tokens.slice();
  }
  clone() {
    return new TokenString(this.#tokens);
  }
  reset() {
    this.#offset = 0;
  }
  #subTokenString(from = 0, to = 0) {
    return new TokenString(this.#tokens.slice(from, to).map((t3) => {
      return Object.freeze(Object.assign({}, t3, {
        match: t3.match - from,
        linkBack: t3.linkBack - from,
        linkNext: t3.linkNext - from
      }));
    }));
  }
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  popType(type50) {
    if (this.peek().type !== type50) {
      const top = this.peek();
      throw new Error(`expected ${type50}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = this.#subTokenString(this.#offset + 1, top.match + 1);
    this.#offset = top.match + 1;
    return result;
  }
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (this.#offset < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(this.#subTokenString(this.#offset + 1, link));
      this.#offset = link;
    }
    this.#offset = top.match + 1;
    return result;
  }
  peek() {
    if (this.#offset >= this.#tokens.length) {
      throw new Error("out-of-bounds");
    }
    return this.#tokens[this.#offset];
  }
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  peekType(type50) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type50 ? top.text : null;
  }
  pop() {
    const result = this.peek();
    this.#offset++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i3 = this.#offset;i3 < this.#tokens.length; i3++) {
      const token = this.#tokens[i3];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
}
var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
var _guard4 = {};
var internal = Symbol.for("_ethers_internal");
var ParamTypeInternal = "_ParamTypeInternal";
var ErrorFragmentInternal = "_ErrorInternal";
var EventFragmentInternal = "_EventInternal";
var ConstructorFragmentInternal = "_ConstructorInternal";
var FallbackFragmentInternal = "_FallbackInternal";
var FunctionFragmentInternal = "_FunctionInternal";
var StructFragmentInternal = "_StructInternal";

class ParamType {
  name;
  type;
  baseType;
  indexed;
  components;
  arrayLength;
  arrayChildren;
  constructor(guard22, name, type50, baseType, indexed11, components, arrayLength, arrayChildren) {
    assertPrivate(guard22, _guard4, "ParamType");
    Object.defineProperty(this, internal, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type: type50,
      baseType,
      indexed: indexed11,
      components,
      arrayLength,
      arrayChildren
    });
  }
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c3) => JSON.parse(c3.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  isArray() {
    return this.baseType === "array";
  }
  isTuple() {
    return this.baseType === "tuple";
  }
  isIndexable() {
    return this.indexed != null;
  }
  walk(value15, process3) {
    if (this.isArray()) {
      if (!Array.isArray(value15)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value15.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value15.map((v3) => _this.arrayChildren.walk(v3, process3));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value15)) {
        throw new Error("invalid tuple value");
      }
      if (value15.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value15.map((v3, i3) => _this.components[i3].walk(v3, process3));
    }
    return process3(this.type, value15);
  }
  #walkAsync(promises3, value15, process3, setValue) {
    if (this.isArray()) {
      if (!Array.isArray(value15)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value15.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const childType = this.arrayChildren;
      const result2 = value15.slice();
      result2.forEach((value16, index2) => {
        childType.#walkAsync(promises3, value16, process3, (value17) => {
          result2[index2] = value17;
        });
      });
      setValue(result2);
      return;
    }
    if (this.isTuple()) {
      const components = this.components;
      let result2;
      if (Array.isArray(value15)) {
        result2 = value15.slice();
      } else {
        if (value15 == null || typeof value15 !== "object") {
          throw new Error("invalid tuple value");
        }
        result2 = components.map((param) => {
          if (!param.name) {
            throw new Error("cannot use object value with unnamed components");
          }
          if (!(param.name in value15)) {
            throw new Error(`missing value for component ${param.name}`);
          }
          return value15[param.name];
        });
      }
      if (result2.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      result2.forEach((value16, index2) => {
        components[index2].#walkAsync(promises3, value16, process3, (value17) => {
          result2[index2] = value17;
        });
      });
      setValue(result2);
      return;
    }
    const result = process3(this.type, value15);
    if (result.then) {
      promises3.push(async function() {
        setValue(await result);
      }());
    } else {
      setValue(result);
    }
  }
  async walkAsync(value15, process3) {
    const promises3 = [];
    const result = [value15];
    this.#walkAsync(promises3, value15, process3, (value16) => {
      result[0] = value16;
    });
    if (promises3.length) {
      await Promise.all(promises3);
    }
    return result[0];
  }
  static from(obj, allowIndexed) {
    if (ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ParamType.from(lex(obj), allowIndexed);
      } catch (error23) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type51 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t3) => ParamType.from(t3));
        type51 = `tuple(${comps.map((c3) => c3.format()).join(",")})`;
      } else {
        type51 = verifyBasicType(obj.popType("TYPE"));
        baseType = type51;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new ParamType(_guard4, "", type51, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type51 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed12 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed12 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new ParamType(_guard4, name2, type51, baseType, indexed12, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed11 = obj.indexed;
    if (indexed11 != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed11 = !!indexed11;
    }
    let type50 = obj.type;
    let arrayMatch = type50.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new ParamType(_guard4, name || "", type50, "array", indexed11, null, arrayLength, arrayChildren);
    }
    if (type50 === "tuple" || type50.startsWith("tuple(") || type50.startsWith("(")) {
      const comps = obj.components != null ? obj.components.map((c3) => ParamType.from(c3)) : null;
      const tuple8 = new ParamType(_guard4, name || "", type50, "tuple", indexed11, comps, null, null);
      return tuple8;
    }
    type50 = verifyBasicType(obj.type);
    return new ParamType(_guard4, name || "", type50, type50, indexed11, null, null, null);
  }
  static isParamType(value15) {
    return value15 && value15[internal] === ParamTypeInternal;
  }
}

class Fragment {
  type;
  inputs;
  constructor(guard22, type50, inputs) {
    assertPrivate(guard22, _guard4, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type: type50, inputs });
  }
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type50 = obj.peekKeyword(KwTypes);
      switch (type50) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  static isConstructor(value15) {
    return ConstructorFragment.isFragment(value15);
  }
  static isError(value15) {
    return ErrorFragment.isFragment(value15);
  }
  static isEvent(value15) {
    return EventFragment.isFragment(value15);
  }
  static isFunction(value15) {
    return FunctionFragment.isFragment(value15);
  }
  static isStruct(value15) {
    return StructFragment.isFragment(value15);
  }
}

class NamedFragment extends Fragment {
  name;
  constructor(guard22, type50, name, inputs) {
    super(guard22, type50, inputs);
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
}

class ErrorFragment extends NamedFragment {
  constructor(guard22, name, inputs) {
    super(guard22, "error", name, inputs);
    Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
  }
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format, this.inputs));
    return result.join(" ");
  }
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard4, name, inputs);
    }
    return new ErrorFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  static isFragment(value15) {
    return value15 && value15[internal] === ErrorFragmentInternal;
  }
}

class EventFragment extends NamedFragment {
  anonymous;
  constructor(guard22, name, inputs, anonymous2) {
    super(guard22, "event", name, inputs);
    Object.defineProperty(this, internal, { value: EventFragmentInternal });
    defineProperties(this, { anonymous: anonymous2 });
  }
  get topicHash() {
    return id(this.format("sighash"));
  }
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i3) => JSON.parse(i3.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  static getTopicHash(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new EventFragment(_guard4, name, params, false);
    return fragment.topicHash;
  }
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error23) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous2 = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard4, name, inputs, anonymous2);
    }
    return new EventFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
  }
  static isFragment(value15) {
    return value15 && value15[internal] === EventFragmentInternal;
  }
}

class ConstructorFragment extends Fragment {
  payable;
  gas;
  constructor(guard22, type50, inputs, payable, gas) {
    super(guard22, type50, inputs);
    Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  format(format) {
    assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : undefined,
        inputs: this.inputs.map((i3) => JSON.parse(i3.format(format)))
      });
    }
    const result = [`constructor${joinParams(format, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error23) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard4, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard4, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  static isFragment(value15) {
    return value15 && value15[internal] === ConstructorFragmentInternal;
  }
}

class FallbackFragment extends Fragment {
  payable;
  constructor(guard22, inputs, payable) {
    super(guard22, "fallback", inputs);
    Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  format(format) {
    const type50 = this.inputs.length === 0 ? "receive" : "fallback";
    if (format === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type: type50, stateMutability });
    }
    return `${type50}()${this.payable ? " payable" : ""}`;
  }
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error23) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type50 = obj.popKeyword(setify(["fallback", "receive"]));
      if (type50 === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard4, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i3) => i3.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i3) => i3.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard4, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard4, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard4, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  static isFragment(value15) {
    return value15 && value15[internal] === FallbackFragmentInternal;
  }
}

class FunctionFragment extends NamedFragment {
  constant;
  outputs;
  stateMutability;
  payable;
  gas;
  constructor(guard22, name, stateMutability, inputs, outputs, gas) {
    super(guard22, "function", name, inputs);
    Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
        payable: this.payable,
        gas: this.gas != null ? this.gas : undefined,
        inputs: this.inputs.map((i3) => JSON.parse(i3.format(format))),
        outputs: this.outputs.map((o3) => JSON.parse(o3.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  static getSelector(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new FunctionFragment(_guard4, name, "view", params, [], null);
    return fragment.selector;
  }
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error23) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard4, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard4, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  static isFragment(value15) {
    return value15 && value15[internal] === FunctionFragmentInternal;
  }
}

class StructFragment extends NamedFragment {
  constructor(guard22, name, inputs) {
    super(guard22, "struct", name, inputs);
    Object.defineProperty(this, internal, { value: StructFragmentInternal });
  }
  format() {
    throw new Error("@TODO");
  }
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error23) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard4, name, inputs);
    }
    return new StructFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  static isFragment(value15) {
    return value15 && value15[internal] === StructFragmentInternal;
  }
}

// node_modules/ethers/lib.esm/abi/abi-coder.js
function getBuiltinCallException(action, tx, data12, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data12) {
    message = "execution reverted";
    const bytes5 = getBytes(data12);
    data12 = hexlify(data12);
    if (bytes5.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes5.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes5.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes5.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error23) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes5.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes5.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error23) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction4 = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction4.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data: data12,
    reason,
    transaction: transaction4,
    invocation,
    revert
  });
}
var PanicReasons = new Map;
PanicReasons.set(0, "GENERIC_PANIC");
PanicReasons.set(1, "ASSERT_FALSE");
PanicReasons.set(17, "OVERFLOW");
PanicReasons.set(18, "DIVIDE_BY_ZERO");
PanicReasons.set(33, "ENUM_RANGE_ERROR");
PanicReasons.set(34, "BAD_STORAGE_DATA");
PanicReasons.set(49, "STACK_UNDERFLOW");
PanicReasons.set(50, "ARRAY_RANGE_ERROR");
PanicReasons.set(65, "OUT_OF_MEMORY");
PanicReasons.set(81, "UNINITIALIZED_FUNCTION_CALL");
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var defaultCoder = null;
var defaultMaxInflation = 1024;

class AbiCoder {
  #getCoder(param) {
    if (param.isArray()) {
      return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
      return new TupleCoder(param.components.map((c3) => this.#getCoder(c3)), param.name);
    }
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
      return new FixedBytesCoder(size, param.name);
    }
    assertArgument(false, "invalid type", "type", param.type);
  }
  getDefaultValue(types) {
    const coders = types.map((type50) => this.#getCoder(ParamType.from(type50)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    assertArgumentCount(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type50) => this.#getCoder(ParamType.from(type50)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer;
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data12, loose) {
    const coders = types.map((type50) => this.#getCoder(ParamType.from(type50)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data12, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value15) {
    assertArgument(typeof value15 === "number" && Number.isInteger(value15), "invalid defaultMaxInflation factor", "value", value15);
    defaultMaxInflation = value15;
  }
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new AbiCoder;
    }
    return defaultCoder;
  }
  static getBuiltinCallException(action, tx, data12) {
    return getBuiltinCallException(action, tx, data12, AbiCoder.defaultAbiCoder());
  }
}
// node_modules/ethers/lib.esm/abi/bytes32.js
function encodeBytes32String(text) {
  const bytes5 = toUtf8Bytes(text);
  if (bytes5.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return zeroPadBytes(bytes5, 32);
}
function decodeBytes32String(_bytes) {
  const data12 = getBytes(_bytes, "bytes");
  if (data12.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data12[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data12[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data12.slice(0, length));
}
// node_modules/ethers/lib.esm/abi/interface.js
class LogDescription {
  fragment;
  name;
  signature;
  topic;
  args;
  constructor(fragment, topic, args) {
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature: signature2,
      topic,
      args
    });
  }
}

class TransactionDescription {
  fragment;
  name;
  args;
  signature;
  selector;
  value;
  constructor(fragment, selector, args, value15) {
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature: signature2,
      selector,
      value: value15
    });
  }
}

class ErrorDescription {
  fragment;
  name;
  args;
  signature;
  selector;
  constructor(fragment, selector, args) {
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature: signature2,
      selector
    });
  }
}

class Indexed {
  hash;
  _isIndexed;
  static isIndexed(value15) {
    return !!(value15 && value15._isIndexed);
  }
  constructor(hash10) {
    defineProperties(this, { hash: hash10, _isIndexed: true });
  }
}
var PanicReasons2 = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons2[code.toString()]) {
        reason = PanicReasons2[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};

class Interface {
  fragments;
  deploy;
  fallback;
  receive;
  #errors;
  #events;
  #functions;
  #abiCoder;
  constructor(fragments3) {
    let abi = [];
    if (typeof fragments3 === "string") {
      abi = JSON.parse(fragments3);
    } else {
      abi = fragments3;
    }
    this.#functions = new Map;
    this.#errors = new Map;
    this.#events = new Map;
    const frags = [];
    for (const a of abi) {
      try {
        frags.push(Fragment.from(a));
      } catch (error23) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error23.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback2 = null;
    let receive = false;
    this.#abiCoder = this.getAbiCoder();
    this.fragments.forEach((fragment, index2) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback2 || fragment.payable !== fallback2.payable, "conflicting fallback fragments", `fragments[${index2}]`, fragment);
            fallback2 = fragment;
            receive = fallback2.payable;
          }
          return;
        case "function":
          bucket = this.#functions;
          break;
        case "event":
          bucket = this.#events;
          break;
        case "error":
          bucket = this.#errors;
          break;
        default:
          return;
      }
      const signature2 = fragment.format();
      if (bucket.has(signature2)) {
        return;
      }
      bucket.set(signature2, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback: fallback2, receive });
  }
  format(minimal) {
    const format = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f4) => f4.format(format));
    return abi;
  }
  formatJson() {
    const abi = this.fragments.map((f4) => f4.format("json"));
    return JSON.stringify(abi.map((j) => JSON.parse(j)));
  }
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  #getFunction(key, values, forceUnique) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      for (const fragment of this.#functions.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#functions) {
        if (name.split("(")[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        const lastValue = values.length > 0 ? values[values.length - 1] : null;
        let valueLength = values.length;
        let allowOptions = true;
        if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
          allowOptions = false;
          valueLength--;
        }
        for (let i3 = matching.length - 1;i3 >= 0; i3--) {
          const inputs = matching[i3].inputs.length;
          if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
            matching.splice(i3, 1);
          }
        }
        for (let i3 = matching.length - 1;i3 >= 0; i3--) {
          const inputs = matching[i3].inputs;
          for (let j = 0;j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (j >= inputs.length) {
              if (values[j].type === "overrides") {
                continue;
              }
              matching.splice(i3, 1);
              break;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i3, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
        const lastArg = values[values.length - 1];
        if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
          matching.splice(0, 1);
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m3) => JSON.stringify(m3.format())).join(", ");
        assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#functions.get(FunctionFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  getFunctionName(key) {
    const fragment = this.#getFunction(key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  hasFunction(key) {
    return !!this.#getFunction(key, null, false);
  }
  getFunction(key, values) {
    return this.#getFunction(key, values || null, true);
  }
  forEachFunction(callback) {
    const names2 = Array.from(this.#functions.keys());
    names2.sort((a, b3) => a.localeCompare(b3));
    for (let i3 = 0;i3 < names2.length; i3++) {
      const name = names2[i3];
      callback(this.#functions.get(name), i3);
    }
  }
  #getEvent(key, values, forceUnique) {
    if (isHexString(key)) {
      const eventTopic = key.toLowerCase();
      for (const fragment of this.#events.values()) {
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#events) {
        if (name.split("(")[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        for (let i3 = matching.length - 1;i3 >= 0; i3--) {
          if (matching[i3].inputs.length < values.length) {
            matching.splice(i3, 1);
          }
        }
        for (let i3 = matching.length - 1;i3 >= 0; i3--) {
          const inputs = matching[i3].inputs;
          for (let j = 0;j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i3, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m3) => JSON.stringify(m3.format())).join(", ");
        assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#events.get(EventFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  getEventName(key) {
    const fragment = this.#getEvent(key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  hasEvent(key) {
    return !!this.#getEvent(key, null, false);
  }
  getEvent(key, values) {
    return this.#getEvent(key, values || null, true);
  }
  forEachEvent(callback) {
    const names2 = Array.from(this.#events.keys());
    names2.sort((a, b3) => a.localeCompare(b3));
    for (let i3 = 0;i3 < names2.length; i3++) {
      const name = names2[i3];
      callback(this.#events.get(name), i3);
    }
  }
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of this.#errors.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#errors) {
        if (name.split("(")[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m3) => JSON.stringify(m3.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = this.#errors.get(key);
    if (result) {
      return result;
    }
    return null;
  }
  forEachError(callback) {
    const names2 = Array.from(this.#errors.keys());
    names2.sort((a, b3) => a.localeCompare(b3));
    for (let i3 = 0;i3 < names2.length; i3++) {
      const name = names2[i3];
      callback(this.#errors.get(name), i3);
    }
  }
  _decodeParams(params, data12) {
    return this.#abiCoder.decode(params, data12);
  }
  _encodeParams(params, values) {
    return this.#abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data12) {
    if (typeof fragment === "string") {
      const f4 = this.getError(fragment);
      assertArgument(f4, "unknown error", "fragment", fragment);
      fragment = f4;
    }
    assertArgument(dataSlice(data12, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data12);
    return this._decodeParams(fragment.inputs, dataSlice(data12, 4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getError(fragment);
      assertArgument(f4, "unknown error", "fragment", fragment);
      fragment = f4;
    }
    return concat2([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  decodeFunctionData(fragment, data12) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    assertArgument(dataSlice(data12, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data12);
    return this._decodeParams(fragment.inputs, dataSlice(data12, 4));
  }
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    return concat2([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  decodeFunctionResult(fragment, data12) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    let message = "invalid length for result data";
    const bytes5 = getBytesCopy(data12);
    if (bytes5.length % 32 === 0) {
      try {
        return this.#abiCoder.decode(fragment.outputs, bytes5);
      } catch (error23) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes5),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data, tx) {
    const data12 = getBytes(_data, "data");
    const error23 = AbiCoder.getBuiltinCallException("call", tx, data12);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error23.message.startsWith(customPrefix)) {
      const selector = hexlify(data12.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = this.#abiCoder.decode(ef.inputs, data12.slice(4));
          error23.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error23.reason = error23.revert.signature;
          error23.message = `execution reverted: ${error23.reason}`;
        } catch (e) {
          error23.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error23.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error23;
  }
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getFunction(fragment);
      assertArgument(f4, "unknown function", "fragment", fragment);
      fragment = f4;
    }
    return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
  }
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getEvent(fragment);
      assertArgument(f4, "unknown event", "eventFragment", fragment);
      fragment = f4;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value15) => {
      if (param.type === "string") {
        return id(value15);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value15));
      }
      if (param.type === "bool" && typeof value15 === "boolean") {
        value15 = value15 ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value15 = toBeHex(value15);
      } else if (param.type.match(/^bytes/)) {
        value15 = zeroPadBytes(value15, 32);
      } else if (param.type === "address") {
        this.#abiCoder.encode(["address"], [value15]);
      }
      return zeroPadValue(hexlify(value15), 32);
    };
    values.forEach((value15, index2) => {
      const param = fragment.inputs[index2];
      if (!param.indexed) {
        assertArgument(value15 == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value15);
        return;
      }
      if (value15 == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value15);
      } else if (Array.isArray(value15)) {
        topics.push(value15.map((value16) => encodeTopic(param, value16)));
      } else {
        topics.push(encodeTopic(param, value15));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f4 = this.getEvent(fragment);
      assertArgument(f4, "unknown event", "eventFragment", fragment);
      fragment = f4;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index2) => {
      const value15 = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value15));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value15));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this.#abiCoder.encode([param.type], [value15]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value15);
      }
    });
    return {
      data: this.#abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  decodeEventLog(fragment, data12, topics) {
    if (typeof fragment === "string") {
      const f4 = this.getEvent(fragment);
      assertArgument(f4, "unknown event", "eventFragment", fragment);
      fragment = f4;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed11 = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed11.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed11.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? this.#abiCoder.decode(indexed11, concat2(topics)) : null;
    const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data12, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index2) => {
      let value15 = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value15 = new Indexed(null);
        } else if (dynamic[index2]) {
          value15 = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value15 = resultIndexed[indexedIndex++];
          } catch (error23) {
            value15 = error23;
          }
        }
      } else {
        try {
          value15 = resultNonIndexed[nonIndexedIndex++];
        } catch (error23) {
          value15 = error23;
        }
      }
      values.push(value15);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  parseTransaction(tx) {
    const data12 = getBytes(tx.data, "tx.data");
    const value15 = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data12.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, data12.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value15);
  }
  parseCallResult(data12) {
    throw new Error("@TODO");
  }
  parseLog(log2) {
    const fragment = this.getEvent(log2.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log2.data, log2.topics));
  }
  parseError(data12) {
    const hexData = hexlify(data12);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  static from(value15) {
    if (value15 instanceof Interface) {
      return value15;
    }
    if (typeof value15 === "string") {
      return new Interface(JSON.parse(value15));
    }
    if (typeof value15.formatJson === "function") {
      return new Interface(value15.formatJson());
    }
    if (typeof value15.format === "function") {
      return new Interface(value15.format("json"));
    }
    return new Interface(value15);
  }
}
// node_modules/ethers/lib.esm/providers/provider.js
function getValue2(value15) {
  if (value15 == null) {
    return null;
  }
  return value15;
}
function toJson(value15) {
  if (value15 == null) {
    return null;
  }
  return value15.toString();
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if (req.authorizationList) {
    result.authorizationList = req.authorizationList.slice();
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b3) => {
      if (isBytesLike(b3)) {
        return hexlify(b3);
      }
      return Object.assign({}, b3);
    });
  }
  return result;
}
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log2) {
  return { orphan: "drop-log", log: {
    transactionHash: log2.transactionHash,
    blockHash: log2.blockHash,
    blockNumber: log2.blockNumber,
    address: log2.address,
    data: log2.data,
    topics: Object.freeze(log2.topics.slice()),
    index: log2.index
  } };
}
var BN_09 = BigInt(0);

class FeeData {
  gasPrice;
  maxFeePerGas;
  maxPriorityFeePerGas;
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    defineProperties(this, {
      gasPrice: getValue2(gasPrice),
      maxFeePerGas: getValue2(maxFeePerGas),
      maxPriorityFeePerGas: getValue2(maxPriorityFeePerGas)
    });
  }
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}

class Block {
  provider;
  number;
  hash;
  timestamp;
  parentHash;
  parentBeaconBlockRoot;
  nonce;
  difficulty;
  gasLimit;
  gasUsed;
  stateRoot;
  receiptsRoot;
  blobGasUsed;
  excessBlobGas;
  miner;
  prevRandao;
  extraData;
  baseFeePerGas;
  #transactions;
  constructor(block, provider) {
    this.#transactions = block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    });
    defineProperties(this, {
      provider,
      hash: getValue2(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue2(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue2(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  get transactions() {
    return this.#transactions.map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  get prefetchedTransactions() {
    const txs = this.#transactions.slice();
    if (txs.length === 0) {
      return [];
    }
    assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash10, miner, prevRandao, nonce, number: number9, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash: hash10,
      miner,
      prevRandao,
      nonce,
      number: number9,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index2 = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index2 < this.length) {
          return {
            value: txs[index2++],
            done: false
          };
        }
        return { value: undefined, done: true };
      }
    };
  }
  get length() {
    return this.#transactions.length;
  }
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1000);
  }
  async getTransaction(indexOrHash) {
    let tx = undefined;
    if (typeof indexOrHash === "number") {
      tx = this.#transactions[indexOrHash];
    } else {
      const hash10 = indexOrHash.toLowerCase();
      for (const v3 of this.#transactions) {
        if (typeof v3 === "string") {
          if (v3 !== hash10) {
            continue;
          }
          tx = v3;
          break;
        } else {
          if (v3.hash !== hash10) {
            continue;
          }
          tx = v3;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  isMined() {
    return !!this.hash;
  }
  isLondon() {
    return !!this.baseFeePerGas;
  }
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}

class Log {
  provider;
  transactionHash;
  blockHash;
  blockNumber;
  removed;
  address;
  data;
  topics;
  index;
  transactionIndex;
  constructor(log2, provider) {
    this.provider = provider;
    const topics = Object.freeze(log2.topics.slice());
    defineProperties(this, {
      transactionHash: log2.transactionHash,
      blockHash: log2.blockHash,
      blockNumber: log2.blockNumber,
      removed: log2.removed,
      address: log2.address,
      data: log2.data,
      topics,
      index: log2.index,
      transactionIndex: log2.transactionIndex
    });
  }
  toJSON() {
    const { address: address14, blockHash, blockNumber, data: data12, index: index2, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address: address14,
      blockHash,
      blockNumber,
      data: data12,
      index: index2,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}

class TransactionReceipt {
  provider;
  to;
  from;
  contractAddress;
  hash;
  index;
  blockHash;
  blockNumber;
  logsBloom;
  gasUsed;
  blobGasUsed;
  cumulativeGasUsed;
  gasPrice;
  blobGasPrice;
  type;
  status;
  root;
  #logs;
  constructor(tx, provider) {
    this.#logs = Object.freeze(tx.logs.map((log2) => {
      return new Log(log2, provider);
    }));
    let gasPrice = BN_09;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      status: tx.status,
      root: tx.root
    });
  }
  get logs() {
    return this.#logs;
  }
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash10,
      index: index2,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash10,
      index: index2,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index2 = 0;
    return {
      next: () => {
        if (index2 < this.length) {
          return { value: this.logs[index2++], done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}

class TransactionResponse {
  provider;
  blockNumber;
  blockHash;
  index;
  hash;
  type;
  to;
  from;
  nonce;
  gasLimit;
  gasPrice;
  maxPriorityFeePerGas;
  maxFeePerGas;
  maxFeePerBlobGas;
  data;
  value;
  chainId;
  signature;
  accessList;
  blobVersionedHashes;
  authorizationList;
  #startBlock;
  constructor(tx, provider) {
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;
    this.#startBlock = -1;
  }
  toJSON() {
    const { blockNumber, blockHash, index: index2, hash: hash10, type: type50, to, from, nonce, data: data12, signature: signature2, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data: data12,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash10,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature: signature2,
      to,
      index: index2,
      type: type50,
      value: toJson(this.value)
    };
  }
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  async wait(_confirms, _timeout) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout == null ? 0 : _timeout;
    let startBlock = this.#startBlock;
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < this.#startBlock) {
          nextScan = this.#startBlock;
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash10 of block) {
          if (hash10 === this.hash) {
            return;
          }
        }
        for (let i3 = 0;i3 < block.length; i3++) {
          const tx = await block.getTransaction(i3);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_09) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (confirms === 1 || await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject2) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c3) => c3());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject2(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error23) {
            reject2(error23);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error23) {
            if (isError(error23, "TRANSACTION_REPLACED")) {
              cancel();
              reject2(error23);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  isMined() {
    return this.blockHash != null;
  }
  isLegacy() {
    return this.type === 0;
  }
  isBerlin() {
    return this.type === 1;
  }
  isLondon() {
    return this.type === 2;
  }
  isCancun() {
    return this.type === 3;
  }
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new TransactionResponse(this, this.provider);
    tx.#startBlock = startBlock;
    return tx;
  }
}

// node_modules/ethers/lib.esm/contract/wrappers.js
class EventLog extends Log {
  interface;
  fragment;
  args;
  constructor(log2, iface, fragment) {
    super(log2, log2.provider);
    const args = iface.decodeEventLog(fragment, log2.data, log2.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  get eventName() {
    return this.fragment.name;
  }
  get eventSignature() {
    return this.fragment.format();
  }
}

class UndecodedEventLog extends Log {
  error;
  constructor(log2, error23) {
    super(log2, log2.provider);
    defineProperties(this, { error: error23 });
  }
}

class ContractTransactionReceipt extends TransactionReceipt {
  #iface;
  constructor(iface, provider2, tx) {
    super(tx, provider2);
    this.#iface = iface;
  }
  get logs() {
    return super.logs.map((log2) => {
      const fragment = log2.topics.length ? this.#iface.getEvent(log2.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log2, this.#iface, fragment);
        } catch (error23) {
          return new UndecodedEventLog(log2, error23);
        }
      }
      return log2;
    });
  }
}

class ContractTransactionResponse extends TransactionResponse {
  #iface;
  constructor(iface, provider2, tx) {
    super(tx, provider2);
    this.#iface = iface;
  }
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
  }
}

class ContractUnknownEventPayload extends EventPayload {
  log;
  constructor(contract, listener, filter2, log2) {
    super(contract, listener, filter2);
    defineProperties(this, { log: log2 });
  }
  async getBlock() {
    return await this.log.getBlock();
  }
  async getTransaction() {
    return await this.log.getTransaction();
  }
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}

class ContractEventPayload extends ContractUnknownEventPayload {
  constructor(contract, listener, filter2, fragment, _log) {
    super(contract, listener, filter2, new EventLog(_log, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  get eventName() {
    return this.fragment.name;
  }
  get eventSignature() {
    return this.fragment.format();
  }
}

// node_modules/ethers/lib.esm/contract/contract.js
function canCall(value15) {
  return value15 && typeof value15.call === "function";
}
function canEstimate(value15) {
  return value15 && typeof value15.estimateGas === "function";
}
function canResolve(value15) {
  return value15 && typeof value15.resolveName === "function";
}
function canSend(value15) {
  return value15 && typeof value15.sendTransaction === "function";
}
function getResolver(value15) {
  if (value15 != null) {
    if (canResolve(value15)) {
      return value15;
    }
    if (value15.provider) {
      return value15.provider;
    }
  }
  return;
}
function getRunner(value15, feature) {
  if (value15 == null) {
    return null;
  }
  if (typeof value15[feature] === "function") {
    return value15;
  }
  if (value15.provider && typeof value15.provider[feature] === "function") {
    return value15.provider;
  }
  return null;
}
function getProvider(value15) {
  if (value15 == null) {
    return null;
  }
  return value15.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index2) => {
    return param.walkAsync(args[index2], (type50, value15) => {
      value15 = Typed.dereference(value15, type50);
      if (type50 === "address") {
        return resolveAddress(value15, resolver);
      }
      return value15;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_010, "overrides.value") === BN_010;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error23) {
      if (isCallException(error23) && error23.data) {
        throw contract.interface.makeError(error23.data, tx);
      }
      throw error23;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider3 = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider3, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider3 = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider3, tx);
  };
  const estimateGas = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error23) {
      if (isCallException(error23) && error23.data) {
        throw contract.interface.makeError(error23.data, tx);
      }
      throw error23;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function setInternal(contract, values) {
  internalValues.set(contract[internal2], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal2]);
}
function isDeferred(value15) {
  return value15 && typeof value15 === "object" && "getTopicFilter" in value15 && typeof value15.getTopicFilter === "function" && value15.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e) => {
      if (e == null) {
        return null;
      }
      if (Array.isArray(e)) {
        return e.map(topicHashify);
      }
      return topicHashify(e);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t3) => {
    if (t3 == null) {
      return null;
    }
    if (Array.isArray(t3)) {
      const items = Array.from(new Set(t3.map((t4) => t4.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t3.toLowerCase();
  });
  const tag = topics.map((t3) => {
    if (t3 == null) {
      return "null";
    }
    if (Array.isArray(t3)) {
      return t3.join("|");
    }
    return t3;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider3 = getProvider(contract.runner);
  assert(provider3, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address15 = addr ? addr : contract;
    const filter2 = { address: address15, topics };
    const listener = (log2) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log2.topics[0]);
        } catch (error23) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log2.data, log2.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log2);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log2);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider3.on(filter2, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider3.off(filter2, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once: once2 }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once2 ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error23) {
    }
    return !once2;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error23) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
function _ContractBase() {
  return BaseContract;
}
var BN_010 = BigInt(0);

class PreparedTopicFilter {
  #filter;
  fragment;
  constructor(contract, fragment, args) {
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    this.#filter = async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index2) => {
        const arg = args[index2];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index2], (type50, value15) => {
          if (type50 === "address") {
            if (Array.isArray(value15)) {
              return Promise.all(value15.map((v3) => resolveAddress(v3, resolver)));
            }
            return resolveAddress(value15, resolver);
          }
          return value15;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }();
  }
  getTopicFilter() {
    return this.#filter;
  }
}
var internal2 = Symbol.for("_ethersInternal_contract");
var internalValues = new WeakMap;
var lastEmit = Promise.resolve();
var passProperties2 = ["then"];

class BaseContract {
  target;
  interface;
  runner;
  filters;
  [internal2];
  fallback;
  constructor(target, abi2, runner, _deployTx) {
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi2);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal2, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider3 = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider3, _deployTx);
    }
    let subs = new Map;
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error23) {
          if (!isError(error23, "INVALID_ARGUMENT") || error23.argument !== "key") {
            throw error23;
          }
        }
        return;
      },
      has: (target2, prop) => {
        if (passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error23) {
          if (!isError(error23, "INVALID_ARGUMENT") || error23.argument !== "key") {
            throw error23;
          }
        }
        return;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  connect(runner) {
    return new BaseContract(this.target, this.interface, runner);
  }
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  async getDeployedCode() {
    const provider3 = getProvider(this.runner);
    assert(provider3, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider3.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider3 = getProvider(this.runner);
    assert(provider3 != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject2) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider3.once("block", checkCode);
        } catch (error23) {
          reject2(error23);
        }
      };
      checkCode();
    });
  }
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  async queryTransaction(hash10) {
    throw new Error("@TODO");
  }
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address15 = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter2 = { address: address15, topics, fromBlock, toBlock };
    const provider3 = getProvider(this.runner);
    assert(provider3, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider3.getLogs(filter2)).map((log2) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log2.topics[0]);
        } catch (error23) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log2, this.interface, foundFragment);
        } catch (error23) {
          return new UndecodedEventLog(log2, error23);
        }
      }
      return new Log(log2, provider3);
    });
  }
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index2 = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index2 >= 0) {
        sub.listeners.splice(index2, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  static buildClass(abi2) {

    class CustomContract extends BaseContract {
      constructor(address15, runner = null) {
        super(address15, abi2, runner);
      }
    }
    return CustomContract;
  }
  static from(target, abi2, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi2, runner);
    return contract;
  }
}

class Contract extends _ContractBase() {
}
// node_modules/ethers/lib.esm/contract/factory.js
class ContractFactory {
  interface;
  bytecode;
  runner;
  constructor(abi3, bytecode, runner) {
    const iface = Interface.from(abi3);
    if (bytecode instanceof Uint8Array) {
      bytecode = hexlify(getBytes(bytecode));
    } else {
      if (typeof bytecode === "object") {
        bytecode = bytecode.object;
      }
      if (!bytecode.startsWith("0x")) {
        bytecode = "0x" + bytecode;
      }
      bytecode = hexlify(getBytes(bytecode));
    }
    defineProperties(this, {
      bytecode,
      interface: iface,
      runner: runner || null
    });
  }
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  async getDeployTransaction(...args) {
    let overrides = {};
    const fragment = this.interface.deploy;
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("incorrect number of arguments to constructor");
    }
    const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);
    const data12 = concat2([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
    return Object.assign({}, overrides, { data: data12 });
  }
  async deploy(...args) {
    const tx = await this.getDeployTransaction(...args);
    assert(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
      operation: "sendTransaction"
    });
    const sentTx = await this.runner.sendTransaction(tx);
    const address16 = getCreateAddress(sentTx);
    return new BaseContract(address16, this.interface, this.runner, sentTx);
  }
  connect(runner) {
    return new ContractFactory(this.interface, this.bytecode, runner);
  }
  static fromSolidity(output2, runner) {
    assertArgument(output2 != null, "bad compiler output", "output", output2);
    if (typeof output2 === "string") {
      output2 = JSON.parse(output2);
    }
    const abi3 = output2.abi;
    let bytecode = "";
    if (output2.bytecode) {
      bytecode = output2.bytecode;
    } else if (output2.evm && output2.evm.bytecode) {
      bytecode = output2.evm.bytecode;
    }
    return new this(abi3, bytecode, runner);
  }
}
// node_modules/ethers/lib.esm/providers/ens-resolver.js
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}

class MulticoinProviderPlugin {
  name;
  constructor(name) {
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  supportsCoinType(coinType) {
    return false;
  }
  async encodeAddress(coinType, address17) {
    throw new Error("unsupported coin");
  }
  async decodeAddress(coinType, data12) {
    throw new Error("unsupported coin");
  }
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];

class EnsResolver {
  provider;
  address;
  name;
  #supports2544;
  #resolver;
  constructor(provider3, address17, name) {
    defineProperties(this, { provider: provider3, address: address17, name });
    this.#supports2544 = null;
    this.#resolver = new Contract(address17, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider3);
  }
  async supportsWildcard() {
    if (this.#supports2544 == null) {
      this.#supports2544 = (async () => {
        try {
          return await this.#resolver.supportsInterface("0x9061b923");
        } catch (error23) {
          if (isError(error23, "CALL_EXCEPTION")) {
            return false;
          }
          this.#supports2544 = null;
          throw error23;
        }
      })();
    }
    return await this.#supports2544;
  }
  async#fetch(funcName, params) {
    params = (params || []).slice();
    const iface = this.#resolver.interface;
    params.unshift(namehash(this.name));
    let fragment = null;
    if (await this.supportsWildcard()) {
      fragment = iface.getFunction(funcName);
      assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
        info: { funcName }
      });
      params = [
        dnsEncode(this.name, 255),
        iface.encodeFunctionData(fragment, params)
      ];
      funcName = "resolve(bytes,bytes)";
    }
    params.push({
      enableCcipRead: true
    });
    try {
      const result = await this.#resolver[funcName](...params);
      if (fragment) {
        return iface.decodeFunctionResult(fragment, result)[0];
      }
      return result;
    } catch (error23) {
      if (!isError(error23, "CALL_EXCEPTION")) {
        throw error23;
      }
    }
    return null;
  }
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await this.#fetch("addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error23) {
        if (isError(error23, "CALL_EXCEPTION")) {
          return null;
        }
        throw error23;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data13 = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data13, 20)) {
        return getAddress(data13);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data12 = await this.#fetch("addr(bytes32,uint)", [coinType]);
    if (data12 == null || data12 === "0x") {
      return null;
    }
    const address17 = await coinPlugin.decodeAddress(coinType, data12);
    if (address17 != null) {
      return address17;
    }
    assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data: data12 }
    });
  }
  async getText(key) {
    const data12 = await this.#fetch("text(bytes32,string)", [key]);
    if (data12 == null || data12 === "0x") {
      return null;
    }
    return data12;
  }
  async getContentHash() {
    const data12 = await this.#fetch("contenthash(bytes32)");
    if (data12 == null || data12 === "0x") {
      return null;
    }
    const ipfs = data12.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data12.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: data12 }
    });
  }
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i3 = 0;i3 < matchers.length; i3++) {
        const match = avatar.match(matchers[i3]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract3 = new Contract(comps[0], [
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract3.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract3.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract3[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response4 = await new FetchRequest(metadataUrl).send();
            response4.assertOk();
            try {
              metadata = response4.bodyJson;
            } catch (error23) {
              try {
                linkage.push({ type: "!metadata", value: response4.bodyText });
              } catch (error24) {
                const bytes5 = response4.body;
                if (bytes5) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes5) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error23) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider3) {
    const network = await provider3.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  static async#getResolver(provider3, name) {
    const ensAddr = await EnsResolver.getEnsAddress(provider3);
    try {
      const contract3 = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], provider3);
      const addr = await contract3.resolver(namehash(name), {
        enableCcipRead: true
      });
      if (addr === ZeroAddress) {
        return null;
      }
      return addr;
    } catch (error23) {
      throw error23;
    }
    return null;
  }
  static async fromName(provider3, name) {
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await EnsResolver.#getResolver(provider3, currentName);
      if (addr != null) {
        const resolver = new EnsResolver(provider3, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
}

// node_modules/ethers/lib.esm/providers/format.js
function allowNull(format, nullValue) {
  return function(value15) {
    if (value15 == null) {
      return nullValue;
    }
    return format(value15);
  };
}
function arrayOf(format, allowNull2) {
  return (array7) => {
    if (allowNull2 && array7 == null) {
      return null;
    }
    if (!Array.isArray(array7)) {
      throw new Error("not an array");
    }
    return array7.map((i3) => format(i3));
  };
}
function object13(format, altNames) {
  return (value15) => {
    const result = {};
    for (const key in format) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value15)) {
        for (const altKey of altNames[key]) {
          if (altKey in value15) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format[key](value15[srcKey]);
        if (nv !== undefined) {
          result[key] = nv;
        }
      } catch (error23) {
        const message = error23 instanceof Error ? error23.message : "not-an-error";
        assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value: value15 });
      }
    }
    return result;
  };
}
function formatBoolean(value15) {
  switch (value15) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value15)}`, "value", value15);
}
function formatData(value15) {
  assertArgument(isHexString(value15, true), "invalid data", "value", value15);
  return value15;
}
function formatHash(value15) {
  assertArgument(isHexString(value15, 32), "invalid hash", "value", value15);
  return value15;
}
function formatLog(value15) {
  return _formatLog(value15);
}
function formatBlock(value15) {
  const result = _formatBlock(value15);
  result.transactions = value15.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
function formatReceiptLog(value15) {
  return _formatReceiptLog(value15);
}
function formatTransactionReceipt(value15) {
  return _formatTransactionReceipt(value15);
}
function formatTransactionResponse(value15) {
  if (value15.to && getBigInt(value15.to) === BN_011) {
    value15.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object13({
    hash: formatHash,
    index: allowNull(getNumber, undefined),
    type: (value16) => {
      if (value16 === "0x" || value16 == null) {
        return 0;
      }
      return getNumber(value16);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    authorizationList: allowNull(arrayOf((v3) => {
      let sig;
      if (v3.signature) {
        sig = v3.signature;
      } else {
        let yParity = v3.yParity;
        if (yParity === "0x1b") {
          yParity = 0;
        } else if (yParity === "0x1c") {
          yParity = 1;
        }
        sig = Object.assign({}, v3, { yParity });
      }
      return {
        address: getAddress(v3.address),
        chainId: getBigInt(v3.chainId),
        nonce: getBigInt(v3.nonce),
        signature: Signature2.from(sig)
      };
    }, false), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value15);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value15.type === 1 || value15.type === 2) && value15.accessList == null) {
    result.accessList = [];
  }
  if (value15.signature) {
    result.signature = Signature2.from(value15.signature);
  } else {
    result.signature = Signature2.from(value15);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_011) {
    result.blockHash = null;
  }
  return result;
}
var BN_011 = BigInt(0);
var _formatLog = object13({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
var _formatBlock = object13({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
var _formatReceiptLog = object13({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
var _formatTransactionReceipt = object13({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});

// node_modules/ethers/lib.esm/providers/plugins-network.js
var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";

class NetworkPlugin {
  name;
  constructor(name) {
    defineProperties(this, { name });
  }
  clone() {
    return new NetworkPlugin(this.name);
  }
}

class GasCostPlugin extends NetworkPlugin {
  effectiveBlock;
  txBase;
  txCreate;
  txDataZero;
  txDataNonzero;
  txAccessListStorageKey;
  txAccessListAddress;
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    const props = { effectiveBlock };
    function set2(name, nullish) {
      let value15 = (costs || {})[name];
      if (value15 == null) {
        value15 = nullish;
      }
      assertArgument(typeof value15 === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value15;
    }
    set2("txBase", 21000);
    set2("txCreate", 32000);
    set2("txDataZero", 4);
    set2("txDataNonzero", 16);
    set2("txAccessListStorageKey", 1900);
    set2("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}

class EnsPlugin extends NetworkPlugin {
  address;
  targetNetwork;
  constructor(address18, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    defineProperties(this, {
      address: address18 || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}

class FeeDataNetworkPlugin extends NetworkPlugin {
  #feeDataFunc;
  get feeDataFunc() {
    return this.#feeDataFunc;
  }
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    this.#feeDataFunc = feeDataFunc;
  }
  async getFeeData(provider3) {
    return await this.#feeDataFunc(provider3);
  }
  clone() {
    return new FeeDataNetworkPlugin(this.#feeDataFunc);
  }
}

class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  #url;
  #processFunc;
  get url() {
    return this.#url;
  }
  get processFunc() {
    return this.#processFunc;
  }
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    this.#url = url;
    this.#processFunc = processFunc;
  }
  clone() {
    return this;
  }
}

// node_modules/ethers/lib.esm/providers/network.js
function parseUnits2(_value, decimals) {
  const value15 = String(_value);
  if (!value15.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  const comps = value15.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider3, request27) => {
    request27.setHeader("User-Agent", "ethers");
    let response4;
    try {
      const [_response, _feeData] = await Promise.all([
        request27.send(),
        fetchFeeData()
      ]);
      response4 = _response;
      const payload = response4.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits2(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits2(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error23) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request27.url)})`, "SERVER_ERROR", { request: request27, response: response4, error: error23 });
    }
  });
}
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin);
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17000, { ensNetwork: 17000 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}
var Networks = new Map;

class Network {
  #name;
  #chainId;
  #plugins;
  constructor(name, chainId) {
    this.#name = name;
    this.#chainId = getBigInt(chainId);
    this.#plugins = new Map;
  }
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  get name() {
    return this.#name;
  }
  set name(value15) {
    this.#name = value15;
  }
  get chainId() {
    return this.#chainId;
  }
  set chainId(value15) {
    this.#chainId = getBigInt(value15, "chainId");
  }
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error23) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error23) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error23) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.clone());
    return this;
  }
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  getPlugins(basename) {
    return this.plugins.filter((p) => p.name.split("#")[0] === basename);
  }
  clone() {
    const clone13 = new Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone13.attachPlugin(plugin.clone());
    });
    return clone13;
  }
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin;
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i3 = 2;i3 < tx.data.length; i3 += 2) {
        if (tx.data.substring(i3, i3 + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone13 = network.clone();
      return clone13;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom2 = new Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom2.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom2;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
}
var injected = false;

// node_modules/ethers/lib.esm/providers/subscriber-polling.js
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class PollingBlockSubscriber {
  #provider;
  #poller;
  #interval;
  #blockNumber;
  constructor(provider3) {
    this.#provider = provider3;
    this.#poller = null;
    this.#interval = 4000;
    this.#blockNumber = -2;
  }
  get pollingInterval() {
    return this.#interval;
  }
  set pollingInterval(value15) {
    this.#interval = value15;
  }
  async#poll() {
    try {
      const blockNumber = await this.#provider.getBlockNumber();
      if (this.#blockNumber === -2) {
        this.#blockNumber = blockNumber;
        return;
      }
      if (blockNumber !== this.#blockNumber) {
        for (let b3 = this.#blockNumber + 1;b3 <= blockNumber; b3++) {
          if (this.#poller == null) {
            return;
          }
          await this.#provider.emit("block", b3);
        }
        this.#blockNumber = blockNumber;
      }
    } catch (error23) {
    }
    if (this.#poller == null) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
  }
  start() {
    if (this.#poller) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    this.#poll();
  }
  stop() {
    if (!this.#poller) {
      return;
    }
    this.#provider._clearTimeout(this.#poller);
    this.#poller = null;
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
}

class OnBlockSubscriber {
  #provider;
  #poll;
  #running;
  constructor(provider3) {
    this.#provider = provider3;
    this.#running = false;
    this.#poll = (blockNumber) => {
      this._poll(blockNumber, this.#provider);
    };
  }
  async _poll(blockNumber, provider3) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
    this.#provider.on("block", this.#poll);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poll);
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}

class PollingBlockTagSubscriber extends OnBlockSubscriber {
  #tag;
  #lastBlock;
  constructor(provider3, tag) {
    super(provider3);
    this.#tag = tag;
    this.#lastBlock = -2;
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#lastBlock = -2;
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider3) {
    const block = await provider3.getBlock(this.#tag);
    if (block == null) {
      return;
    }
    if (this.#lastBlock === -2) {
      this.#lastBlock = block.number;
    } else if (block.number > this.#lastBlock) {
      provider3.emit(this.#tag, block.number);
      this.#lastBlock = block.number;
    }
  }
}

class PollingOrphanSubscriber extends OnBlockSubscriber {
  #filter;
  constructor(provider3, filter2) {
    super(provider3);
    this.#filter = copy(filter2);
  }
  async _poll(blockNumber, provider3) {
    throw new Error("@TODO");
    console.log(this.#filter);
  }
}

class PollingTransactionSubscriber extends OnBlockSubscriber {
  #hash;
  constructor(provider3, hash11) {
    super(provider3);
    this.#hash = hash11;
  }
  async _poll(blockNumber, provider3) {
    const tx = await provider3.getTransactionReceipt(this.#hash);
    if (tx) {
      provider3.emit(this.#hash, tx);
    }
  }
}

class PollingEventSubscriber {
  #provider;
  #filter;
  #poller;
  #running;
  #blockNumber;
  constructor(provider3, filter2) {
    this.#provider = provider3;
    this.#filter = copy(filter2);
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#blockNumber = -2;
  }
  async#poll(blockNumber) {
    if (this.#blockNumber === -2) {
      return;
    }
    const filter2 = copy(this.#filter);
    filter2.fromBlock = this.#blockNumber + 1;
    filter2.toBlock = blockNumber;
    const logs = await this.#provider.getLogs(filter2);
    if (logs.length === 0) {
      if (this.#blockNumber < blockNumber - 60) {
        this.#blockNumber = blockNumber - 60;
      }
      return;
    }
    for (const log2 of logs) {
      this.#provider.emit(this.#filter, log2);
      this.#blockNumber = log2.blockNumber;
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    if (this.#blockNumber === -2) {
      this.#provider.getBlockNumber().then((blockNumber) => {
        this.#blockNumber = blockNumber;
      });
    }
    this.#provider.on("block", this.#poller);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
}

// node_modules/ethers/lib.esm/providers/abstract-provider.js
function isPromise(value15) {
  return value15 && typeof value15.then === "function";
}
function getTag(prefix, value15) {
  return prefix + ":" + JSON.stringify(value15, (k, v3) => {
    if (v3 == null) {
      return "null";
    }
    if (typeof v3 === "bigint") {
      return `bigint:${v3.toString()}`;
    }
    if (typeof v3 === "string") {
      return v3.toLowerCase();
    }
    if (typeof v3 === "object" && !Array.isArray(v3)) {
      const keys = Object.keys(v3);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v3[key];
        return accum;
      }, {});
    }
    return v3;
  });
}
function copy2(value15) {
  return JSON.parse(JSON.stringify(value15));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event, provider4) {
  if (_event == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event)) {
    _event = { topics: _event };
  }
  if (typeof _event === "string") {
    switch (_event) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event, tag: _event };
      }
    }
  }
  if (isHexString(_event, 32)) {
    const hash12 = _event.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash12 }), hash: hash12 };
  }
  if (_event.orphan) {
    const event = _event;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy2(event) };
  }
  if (_event.address || _event.topics) {
    const event = _event;
    const filter2 = {
      topics: (event.topics || []).map((t3) => {
        if (t3 == null) {
          return null;
        }
        if (Array.isArray(t3)) {
          return concisify(t3.map((t4) => t4.toLowerCase()));
        }
        return t3.toLowerCase();
      })
    };
    if (event.address) {
      const addresses2 = [];
      const promises3 = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses2.push(addr);
        } else {
          promises3.push((async () => {
            addresses2.push(await resolveAddress(addr, provider4));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises3.length) {
        await Promise.all(promises3);
      }
      filter2.address = concisify(addresses2.map((a) => a.toLowerCase()));
    }
    return { filter: filter2, tag: getTag("event", filter2), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event);
}
function getTime2() {
  return new Date().getTime();
}
function _parseString(result, start) {
  try {
    const bytes5 = _parseBytes(result, start);
    if (bytes5) {
      return toUtf8String(bytes5);
    }
  } catch (error23) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error23) {
  }
  return null;
}
function numPad(value15) {
  const result = toBeArray(value15);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value15) {
  if (value15.length % 32 === 0) {
    return value15;
  }
  const result = new Uint8Array(Math.ceil(value15.length / 32) * 32);
  result.set(value15);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i3 = 0;i3 < datas.length; i3++) {
    result.push(empty2);
    byteCount += 32;
  }
  for (let i3 = 0;i3 < datas.length; i3++) {
    const data12 = getBytes(datas[i3]);
    result[i3] = numPad(byteCount);
    result.push(numPad(data12.length));
    result.push(bytesPad(data12));
    byteCount += 32 + Math.ceil(data12.length / 32) * 32;
  }
  return concat2(result);
}
function parseOffchainLookup(data12) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert(dataLength(data12) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data12, 0, 32);
  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data12, 32, 64));
    const urlsLength = getNumber(dataSlice(data12, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data12, urlsOffset + 32);
    for (let u3 = 0;u3 < urlsLength; u3++) {
      const url = _parseString(urlsData, u3 * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error23) {
    assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data12, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error23) {
    assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert(dataSlice(data12, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data12, 96, 100);
  try {
    const extraData = _parseBytes(data12, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error23) {
    assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
  return result;
}
var BN_23 = BigInt(2);
var MAX_CCIP_REDIRECTS = 10;

class UnmanagedSubscriber {
  name;
  constructor(name) {
    defineProperties(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
}
var defaultOptions2 = {
  cacheTimeout: 250,
  pollingInterval: 4000
};

class AbstractProvider {
  #subs;
  #plugins;
  #pausedState;
  #destroyed;
  #networkPromise;
  #anyNetwork;
  #performCache;
  #lastBlockNumber;
  #nextTimer;
  #timers;
  #disableCcipRead;
  #options;
  constructor(_network, options) {
    this.#options = Object.assign({}, defaultOptions2, options || {});
    if (_network === "any") {
      this.#anyNetwork = true;
      this.#networkPromise = null;
    } else if (_network) {
      const network2 = Network.from(_network);
      this.#anyNetwork = false;
      this.#networkPromise = Promise.resolve(network2);
      setTimeout(() => {
        this.emit("network", network2, null);
      }, 0);
    } else {
      this.#anyNetwork = false;
      this.#networkPromise = null;
    }
    this.#lastBlockNumber = -1;
    this.#performCache = new Map;
    this.#subs = new Map;
    this.#plugins = new Map;
    this.#pausedState = null;
    this.#destroyed = false;
    this.#nextTimer = 1;
    this.#timers = new Map;
    this.#disableCcipRead = false;
  }
  get pollingInterval() {
    return this.#options.pollingInterval;
  }
  get provider() {
    return this;
  }
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.connect(this));
    return this;
  }
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  get disableCcipRead() {
    return this.#disableCcipRead;
  }
  set disableCcipRead(value15) {
    this.#disableCcipRead = !!value15;
  }
  async#perform(req) {
    const timeout = this.#options.cacheTimeout;
    if (timeout < 0) {
      return await this._perform(req);
    }
    const tag = getTag(req.method, req);
    let perform = this.#performCache.get(tag);
    if (!perform) {
      perform = this._perform(req);
      this.#performCache.set(tag, perform);
      setTimeout(() => {
        if (this.#performCache.get(tag) === perform) {
          this.#performCache.delete(tag);
        }
      }, timeout);
    }
    return await perform;
  }
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data12 = calldata.toLowerCase();
    const errorMessages = [];
    for (let i3 = 0;i3 < urls.length; i3++) {
      const url = urls[i3];
      const href = url.replace("{sender}", sender).replace("{data}", data12);
      const request27 = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request27.body = { data: data12, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request: request27, index: i3, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request27.send();
      } catch (error23) {
        errorMessages.push(error23.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request: request27, result: { error: error23 } });
        continue;
      }
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request: request27, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request: request27, result });
      } catch (error23) {
      }
      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m3) => JSON.stringify(m3)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  _wrapBlock(value15, network2) {
    return new Block(formatBlock(value15), this);
  }
  _wrapLog(value15, network2) {
    return new Log(formatLog(value15), this);
  }
  _wrapTransactionReceipt(value15, network2) {
    return new TransactionReceipt(formatTransactionReceipt(value15), this);
  }
  _wrapTransactionResponse(tx, network2) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  _detectNetwork() {
    assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  async _perform(req) {
    assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  async getBlockNumber() {
    const blockNumber = getNumber(await this.#perform({ method: "getBlockNumber" }), "%response");
    if (this.#lastBlockNumber >= 0) {
      this.#lastBlockNumber = blockNumber;
    }
    return blockNumber;
  }
  _getAddress(address19) {
    return resolveAddress(address19, this);
  }
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (this.#lastBlockNumber >= 0) {
        return toQuantity(this.#lastBlockNumber + blockTag);
      }
      return this.getBlockNumber().then((b3) => toQuantity(b3 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  _getFilter(filter2) {
    const topics = (filter2.topics || []).map((t3) => {
      if (t3 == null) {
        return null;
      }
      if (Array.isArray(t3)) {
        return concisify(t3.map((t4) => t4.toLowerCase()));
      }
      return t3.toLowerCase();
    });
    const blockHash = "blockHash" in filter2 ? filter2.blockHash : undefined;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address20 = undefined;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address20 = _address[0];
          break;
        default:
          _address.sort();
          address20 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter3 = {};
      if (address20) {
        filter3.address = address20;
      }
      if (topics.length) {
        filter3.topics = topics;
      }
      if (fromBlock2) {
        filter3.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter3.toBlock = toBlock2;
      }
      if (blockHash) {
        filter3.blockHash = blockHash;
      }
      return filter3;
    };
    let address19 = [];
    if (filter2.address) {
      if (Array.isArray(filter2.address)) {
        for (const addr of filter2.address) {
          address19.push(this._getAddress(addr));
        }
      } else {
        address19.push(this._getAddress(filter2.address));
      }
    }
    let fromBlock = undefined;
    if ("fromBlock" in filter2) {
      fromBlock = this._getBlockTag(filter2.fromBlock);
    }
    let toBlock = undefined;
    if ("toBlock" in filter2) {
      toBlock = this._getBlockTag(filter2.toBlock);
    }
    if (address19.filter((a) => typeof a !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address19), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address19, fromBlock, toBlock);
  }
  _getTransactionRequest(_request) {
    const request27 = copyRequest(_request);
    const promises3 = [];
    ["to", "from"].forEach((key) => {
      if (request27[key] == null) {
        return;
      }
      const addr = resolveAddress(request27[key], this);
      if (isPromise(addr)) {
        promises3.push(async function() {
          request27[key] = await addr;
        }());
      } else {
        request27[key] = addr;
      }
    });
    if (request27.blockTag != null) {
      const blockTag = this._getBlockTag(request27.blockTag);
      if (isPromise(blockTag)) {
        promises3.push(async function() {
          request27.blockTag = await blockTag;
        }());
      } else {
        request27.blockTag = blockTag;
      }
    }
    if (promises3.length) {
      return async function() {
        await Promise.all(promises3);
        return request27;
      }();
    }
    return request27;
  }
  async getNetwork() {
    if (this.#networkPromise == null) {
      const detectNetwork = (async () => {
        try {
          const network2 = await this._detectNetwork();
          this.emit("network", network2, null);
          return network2;
        } catch (error23) {
          if (this.#networkPromise === detectNetwork) {
            this.#networkPromise = null;
          }
          throw error23;
        }
      })();
      this.#networkPromise = detectNetwork;
      return (await detectNetwork).clone();
    }
    const networkPromise = this.#networkPromise;
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
    ]);
    if (expected.chainId !== actual.chainId) {
      if (this.#anyNetwork) {
        this.emit("network", actual, expected);
        if (this.#networkPromise === networkPromise) {
          this.#networkPromise = Promise.resolve(actual);
        }
      } else {
        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network2 = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: this.#getBlock("latest", false),
        gasPrice: (async () => {
          try {
            const value15 = await this.#perform({ method: "getGasPrice" });
            return getBigInt(value15, "%response");
          } catch (error23) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value15 = await this.#perform({ method: "getPriorityFee" });
            return getBigInt(value15, "%response");
          } catch (error23) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network2);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_23 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network2.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise(tx)) {
      tx = await tx;
    }
    return getBigInt(await this.#perform({
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async#call(tx, blockTag, attempt) {
    assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
    });
    const transaction8 = copyRequest(tx);
    try {
      return hexlify(await this._perform({ method: "call", transaction: transaction8, blockTag }));
    } catch (error23) {
      if (!this.disableCcipRead && isCallException(error23) && error23.data && attempt >= 0 && blockTag === "latest" && transaction8.to != null && dataSlice(error23.data, 0, 4) === "0x556f1830") {
        const data12 = error23.data;
        const txSender = await resolveAddress(transaction8.to, this);
        let ccipArgs;
        try {
          ccipArgs = parseOffchainLookup(dataSlice(error23.data, 4));
        } catch (error24) {
          assert(false, error24.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction: transaction8,
            info: { data: data12 }
          });
        }
        assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
          action: "call",
          data: data12,
          reason: "OffchainLookup",
          transaction: transaction8,
          invocation: null,
          revert: {
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            name: "OffchainLookup",
            args: ccipArgs.errorArgs
          }
        });
        const ccipResult = await this.ccipReadFetch(transaction8, ccipArgs.calldata, ccipArgs.urls);
        assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction: transaction8,
          info: { data: error23.data, errorArgs: ccipArgs.errorArgs }
        });
        const tx2 = {
          to: txSender,
          data: concat2([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
        };
        this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
        try {
          const result = await this.#call(tx2, blockTag, attempt + 1);
          this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
          return result;
        } catch (error24) {
          this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error24 });
          throw error24;
        }
      }
      throw error23;
    }
  }
  async#checkNetwork(promise5) {
    const { value: value15 } = await resolveProperties({
      network: this.getNetwork(),
      value: promise5
    });
    return value15;
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  async#getAccountValue(request27, _address, _blockTag) {
    let address19 = this._getAddress(_address);
    let blockTag = this._getBlockTag(_blockTag);
    if (typeof address19 !== "string" || typeof blockTag !== "string") {
      [address19, blockTag] = await Promise.all([address19, blockTag]);
    }
    return await this.#checkNetwork(this.#perform(Object.assign(request27, { address: address19, blockTag })));
  }
  async getBalance(address19, blockTag) {
    return getBigInt(await this.#getAccountValue({ method: "getBalance" }, address19, blockTag), "%response");
  }
  async getTransactionCount(address19, blockTag) {
    return getNumber(await this.#getAccountValue({ method: "getTransactionCount" }, address19, blockTag), "%response");
  }
  async getCode(address19, blockTag) {
    return hexlify(await this.#getAccountValue({ method: "getCode" }, address19, blockTag));
  }
  async getStorage(address19, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await this.#getAccountValue({ method: "getStorage", position }, address19, blockTag));
  }
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash12, network: network2 } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash12) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network2).replaceableTransaction(blockNumber);
  }
  async#getBlock(block, includeTransactions) {
    if (isHexString(block, 32)) {
      return await this.#perform({
        method: "getBlock",
        blockHash: block,
        includeTransactions
      });
    }
    let blockTag = this._getBlockTag(block);
    if (typeof blockTag !== "string") {
      blockTag = await blockTag;
    }
    return await this.#perform({
      method: "getBlock",
      blockTag,
      includeTransactions
    });
  }
  async getBlock(block, prefetchTxs) {
    const { network: network2, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#getBlock(block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network2);
  }
  async getTransaction(hash12) {
    const { network: network2, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransaction", hash: hash12 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network2);
  }
  async getTransactionReceipt(hash12) {
    const { network: network2, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransactionReceipt", hash: hash12 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await this.#perform({ method: "getTransaction", hash: hash12 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network2);
  }
  async getTransactionResult(hash12) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: this.#perform({ method: "getTransactionResult", hash: hash12 })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  async getLogs(_filter2) {
    let filter2 = this._getFilter(_filter2);
    if (isPromise(filter2)) {
      filter2 = await filter2;
    }
    const { network: network2, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getLogs", filter: filter2 })
    });
    return params.map((p) => this._wrapLog(p, network2));
  }
  _getProvider(chainId) {
    assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address19) {
    address19 = getAddress(address19);
    const node = namehash(address19.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check11 = await this.resolveName(name);
      if (check11 !== address19) {
        return null;
      }
      return name;
    } catch (error23) {
      if (isError(error23, "BAD_DATA") && error23.value === "0x") {
        return null;
      }
      if (isError(error23, "CALL_EXCEPTION")) {
        return null;
      }
      throw error23;
    }
    return null;
  }
  async waitForTransaction(hash12, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash12);
    }
    return new Promise(async (resolve, reject2) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash12);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error23) {
          console.log("EEE", error23);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject2(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  _clearTimeout(timerId) {
    const timer = this.#timers.get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    this.#timers.delete(timerId);
  }
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = this.#nextTimer++;
    const func = () => {
      this.#timers.delete(timerId);
      _func();
    };
    if (this.paused) {
      this.#timers.set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      this.#timers.set(timerId, { timer, func, time: getTime2() });
    }
    return timerId;
  }
  _forEachSubscriber(func) {
    for (const sub of this.#subs.values()) {
      func(sub.subscriber);
    }
  }
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub.type);
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of this.#subs.values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (this.#pausedState != null) {
          newSub.pause(this.#pausedState);
        }
        break;
      }
    }
  }
  async#hasSub(event, emitArgs) {
    let sub = await getSubscription(event, this);
    if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
      sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
    }
    return this.#subs.get(sub.tag) || null;
  }
  async#getSub(event) {
    const subscription = await getSubscription(event, this);
    const tag = subscription.tag;
    let sub = this.#subs.get(tag);
    if (!sub) {
      const subscriber = this._getSubscriber(subscription);
      const addressableMap = new WeakMap;
      const nameMap = new Map;
      sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
      this.#subs.set(tag, sub);
    }
    return sub;
  }
  async on(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub = await this.#hasSub(event, args);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once: once2 }) => {
      const payload = new EventPayload(this, once2 ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error23) {
      }
      return !once2;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners } of this.#subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of this.#subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await this.#hasSub(event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index2 = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index2 >= 0) {
        sub.listeners.splice(index2, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await this.#getSub(event);
      if (started) {
        subscriber.stop();
      }
      this.#subs.delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of this.#subs) {
        if (started) {
          subscriber.stop();
        }
        this.#subs.delete(tag);
      }
    }
    return this;
  }
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  get destroyed() {
    return this.#destroyed;
  }
  destroy() {
    this.removeAllListeners();
    for (const timerId of this.#timers.keys()) {
      this._clearTimeout(timerId);
    }
    this.#destroyed = true;
  }
  get paused() {
    return this.#pausedState != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  pause(dropWhilePaused) {
    this.#lastBlockNumber = -1;
    if (this.#pausedState != null) {
      if (this.#pausedState == !!dropWhilePaused) {
        return;
      }
      assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s3) => s3.pause(dropWhilePaused));
    this.#pausedState = !!dropWhilePaused;
    for (const timer of this.#timers.values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime2() - timer.time;
    }
  }
  resume() {
    if (this.#pausedState == null) {
      return;
    }
    this._forEachSubscriber((s3) => s3.resume());
    this.#pausedState = null;
    for (const timer of this.#timers.values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime2();
      setTimeout(timer.func, timeout);
    }
  }
}
var empty2 = new Uint8Array([]);
var zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
// node_modules/ethers/lib.esm/providers/abstract-signer.js
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address20, from2]) => {
      assertArgument(address20.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address20;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}

class AbstractSigner {
  provider;
  constructor(provider5) {
    defineProperties(this, { provider: provider5 || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider5 = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network2 = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network2.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network2.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider5.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider5.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          if (pop.authorizationList && pop.authorizationList.length) {
            pop.type = 4;
          } else {
            pop.type = 2;
          }
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async populateAuthorization(_auth) {
    const auth3 = Object.assign({}, _auth);
    if (auth3.chainId == null) {
      auth3.chainId = (await checkProvider(this, "getNetwork").getNetwork()).chainId;
    }
    if (auth3.nonce == null) {
      auth3.nonce = await this.getNonce();
    }
    return auth3;
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider5 = checkProvider(this, "resolveName");
    return await provider5.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider5 = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider5.broadcastTransaction(await this.signTransaction(txObj));
  }
  authorize(authorization2) {
    assert(false, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
}

class VoidSigner extends AbstractSigner {
  address;
  constructor(address20, provider5) {
    super(provider5);
    defineProperties(this, { address: address20 });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider5) {
    return new VoidSigner(this.address, provider5);
  }
  #throwUnsupported(suffix, operation) {
    assert(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
  }
  async signTransaction(tx) {
    this.#throwUnsupported("transactions", "signTransaction");
  }
  async signMessage(message) {
    this.#throwUnsupported("messages", "signMessage");
  }
  async signTypedData(domain, types, value15) {
    this.#throwUnsupported("typed-data", "signTypedData");
  }
}
// node_modules/ethers/lib.esm/providers/community.js
function showThrottleMessage(service) {
  if (shown.has(service)) {
    return;
  }
  shown.add(service);
  console.log("========= NOTICE =========");
  console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.org/api-keys/");
  console.log("==========================");
}
var shown = new Set;
// node_modules/ethers/lib.esm/providers/subscriber-filterid.js
function copy3(obj) {
  return JSON.parse(JSON.stringify(obj));
}

class FilterIdSubscriber {
  #provider;
  #filterIdPromise;
  #poller;
  #running;
  #network;
  #hault;
  constructor(provider5) {
    this.#provider = provider5;
    this.#filterIdPromise = null;
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#network = null;
    this.#hault = false;
  }
  _subscribe(provider5) {
    throw new Error("subclasses must override this");
  }
  _emitResults(provider5, result) {
    throw new Error("subclasses must override this");
  }
  _recover(provider5) {
    throw new Error("subclasses must override this");
  }
  async#poll(blockNumber) {
    try {
      if (this.#filterIdPromise == null) {
        this.#filterIdPromise = this._subscribe(this.#provider);
      }
      let filterId = null;
      try {
        filterId = await this.#filterIdPromise;
      } catch (error23) {
        if (!isError(error23, "UNSUPPORTED_OPERATION") || error23.operation !== "eth_newFilter") {
          throw error23;
        }
      }
      if (filterId == null) {
        this.#filterIdPromise = null;
        this.#provider._recoverSubscriber(this, this._recover(this.#provider));
        return;
      }
      const network2 = await this.#provider.getNetwork();
      if (!this.#network) {
        this.#network = network2;
      }
      if (this.#network.chainId !== network2.chainId) {
        throw new Error("chaid changed");
      }
      if (this.#hault) {
        return;
      }
      const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
      await this._emitResults(this.#provider, result);
    } catch (error23) {
      console.log("@TODO", error23);
    }
    this.#provider.once("block", this.#poller);
  }
  #teardown() {
    const filterIdPromise = this.#filterIdPromise;
    if (filterIdPromise) {
      this.#filterIdPromise = null;
      filterIdPromise.then((filterId) => {
        if (this.#provider.destroyed) {
          return;
        }
        this.#provider.send("eth_uninstallFilter", [filterId]);
      });
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#hault = true;
    this.#teardown();
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#teardown();
    }
    this.#provider.off("block", this.#poller);
  }
  resume() {
    this.start();
  }
}

class FilterIdEventSubscriber extends FilterIdSubscriber {
  #event;
  constructor(provider5, filter2) {
    super(provider5);
    this.#event = copy3(filter2);
  }
  _recover(provider5) {
    return new PollingEventSubscriber(provider5, this.#event);
  }
  async _subscribe(provider5) {
    const filterId = await provider5.send("eth_newFilter", [this.#event]);
    return filterId;
  }
  async _emitResults(provider5, results) {
    for (const result of results) {
      provider5.emit(this.#event, provider5._wrapLog(result, provider5._network));
    }
  }
}

class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider5) {
    return await provider5.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider5, results) {
    for (const result of results) {
      provider5.emit("pending", result);
    }
  }
}

// node_modules/ethers/lib.esm/providers/provider-jsonrpc.js
function deepCopy(value15) {
  if (value15 == null || Primitive.indexOf(typeof value15) >= 0) {
    return value15;
  }
  if (typeof value15.getAddress === "function") {
    return value15;
  }
  if (Array.isArray(value15)) {
    return value15.map(deepCopy);
  }
  if (typeof value15 === "object") {
    return Object.keys(value15).reduce((accum, key) => {
      accum[key] = value15[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value15} (${typeof value15})`);
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value15) {
  if (value15) {
    return value15.toLowerCase();
  }
  return value15;
}
function isPollable(value15) {
  return value15 && typeof value15.pollingInterval === "number";
}
function spelunkData(value15) {
  if (value15 == null) {
    return null;
  }
  if (typeof value15.message === "string" && value15.message.match(/revert/i) && isHexString(value15.data)) {
    return { message: value15.message, data: value15.data };
  }
  if (typeof value15 === "object") {
    for (const key in value15) {
      const result = spelunkData(value15[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value15 === "string") {
    try {
      return spelunkData(JSON.parse(value15));
    } catch (error23) {
    }
  }
  return null;
}
function _spelunkMessage(value15, result) {
  if (value15 == null) {
    return;
  }
  if (typeof value15.message === "string") {
    result.push(value15.message);
  }
  if (typeof value15 === "object") {
    for (const key in value15) {
      _spelunkMessage(value15[key], result);
    }
  }
  if (typeof value15 === "string") {
    try {
      return _spelunkMessage(JSON.parse(value15), result);
    } catch (error23) {
    }
  }
}
function spelunkMessage(value15) {
  const result = [];
  _spelunkMessage(value15, result);
  return result;
}
var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
var defaultOptions3 = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4000
};

class JsonRpcSigner extends AbstractSigner {
  address;
  constructor(provider5, address21) {
    super(provider5);
    address21 = getAddress(address21);
    defineProperties(this, { address: address21 });
  }
  connect(provider5) {
    assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises3 = [];
    if (tx.from) {
      const _from = tx.from;
      promises3.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises3.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to = tx.to;
      promises3.push((async () => {
        tx.to = await resolveAddress(_to, this.provider);
      })());
    }
    if (promises3.length) {
      await Promise.all(promises3);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash13 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject2) => {
      const timeouts = [1000, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash13);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error23) {
          if (isError(error23, "CANCELLED") || isError(error23, "BAD_DATA") || isError(error23, "NETWORK_ERROR") || isError(error23, "UNSUPPORTED_OPERATION")) {
            if (error23.info == null) {
              error23.info = {};
            }
            error23.info.sendTransactionHash = hash13;
            reject2(error23);
            return;
          }
          if (isError(error23, "INVALID_ARGUMENT")) {
            invalids++;
            if (error23.info == null) {
              error23.info = {};
            }
            error23.info.sendTransactionHash = hash13;
            if (invalids > 10) {
              reject2(error23);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: error23 }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4000);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types, _value) {
    const value15 = deepCopy(_value);
    const populated = await TypedDataEncoder.resolveNames(domain, types, value15, async (value16) => {
      const address21 = await resolveAddress(value16);
      assertArgument(address21 != null, "TypedData does not support null address", "value", value16);
      return address21;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}

class JsonRpcApiProvider extends AbstractProvider {
  #options;
  #nextId;
  #payloads;
  #drainTimer;
  #notReady;
  #network;
  #pendingDetectNetwork;
  #scheduleDrain() {
    if (this.#drainTimer) {
      return;
    }
    const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    this.#drainTimer = setTimeout(() => {
      this.#drainTimer = null;
      const payloads = this.#payloads;
      this.#payloads = [];
      while (payloads.length) {
        const batch = [payloads.shift()];
        while (payloads.length) {
          if (batch.length === this.#options.batchMaxCount) {
            break;
          }
          batch.push(payloads.shift());
          const bytes5 = JSON.stringify(batch.map((p) => p.payload));
          if (bytes5.length > this.#options.batchMaxSize) {
            payloads.unshift(batch.pop());
            break;
          }
        }
        (async () => {
          const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
          this.emit("debug", { action: "sendRpcPayload", payload });
          try {
            const result = await this._send(payload);
            this.emit("debug", { action: "receiveRpcResult", result });
            for (const { resolve, reject: reject2, payload: payload2 } of batch) {
              if (this.destroyed) {
                reject2(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                continue;
              }
              const resp = result.filter((r) => r.id === payload2.id)[0];
              if (resp == null) {
                const error23 = makeError("missing response for request", "BAD_DATA", {
                  value: result,
                  info: { payload: payload2 }
                });
                this.emit("error", error23);
                reject2(error23);
                continue;
              }
              if ("error" in resp) {
                reject2(this.getRpcError(payload2, resp));
                continue;
              }
              resolve(resp.result);
            }
          } catch (error23) {
            this.emit("debug", { action: "receiveRpcError", error: error23 });
            for (const { reject: reject2 } of batch) {
              reject2(error23);
            }
          }
        })();
      }
    }, stallTime);
  }
  constructor(network3, options) {
    super(network3, options);
    this.#nextId = 1;
    this.#options = Object.assign({}, defaultOptions3, options || {});
    this.#payloads = [];
    this.#drainTimer = null;
    this.#network = null;
    this.#pendingDetectNetwork = null;
    {
      let resolve = null;
      const promise5 = new Promise((_resolve) => {
        resolve = _resolve;
      });
      this.#notReady = { promise: promise5, resolve };
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network3 !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network3 != null) {
        this.#network = Network.from(network3);
      }
    } else if (staticNetwork) {
      assertArgument(network3 == null || staticNetwork.matches(network3), "staticNetwork MUST match network object", "options", options);
      this.#network = staticNetwork;
    }
  }
  _getOption(key) {
    return this.#options[key];
  }
  get _network() {
    assert(this.#network, "network is not available yet", "NETWORK_ERROR");
    return this.#network;
  }
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: undefined })
            });
          }
        }
      }
    }
    const request27 = this.getRpcRequest(req);
    if (request27 != null) {
      return await this.send(request27.method, request27.args);
    }
    return super._perform(req);
  }
  async _detectNetwork() {
    const network3 = this._getOption("staticNetwork");
    if (network3) {
      if (network3 === true) {
        if (this.#network) {
          return this.#network;
        }
      } else {
        return network3;
      }
    }
    if (this.#pendingDetectNetwork) {
      return await this.#pendingDetectNetwork;
    }
    if (this.ready) {
      this.#pendingDetectNetwork = (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          this.#pendingDetectNetwork = null;
          return result;
        } catch (error23) {
          this.#pendingDetectNetwork = null;
          throw error23;
        }
      })();
      return await this.#pendingDetectNetwork;
    }
    this.#pendingDetectNetwork = (async () => {
      const payload = {
        id: this.#nextId++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        this.#pendingDetectNetwork = null;
      } catch (error23) {
        this.#pendingDetectNetwork = null;
        this.emit("debug", { action: "receiveRpcError", error: error23 });
        throw error23;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })();
    return await this.#pendingDetectNetwork;
  }
  _start() {
    if (this.#notReady == null || this.#notReady.resolve == null) {
      return;
    }
    this.#notReady.resolve();
    this.#notReady = null;
    (async () => {
      while (this.#network == null && !this.destroyed) {
        try {
          this.#network = await this._detectNetwork();
        } catch (error23) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: error23 } }));
          await stall(1000);
        }
      }
      this.#scheduleDrain();
    })();
  }
  async _waitUntilReady() {
    if (this.#notReady == null) {
      return;
    }
    return await this.#notReady.promise;
  }
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  get ready() {
    return this.#notReady == null;
  }
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result[key] = hexlify(tx[key]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h) => h.toLowerCase());
    }
    if (tx.authorizationList) {
      result["authorizationList"] = tx.authorizationList.map((_a2) => {
        const a = authorizationify(_a2);
        return {
          address: a.address,
          nonce: toQuantity(a.nonce),
          chainId: toQuantity(a.chainId),
          yParity: toQuantity(a.signature.yParity),
          r: toQuantity(a.signature.r),
          s: toQuantity(a.signature.s)
        };
      });
    }
    return result;
  }
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  getRpcError(payload, _error) {
    const { method } = payload;
    const { error: error23 } = _error;
    if (method === "eth_estimateGas" && error23.message) {
      const msg = error23.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error: error23 }
        });
      } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", {
          transaction: payload.params[0],
          info: { payload, error: error23 }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error23);
      const e = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e.info = { error: error23, payload };
      return e;
    }
    const message = JSON.stringify(spelunkMessage(error23));
    if (typeof error23.message === "string" && error23.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error: error23 }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction10 = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: transaction10,
          info: { error: error23 }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction: transaction10, info: { error: error23 } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: transaction10, info: { error: error23 } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction: transaction10, info: { error: error23 } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error23 && error23.details && error23.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error: error23, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error: error23, payload });
  }
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id3 = this.#nextId++;
    const promise5 = new Promise((resolve, reject2) => {
      this.#payloads.push({
        resolve,
        reject: reject2,
        payload: { method, params, id: id3, jsonrpc: "2.0" }
      });
    });
    this.#scheduleDrain();
    return promise5;
  }
  async getSigner(address21) {
    if (address21 == null) {
      address21 = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address21 === "number") {
      const accounts2 = await accountsPromise;
      if (address21 >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address21]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address21 = getAddress(address21);
    for (const account of accounts) {
      if (getAddress(account) === address21) {
        return new JsonRpcSigner(this, address21);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a) => new JsonRpcSigner(this, a));
  }
  destroy() {
    if (this.#drainTimer) {
      clearTimeout(this.#drainTimer);
      this.#drainTimer = null;
    }
    for (const { payload, reject: reject2 } of this.#payloads) {
      reject2(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    this.#payloads = [];
    super.destroy();
  }
}

class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  #pollingInterval;
  constructor(network3, options) {
    super(network3, options);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions3.pollingInterval;
    }
    this.#pollingInterval = pollingInterval;
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = this.#pollingInterval;
    }
    return subscriber;
  }
  get pollingInterval() {
    return this.#pollingInterval;
  }
  set pollingInterval(value15) {
    if (!Number.isInteger(value15) || value15 < 0) {
      throw new Error("invalid interval");
    }
    this.#pollingInterval = value15;
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = this.#pollingInterval;
      }
    });
  }
}

class JsonRpcProvider extends JsonRpcApiPollingProvider {
  #connect;
  constructor(url, network3, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network3, options);
    if (typeof url === "string") {
      this.#connect = new FetchRequest(url);
    } else {
      this.#connect = url.clone();
    }
  }
  _getConnection() {
    return this.#connect.clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request27 = this._getConnection();
    request27.body = JSON.stringify(payload);
    request27.setHeader("content-type", "application/json");
    const response4 = await request27.send();
    response4.assertOk();
    let resp = response4.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}

// node_modules/ethers/lib.esm/providers/provider-ankr.js
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "rpc.ankr.com/eth";
    case "goerli":
      return "rpc.ankr.com/eth_goerli";
    case "sepolia":
      return "rpc.ankr.com/eth_sepolia";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum";
    case "base":
      return "rpc.ankr.com/base";
    case "base-goerli":
      return "rpc.ankr.com/base_goerli";
    case "base-sepolia":
      return "rpc.ankr.com/base_sepolia";
    case "bnb":
      return "rpc.ankr.com/bsc";
    case "bnbt":
      return "rpc.ankr.com/bsc_testnet_chapel";
    case "matic":
      return "rpc.ankr.com/polygon";
    case "matic-mumbai":
      return "rpc.ankr.com/polygon_mumbai";
    case "optimism":
      return "rpc.ankr.com/optimism";
    case "optimism-goerli":
      return "rpc.ankr.com/optimism_testnet";
    case "optimism-sepolia":
      return "rpc.ankr.com/optimism_sepolia";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";

class AnkrProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network4 = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const options = { polling: true, staticNetwork: network4 };
    const request27 = AnkrProvider.getRequest(network4, apiKey);
    super(request27, network4, options);
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new AnkrProvider(chainId, this.apiKey);
    } catch (error23) {
    }
    return super._getProvider(chainId);
  }
  static getRequest(network4, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const request27 = new FetchRequest(`https://${getHost(network4.name)}/${apiKey}`);
    request27.allowGzip = true;
    if (apiKey === defaultApiKey) {
      request27.retryFunc = async (request28, response4, attempt) => {
        showThrottleMessage("AnkrProvider");
        return true;
      };
    }
    return request27;
  }
  getRpcError(payload, error23) {
    if (payload.method === "eth_sendRawTransaction") {
      if (error23 && error23.error && error23.error.message === "INTERNAL_ERROR: could not replace existing tx") {
        error23.error.message = "replacement transaction underpriced";
      }
    }
    return super.getRpcError(payload, error23);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
}

// node_modules/ethers/lib.esm/providers/provider-alchemy.js
function getHost2(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.alchemyapi.io";
    case "goerli":
      return "eth-goerli.g.alchemy.com";
    case "sepolia":
      return "eth-sepolia.g.alchemy.com";
    case "arbitrum":
      return "arb-mainnet.g.alchemy.com";
    case "arbitrum-goerli":
      return "arb-goerli.g.alchemy.com";
    case "arbitrum-sepolia":
      return "arb-sepolia.g.alchemy.com";
    case "base":
      return "base-mainnet.g.alchemy.com";
    case "base-goerli":
      return "base-goerli.g.alchemy.com";
    case "base-sepolia":
      return "base-sepolia.g.alchemy.com";
    case "matic":
      return "polygon-mainnet.g.alchemy.com";
    case "matic-amoy":
      return "polygon-amoy.g.alchemy.com";
    case "matic-mumbai":
      return "polygon-mumbai.g.alchemy.com";
    case "optimism":
      return "opt-mainnet.g.alchemy.com";
    case "optimism-goerli":
      return "opt-goerli.g.alchemy.com";
    case "optimism-sepolia":
      return "opt-sepolia.g.alchemy.com";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var defaultApiKey2 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";

class AlchemyProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network5 = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const request27 = AlchemyProvider.getRequest(network5, apiKey);
    super(request27, network5, { staticNetwork: network5 });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new AlchemyProvider(chainId, this.apiKey);
    } catch (error23) {
    }
    return super._getProvider(chainId);
  }
  async _perform(req) {
    if (req.method === "getTransactionResult") {
      const { trace, tx } = await resolveProperties({
        trace: this.send("trace_transaction", [req.hash]),
        tx: this.getTransaction(req.hash)
      });
      if (trace == null || tx == null) {
        return null;
      }
      let data12;
      let error23 = false;
      try {
        data12 = trace[0].result.output;
        error23 = trace[0].error === "Reverted";
      } catch (error24) {
      }
      if (data12) {
        assert(!error23, "an error occurred during transaction executions", "CALL_EXCEPTION", {
          action: "getTransactionResult",
          data: data12,
          reason: null,
          transaction: tx,
          invocation: null,
          revert: null
        });
        return data12;
      }
      assert(false, "could not parse trace result", "BAD_DATA", { value: trace });
    }
    return await super._perform(req);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getRequest(network5, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const request27 = new FetchRequest(`https://${getHost2(network5.name)}/v2/${apiKey}`);
    request27.allowGzip = true;
    if (apiKey === defaultApiKey2) {
      request27.retryFunc = async (request28, response4, attempt) => {
        showThrottleMessage("alchemy");
        return true;
      };
    }
    return request27;
  }
}

// node_modules/ethers/lib.esm/providers/provider-chainstack.js
function getApiKey(name) {
  switch (name) {
    case "mainnet":
      return "39f1d67cedf8b7831010a665328c9197";
    case "arbitrum":
      return "0550c209db33c3abf4cc927e1e18cea1";
    case "bnb":
      return "98b5a77e531614387366f6fc5da097f8";
    case "matic":
      return "cd9d4d70377471aa7c142ec4a4205249";
  }
  assertArgument(false, "unsupported network", "network", name);
}
function getHost3(name) {
  switch (name) {
    case "mainnet":
      return "ethereum-mainnet.core.chainstack.com";
    case "arbitrum":
      return "arbitrum-mainnet.core.chainstack.com";
    case "bnb":
      return "bsc-mainnet.core.chainstack.com";
    case "matic":
      return "polygon-mainnet.core.chainstack.com";
  }
  assertArgument(false, "unsupported network", "network", name);
}

class ChainstackProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network6 = Network.from(_network);
    if (apiKey == null) {
      apiKey = getApiKey(network6.name);
    }
    const request27 = ChainstackProvider.getRequest(network6, apiKey);
    super(request27, network6, { staticNetwork: network6 });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new ChainstackProvider(chainId, this.apiKey);
    } catch (error23) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.apiKey === getApiKey(this._network.name);
  }
  static getRequest(network6, apiKey) {
    if (apiKey == null) {
      apiKey = getApiKey(network6.name);
    }
    const request27 = new FetchRequest(`https://${getHost3(network6.name)}/${apiKey}`);
    request27.allowGzip = true;
    if (apiKey === getApiKey(network6.name)) {
      request27.retryFunc = async (request28, response4, attempt) => {
        showThrottleMessage("ChainstackProvider");
        return true;
      };
    }
    return request27;
  }
}

// node_modules/ethers/lib.esm/providers/provider-cloudflare.js
class CloudflareProvider extends JsonRpcProvider {
  constructor(_network) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network7 = Network.from(_network);
    assertArgument(network7.name === "mainnet", "unsupported network", "network", _network);
    super("https://cloudflare-eth.com/", network7, { staticNetwork: network7 });
  }
}

// node_modules/ethers/lib.esm/providers/provider-etherscan.js
function isPromise2(value15) {
  return value15 && typeof value15.then === "function";
}
var THROTTLE = 2000;
var EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";

class EtherscanPlugin extends NetworkPlugin {
  baseUrl;
  constructor(baseUrl) {
    super(EtherscanPluginId);
    defineProperties(this, { baseUrl });
  }
  clone() {
    return new EtherscanPlugin(this.baseUrl);
  }
}
var skipKeys = ["enableCcipRead"];
var nextId = 1;

class EtherscanProvider extends AbstractProvider {
  network;
  apiKey;
  #plugin;
  constructor(_network, _apiKey) {
    const apiKey = _apiKey != null ? _apiKey : null;
    super();
    const network8 = Network.from(_network);
    this.#plugin = network8.getPlugin(EtherscanPluginId);
    defineProperties(this, { apiKey, network: network8 });
  }
  getBaseUrl() {
    if (this.#plugin) {
      return this.#plugin.baseUrl;
    }
    switch (this.network.name) {
      case "mainnet":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "holesky":
        return "https://api-holesky.etherscan.io";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "base":
        return "https://api.basescan.org";
      case "base-sepolia":
        return "https://api-sepolia.basescan.org";
      case "bnb":
        return "https://api.bscscan.com";
      case "bnbt":
        return "https://api-testnet.bscscan.com";
      case "matic":
        return "https://api.polygonscan.com";
      case "matic-amoy":
        return "https://api-amoy.polygonscan.com";
      case "matic-mumbai":
        return "https://api-testnet.polygonscan.com";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    assertArgument(false, "unsupported network", "network", this.network);
  }
  getUrl(module, params) {
    let query = Object.keys(params).reduce((accum, key) => {
      const value15 = params[key];
      if (value15 != null) {
        accum += `&${key}=${value15}`;
      }
      return accum;
    }, "");
    if (this.apiKey) {
      query += `&apikey=${this.apiKey}`;
    }
    return `https://api.etherscan.io/v2/api?chainid=${this.network.chainId}&module=${module}${query}`;
  }
  getPostUrl() {
    return `https://api.etherscan.io/v2/api?chainid=${this.network.chainId}`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    params.chainid = this.network.chainId;
    return params;
  }
  async detectNetwork() {
    return this.network;
  }
  async fetch(module, params, post) {
    const id3 = nextId++;
    const url = post ? this.getPostUrl() : this.getUrl(module, params);
    const payload = post ? this.getPostData(module, params) : null;
    this.emit("debug", { action: "sendRequest", id: id3, url, payload });
    const request27 = new FetchRequest(url);
    request27.setThrottleParams({ slotInterval: 1000 });
    request27.retryFunc = (req, resp, attempt) => {
      if (this.isCommunityResource()) {
        showThrottleMessage("Etherscan");
      }
      return Promise.resolve(true);
    };
    request27.processFunc = async (request28, response5) => {
      const result2 = response5.hasBody() ? JSON.parse(toUtf8String(response5.body)) : {};
      const throttle = (typeof result2.result === "string" ? result2.result : "").toLowerCase().indexOf("rate limit") >= 0;
      if (module === "proxy") {
        if (result2 && result2.status == 0 && result2.message == "NOTOK" && throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "proxy-NOTOK", error: result2 });
          response5.throwThrottleError(result2.result, THROTTLE);
        }
      } else {
        if (throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "null result", error: result2.result });
          response5.throwThrottleError(result2.result, THROTTLE);
        }
      }
      return response5;
    };
    if (payload) {
      request27.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
      request27.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join("&");
    }
    const response4 = await request27.send();
    try {
      response4.assertOk();
    } catch (error23) {
      this.emit("debug", { action: "receiveError", id: id3, error: error23, reason: "assertOk" });
      assert(false, "response error", "SERVER_ERROR", { request: request27, response: response4 });
    }
    if (!response4.hasBody()) {
      this.emit("debug", { action: "receiveError", id: id3, error: "missing body", reason: "null body" });
      assert(false, "missing response", "SERVER_ERROR", { request: request27, response: response4 });
    }
    const result = JSON.parse(toUtf8String(response4.body));
    if (module === "proxy") {
      if (result.jsonrpc != "2.0") {
        this.emit("debug", { action: "receiveError", id: id3, result, reason: "invalid JSON-RPC" });
        assert(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request: request27, response: response4, info: { result } });
      }
      if (result.error) {
        this.emit("debug", { action: "receiveError", id: id3, result, reason: "JSON-RPC error" });
        assert(false, "error response", "SERVER_ERROR", { request: request27, response: response4, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result });
      return result.result;
    } else {
      if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        this.emit("debug", { action: "receiveRequest", id: id3, result });
        return result.result;
      }
      if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
        this.emit("debug", { action: "receiveError", id: id3, result });
        assert(false, "error response", "SERVER_ERROR", { request: request27, response: response4, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result });
      return result.result;
    }
  }
  _getTransactionPostData(transaction11) {
    const result = {};
    for (let key in transaction11) {
      if (skipKeys.indexOf(key) >= 0) {
        continue;
      }
      if (transaction11[key] == null) {
        continue;
      }
      let value15 = transaction11[key];
      if (key === "type" && value15 === 0) {
        continue;
      }
      if (key === "blockTag" && value15 === "latest") {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
        value15 = toQuantity(value15);
      } else if (key === "accessList") {
        value15 = "[" + accessListify(value15).map((set2) => {
          return `{address:"${set2.address}",storageKeys:["${set2.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else if (key === "blobVersionedHashes") {
        if (value15.length === 0) {
          continue;
        }
        assert(false, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
          operation: "_getTransactionPostData",
          info: { transaction: transaction11 }
        });
      } else {
        value15 = hexlify(value15);
      }
      result[key] = value15;
    }
    return result;
  }
  _checkError(req, error23, transaction11) {
    let message = "";
    if (isError(error23, "SERVER_ERROR")) {
      try {
        message = error23.info.result.error.message;
      } catch (e) {
      }
      if (!message) {
        try {
          message = error23.info.message;
        } catch (e) {
        }
      }
    }
    if (req.method === "estimateGas") {
      if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
        assert(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: req.transaction
        });
      }
    }
    if (req.method === "call" || req.method === "estimateGas") {
      if (message.match(/execution reverted/i)) {
        let data12 = "";
        try {
          data12 = error23.info.result.error.data;
        } catch (error24) {
        }
        const e = AbiCoder.getBuiltinCallException(req.method, req.transaction, data12);
        e.info = { request: req, error: error23 };
        throw e;
      }
    }
    if (message) {
      if (req.method === "broadcastTransaction") {
        const transaction12 = Transaction.from(req.signedTransaction);
        if (message.match(/replacement/i) && message.match(/underpriced/i)) {
          assert(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: transaction12
          });
        }
        if (message.match(/insufficient funds/)) {
          assert(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction: transaction12
          });
        }
        if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
          assert(false, "nonce has already been used", "NONCE_EXPIRED", {
            transaction: transaction12
          });
        }
      }
    }
    throw error23;
  }
  async _detectNetwork() {
    return this.network;
  }
  async _perform(req) {
    switch (req.method) {
      case "chainId":
        return this.network.chainId;
      case "getBlockNumber":
        return this.fetch("proxy", { action: "eth_blockNumber" });
      case "getGasPrice":
        return this.fetch("proxy", { action: "eth_gasPrice" });
      case "getPriorityFee":
        if (this.network.name === "mainnet") {
          return "1000000000";
        } else if (this.network.name === "optimism") {
          return "1000000";
        } else {
          throw new Error("fallback onto the AbstractProvider default");
        }
      case "getBalance":
        return this.fetch("account", {
          action: "balance",
          address: req.address,
          tag: req.blockTag
        });
      case "getTransactionCount":
        return this.fetch("proxy", {
          action: "eth_getTransactionCount",
          address: req.address,
          tag: req.blockTag
        });
      case "getCode":
        return this.fetch("proxy", {
          action: "eth_getCode",
          address: req.address,
          tag: req.blockTag
        });
      case "getStorage":
        return this.fetch("proxy", {
          action: "eth_getStorageAt",
          address: req.address,
          position: req.position,
          tag: req.blockTag
        });
      case "broadcastTransaction":
        return this.fetch("proxy", {
          action: "eth_sendRawTransaction",
          hex: req.signedTransaction
        }, true).catch((error23) => {
          return this._checkError(req, error23, req.signedTransaction);
        });
      case "getBlock":
        if ("blockTag" in req) {
          return this.fetch("proxy", {
            action: "eth_getBlockByNumber",
            tag: req.blockTag,
            boolean: req.includeTransactions ? "true" : "false"
          });
        }
        assert(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
          operation: "getBlock(blockHash)"
        });
      case "getTransaction":
        return this.fetch("proxy", {
          action: "eth_getTransactionByHash",
          txhash: req.hash
        });
      case "getTransactionReceipt":
        return this.fetch("proxy", {
          action: "eth_getTransactionReceipt",
          txhash: req.hash
        });
      case "call": {
        if (req.blockTag !== "latest") {
          throw new Error("EtherscanProvider does not support blockTag for call");
        }
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_call";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error23) {
          return this._checkError(req, error23, req.transaction);
        }
      }
      case "estimateGas": {
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_estimateGas";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error23) {
          return this._checkError(req, error23, req.transaction);
        }
      }
      default:
        break;
    }
    return super._perform(req);
  }
  async getNetwork() {
    return this.network;
  }
  async getEtherPrice() {
    if (this.network.name !== "mainnet") {
      return 0;
    }
    return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
  }
  async getContract(_address) {
    let address21 = this._getAddress(_address);
    if (isPromise2(address21)) {
      address21 = await address21;
    }
    try {
      const resp = await this.fetch("contract", {
        action: "getabi",
        address: address21
      });
      const abi5 = JSON.parse(resp);
      return new Contract(address21, abi5, this);
    } catch (error23) {
      return null;
    }
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}

// node_modules/ethers/lib.esm/providers/ws.js
import {WebSocket} from "ws";

// node_modules/ethers/lib.esm/providers/provider-socket.js
class SocketSubscriber {
  #provider;
  #filter;
  get filter() {
    return JSON.parse(this.#filter);
  }
  #filterId;
  #paused;
  #emitPromise;
  constructor(provider5, filter2) {
    this.#provider = provider5;
    this.#filter = JSON.stringify(filter2);
    this.#filterId = null;
    this.#paused = null;
    this.#emitPromise = null;
  }
  start() {
    this.#filterId = this.#provider.send("eth_subscribe", this.filter).then((filterId) => {
      this.#provider._register(filterId, this);
      return filterId;
    });
  }
  stop() {
    this.#filterId.then((filterId) => {
      if (this.#provider.destroyed) {
        return;
      }
      this.#provider.send("eth_unsubscribe", [filterId]);
    });
    this.#filterId = null;
  }
  pause(dropWhilePaused) {
    assert(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
    this.#paused = !!dropWhilePaused;
  }
  resume() {
    this.#paused = null;
  }
  _handleMessage(message) {
    if (this.#filterId == null) {
      return;
    }
    if (this.#paused === null) {
      let emitPromise = this.#emitPromise;
      if (emitPromise == null) {
        emitPromise = this._emit(this.#provider, message);
      } else {
        emitPromise = emitPromise.then(async () => {
          await this._emit(this.#provider, message);
        });
      }
      this.#emitPromise = emitPromise.then(() => {
        if (this.#emitPromise === emitPromise) {
          this.#emitPromise = null;
        }
      });
    }
  }
  async _emit(provider5, message) {
    throw new Error("sub-classes must implemente this; _emit");
  }
}

class SocketBlockSubscriber extends SocketSubscriber {
  constructor(provider5) {
    super(provider5, ["newHeads"]);
  }
  async _emit(provider5, message) {
    provider5.emit("block", parseInt(message.number));
  }
}

class SocketPendingSubscriber extends SocketSubscriber {
  constructor(provider5) {
    super(provider5, ["newPendingTransactions"]);
  }
  async _emit(provider5, message) {
    provider5.emit("pending", message);
  }
}

class SocketEventSubscriber extends SocketSubscriber {
  #logFilter;
  get logFilter() {
    return JSON.parse(this.#logFilter);
  }
  constructor(provider5, filter2) {
    super(provider5, ["logs", filter2]);
    this.#logFilter = JSON.stringify(filter2);
  }
  async _emit(provider5, message) {
    provider5.emit(this.logFilter, provider5._wrapLog(message, provider5._network));
  }
}

class SocketProvider extends JsonRpcApiProvider {
  #callbacks;
  #subs;
  #pending;
  constructor(network8, _options) {
    const options = Object.assign({}, _options != null ? _options : {});
    assertArgument(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options);
    options.batchMaxCount = 1;
    if (options.staticNetwork == null) {
      options.staticNetwork = true;
    }
    super(network8, options);
    this.#callbacks = new Map;
    this.#subs = new Map;
    this.#pending = new Map;
  }
  _getSubscriber(sub) {
    switch (sub.type) {
      case "close":
        return new UnmanagedSubscriber("close");
      case "block":
        return new SocketBlockSubscriber(this);
      case "pending":
        return new SocketPendingSubscriber(this);
      case "event":
        return new SocketEventSubscriber(this, sub.filter);
      case "orphan":
        if (sub.filter.orphan === "drop-log") {
          return new UnmanagedSubscriber("drop-log");
        }
    }
    return super._getSubscriber(sub);
  }
  _register(filterId, subscriber) {
    this.#subs.set(filterId, subscriber);
    const pending = this.#pending.get(filterId);
    if (pending) {
      for (const message of pending) {
        subscriber._handleMessage(message);
      }
      this.#pending.delete(filterId);
    }
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
    const promise5 = new Promise((resolve, reject2) => {
      this.#callbacks.set(payload.id, { payload, resolve, reject: reject2 });
    });
    await this._waitUntilReady();
    await this._write(JSON.stringify(payload));
    return [await promise5];
  }
  async _processMessage(message) {
    const result = JSON.parse(message);
    if (result && typeof result === "object" && "id" in result) {
      const callback = this.#callbacks.get(result.id);
      if (callback == null) {
        this.emit("error", makeError("received result for unknown id", "UNKNOWN_ERROR", {
          reasonCode: "UNKNOWN_ID",
          result
        }));
        return;
      }
      this.#callbacks.delete(result.id);
      callback.resolve(result);
    } else if (result && result.method === "eth_subscription") {
      const filterId = result.params.subscription;
      const subscriber = this.#subs.get(filterId);
      if (subscriber) {
        subscriber._handleMessage(result.params.result);
      } else {
        let pending = this.#pending.get(filterId);
        if (pending == null) {
          pending = [];
          this.#pending.set(filterId, pending);
        }
        pending.push(result.params.result);
      }
    } else {
      this.emit("error", makeError("received unexpected message", "UNKNOWN_ERROR", {
        reasonCode: "UNEXPECTED_MESSAGE",
        result
      }));
      return;
    }
  }
  async _write(message) {
    throw new Error("sub-classes must override this");
  }
}

// node_modules/ethers/lib.esm/providers/provider-websocket.js
class WebSocketProvider extends SocketProvider {
  #connect;
  #websocket;
  get websocket() {
    if (this.#websocket == null) {
      throw new Error("websocket closed");
    }
    return this.#websocket;
  }
  constructor(url, network8, options) {
    super(network8, options);
    if (typeof url === "string") {
      this.#connect = () => {
        return new WebSocket(url);
      };
      this.#websocket = this.#connect();
    } else if (typeof url === "function") {
      this.#connect = url;
      this.#websocket = url();
    } else {
      this.#connect = null;
      this.#websocket = url;
    }
    this.websocket.onopen = async () => {
      try {
        await this._start();
        this.resume();
      } catch (error23) {
        console.log("failed to start WebsocketProvider", error23);
      }
    };
    this.websocket.onmessage = (message) => {
      this._processMessage(message.data);
    };
  }
  async _write(message) {
    this.websocket.send(message);
  }
  async destroy() {
    if (this.#websocket != null) {
      this.#websocket.close();
      this.#websocket = null;
    }
    super.destroy();
  }
}

// node_modules/ethers/lib.esm/providers/provider-infura.js
function getHost4(name) {
  switch (name) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "arbitrum-sepolia":
      return "arbitrum-sepolia.infura.io";
    case "base":
      return "base-mainnet.infura.io";
    case "base-goerlia":
    case "base-goerli":
      return "base-goerli.infura.io";
    case "base-sepolia":
      return "base-sepolia.infura.io";
    case "bnb":
      return "bsc-mainnet.infura.io";
    case "bnbt":
      return "bsc-testnet.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "linea-sepolia":
      return "linea-sepolia.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-amoy":
      return "polygon-amoy.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
    case "optimism-sepolia":
      return "optimism-sepolia.infura.io";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var defaultProjectId = "84842078b09946638c03157f83405213";

class InfuraWebSocketProvider extends WebSocketProvider {
  projectId;
  projectSecret;
  constructor(network9, projectId) {
    const provider5 = new InfuraProvider(network9, projectId);
    const req = provider5._getConnection();
    assert(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
    const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, provider5._network);
    defineProperties(this, {
      projectId: provider5.projectId,
      projectSecret: provider5.projectSecret
    });
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}

class InfuraProvider extends JsonRpcProvider {
  projectId;
  projectSecret;
  constructor(_network, projectId, projectSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network9 = Network.from(_network);
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request27 = InfuraProvider.getRequest(network9, projectId, projectSecret);
    super(request27, network9, { staticNetwork: network9 });
    defineProperties(this, { projectId, projectSecret });
  }
  _getProvider(chainId) {
    try {
      return new InfuraProvider(chainId, this.projectId, this.projectSecret);
    } catch (error23) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
  static getWebSocketProvider(network9, projectId) {
    return new InfuraWebSocketProvider(network9, projectId);
  }
  static getRequest(network9, projectId, projectSecret) {
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request27 = new FetchRequest(`https://${getHost4(network9.name)}/v3/${projectId}`);
    request27.allowGzip = true;
    if (projectSecret) {
      request27.setCredentials("", projectSecret);
    }
    if (projectId === defaultProjectId) {
      request27.retryFunc = async (request28, response4, attempt) => {
        showThrottleMessage("InfuraProvider");
        return true;
      };
    }
    return request27;
  }
}

// node_modules/ethers/lib.esm/providers/provider-quicknode.js
function getHost5(name) {
  switch (name) {
    case "mainnet":
      return "ethers.quiknode.pro";
    case "goerli":
      return "ethers.ethereum-goerli.quiknode.pro";
    case "sepolia":
      return "ethers.ethereum-sepolia.quiknode.pro";
    case "holesky":
      return "ethers.ethereum-holesky.quiknode.pro";
    case "arbitrum":
      return "ethers.arbitrum-mainnet.quiknode.pro";
    case "arbitrum-goerli":
      return "ethers.arbitrum-goerli.quiknode.pro";
    case "arbitrum-sepolia":
      return "ethers.arbitrum-sepolia.quiknode.pro";
    case "base":
      return "ethers.base-mainnet.quiknode.pro";
    case "base-goerli":
      return "ethers.base-goerli.quiknode.pro";
    case "base-spolia":
      return "ethers.base-sepolia.quiknode.pro";
    case "bnb":
      return "ethers.bsc.quiknode.pro";
    case "bnbt":
      return "ethers.bsc-testnet.quiknode.pro";
    case "matic":
      return "ethers.matic.quiknode.pro";
    case "matic-mumbai":
      return "ethers.matic-testnet.quiknode.pro";
    case "optimism":
      return "ethers.optimism.quiknode.pro";
    case "optimism-goerli":
      return "ethers.optimism-goerli.quiknode.pro";
    case "optimism-sepolia":
      return "ethers.optimism-sepolia.quiknode.pro";
    case "xdai":
      return "ethers.xdai.quiknode.pro";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";

class QuickNodeProvider extends JsonRpcProvider {
  token;
  constructor(_network, token) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network10 = Network.from(_network);
    if (token == null) {
      token = defaultToken;
    }
    const request27 = QuickNodeProvider.getRequest(network10, token);
    super(request27, network10, { staticNetwork: network10 });
    defineProperties(this, { token });
  }
  _getProvider(chainId) {
    try {
      return new QuickNodeProvider(chainId, this.token);
    } catch (error23) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.token === defaultToken;
  }
  static getRequest(network10, token) {
    if (token == null) {
      token = defaultToken;
    }
    const request27 = new FetchRequest(`https://${getHost5(network10.name)}/${token}`);
    request27.allowGzip = true;
    if (token === defaultToken) {
      request27.retryFunc = async (request28, response4, attempt) => {
        showThrottleMessage("QuickNodeProvider");
        return true;
      };
    }
    return request27;
  }
}

// node_modules/ethers/lib.esm/providers/provider-fallback.js
function shuffle(array7) {
  for (let i3 = array7.length - 1;i3 > 0; i3--) {
    const j = Math.floor(Math.random() * (i3 + 1));
    const tmp = array7[i3];
    array7[i3] = array7[j];
    array7[j] = tmp;
  }
}
function stall2(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getTime3() {
  return new Date().getTime();
}
function stringify2(value15) {
  return JSON.stringify(value15, (key, value16) => {
    if (typeof value16 === "bigint") {
      return { type: "bigint", value: value16.toString() };
    }
    return value16;
  });
}
async function waitForSync(config2, blockNumber) {
  while (config2.blockNumber < 0 || config2.blockNumber < blockNumber) {
    if (!config2._updateNumber) {
      config2._updateNumber = (async () => {
        try {
          const blockNumber2 = await config2.provider.getBlockNumber();
          if (blockNumber2 > config2.blockNumber) {
            config2.blockNumber = blockNumber2;
          }
        } catch (error23) {
          config2.blockNumber = -2;
          config2._lastFatalError = error23;
          config2._lastFatalErrorTimestamp = getTime3();
        }
        config2._updateNumber = null;
      })();
    }
    await config2._updateNumber;
    config2.outOfSync++;
    if (config2._lastFatalError) {
      break;
    }
  }
}
function _normalize(value15) {
  if (value15 == null) {
    return "null";
  }
  if (Array.isArray(value15)) {
    return "[" + value15.map(_normalize).join(",") + "]";
  }
  if (typeof value15 === "object" && typeof value15.toJSON === "function") {
    return _normalize(value15.toJSON());
  }
  switch (typeof value15) {
    case "boolean":
    case "symbol":
      return value15.toString();
    case "bigint":
    case "number":
      return BigInt(value15).toString();
    case "string":
      return JSON.stringify(value15);
    case "object": {
      const keys = Object.keys(value15);
      keys.sort();
      return "{" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value15[k])}`).join(",") + "}";
    }
  }
  console.log("Could not serialize", value15);
  throw new Error("Hmm...");
}
function normalizeResult(method, value15) {
  if ("error" in value15) {
    const error23 = value15.error;
    let tag;
    if (isError(error23, "CALL_EXCEPTION")) {
      tag = _normalize(Object.assign({}, error23, {
        shortMessage: undefined,
        reason: undefined,
        info: undefined
      }));
    } else {
      tag = _normalize(error23);
    }
    return { tag, value: error23 };
  }
  const result = value15.result;
  return { tag: _normalize(result), value: result };
}
function checkQuorum(quorum, results) {
  const tally = new Map;
  for (const { value: value15, tag, weight } of results) {
    const t3 = tally.get(tag) || { value: value15, weight: 0 };
    t3.weight += weight;
    tally.set(tag, t3);
  }
  let best = null;
  for (const r of tally.values()) {
    if (r.weight >= quorum && (!best || r.weight > best.weight)) {
      best = r;
    }
  }
  if (best) {
    return best.value;
  }
  return;
}
function getMedian(quorum, results) {
  let resultWeight = 0;
  const errorMap2 = new Map;
  let bestError = null;
  const values = [];
  for (const { value: value15, tag, weight } of results) {
    if (value15 instanceof Error) {
      const e = errorMap2.get(tag) || { value: value15, weight: 0 };
      e.weight += weight;
      errorMap2.set(tag, e);
      if (bestError == null || e.weight > bestError.weight) {
        bestError = e;
      }
    } else {
      values.push(BigInt(value15));
      resultWeight += weight;
    }
  }
  if (resultWeight < quorum) {
    if (bestError && bestError.weight >= quorum) {
      return bestError.value;
    }
    return;
  }
  values.sort((a, b3) => a < b3 ? -1 : b3 > a ? 1 : 0);
  const mid = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[mid];
  }
  return (values[mid - 1] + values[mid] + BN_16) / BN_24;
}
function getAnyResult(quorum, results) {
  const result = checkQuorum(quorum, results);
  if (result !== undefined) {
    return result;
  }
  for (const r of results) {
    if (r.value) {
      return r.value;
    }
  }
  return;
}
function getFuzzyMode(quorum, results) {
  if (quorum === 1) {
    return getNumber(getMedian(quorum, results), "%internal");
  }
  const tally = new Map;
  const add = (result, weight) => {
    const t3 = tally.get(result) || { result, weight: 0 };
    t3.weight += weight;
    tally.set(result, t3);
  };
  for (const { weight, value: value15 } of results) {
    const r = getNumber(value15);
    add(r - 1, weight);
    add(r, weight);
    add(r + 1, weight);
  }
  let bestWeight = 0;
  let bestResult = undefined;
  for (const { weight, result } of tally.values()) {
    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {
      bestWeight = weight;
      bestResult = result;
    }
  }
  return bestResult;
}
var BN_16 = BigInt("1");
var BN_24 = BigInt("2");
var defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
var defaultState = {
  blockNumber: -2,
  requests: 0,
  lateResponses: 0,
  errorResponses: 0,
  outOfSync: -1,
  unsupportedEvents: 0,
  rollingDuration: 0,
  score: 0,
  _network: null,
  _updateNumber: null,
  _totalTime: 0,
  _lastFatalError: null,
  _lastFatalErrorTimestamp: 0
};

class FallbackProvider extends AbstractProvider {
  quorum;
  eventQuorum;
  eventWorkers;
  #configs;
  #height;
  #initialSyncPromise;
  constructor(providers, network11, options) {
    super(network11, options);
    this.#configs = providers.map((p) => {
      if (p instanceof AbstractProvider) {
        return Object.assign({ provider: p }, defaultConfig, defaultState);
      } else {
        return Object.assign({}, defaultConfig, p, defaultState);
      }
    });
    this.#height = -2;
    this.#initialSyncPromise = null;
    if (options && options.quorum != null) {
      this.quorum = options.quorum;
    } else {
      this.quorum = Math.ceil(this.#configs.reduce((accum, config2) => {
        accum += config2.weight;
        return accum;
      }, 0) / 2);
    }
    this.eventQuorum = 1;
    this.eventWorkers = 1;
    assertArgument(this.quorum <= this.#configs.reduce((a, c3) => a + c3.weight, 0), "quorum exceed provider weight", "quorum", this.quorum);
  }
  get providerConfigs() {
    return this.#configs.map((c3) => {
      const result = Object.assign({}, c3);
      for (const key in result) {
        if (key[0] === "_") {
          delete result[key];
        }
      }
      return result;
    });
  }
  async _detectNetwork() {
    return Network.from(getBigInt(await this._perform({ method: "chainId" })));
  }
  async _translatePerform(provider5, req) {
    switch (req.method) {
      case "broadcastTransaction":
        return await provider5.broadcastTransaction(req.signedTransaction);
      case "call":
        return await provider5.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
      case "chainId":
        return (await provider5.getNetwork()).chainId;
      case "estimateGas":
        return await provider5.estimateGas(req.transaction);
      case "getBalance":
        return await provider5.getBalance(req.address, req.blockTag);
      case "getBlock": {
        const block = "blockHash" in req ? req.blockHash : req.blockTag;
        return await provider5.getBlock(block, req.includeTransactions);
      }
      case "getBlockNumber":
        return await provider5.getBlockNumber();
      case "getCode":
        return await provider5.getCode(req.address, req.blockTag);
      case "getGasPrice":
        return (await provider5.getFeeData()).gasPrice;
      case "getPriorityFee":
        return (await provider5.getFeeData()).maxPriorityFeePerGas;
      case "getLogs":
        return await provider5.getLogs(req.filter);
      case "getStorage":
        return await provider5.getStorage(req.address, req.position, req.blockTag);
      case "getTransaction":
        return await provider5.getTransaction(req.hash);
      case "getTransactionCount":
        return await provider5.getTransactionCount(req.address, req.blockTag);
      case "getTransactionReceipt":
        return await provider5.getTransactionReceipt(req.hash);
      case "getTransactionResult":
        return await provider5.getTransactionResult(req.hash);
    }
  }
  #getNextConfig(running) {
    const configs = Array.from(running).map((r) => r.config);
    const allConfigs = this.#configs.slice();
    shuffle(allConfigs);
    allConfigs.sort((a, b3) => a.priority - b3.priority);
    for (const config2 of allConfigs) {
      if (config2._lastFatalError) {
        continue;
      }
      if (configs.indexOf(config2) === -1) {
        return config2;
      }
    }
    return null;
  }
  #addRunner(running, req) {
    const config2 = this.#getNextConfig(running);
    if (config2 == null) {
      return null;
    }
    const runner = {
      config: config2,
      result: null,
      didBump: false,
      perform: null,
      staller: null
    };
    const now = getTime3();
    runner.perform = (async () => {
      try {
        config2.requests++;
        const result = await this._translatePerform(config2.provider, req);
        runner.result = { result };
      } catch (error23) {
        config2.errorResponses++;
        runner.result = { error: error23 };
      }
      const dt = getTime3() - now;
      config2._totalTime += dt;
      config2.rollingDuration = 0.95 * config2.rollingDuration + 0.05 * dt;
      runner.perform = null;
    })();
    runner.staller = (async () => {
      await stall2(config2.stallTimeout);
      runner.staller = null;
    })();
    running.add(runner);
    return runner;
  }
  async#initialSync() {
    let initialSync = this.#initialSyncPromise;
    if (!initialSync) {
      const promises3 = [];
      this.#configs.forEach((config2) => {
        promises3.push((async () => {
          await waitForSync(config2, 0);
          if (!config2._lastFatalError) {
            config2._network = await config2.provider.getNetwork();
          }
        })());
      });
      this.#initialSyncPromise = initialSync = (async () => {
        await Promise.all(promises3);
        let chainId = null;
        for (const config2 of this.#configs) {
          if (config2._lastFatalError) {
            continue;
          }
          const network11 = config2._network;
          if (chainId == null) {
            chainId = network11.chainId;
          } else if (network11.chainId !== chainId) {
            assert(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
              operation: "new FallbackProvider"
            });
          }
        }
      })();
    }
    await initialSync;
  }
  async#checkQuorum(running, req) {
    const results = [];
    for (const runner of running) {
      if (runner.result != null) {
        const { tag, value: value15 } = normalizeResult(req.method, runner.result);
        results.push({ tag, value: value15, weight: runner.config.weight });
      }
    }
    if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {
      return;
    }
    switch (req.method) {
      case "getBlockNumber": {
        if (this.#height === -2) {
          this.#height = Math.ceil(getNumber(getMedian(this.quorum, this.#configs.filter((c3) => !c3._lastFatalError).map((c3) => ({
            value: c3.blockNumber,
            tag: getNumber(c3.blockNumber).toString(),
            weight: c3.weight
          })))));
        }
        const mode = getFuzzyMode(this.quorum, results);
        if (mode === undefined) {
          return;
        }
        if (mode > this.#height) {
          this.#height = mode;
        }
        return this.#height;
      }
      case "getGasPrice":
      case "getPriorityFee":
      case "estimateGas":
        return getMedian(this.quorum, results);
      case "getBlock":
        if ("blockTag" in req && req.blockTag === "pending") {
          return getAnyResult(this.quorum, results);
        }
        return checkQuorum(this.quorum, results);
      case "call":
      case "chainId":
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
      case "getStorage":
      case "getTransaction":
      case "getTransactionReceipt":
      case "getLogs":
        return checkQuorum(this.quorum, results);
      case "broadcastTransaction":
        return getAnyResult(this.quorum, results);
    }
    assert(false, "unsupported method", "UNSUPPORTED_OPERATION", {
      operation: `_perform(${stringify2(req.method)})`
    });
  }
  async#waitForQuorum(running, req) {
    if (running.size === 0) {
      throw new Error("no runners?!");
    }
    const interesting = [];
    let newRunners = 0;
    for (const runner of running) {
      if (runner.perform) {
        interesting.push(runner.perform);
      }
      if (runner.staller) {
        interesting.push(runner.staller);
        continue;
      }
      if (runner.didBump) {
        continue;
      }
      runner.didBump = true;
      newRunners++;
    }
    const value15 = await this.#checkQuorum(running, req);
    if (value15 !== undefined) {
      if (value15 instanceof Error) {
        throw value15;
      }
      return value15;
    }
    for (let i3 = 0;i3 < newRunners; i3++) {
      this.#addRunner(running, req);
    }
    assert(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
      request: "%sub-requests",
      info: { request: req, results: Array.from(running).map((r) => stringify2(r.result)) }
    });
    await Promise.race(interesting);
    return await this.#waitForQuorum(running, req);
  }
  async _perform(req) {
    if (req.method === "broadcastTransaction") {
      const results = this.#configs.map((c3) => null);
      const broadcasts = this.#configs.map(async ({ provider: provider5, weight }, index2) => {
        try {
          const result3 = await provider5._perform(req);
          results[index2] = Object.assign(normalizeResult(req.method, { result: result3 }), { weight });
        } catch (error23) {
          results[index2] = Object.assign(normalizeResult(req.method, { error: error23 }), { weight });
        }
      });
      while (true) {
        const done = results.filter((r) => r != null);
        for (const { value: value15 } of done) {
          if (!(value15 instanceof Error)) {
            return value15;
          }
        }
        const result3 = checkQuorum(this.quorum, results.filter((r) => r != null));
        if (isError(result3, "INSUFFICIENT_FUNDS")) {
          throw result3;
        }
        const waiting = broadcasts.filter((b3, i3) => results[i3] == null);
        if (waiting.length === 0) {
          break;
        }
        await Promise.race(waiting);
      }
      const result2 = getAnyResult(this.quorum, results);
      assert(result2 !== undefined, "problem multi-broadcasting", "SERVER_ERROR", {
        request: "%sub-requests",
        info: { request: req, results: results.map(stringify2) }
      });
      if (result2 instanceof Error) {
        throw result2;
      }
      return result2;
    }
    await this.#initialSync();
    const running = new Set;
    let inflightQuorum = 0;
    while (true) {
      const runner = this.#addRunner(running, req);
      if (runner == null) {
        break;
      }
      inflightQuorum += runner.config.weight;
      if (inflightQuorum >= this.quorum) {
        break;
      }
    }
    const result = await this.#waitForQuorum(running, req);
    for (const runner of running) {
      if (runner.perform && runner.result == null) {
        runner.config.lateResponses++;
      }
    }
    return result;
  }
  async destroy() {
    for (const { provider: provider5 } of this.#configs) {
      provider5.destroy();
    }
    super.destroy();
  }
}

// node_modules/ethers/lib.esm/providers/default-provider.js
function isWebSocketLike(value15) {
  return value15 && typeof value15.send === "function" && typeof value15.close === "function";
}
function getDefaultProvider(network12, options) {
  if (options == null) {
    options = {};
  }
  const allowService = (name) => {
    if (options[name] === "-") {
      return false;
    }
    if (typeof options.exclusive === "string") {
      return name === options.exclusive;
    }
    if (Array.isArray(options.exclusive)) {
      return options.exclusive.indexOf(name) !== -1;
    }
    return true;
  };
  if (typeof network12 === "string" && network12.match(/^https?:/)) {
    return new JsonRpcProvider(network12);
  }
  if (typeof network12 === "string" && network12.match(/^wss?:/) || isWebSocketLike(network12)) {
    return new WebSocketProvider(network12);
  }
  let staticNetwork = null;
  try {
    staticNetwork = Network.from(network12);
  } catch (error23) {
  }
  const providers = [];
  if (allowService("publicPolygon") && staticNetwork) {
    if (staticNetwork.name === "matic") {
      providers.push(new JsonRpcProvider("https://polygon-rpc.com/", staticNetwork, { staticNetwork }));
    } else if (staticNetwork.name === "matic-amoy") {
      providers.push(new JsonRpcProvider("https://rpc-amoy.polygon.technology/", staticNetwork, { staticNetwork }));
    }
  }
  if (allowService("alchemy")) {
    try {
      providers.push(new AlchemyProvider(network12, options.alchemy));
    } catch (error23) {
    }
  }
  if (allowService("ankr") && options.ankr != null) {
    try {
      providers.push(new AnkrProvider(network12, options.ankr));
    } catch (error23) {
    }
  }
  if (allowService("chainstack")) {
    try {
      providers.push(new ChainstackProvider(network12, options.chainstack));
    } catch (error23) {
    }
  }
  if (allowService("cloudflare")) {
    try {
      providers.push(new CloudflareProvider(network12));
    } catch (error23) {
    }
  }
  if (allowService("etherscan")) {
    try {
      providers.push(new EtherscanProvider(network12, options.etherscan));
    } catch (error23) {
    }
  }
  if (allowService("infura")) {
    try {
      let projectId = options.infura;
      let projectSecret = undefined;
      if (typeof projectId === "object") {
        projectSecret = projectId.projectSecret;
        projectId = projectId.projectId;
      }
      providers.push(new InfuraProvider(network12, projectId, projectSecret));
    } catch (error23) {
    }
  }
  if (allowService("quicknode")) {
    try {
      let token = options.quicknode;
      providers.push(new QuickNodeProvider(network12, token));
    } catch (error23) {
    }
  }
  assert(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
    operation: "getDefaultProvider"
  });
  if (providers.length === 1) {
    return providers[0];
  }
  let quorum = Math.floor(providers.length / 2);
  if (quorum > 2) {
    quorum = 2;
  }
  if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
    quorum = 1;
  }
  if (options && options.quorum) {
    quorum = options.quorum;
  }
  return new FallbackProvider(providers, undefined, { quorum });
}
var Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
// node_modules/ethers/lib.esm/providers/signer-noncemanager.js
class NonceManager extends AbstractSigner {
  signer;
  #noncePromise;
  #delta;
  constructor(signer) {
    super(signer.provider);
    defineProperties(this, { signer });
    this.#noncePromise = null;
    this.#delta = 0;
  }
  async getAddress() {
    return this.signer.getAddress();
  }
  connect(provider5) {
    return new NonceManager(this.signer.connect(provider5));
  }
  async getNonce(blockTag) {
    if (blockTag === "pending") {
      if (this.#noncePromise == null) {
        this.#noncePromise = super.getNonce("pending");
      }
      const delta4 = this.#delta;
      return await this.#noncePromise + delta4;
    }
    return super.getNonce(blockTag);
  }
  increment() {
    this.#delta++;
  }
  reset() {
    this.#delta = 0;
    this.#noncePromise = null;
  }
  async sendTransaction(tx) {
    const noncePromise = this.getNonce("pending");
    this.increment();
    tx = await this.signer.populateTransaction(tx);
    tx.nonce = await noncePromise;
    return await this.signer.sendTransaction(tx);
  }
  signTransaction(tx) {
    return this.signer.signTransaction(tx);
  }
  signMessage(message) {
    return this.signer.signMessage(message);
  }
  signTypedData(domain, types, value15) {
    return this.signer.signTypedData(domain, types, value15);
  }
}
// node_modules/ethers/lib.esm/providers/provider-browser.js
class BrowserProvider extends JsonRpcApiPollingProvider {
  #request;
  #providerInfo;
  constructor(ethereum, network12, _options) {
    const options = Object.assign({}, _options != null ? _options : {}, { batchMaxCount: 1 });
    assertArgument(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
    super(network12, options);
    this.#providerInfo = null;
    if (_options && _options.providerInfo) {
      this.#providerInfo = _options.providerInfo;
    }
    this.#request = async (method, params) => {
      const payload = { method, params };
      this.emit("debug", { action: "sendEip1193Request", payload });
      try {
        const result = await ethereum.request(payload);
        this.emit("debug", { action: "receiveEip1193Result", result });
        return result;
      } catch (e) {
        const error23 = new Error(e.message);
        error23.code = e.code;
        error23.data = e.data;
        error23.payload = payload;
        this.emit("debug", { action: "receiveEip1193Error", error: error23 });
        throw error23;
      }
    };
  }
  get providerInfo() {
    return this.#providerInfo;
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
    try {
      const result = await this.#request(payload.method, payload.params || []);
      return [{ id: payload.id, result }];
    } catch (e) {
      return [{
        id: payload.id,
        error: { code: e.code, data: e.data, message: e.message }
      }];
    }
  }
  getRpcError(payload, error23) {
    error23 = JSON.parse(JSON.stringify(error23));
    switch (error23.error.code || -1) {
      case 4001:
        error23.error.message = `ethers-user-denied: ${error23.error.message}`;
        break;
      case 4200:
        error23.error.message = `ethers-unsupported: ${error23.error.message}`;
        break;
    }
    return super.getRpcError(payload, error23);
  }
  async hasSigner(address21) {
    if (address21 == null) {
      address21 = 0;
    }
    const accounts = await this.send("eth_accounts", []);
    if (typeof address21 === "number") {
      return accounts.length > address21;
    }
    address21 = address21.toLowerCase();
    return accounts.filter((a) => a.toLowerCase() === address21).length !== 0;
  }
  async getSigner(address21) {
    if (address21 == null) {
      address21 = 0;
    }
    if (!await this.hasSigner(address21)) {
      try {
        await this.#request("eth_requestAccounts", []);
      } catch (error23) {
        const payload = error23.payload;
        throw this.getRpcError(payload, { id: payload.id, error: error23 });
      }
    }
    return await super.getSigner(address21);
  }
  static async discover(options) {
    if (options == null) {
      options = {};
    }
    if (options.provider) {
      return new BrowserProvider(options.provider);
    }
    const context = options.window ? options.window : typeof window !== "undefined" ? window : null;
    if (context == null) {
      return null;
    }
    const anyProvider = options.anyProvider;
    if (anyProvider && context.ethereum) {
      return new BrowserProvider(context.ethereum);
    }
    if (!(("addEventListener" in context) && ("dispatchEvent" in context) && ("removeEventListener" in context))) {
      return null;
    }
    const timeout = options.timeout ? options.timeout : 300;
    if (timeout === 0) {
      return null;
    }
    return await new Promise((resolve, reject2) => {
      let found = [];
      const addProvider = (event) => {
        found.push(event.detail);
        if (anyProvider) {
          finalize();
        }
      };
      const finalize = () => {
        clearTimeout(timer);
        if (found.length) {
          if (options && options.filter) {
            const filtered = options.filter(found.map((i3) => Object.assign({}, i3.info)));
            if (filtered == null) {
              resolve(null);
            } else if (filtered instanceof BrowserProvider) {
              resolve(filtered);
            } else {
              let match = null;
              if (filtered.uuid) {
                const matches = found.filter((f4) => filtered.uuid === f4.info.uuid);
                match = matches[0];
              }
              if (match) {
                const { provider: provider5, info } = match;
                resolve(new BrowserProvider(provider5, undefined, {
                  providerInfo: info
                }));
              } else {
                reject2(makeError("filter returned unknown info", "UNSUPPORTED_OPERATION", {
                  value: filtered
                }));
              }
            }
          } else {
            const { provider: provider5, info } = found[0];
            resolve(new BrowserProvider(provider5, undefined, {
              providerInfo: info
            }));
          }
        } else {
          resolve(null);
        }
        context.removeEventListener("eip6963:announceProvider", addProvider);
      };
      const timer = setTimeout(() => {
        finalize();
      }, timeout);
      context.addEventListener("eip6963:announceProvider", addProvider);
      context.dispatchEvent(new Event("eip6963:requestProvider"));
    });
  }
}
// node_modules/ethers/lib.esm/providers/provider-blockscout.js
function getUrl(name) {
  switch (name) {
    case "mainnet":
      return "https://eth.blockscout.com/api/eth-rpc";
    case "sepolia":
      return "https://eth-sepolia.blockscout.com/api/eth-rpc";
    case "holesky":
      return "https://eth-holesky.blockscout.com/api/eth-rpc";
    case "classic":
      return "https://etc.blockscout.com/api/eth-rpc";
    case "arbitrum":
      return "https://arbitrum.blockscout.com/api/eth-rpc";
    case "base":
      return "https://base.blockscout.com/api/eth-rpc";
    case "base-sepolia":
      return "https://base-sepolia.blockscout.com/api/eth-rpc";
    case "matic":
      return "https://polygon.blockscout.com/api/eth-rpc";
    case "optimism":
      return "https://optimism.blockscout.com/api/eth-rpc";
    case "optimism-sepolia":
      return "https://optimism-sepolia.blockscout.com/api/eth-rpc";
    case "xdai":
      return "https://gnosis.blockscout.com/api/eth-rpc";
  }
  assertArgument(false, "unsupported network", "network", name);
}

class BlockscoutProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network13 = Network.from(_network);
    if (apiKey == null) {
      apiKey = null;
    }
    const request27 = BlockscoutProvider.getRequest(network13);
    super(request27, network13, { staticNetwork: network13 });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new BlockscoutProvider(chainId, this.apiKey);
    } catch (error23) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.apiKey === null;
  }
  getRpcRequest(req) {
    const resp = super.getRpcRequest(req);
    if (resp && resp.method === "eth_estimateGas" && resp.args.length == 1) {
      resp.args = resp.args.slice();
      resp.args.push("latest");
    }
    return resp;
  }
  getRpcError(payload, _error) {
    const error23 = _error ? _error.error : null;
    if (error23 && error23.code === -32015 && !isHexString(error23.data || "", true)) {
      const panicCodes = {
        "assert(false)": "01",
        "arithmetic underflow or overflow": "11",
        "division or modulo by zero": "12",
        "out-of-bounds array access; popping on an empty array": "31",
        "out-of-bounds access of an array or bytesN": "32"
      };
      let panicCode = "";
      if (error23.message === "VM execution error.") {
        panicCode = panicCodes[error23.data] || "";
      } else if (panicCodes[error23.message || ""]) {
        panicCode = panicCodes[error23.message || ""];
      }
      if (panicCode) {
        error23.message += ` (reverted: ${error23.data})`;
        error23.data = "0x4e487b7100000000000000000000000000000000000000000000000000000000000000" + panicCode;
      }
    } else if (error23 && error23.code === -32000) {
      if (error23.message === "wrong transaction nonce") {
        error23.message += " (nonce too low)";
      }
    }
    return super.getRpcError(payload, _error);
  }
  static getRequest(network13) {
    const request27 = new FetchRequest(getUrl(network13.name));
    request27.allowGzip = true;
    return request27;
  }
}
// node_modules/ethers/lib.esm/providers/provider-pocket.js
function getHost6(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.gateway.pokt.network";
    case "goerli":
      return "eth-goerli.gateway.pokt.network";
    case "matic":
      return "poly-mainnet.gateway.pokt.network";
    case "matic-mumbai":
      return "polygon-mumbai-rpc.gateway.pokt.network";
  }
  assertArgument(false, "unsupported network", "network", name);
}
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";

class PocketProvider extends JsonRpcProvider {
  applicationId;
  applicationSecret;
  constructor(_network, applicationId, applicationSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network14 = Network.from(_network);
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    if (applicationSecret == null) {
      applicationSecret = null;
    }
    const options = { staticNetwork: network14 };
    const request27 = PocketProvider.getRequest(network14, applicationId, applicationSecret);
    super(request27, network14, options);
    defineProperties(this, { applicationId, applicationSecret });
  }
  _getProvider(chainId) {
    try {
      return new PocketProvider(chainId, this.applicationId, this.applicationSecret);
    } catch (error23) {
    }
    return super._getProvider(chainId);
  }
  static getRequest(network14, applicationId, applicationSecret) {
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    const request27 = new FetchRequest(`https://${getHost6(network14.name)}/v1/lb/${applicationId}`);
    request27.allowGzip = true;
    if (applicationSecret) {
      request27.setCredentials("", applicationSecret);
    }
    if (applicationId === defaultApplicationId) {
      request27.retryFunc = async (request28, response4, attempt) => {
        showThrottleMessage("PocketProvider");
        return true;
      };
    }
    return request27;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
}
// node_modules/ethers/lib.esm/providers/provider-ipcsocket.js
import {connect} from "net";
function splitBuffer(data12) {
  const messages = [];
  let lastStart = 0;
  while (true) {
    const nl = data12.indexOf(10, lastStart);
    if (nl === -1) {
      break;
    }
    messages.push(data12.subarray(lastStart, nl).toString().trim());
    lastStart = nl + 1;
  }
  return { messages, remaining: data12.subarray(lastStart) };
}

class IpcSocketProvider extends SocketProvider {
  #socket;
  get socket() {
    return this.#socket;
  }
  constructor(path2, network14, options) {
    super(network14, options);
    this.#socket = connect(path2);
    this.socket.on("ready", async () => {
      try {
        await this._start();
      } catch (error23) {
        console.log("failed to start IpcSocketProvider", error23);
      }
    });
    let response4 = Buffer.alloc(0);
    this.socket.on("data", (data12) => {
      response4 = Buffer.concat([response4, data12]);
      const { messages, remaining } = splitBuffer(response4);
      messages.forEach((message) => {
        this._processMessage(message);
      });
      response4 = remaining;
    });
    this.socket.on("end", () => {
      this.emit("close");
      this.socket.destroy();
      this.socket.end();
    });
  }
  destroy() {
    this.socket.destroy();
    this.socket.end();
    super.destroy();
  }
  async _write(message) {
    if (!message.endsWith("\n")) {
      message += "\n";
    }
    this.socket.write(message);
  }
}
// node_modules/ethers/lib.esm/wallet/base-wallet.js
class BaseWallet extends AbstractSigner {
  address;
  #signingKey;
  constructor(privateKey, provider5) {
    super(provider5);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    this.#signingKey = privateKey;
    const address22 = computeAddress(this.signingKey.publicKey);
    defineProperties(this, { address: address22 });
  }
  get signingKey() {
    return this.#signingKey;
  }
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider5) {
    return new BaseWallet(this.#signingKey, provider5);
  }
  async signTransaction(tx) {
    tx = copyRequest(tx);
    const { to, from } = await resolveProperties({
      to: tx.to ? resolveAddress(tx.to, this) : undefined,
      from: tx.from ? resolveAddress(tx.from, this) : undefined
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage(message)).serialized;
  }
  authorizeSync(auth3) {
    assertArgument(typeof auth3.address === "string", "invalid address for authorizeSync", "auth.address", auth3);
    const signature2 = this.signingKey.sign(hashAuthorization(auth3));
    return Object.assign({}, {
      address: getAddress(auth3.address),
      nonce: getBigInt(auth3.nonce || 0),
      chainId: getBigInt(auth3.chainId || 0)
    }, { signature: signature2 });
  }
  async authorize(auth3) {
    auth3 = Object.assign({}, auth3, {
      address: await resolveAddress(auth3.address, this)
    });
    return this.authorizeSync(await this.populateAuthorization(auth3));
  }
  async signTypedData(domain, types, value15) {
    const populated = await TypedDataEncoder.resolveNames(domain, types, value15, async (name) => {
      assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address22 = await this.provider.resolveName(name);
      assert(address22 != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address22;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;
  }
}
// node_modules/ethers/lib.esm/wordlists/decode-owl.js
function unfold(words, sep) {
  let initial = 97;
  return words.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode2(data12, subs) {
  for (let i3 = subsChrs.length - 1;i3 >= 0; i3--) {
    data12 = data12.split(subsChrs[i3]).join(subs.substring(2 * i3, 2 * i3 + 2));
  }
  const clumps = [];
  const leftover = data12.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
    if (semi) {
      for (let i3 = parseInt(semi);i3 >= 0; i3--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data12) {
  assertArgument(data12[0] === "0", "unsupported auwl data", "data", data12);
  return decode2(data12.substring(1 + 2 * subsChrs.length), data12.substring(1, 1 + 2 * subsChrs.length));
}
var subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
var Word = /^[a-z]*$/i;

// node_modules/ethers/lib.esm/wordlists/wordlist.js
class Wordlist {
  locale;
  constructor(locale) {
    defineProperties(this, { locale });
  }
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  join(words) {
    return words.join(" ");
  }
}

// node_modules/ethers/lib.esm/wordlists/wordlist-owl.js
class WordlistOwl extends Wordlist {
  #data;
  #checksum;
  constructor(locale, data12, checksum) {
    super(locale);
    this.#data = data12;
    this.#checksum = checksum;
    this.#words = null;
  }
  get _data() {
    return this.#data;
  }
  _decodeWords() {
    return decodeOwl(this.#data);
  }
  #words;
  #loadWords() {
    if (this.#words == null) {
      const words = this._decodeWords();
      const checksum = id(words.join("\n") + "\n");
      if (checksum !== this.#checksum) {
        throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
      }
      this.#words = words;
    }
    return this.#words;
  }
  getWord(index2) {
    const words = this.#loadWords();
    assertArgument(index2 >= 0 && index2 < words.length, `invalid word index: ${index2}`, "index", index2);
    return words[index2];
  }
  getWordIndex(word) {
    return this.#loadWords().indexOf(word);
  }
}

// node_modules/ethers/lib.esm/wordlists/lang-en.js
var words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
var checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
var wordlist2 = null;

class LangEn extends WordlistOwl {
  constructor() {
    super("en", words, checksum);
  }
  static wordlist() {
    if (wordlist2 == null) {
      wordlist2 = new LangEn;
    }
    return wordlist2;
  }
}

// node_modules/ethers/lib.esm/wallet/mnemonic.js
function getUpperMask(bits2) {
  return (1 << bits2) - 1 << 8 - bits2 & 255;
}
function getLowerMask(bits2) {
  return (1 << bits2) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist3) {
  assertNormalize("NFKD");
  if (wordlist3 == null) {
    wordlist3 = LangEn.wordlist();
  }
  const words2 = wordlist3.split(mnemonic);
  assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
  let offset = 0;
  for (let i3 = 0;i3 < words2.length; i3++) {
    let index2 = wordlist3.getWordIndex(words2[i3].normalize("NFKD"));
    assertArgument(index2 >= 0, `invalid mnemonic word at index ${i3}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0;bit < 11; bit++) {
      if (index2 & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = getBytes(sha2565(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist3) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist3 == null) {
    wordlist3 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i3 = 0;i3 < entropy.length; i3++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i3];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i3] >> 8 - remainingBits;
      indices.push(entropy[i3] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha2565(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist3.join(indices.map((index2) => wordlist3.getWord(index2)));
}
var _guard5 = {};

class Mnemonic {
  phrase;
  password;
  wordlist;
  entropy;
  constructor(guard22, entropy, phrase, password, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn.wordlist();
    }
    assertPrivate(guard22, _guard5, "Mnemonic");
    defineProperties(this, { phrase, password, wordlist: wordlist3, entropy });
  }
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf2(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  static fromPhrase(phrase, password, wordlist3) {
    const entropy = mnemonicToEntropy(phrase, wordlist3);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist3);
    return new Mnemonic(_guard5, entropy, phrase, password, wordlist3);
  }
  static fromEntropy(_entropy, password, wordlist3) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist3);
    return new Mnemonic(_guard5, hexlify(entropy), phrase, password, wordlist3);
  }
  static entropyToPhrase(_entropy, wordlist3) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist3);
  }
  static phraseToEntropy(phrase, wordlist3) {
    return mnemonicToEntropy(phrase, wordlist3);
  }
  static isValidMnemonic(phrase, wordlist3) {
    try {
      mnemonicToEntropy(phrase, wordlist3);
      return true;
    } catch (error23) {
    }
    return false;
  }
}

// node_modules/aes-js/lib.esm/aes.js
function convertToInt32(bytes5) {
  const result = [];
  for (let i3 = 0;i3 < bytes5.length; i3 += 4) {
    result.push(bytes5[i3] << 24 | bytes5[i3 + 1] << 16 | bytes5[i3 + 2] << 8 | bytes5[i3 + 3]);
  }
  return result;
}
/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
var __classPrivateFieldGet2 = function(receiver, state, kind28, f4) {
  if (kind28 === "a" && !f4)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind28 === "m" ? f4 : kind28 === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var __classPrivateFieldSet2 = function(receiver, state, value15, kind28, f4) {
  if (kind28 === "m")
    throw new TypeError("Private method is not writable");
  if (kind28 === "a" && !f4)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind28 === "a" ? f4.call(receiver, value15) : f4 ? f4.value = value15 : state.set(receiver, value15), value15;
};
var _AES_key;
var _AES_Kd;
var _AES_Ke;
var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
var S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
var T13 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239000, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998000, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
var U22 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239000, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998000, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];

class AES {
  get key() {
    return __classPrivateFieldGet2(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, undefined);
    _AES_Kd.set(this, undefined);
    _AES_Ke.set(this, undefined);
    if (!(this instanceof AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet2(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet2(this, _AES_Ke, [], "f");
    __classPrivateFieldSet2(this, _AES_Kd, [], "f");
    for (let i3 = 0;i3 <= rounds; i3++) {
      __classPrivateFieldGet2(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet2(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt32(this.key);
    let index2;
    for (let i3 = 0;i3 < KC; i3++) {
      index2 = i3 >> 2;
      __classPrivateFieldGet2(this, _AES_Ke, "f")[index2][i3 % 4] = tk[i3];
      __classPrivateFieldGet2(this, _AES_Kd, "f")[rounds - index2][i3 % 4] = tk[i3];
    }
    let rconpointer = 0;
    let t3 = KC, tt;
    while (t3 < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i4 = 1;i4 < KC; i4++) {
          tk[i4] ^= tk[i4 - 1];
        }
      } else {
        for (let i4 = 1;i4 < KC / 2; i4++) {
          tk[i4] ^= tk[i4 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i4 = KC / 2 + 1;i4 < KC; i4++) {
          tk[i4] ^= tk[i4 - 1];
        }
      }
      let i3 = 0, r, c3;
      while (i3 < KC && t3 < roundKeyCount) {
        r = t3 >> 2;
        c3 = t3 % 4;
        __classPrivateFieldGet2(this, _AES_Ke, "f")[r][c3] = tk[i3];
        __classPrivateFieldGet2(this, _AES_Kd, "f")[rounds - r][c3] = tk[i3++];
        t3++;
      }
    }
    for (let r = 1;r < rounds; r++) {
      for (let c3 = 0;c3 < 4; c3++) {
        tt = __classPrivateFieldGet2(this, _AES_Kd, "f")[r][c3];
        __classPrivateFieldGet2(this, _AES_Kd, "f")[r][c3] = U1[tt >> 24 & 255] ^ U22[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet2(this, _AES_Ke, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t3 = convertToInt32(plaintext);
    for (let i3 = 0;i3 < 4; i3++) {
      t3[i3] ^= __classPrivateFieldGet2(this, _AES_Ke, "f")[0][i3];
    }
    for (let r = 1;r < rounds; r++) {
      for (let i3 = 0;i3 < 4; i3++) {
        a[i3] = T13[t3[i3] >> 24 & 255] ^ T22[t3[(i3 + 1) % 4] >> 16 & 255] ^ T3[t3[(i3 + 2) % 4] >> 8 & 255] ^ T4[t3[(i3 + 3) % 4] & 255] ^ __classPrivateFieldGet2(this, _AES_Ke, "f")[r][i3];
      }
      t3 = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i3 = 0;i3 < 4; i3++) {
      tt = __classPrivateFieldGet2(this, _AES_Ke, "f")[rounds][i3];
      result[4 * i3] = (S[t3[i3] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i3 + 1] = (S[t3[(i3 + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i3 + 2] = (S[t3[(i3 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i3 + 3] = (S[t3[(i3 + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet2(this, _AES_Kd, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t3 = convertToInt32(ciphertext);
    for (let i3 = 0;i3 < 4; i3++) {
      t3[i3] ^= __classPrivateFieldGet2(this, _AES_Kd, "f")[0][i3];
    }
    for (let r = 1;r < rounds; r++) {
      for (let i3 = 0;i3 < 4; i3++) {
        a[i3] = T5[t3[i3] >> 24 & 255] ^ T6[t3[(i3 + 3) % 4] >> 16 & 255] ^ T7[t3[(i3 + 2) % 4] >> 8 & 255] ^ T8[t3[(i3 + 1) % 4] & 255] ^ __classPrivateFieldGet2(this, _AES_Kd, "f")[r][i3];
      }
      t3 = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i3 = 0;i3 < 4; i3++) {
      tt = __classPrivateFieldGet2(this, _AES_Kd, "f")[rounds][i3];
      result[4 * i3] = (Si[t3[i3] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i3 + 1] = (Si[t3[(i3 + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i3 + 2] = (Si[t3[(i3 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i3 + 3] = (Si[t3[(i3 + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
}
_AES_key = new WeakMap, _AES_Kd = new WeakMap, _AES_Ke = new WeakMap;

// node_modules/aes-js/lib.esm/mode.js
class ModeOfOperation {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name }
    });
  }
}

// node_modules/aes-js/lib.esm/mode-cbc.js
var __classPrivateFieldSet3 = function(receiver, state, value15, kind28, f4) {
  if (kind28 === "m")
    throw new TypeError("Private method is not writable");
  if (kind28 === "a" && !f4)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind28 === "a" ? f4.call(receiver, value15) : f4 ? f4.value = value15 : state.set(receiver, value15), value15;
};
var __classPrivateFieldGet3 = function(receiver, state, kind28, f4) {
  if (kind28 === "a" && !f4)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind28 === "m" ? f4 : kind28 === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var _CBC_iv;
var _CBC_lastBlock;

class CBC extends ModeOfOperation {
  constructor(key, iv) {
    super("ECC", key, CBC);
    _CBC_iv.set(this, undefined);
    _CBC_lastBlock.set(this, undefined);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet3(this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet3(this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet3(this, _CBC_lastBlock, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet3(this, _CBC_iv, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i3 = 0;i3 < plaintext.length; i3 += 16) {
      for (let j = 0;j < 16; j++) {
        __classPrivateFieldGet3(this, _CBC_lastBlock, "f")[j] ^= plaintext[i3 + j];
      }
      __classPrivateFieldSet3(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet3(this, _CBC_lastBlock, "f")), "f");
      ciphertext.set(__classPrivateFieldGet3(this, _CBC_lastBlock, "f"), i3);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i3 = 0;i3 < ciphertext.length; i3 += 16) {
      const block = this.aes.decrypt(ciphertext.subarray(i3, i3 + 16));
      for (let j = 0;j < 16; j++) {
        plaintext[i3 + j] = block[j] ^ __classPrivateFieldGet3(this, _CBC_lastBlock, "f")[j];
        __classPrivateFieldGet3(this, _CBC_lastBlock, "f")[j] = ciphertext[i3 + j];
      }
    }
    return plaintext;
  }
}
_CBC_iv = new WeakMap, _CBC_lastBlock = new WeakMap;
// node_modules/aes-js/lib.esm/mode-ctr.js
var __classPrivateFieldSet4 = function(receiver, state, value15, kind28, f4) {
  if (kind28 === "m")
    throw new TypeError("Private method is not writable");
  if (kind28 === "a" && !f4)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind28 === "a" ? f4.call(receiver, value15) : f4 ? f4.value = value15 : state.set(receiver, value15), value15;
};
var __classPrivateFieldGet4 = function(receiver, state, kind28, f4) {
  if (kind28 === "a" && !f4)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind28 === "m" ? f4 : kind28 === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
};
var _CTR_remaining;
var _CTR_remainingIndex;
var _CTR_counter;

class CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, CTR);
    _CTR_remaining.set(this, undefined);
    _CTR_remainingIndex.set(this, undefined);
    _CTR_counter.set(this, undefined);
    __classPrivateFieldSet4(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet4(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet4(this, _CTR_remaining, __classPrivateFieldGet4(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet4(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet4(this, _CTR_counter, "f"));
  }
  setCounterValue(value15) {
    if (!Number.isInteger(value15) || value15 < 0 || value15 > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index2 = 15;index2 >= 0; --index2) {
      __classPrivateFieldGet4(this, _CTR_counter, "f")[index2] = value15 % 256;
      value15 = Math.floor(value15 / 256);
    }
  }
  setCounterBytes(value15) {
    if (value15.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet4(this, _CTR_counter, "f").set(value15);
  }
  increment() {
    for (let i3 = 15;i3 >= 0; i3--) {
      if (__classPrivateFieldGet4(this, _CTR_counter, "f")[i3] === 255) {
        __classPrivateFieldGet4(this, _CTR_counter, "f")[i3] = 0;
      } else {
        __classPrivateFieldGet4(this, _CTR_counter, "f")[i3]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a2, _b2;
    const crypttext = new Uint8Array(plaintext);
    for (let i3 = 0;i3 < crypttext.length; i3++) {
      if (__classPrivateFieldGet4(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet4(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet4(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet4(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i3] ^= __classPrivateFieldGet4(this, _CTR_remaining, "f")[__classPrivateFieldSet4(this, _CTR_remainingIndex, (_b2 = __classPrivateFieldGet4(this, _CTR_remainingIndex, "f"), _a2 = _b2++, _b2), "f"), _a2];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
}
_CTR_remaining = new WeakMap, _CTR_remainingIndex = new WeakMap, _CTR_counter = new WeakMap;
// node_modules/aes-js/lib.esm/padding.js
function pkcs7Strip(data12) {
  if (data12.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data12[data12.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data12.length - padder;
  for (let i3 = 0;i3 < padder; i3++) {
    if (data12[length + i3] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data12.subarray(0, length));
}
// node_modules/ethers/lib.esm/wallet/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad(value15, length) {
  value15 = String(value15);
  while (value15.length < length) {
    value15 = "0" + value15;
  }
  return value15;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object14, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  const path2 = match[1];
  const type50 = match[3];
  const reqd = match[4] === "!";
  let cur = object14;
  for (const comp of path2.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key in cur) {
        if (key.toLowerCase() === comp) {
          found = cur[key];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path2);
  if (type50 && cur != null) {
    if (type50 === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type50 === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type50 === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type50 === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type50 === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type50} `, "path", path2);
  }
  return cur;
}

// node_modules/ethers/lib.esm/wallet/json-keystore.js
function isKeystoreJson(json2) {
  try {
    const data12 = JSON.parse(json2);
    const version2 = data12.version != null ? parseInt(data12.version) : 0;
    if (version2 === 3) {
      return true;
    }
  } catch (error23) {
  }
  return false;
}
function decrypt(data12, key, ciphertext) {
  const cipher = spelunk(data12, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk(data12, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data12, _key) {
  const key = getBytes(_key);
  const ciphertext = spelunk(data12, "crypto.ciphertext:data!");
  const computedMAC = hexlify(keccak256(concat2([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data12, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt(data12, key.slice(0, 16), ciphertext);
  const address23 = computeAddress(privateKey);
  if (data12.address) {
    let check11 = data12.address.toLowerCase();
    if (!check11.startsWith("0x")) {
      check11 = "0x" + check11;
    }
    assertArgument(getAddress(check11) === address23, "keystore address/privateKey mismatch", "address", data12.address);
  }
  const account = { address: address23, privateKey };
  const version2 = spelunk(data12, "x-ethers.version:string");
  if (version2 === "0.1") {
    const mnemonicKey = key.slice(32, 64);
    const mnemonicCiphertext = spelunk(data12, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk(data12, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk(data12, "x-ethers.path:string") || defaultPath,
      locale: spelunk(data12, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data12) {
  const kdf = spelunk(data12, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk(data12, "crypto.kdfparams.salt:data!");
      const N4 = spelunk(data12, "crypto.kdfparams.n:int!");
      const r = spelunk(data12, "crypto.kdfparams.r:int!");
      const p = spelunk(data12, "crypto.kdfparams.p:int!");
      assertArgument(N4 > 0 && (N4 & N4 - 1) === 0, "invalid kdf.N", "kdf.N", N4);
      assertArgument(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk(data12, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N4, r, p, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk(data12, "crypto.kdfparams.salt:data!");
      const prf = spelunk(data12, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk(data12, "crypto.kdfparams.c:int!");
      const dkLen = spelunk(data12, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync(json2, _password) {
  const data12 = JSON.parse(json2);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data12);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count, dkLen2, algorithm);
    return getAccount(data12, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N4, r, p, dkLen } = params;
  const key = scryptSync(password, salt, N4, r, p, dkLen);
  return getAccount(data12, key);
}
function stall3(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
async function decryptKeystoreJson(json2, _password, progress) {
  const data12 = JSON.parse(json2);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data12);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall3(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf2(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall3(0);
    }
    return getAccount(data12, key2);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N4, r, p, dkLen } = params;
  const key = await scrypt5(password, salt, N4, r, p, dkLen, progress);
  return getAccount(data12, key);
}
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes3(32);
  let N4 = 1 << 17, r = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N4 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  assertArgument(typeof N4 === "number" && N4 > 0 && Number.isSafeInteger(N4) && (BigInt(N4) & BigInt(N4 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N4);
  assertArgument(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return { name: "scrypt", dkLen: 32, salt, N: N4, r, p };
}
function _encryptKeystore(key, kdf, account, options) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes3(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes3(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat2([macPrefix, ciphertext]));
  const data12 = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client34 = options.client != null ? options.client : `ethers/${version}`;
    const path2 = account.mnemonic.path || defaultPath;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes3(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = new Date;
    const timestamp = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data12.address;
    data12["x-ethers"] = {
      client: client34,
      gethFilename,
      path: path2,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data12);
}
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
async function encryptKeystoreJson(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt5(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
var defaultPath = "m/44'/60'/0'/0/0";

// node_modules/ethers/lib.esm/wallet/hdwallet.js
function zpad2(value15, length) {
  let result = "";
  while (value15) {
    result = Nibbles2[value15 % 16] + result;
    value15 = Math.trunc(value15 / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value) {
  const value15 = getBytes(_value);
  const check11 = dataSlice(sha2565(sha2565(value15)), 0, 4);
  const bytes5 = concat2([value15, check11]);
  return encodeBase58(bytes5);
}
function ser_I(index2, chainCode, publicKey, privateKey) {
  const data12 = new Uint8Array(37);
  if (index2 & HardenedBit) {
    assert(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data12.set(getBytes(privateKey), 1);
  } else {
    data12.set(getBytes(publicKey));
  }
  for (let i3 = 24;i3 >= 0; i3 -= 8) {
    data12[33 + (i3 >> 3)] = index2 >> 24 - i3 & 255;
  }
  const I = getBytes(computeHmac("sha512", chainCode, data12));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node, path2) {
  const components = path2.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path2);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path2);
    components.shift();
  }
  let result = node;
  for (let i3 = 0;i3 < components.length; i3++) {
    const component = components[i3];
    if (component.match(/^[0-9]+'$/)) {
      const index2 = parseInt(component.substring(0, component.length - 1));
      assertArgument(index2 < HardenedBit, "invalid path index", `path[${i3}]`, component);
      result = result.deriveChild(HardenedBit + index2);
    } else if (component.match(/^[0-9]+$/)) {
      const index2 = parseInt(component);
      assertArgument(index2 < HardenedBit, "invalid path index", `path[${i3}]`, component);
      result = result.deriveChild(index2);
    } else {
      assertArgument(false, "invalid path component", `path[${i3}]`, component);
    }
  }
  return result;
}
function getAccountPath(_index) {
  const index2 = getNumber(_index, "index");
  assertArgument(index2 >= 0 && index2 < HardenedBit, "invalid account index", "index", index2);
  return `m/44'/60'/${index2}'/0/0`;
}
function getIndexedAccountPath(_index) {
  const index2 = getNumber(_index, "index");
  assertArgument(index2 >= 0 && index2 < HardenedBit, "invalid account index", "index", index2);
  return `m/44'/60'/0'/0/${index2}`;
}
var defaultPath2 = "m/44'/60'/0'/0/0";
var MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
var HardenedBit = 2147483648;
var N4 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Nibbles2 = "0123456789abcdef";
var _guard6 = {};

class HDNodeWallet extends BaseWallet {
  publicKey;
  fingerprint;
  parentFingerprint;
  mnemonic;
  chainCode;
  path;
  index;
  depth;
  constructor(guard22, signingKey, parentFingerprint, chainCode, path2, index2, depth, mnemonic2, provider5) {
    super(signingKey, provider5);
    assertPrivate(guard22, _guard6, "HDNodeWallet");
    defineProperties(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd1603(sha2565(this.publicKey)), 0, 4);
    defineProperties(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path: path2,
      index: index2,
      depth
    });
    defineProperties(this, { mnemonic: mnemonic2 });
  }
  connect(provider5) {
    return new HDNodeWallet(_guard6, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider5);
  }
  #account() {
    const account = { address: this.address, privateKey: this.privateKey };
    const m3 = this.mnemonic;
    if (this.path && m3 && m3.wordlist.locale === "en" && m3.password === "") {
      account.mnemonic = {
        path: this.path,
        locale: "en",
        entropy: m3.entropy
      };
    }
    return account;
  }
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(this.#account(), password, { progressCallback });
  }
  encryptSync(password) {
    return encryptKeystoreJsonSync(this.#account(), password);
  }
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat2([
      "0x0488ADE4",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      concat2(["0x00", this.privateKey])
    ]));
  }
  hasPath() {
    return this.path != null;
  }
  neuter() {
    return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  deriveChild(_index) {
    const index2 = getNumber(_index, "index");
    assertArgument(index2 <= 4294967295, "invalid index", "index", index2);
    let path2 = this.path;
    if (path2) {
      path2 += "/" + (index2 & ~HardenedBit);
      if (index2 & HardenedBit) {
        path2 += "'";
      }
    }
    const { IR, IL } = ser_I(index2, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N4, 32));
    return new HDNodeWallet(_guard6, ki, this.fingerprint, hexlify(IR), path2, index2, this.depth + 1, this.mnemonic, this.provider);
  }
  derivePath(path2) {
    return derivePath(this, path2);
  }
  static #fromSeed(_seed, mnemonic2) {
    assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
    const seed = getBytes(_seed, "seed");
    assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
    const I = getBytes(computeHmac("sha512", MasterSecret, seed));
    const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
    return new HDNodeWallet(_guard6, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic2, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes5 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes5.length === 82 || encodeBase58Check(bytes5.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes5[4];
    const parentFingerprint = hexlify(bytes5.slice(5, 9));
    const index2 = parseInt(hexlify(bytes5.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes5.slice(13, 45));
    const key = bytes5.slice(45, 78);
    switch (hexlify(bytes5.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key);
        return new HDNodeVoidWallet(_guard6, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index2, depth, null);
      }
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new HDNodeWallet(_guard6, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index2, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  static createRandom(password, path2, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (path2 == null) {
      path2 = defaultPath2;
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn.wordlist();
    }
    const mnemonic2 = Mnemonic.fromEntropy(randomBytes3(16), password, wordlist3);
    return HDNodeWallet.#fromSeed(mnemonic2.computeSeed(), mnemonic2).derivePath(path2);
  }
  static fromMnemonic(mnemonic2, path2) {
    if (!path2) {
      path2 = defaultPath2;
    }
    return HDNodeWallet.#fromSeed(mnemonic2.computeSeed(), mnemonic2).derivePath(path2);
  }
  static fromPhrase(phrase, password, path2, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (path2 == null) {
      path2 = defaultPath2;
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn.wordlist();
    }
    const mnemonic2 = Mnemonic.fromPhrase(phrase, password, wordlist3);
    return HDNodeWallet.#fromSeed(mnemonic2.computeSeed(), mnemonic2).derivePath(path2);
  }
  static fromSeed(seed) {
    return HDNodeWallet.#fromSeed(seed, null);
  }
}

class HDNodeVoidWallet extends VoidSigner {
  publicKey;
  fingerprint;
  parentFingerprint;
  chainCode;
  path;
  index;
  depth;
  constructor(guard22, address23, publicKey, parentFingerprint, chainCode, path2, index2, depth, provider5) {
    super(address23, provider5);
    assertPrivate(guard22, _guard6, "HDNodeVoidWallet");
    defineProperties(this, { publicKey });
    const fingerprint = dataSlice(ripemd1603(sha2565(publicKey)), 0, 4);
    defineProperties(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path: path2,
      index: index2,
      depth
    });
  }
  connect(provider5) {
    return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider5);
  }
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat2([
      "0x0488B21E",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  hasPath() {
    return this.path != null;
  }
  deriveChild(_index) {
    const index2 = getNumber(_index, "index");
    assertArgument(index2 <= 4294967295, "invalid index", "index", index2);
    let path2 = this.path;
    if (path2) {
      path2 += "/" + (index2 & ~HardenedBit);
      if (index2 & HardenedBit) {
        path2 += "'";
      }
    }
    const { IR, IL } = ser_I(index2, this.chainCode, this.publicKey, null);
    const Ki = SigningKey.addPoints(IL, this.publicKey, true);
    const address23 = computeAddress(Ki);
    return new HDNodeVoidWallet(_guard6, address23, Ki, this.fingerprint, hexlify(IR), path2, index2, this.depth + 1, this.provider);
  }
  derivePath(path2) {
    return derivePath(this, path2);
  }
}
// node_modules/ethers/lib.esm/wallet/json-crowdsale.js
function isCrowdsaleJson(json2) {
  try {
    const data12 = JSON.parse(json2);
    if (data12.encseed) {
      return true;
    }
  } catch (error23) {
  }
  return false;
}
function decryptCrowdsaleJson(json2, _password) {
  const data12 = JSON.parse(json2);
  const password = getPassword(_password);
  const address24 = getAddress(spelunk(data12, "ethaddr:string!"));
  const encseed = looseArrayify(spelunk(data12, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json2);
  const key = getBytes(pbkdf2(password, password, 2000, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i3 = 0;i3 < seed.length; i3++) {
    seedHex += String.fromCharCode(seed[i3]);
  }
  return { address: address24, privateKey: id(seedHex) };
}
// node_modules/ethers/lib.esm/wallet/wallet.js
function stall4(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}

class Wallet extends BaseWallet {
  constructor(key, provider5) {
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    let signingKey = typeof key === "string" ? new SigningKey(key) : key;
    super(signingKey, provider5);
  }
  connect(provider5) {
    return new Wallet(this.signingKey, provider5);
  }
  async encrypt(password, progressCallback) {
    const account = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson(account, password, { progressCallback });
  }
  encryptSync(password) {
    const account = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync(account, password);
  }
  static #fromAccount(account) {
    assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
    if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
      const mnemonic3 = Mnemonic.fromEntropy(account.mnemonic.entropy);
      const wallet2 = HDNodeWallet.fromMnemonic(mnemonic3, account.mnemonic.path);
      if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
        return wallet2;
      }
      console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
    }
    const wallet = new Wallet(account.privateKey);
    assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
    return wallet;
  }
  static async fromEncryptedJson(json2, password, progress) {
    let account = null;
    if (isKeystoreJson(json2)) {
      account = await decryptKeystoreJson(json2, password, progress);
    } else if (isCrowdsaleJson(json2)) {
      if (progress) {
        progress(0);
        await stall4(0);
      }
      account = decryptCrowdsaleJson(json2, password);
      if (progress) {
        progress(1);
        await stall4(0);
      }
    }
    return Wallet.#fromAccount(account);
  }
  static fromEncryptedJsonSync(json2, password) {
    let account = null;
    if (isKeystoreJson(json2)) {
      account = decryptKeystoreJsonSync(json2, password);
    } else if (isCrowdsaleJson(json2)) {
      account = decryptCrowdsaleJson(json2, password);
    } else {
      assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return Wallet.#fromAccount(account);
  }
  static createRandom(provider5) {
    const wallet = HDNodeWallet.createRandom();
    if (provider5) {
      return wallet.connect(provider5);
    }
    return wallet;
  }
  static fromPhrase(phrase, provider5) {
    const wallet = HDNodeWallet.fromPhrase(phrase);
    if (provider5) {
      return wallet.connect(provider5);
    }
    return wallet;
  }
}
// node_modules/ethers/lib.esm/wordlists/bit-reader.js
function decodeBits(width, data12) {
  const maxValue2 = (1 << width) - 1;
  const result = [];
  let accum = 0, bits2 = 0, flood = 0;
  for (let i3 = 0;i3 < data12.length; i3++) {
    accum = accum << 6 | Base64.indexOf(data12[i3]);
    bits2 += 6;
    while (bits2 >= width) {
      const value15 = accum >> bits2 - width;
      accum &= (1 << bits2 - width) - 1;
      bits2 -= width;
      if (value15 === 0) {
        flood += maxValue2;
      } else {
        result.push(value15 + flood);
        flood = 0;
      }
    }
  }
  return result;
}
var Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";

// node_modules/ethers/lib.esm/wordlists/decode-owla.js
function decodeOwlA(data12, accents) {
  let words2 = decodeOwl(data12).join(",");
  accents.split(/,/g).forEach((accent) => {
    const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
    assertArgument(match !== null, "internal error parsing accents", "accents", accents);
    let posOffset = 0;
    const positions = decodeBits(parseInt(match[3]), match[4]);
    const charCode = parseInt(match[2]);
    const regex = new RegExp(`([${match[1]}])`, "g");
    words2 = words2.replace(regex, (all, letter) => {
      const rem = --positions[posOffset];
      if (rem === 0) {
        letter = String.fromCharCode(letter.charCodeAt(0), charCode);
        posOffset++;
      }
      return letter;
    });
  });
  return words2.split(",");
}

// node_modules/ethers/lib.esm/wordlists/wordlist-owla.js
class WordlistOwlA extends WordlistOwl {
  #accent;
  constructor(locale, data12, accent, checksum2) {
    super(locale, data12, checksum2);
    this.#accent = accent;
  }
  get _accent() {
    return this.#accent;
  }
  _decodeWords() {
    return decodeOwlA(this._data, this._accent);
  }
}
// node_modules/ethers/lib.esm/wordlists/lang-cz.js
var words2 = "0itatkastcenaovo$taouleraeki&chor*teci%enbalodaeladet'!Chn=0Di#%E%^1Resa2Rese3CeT'#0EjKohol0Pu)%0A&sDul#Ekdo)Ke)Ti#Ul|3}aOgan%0FaltI$@tPi,%TmaTronom0LasL{i#Ol0Tobus4Yl:B#}<CilCul#D!_Ge)GrHnoKterieLa^L{#LkonLon-LvanLzaMbusNkom!R[rR{RmanRokoRvaTer#TohVl&Zal#Zili#Zu#3D&RanSe^StieTonZin#ZmocZ)k3CyklD]Ft-KinyLan%Og,fO]gTvaZon2AhobytAt*/E/aEdu+EskIk!Iz&Ok|Oud Ud2B-BrDl.D~H!(JkotJ|K<ysLe$R>R'?TaUb_U/!U^U+Ur!Xer2A^v#Ambo,An#AtrEp)Ike)KoLohOnzOskevUn{#Usin#Z^Zy2Bl.Bn|})D _D#D'aF{Jar(Kv?LdokLvaN^NkrRzaTikVolZola3D+tL.T'#0Ukot:PartRev&3DrDu+J/JnLaLerLkemLn?N.Nn(N'#NtrumNz<StopisT#2AlupaAp`]Ar aA)E/t!EmieI/otIrurgL`Le[Lub M_Mu,ObotO/olOd[O+,Om=Op Oro[OvRapotRl RtRupTiv(Ud.Utn!V!Vil#V(Y[Y$!Yt 0Bu+Gare)H_&HlaNkotRkusSter&Ta%TrusZin>Z(2O&2KolivUv!4It_N(0Dn(Ke)KrPot0Ak~AlIkRkot2Kli$a:L-oRe[T_Tum1E,1B!a}'#Cib_Fic Fla%KlKr{Mokr!PreseRbyS#T-tiv3Kob,zKt|O^P]mSkSp+jV`]Vo/2AhaOuhoUhopis1Es0BroByt-C@t}ut DnesH+dHo^H,JemJn?Kl`KolaKt<Kum@tLarLevaL.MaM.ntMluv M'Nut P`PisPln PosudPr'odPu$ Raz R(RtSahSl'St!-SudSy)TazT-Tk~Uf!Utn!Voz%Z`uZn!Z<%2Aho)AkAm!ikAv>AzeDolObn(OgerieOzdSn(T Z(2B@}'noD-HaH'#S SnoT(0Oj?Or>2Nam :9O]gOnomie0EktronIpsa0AilIseO%P!ie2Izo^O/aOpejOs2EjEn%K<)Kymo0Ike)0F<ie0Olu%1Eku%KurzePed?P]zeP<tT,kt:C#Jf#Kul)N!ikN)zieRmacieV< Zo+3De,%J{onN#3Al#Gu,ntLozofLtrNan%N)Xa%0Ord1An_IrtOtila2NdSf<T[lT#Ton2Ak%Es#On)2KarNk%3Zi#:LejeRant3N{i#O]g3Lot.2Azu,Ejt2LemLfi$aTi#2AfAmofonAnu+EpIlOgOtes#2Ma:D?DrLaL@#N[NopisRfaRpu&V,n3Bk(J#lJnoJtmanK)rLmaM!omR>R&S]Zky3St<ik2Ad'#AsivkyAvaEd!EnO^v>OhOup(T!Ub.U/o)0AtO)Yz0IsOjivoOut0Bl.Boj}DinyDl!Dno)D|Jn(KejLin#L#LubMo+N [No,%RalR^RizontRkoRliv>RmonRn.RoskopR$voSpo^St.T'(U[UfUp!Us#V<2Ad[An?Av(Az^Bo+kD.D]D(N-Ob#Oma^OtOu^Oz@St#Ub(Yz!2B@(B~D[KotMrS aSto)0Ozd2Bn(D,ntGie&M&Sterik:2Yl#3Ned2O&0Uze0Un a0F-%Fla%KasoOva%Sp-%Tern{Vali^Ve$<Zer%3Onie:Blko})Ho^Kmi+K(L'>N)rRmarkRoSanSnoT#V<Zyk3Din>D+Dn!_HlanKotL@L oMn(NomP?S{erV Zd>Zero3NakNdyNo/Sk,Sto)Trn?Zva3En|1Gurt5R):Bar{B_Bin{}&D{Did]HanJakJu)KaoKtusLam aLhotyLibrLn(Me,MkolivM&Ni[lNoeNt<Pal.P_aP olaP#P+Po)PrPu$aPy[,Ram_Rot#RtonSaTa]gTed,U%UzaVa+cZaj#Ze)Ziv(2EkolivEsi0Dlub@MpRami#3No2A%kAdivoAmApotAsi#AunEcEn[Ep!Es~IdImaIs&Ob*kO#nOpaOubUb'&Us!Uzk(0EnIt!Otr0IhaOt0Al?Ber>B#BlihaBylaC*rH=J@>KosKtejlLapsLe^LizeLoMandoMe)MikMn!aMo,MpasMun aN!N%ptNd?N>NfeseNgresN.NkursN)ktNzervaPan>PieP~Pr'#Rb_R-t<Rmid]RoptevRpusRu&RytoRz{S!>St#T_T+)T*lUk!Up_&Us-Uz]VbojZaZ<oh2Ab?A/Aj.Al|AsopisAv!aEd EjcarEs[Eve)Ik{ItikIzeKav>Me+cMivoOcanOkOni#Op OupaOv#T-Uh`]Up?Ut(Vin#Y/+Yp)Y$alYt2Dlan#FrJn(KlaLaj^Li/L#Lom{Ltu,NaPodivuRtRz<Til0Al aAsin#E$<2No]gS_.Ta,T?T#T'>V`]:B,d<})nDn(IkKom>M_aMpaN'#S?SoStu,Tin#V.3B#CkdyD@Dn?D'#Dv.G@^GieG,%H%Hk(H~KtvarNo/odNtil#P@#Pid]T`]T>TmoTokruhVhartV a%Vobok3B,}ot#DojedDsk(H'.Jav>L-M{#NieN#No+umStop`T.T|5Bi$aDivodGi#GopedKal aK{Mc|P!aPu/RdSosTrU^lUhU#Usk!V>3Tiv(1Cer&CiferMpSkSt,%0I%2RaRi#S.:DamD]Gi$rHagonJ{-J _J< aKakK'?Kr_aL[L.L|Lv?Min#Nd+NkoRn(SakrSkotSopu$T?Tri#Tur aZan>ZivoZl Zur#2Lo[0}anikD a%D'.LasaL*nNtol#TlaTo^TrZe,3G,%H~Hu+K.KrofonL@>Lim{rL(Mi#Nc'&Ni[rNom{Nul(S#StrX|2Ad(HaH'.OkS!Uv 1I/Ohem0BilCn(D_#Dl [HylaKroL-ulaM@t#Nar/aNoklN$rumNt|NzunSazSkytStTiva%T<#Ty#U/aUdr(Zai#Z-Zol2Am<Av@>KevTvolaZ{Zut(0T _1DrcF]nL!MieN?S{Ta%ZeumZi#nt3Sliv>0Da:B*r!}yt!Da%Dbyt-DhozDobroDpisHlasHn!Hodi+H,d Iv aJedn*Ji$oJm=K]n Kon>Krm LevoMaz!Mluv Nom{rOkoOpakO$roP`!PevnoPln P~Pos+dPr(oRod RubyRy/]S` S-!S+poSt!TolikV@-Vr/Vzd<yZv!3Be}!CkyDa+koDb!DuhGa%H{Ho^J@JprveKlidLib(Mil(MocO/o)On#PokojR(RvSmyslS*l`Tv<UronV.Zvyk+3Co)JakKamKdyKlKte,kTro5C+hHav?M.%RaR-S _Sn(UzeVinyVo)Zd,5DaD+G{T Tn(Trie3Mfa:0AlArv AvaDivEcEhn!Ejm=Ez aHajo[Iln?Jasn J-tK]p La$L-Li[LohaLu^NosOh! Oj-OutRaz>R&Ru[RysSahSluhaS)r!UvVazVin VodVyk+Yv!_Z<0AsElEn Hl` Ho)H,&It~0BojByt}odCiz Ebr!Esl!Evzd!EzvaH`%Hod J{JinudKazK*p LivLu#Ml#Oln(P`PisPl=P<Pu$ Pyk!Raz#S*d StupSunTokTudVahaVe)Vol!V,%tZ&k1I&Sajd1LasNiskoRa^Roz Ryz-2ApEn?Li#NoOuzl OvyRasaResRs-RuhUpantUr#Us 0Ejn.Iz|0AkE+)Ez L`.L*v!LuvaYl0Ehdy1Ak|As-E,%I%Il(Is|O,Oz?RavduRoti1B al}e$rGieL?LojT_0A^}~I#IvoLavaLep Ln L' N'aO[Ol Pa+cT@T,haTu^Ty/Voj 0Epl IskOpRh!Rl(RokRubyV<1A~ArEsLivn O%1Id1Do[:}!_Ci@tD*/H<-KtLan^L>LivoLu[Mf+tMls-N@#Ni#N&N|N$voNtof+Pri#Rke)RodieR)Ru#Ry[Se#Siv aSt_#T@tTro&V*kZnehtZ*r-3C#DagogJs-K]LotonNal)Ndr-NzeRiskopRoStr(Tar^T?Tro+jVn.Xeso3Ani$aHaJav?K+KnikL.Ln(Lul#Nze)Pe)S!_Sto+Tev&Vn?V'ar2A%n)Ak!Am@Ane)A$i#At Avid]AzE/Em@oEn)EsEtivoEv_Iv!N NoO/aOd.Om[OutUkYn2Bav Byt}odC Ctiv>D!D%n Deps!Dh+dDiv Dkl`Dman DnikDo[Dpo,D,zD$!aDvodDzimEzieHan#Hnut#H'<HromaHybIn)Ji$#Jm=Kaz K+sKojKrokKu)KynLedneLib-Lk~LohaLynomMaluMi~Ml#MocM$aMys+tNe/!N<#Nur(P`!P_Pis-Pla/Pros Ps!PudR`%R%RodRu/aRyvS` SedSilaSkokSlan>S*d SpoluS)vaSud-SypTahT#nT+skTom-T,vaTupaTvo,U#zUtoUzdroVahaVidlaVlakVozVr/V$!VykVzde/Zd,vZem-Zn!-Z<Zv!2Ac|Ah<yAkti#A+sAot>Ap<-AseAv^IncipKnoObud O%ntoOdejOfeseOh,Oj-tO]m Omi+Onik!Op`OrokOs[OtonOut-OvazS#v#St@Udk(UtV-Voh<y0An>OvodTruh0Actvo0Ber)}DlKav>Kl.Kr+LtMpaNcP@SaSin#St.T|Ty#3Rami^SkT_::C-}otDia%Dn?DonFtGbyKe)K'.M@oMp*/NdeRa/R aS'&StrTo+$Zan%Zid]3Ag|Ak%CeptDakt<Fer@tF+xJnokKlamaK<dKrutKt<Pu)%VizeVmaVolverZerva3Sk|Ziko5Boti#Dokm@H'#K+KokoMan{oP'odPu/aRejsSolStl.Tmi$rTopedTun^Ub@#U/oUpU,V.Vn?Zb<Z/odZd!Zezn!Zhod%Zin#ZjezdZ#zZ]haZmarZp`Zru/ZsahZtokZumZvod5Bri#}`]Kav?Kopis3BaBol'}l(D]P`]T.Z(:Di$aH!KoM>Mizd!Mo)N #Rdin#San#T_ Z[Z@?0Or0H|1B,n#CeseD`]Dim@tD]Hn!Jm=Ke,K)Kun^KvojeM@oNoRvisS` Sho,SkokSl!St,SuvSyp!T[T.Tk!T~Trv!VerZ&m2O^R~0FonLn?R#Rot-RupTua%1AfandrAliskoAnz@AutEptikIcaL`[L@?LoLuzO[O#nOroRip)RzUp.V(Vr&0Abi#Adid]An.A$Avn(Ed|Ep>EvaEz.IbI&Izn?OnOup-OvoU/UhaUn%Up#Za0A,gdE)&Il$voL*vaOgR`RkRt#Ut-Ysl0AdAhaOb0Bo)}aD'#KolP#TvaUbojUc Ud%UhlasUl`Um,kUp,vaUsedUtokUvis{0Al'&As _IsLavOd-Oj@>OluOnz<Orn(Ou$aR/aU$ 1An^AzD%NaN>Ovn!P@StUb1An?Ar(aAti#Av[EhnoEz#OdolaO+kOpaOrnoOup!Ra/ResRh~RomRu&Ud&Upn?VolYk0Bj-tBtropy}arD(KnoNd!N=Rik!aR'.0AhAl$voEtrAt[Az-Is+It-Obo^Odid]Or#Rab2Kav#KotN-N'>P!Pk(R'(S_T(:B+t#Bu+H*nJemnoJfunJgaJ Jn(Kti#Mh+MponNc|N>NkerPe)V@.Z!_3}ni#HdyKut.LefonMno)Nd@%Ni$aN<P])P&PrveRapieRmos#Xtil3}oSkopisTu+k1Ad+cAn.0Ap#Esk!UkotUpa0El1A+)Pin#PolRzoUhaU+c2Ad?Akt<AmpAsaAverzaEf E$Ez<Hav.Hl.O/uOj?Os#Ou[P%P _Pk(Ub>U/l Uhl?UsV!2DyH~H(Nd,Ri$aR&jZemsko0ArohOr[Rd(Rz2GrKev:0Oh(OzeR!R*s-RusYt'&0HoTiv(0Iv 3R` 1Edn!I$ M=0Az!_Lidn Lon Otv Roj 0I%I)Ov 0Yv`]0Av If<maIk~1Ad~L!n Ly~Out!Rav 1AnAz 0Ed~Il|Mrt N`n N=Oud Tl!Tr~0Ah|K!Lum O~Op@>R*s 1Al Oln Oz'#3D,v ElEn.L.N!:GonL/aL*nNaN^lNil#RanRhanyR|1ElkuHod0Ova0DroGe)%J%Lbl*dL{rhL _LmocLry[Nk'Ran^RzeS_#SkrzeSn?SpoduS)Ter.Ver#3B,%}rDeoh,D.D+LaN?S{Tal aZeZ #0Ezd0L`Us0Aj#AkAs>EvoHk(IvN'#Oup!1Uc|Uk0DaDiv(Doz&kD$voJ@skyJ&JskoLantL[L LnoSk'#Zid]Z'&0Ravo1Ab>A%tAhA)Ba}o+kH!StvaTu+0Ad T*p Tup0Ip4Bav Br!}|D!D,Fot H+d!H~Hod H,d Hub Jasn J{Jm=K]p Kon!L-!Maz!Mez Miz{Mys+tNe/!Nik!Nut P`!Pl! P,v Pu$ Raz R'n!Rv!Sl' SokoS)v Su~Syp!Tas Tes!Tr! Vi~Vol!Vrh_Zdob Zn!0AduBud }op D<Du/Dy/!E$upH+demKazLyk!NikOr-P*,TahT-::993Lofon::Br!Byd+t}|DarmoDus F*k!Hlt Hod H,^Hy~J!>J{Ji$ K+p!K*p Lep Mez Mot!Mys+tNe/!Nik!Pl! Poj Ps!Raz S)v Su~Taj Temn Tk~Ujm=Val Ve+tVin Vol!Vrt!Zvon 0Av RusuUd|Yt-1A+#ArmaAtn(IvoOb RojVihYm`]0L@.ManM.Pt!Z`uZdola2At Lt~Lubo#Ot' Ru[0MaMn?0Emn 0Lam!Oum!R!#Umav#0AtoEh#O[OmO$Ozvyk0Ap|ArAt-IjeIz{Ocn Odr!Rzl.Ut|0AkAl(Am@!Ovu0B,z Tav Ub-Ufa+0Lod Omal RavaR( Rud#Rvu1A^An C`]N (NoOv&Y/l Zav(1I/aR! 0B'.Br0Ed~EnkuEs_aOnR!Uk'odYk";
var checksum2 = "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a";
var wordlist3 = null;

class LangCz extends WordlistOwl {
  constructor() {
    super("cz", words2, checksum2);
  }
  static wordlist() {
    if (wordlist3 == null) {
      wordlist3 = new LangCz;
    }
    return wordlist3;
  }
}

// node_modules/ethers/lib.esm/wordlists/lang-es.js
var words3 = "0arertoiotadonoaRteirroenaNonaLsolocoiliaralaorrenadaChoN$n0A>Dom,EjaI!#Oga&O'Or#RazoR*Ue=U<0Ab Adem@Ce<C~Ei)ElgaEn#Ept I&L  NeOg!O<TivoToTrizTu Ud*U!&Us 0Ic#Mit*Opt Or'Ua`Ul#0Reo0Ect Ic~In Irm 0IlIt On@Os#Ot Reg R$UaU&U?aUja0OgoOr+0ReSl 0Ed_zE'Us)1Ac[nAmb_ArmaBaBumCaldeDeaEg_Ej Er%E%F?!GaGo&nIa&I,#Iv$MaMejaMib T TezaTivoToTu[Um'Z 0AbleAn)Apo]ArgoAs B Bi#E'IgoIs%dOrP oPl$0|oC@'C]D D,Em@Gu=Il=ImoIsOt T,aTiguoTojoUalUl Unc$Ad*EjoO1Ag A[#Eti#IoLic O&Or)OyoR,d!Rob Ues%U+1A&A`ArBit+BolBus#|ivoCoD!D?]DuoEaI&IesM.i-esOmaPaP.Reg=RozRugaTeTis%0AA&Al#C,<Egur EoE<rI,#I=Ist*NoOmb+P!oT?]T+Tu#Um*Un#0AjoAqueArEn#EoI>Le%OmoRa!RozUn0DazD$GeLaM,#S,)T^0AlAnceA+EEl]`E`EstruzI.I<2ErU{U'0Af[nArO)Uc Uf_Ul:BaB^|eH@IleJ Lanz/c.LdeMbuN>Nd-oRb(>RnizR+Scu]S#nSu[Tal]T!@T*Tu%UlZ 3BeBid/=S SoSt@3|oEnNgo2An>OqueUsa2ABi`BoCaCi`DaDegaIn//!oLsaMb-{dNi#N}saiRdeRr SqueTeTinVe{Zal2AvoAzoEchaEveIl=In>IsaOcaOmaOnceO)UjaUs>U#2CeoCleE'EyFan{F.HoIt_L#Rbuj(l(+Sc TacaZ.:Bal=BezaBi`B[CaoDav!D,aErFeI{ImanJaJ.LLam Lc$L&Li{dLleLm/^LvoMaMb$Mel=Mi'Mp}c!Nd?Nel-gu+Nic-#N-.ObaOsPazPi%nPo)Pt Puch((b.RcelRe%Rg(i'RneRpe%R+R%SaS>S!oSpaS#rT^ceT_U{lUsaZo3Bol]D!D+Ld/eb_Lo<Lu]M,#Niz-t+Rc(&Rez(oRr R)zaSpedT+2AcalAle>AmpuAnc]ApaAr]I>Is)IvoOqueOzaUle%Up 0Cl.EgoE=EnEr#F[G +M->NeN%P_sR>Rue]SneTaU{d2Am^AnA+AseAveI,)ImaInica2B_Cc~|i'Ci`CoDigoDoF_G!He)JinJoL/ch/eg$Lg Lin/l LmoLum`Mba)M!Mi{Mo&Mpr-deNej}g-oc!Nsej}t PaPi(az.Rba%RchoR&nR.(r!S!SmosS%2AneoAt!E Ec!Ei&EmaIaIm,Ip%IsisOmoOnicaOque%U&Uz2Ad+Ar#At+BoBr*| aEl=En#Er{Es%EvaId Lebr/p/#Mb_Mpl*N-e%O%P.Pul( R$<R<RvaTis:M-z(R&T?3B!B?Ca{C*DoF,saFin*J LfinLga&Li#M^-<N%lP^)RechoR+%Sayu'SeoSf?eSnu&Sti'Sv$TalleT,!U{3AAb=AdemaAman)A`Ar$BujoCt En)E%EzFic?G'Lem/u*N!oRec#Rig*S>Se'Sf[zVaVi'5BleCeL^Ming}N Ra&Rm*R<SSis2Ag.Oga2|aDaE=E'LceOQueR Rez(o:0A'R$0H OUa&r0AdIc~Ific$I#rUc 1Ec#Icaz3EEmp=1Efan)Eg*Em,#Ev IpseI)Ix*Og$Ud*0Bu&It*Oc~Pa)Pe'PleoP_sa0A'C go|ufeC@EmigoE+Fa&F!moGa'Igm/aceOrmeRe&SayoS, T!oTr VaseV$1Oca0Uipo0Izo0Ca]C,aCol Crib*Cu&Enc@F!aFu!zoPa{PejoP@PosaPumaQuiT TeTi=Tufa0ApaEr'Ic-@1Ad*Alu En#It 1Ac#Am,Ce<CusaEn#Ig*Il$Ist*I#P!#Plic P.!T_mo:BricaBu]|a{C?C#rE`J/d/=L<Lt MaM?@Mo<Ra.Rmaci(olRsaSeTigaU`V^X3Br!o|/izORi(ozRt?Rv^Stin3AbleAnzaArB[Cc~|aDeoEb_ElE[Es%Gu[J JoL/e)L@lLt+NNc-g*Ni#Rma2A>Au%EchaOrO%U*UjoU^2B@CaGa%G.L$Lle#N&Rm(+Rtun(z SaTo2Aca<Ag?AnjaAseAudeE*E'EsaIoI#U%2EgoEn)ErzaGaM Nc~Nd(g.R@S?TbolTu+:Ce]FasI%JoL/!i/=Mb- Nch}g-<RajeRzaSoli`St ToV?an3Me=M*NN!}$N)Ran$R,)Rm,S#3Gan)M`s$R Ro2Aci OboOr@2LLfoLo<LpeM(&R?([TaTeoZ 2A{Afi>A'AsaAtisAveIe%Il=IpeIsI#O<rUaUe<UmoUpo2An)ApoArd@Er[IaI'I.I<It [Sa'St :B!B?Bl C!|aD/l Mac(i`ZZa`3B?]B[|oLa&L$Mbr(*Rma'RoeRv*3E=Er+Ga&Gi,eJoM'S#r@5Ci>G Gu!aJaMb_Ng}^Nr((mig('St?Yo5E>ElgaEr%E<EvoI{IrMa'Me&M?deM}d*RacanR#:1O'0EalIomaO=2Lesi/uUal4EgalUs~0Ag,AnIt P P!$P.!Pul<0CapazDiceEr)FielF^meG,$Ic$M,<MuneNa#Sec#S%n)T!esTimoTu*Ut?Vi!'3AIsOn@0L/o):BaliB.M.RabeRdinR[U]Zmin3FeRinga3Ne)5R`d(obaV,Ya5ErgaEvesEzGa&rGoGue)Ic$N>Ngl-$Nt Pit!R S#V,?Zg :7Lo5A]:B$C$C[DoD+nG #GrimaGu`I>M!Mi`Mp --ch-gos%NzaPizRgoRvaStimaTaTexT*U_lV Zo3AlCc~|eC#rErG~Gumb_Ja'Ngu-#NaOnOp &S~TalT[VeY,{3B!%dB+C^D!Di EnzoGaG!oMaMi)M.Mp$NceN&Ne-go)N}t!`Qui&SoS%T!aT$T+2AgaAmaAn#AveEg En Ev Or Ov!Uv@2BoC~CoCu[GicaG+MbrizM}jaTe5|aC*G J}-esPaSt+ToZ:Ce%|oD!aD_Du+Est+F@G@GoIzL{dLe%Ll/oMaMboMutN>N&Nej Ng-iquiNj N}<N%Na`PaQuin(R>Re(f?Rg,Ri&RmolR+nR)sRzoSaSc aSivoT T!@TizTrizXimoY^Z^ca3|aDal]D$Du]J?]J^L,/.M^i-^NsajeN)NuRca&R,gueRi#SS.TaT!To&T+Zc]3E&ElEmb+G/Lag+Lit Ll.M}-!}im}u#OpeR SaS!@S?SmoTadTo5|?aC~DaDe=HoJ LdeL!Li'M,#Mi- c-ed-j-#NoRad(d!Re'R*R+Rs(%lScaStr TivoV!V?Zo5|oD EbleE]Er)Est[G_J!L/e%L%N&Nec(alRoScu=SeoSgoSicaS=:C C~D IpeRanj(izRr SalTalTivoTu[lUseaValVeVi{d3C$Ct G Goc$G+OnRv$ToUt+V V!a3|oDoEb]E#NezNoTi&Vel5Bleza|eMin(i(m()TaTic@Va#Ve]V$5BeCaCleoD?=DoE[EveEzLoM!oTr@:Sis0E<IspoJe#R(!oS!v T,!V$0AA<Ea'H,%HoIoReTavoTub_Ul#Up Urr*0I IoIsea0S)0EnsaEr%Ic$Rec!0Ro1DoR0O1AEa{Fa#IvoLaMoOrVi&0Bligo0DaZa1A>C~E[In On!T TicaUes#1Ac~A&rAlBi%CaD,EjaGa'G@Gul=I,)Ig,Il]OQues%Uga0Ad@Cu+Ez'OT[0O'Ro1EjaU=1I&Ige'0En)0O':C#D_El]Gi`GoIsJ oLabr/>Le%Li&Lm/om/p NNalNi>Nt!-ue=PaPelP?]Que)R Rcel(edR*RoRpa&RqueR[foR)S SeoS~SoS%TaT$Tr@UsaU%VoYa<3A#nCa&C!a|oDalD*G IneL L{'Le/ig+LlejoLoLuc--s N.OnOrPi'Que'R(ch(d!Rez(f?Ri>Rl(mi<R+Rs.aSaScaSimoS%`Ta=T+leoZZu`3C |.EEd[Er`EzaJam/ Lo#Mi,%N}#rNz-aOjoP(a%S Sci`SoS%T.Zca2AcaAnA%AyaAzaEi#E'OmoUmaU[l2B_CoD!D$EmaEs@E%L,Lici/=LvoMa{Me=MoMp-!Rc~R%lSa{Se!SibleS)T,c@T+Zo2A&E>zEgun%Em$EnsaE<Ev$ImoIncipeIs~Iv OaOb Oce<Oduc#OezaOfe<rOg[maOleOmesaOn#Op$OximoUeba2Bli>|!oD^Eb=Er%Es#Lg/*Lm.LpoL<M-#NalNoPaP?(e:99Ed EjaEm Er!E<Ie#ImicaInceIt :Ba'B@BoC~DicalIzMaMp-ch}goPazPi&P#SgoSpaToYoZaZ.3Acc~Ali{dBa'Bo)Ca!Ce%|azoCog!C_oC#Cur<DD.&Duc*FlejoF^maF[nFug$Ga=G*G]G_<H,I'IrJ/a#LevoLieveLle'LojM Med$M}>rNd*N%P #Pet*Po<Pt?SSca)Si`Spe#S#Sum,T*oT^'T[#Un*VesVis%YZ 3CoEgoEn{EsgoFaGi&G^Nc.N.OQuezaSaTmoToZo5BleCeCi D DeoD?]ErJizoJoM!oMp!NN>N{PaP!oSaScaSt+T 5BiB^DoE{G*I&In/e%LoMboM^Ptu[TaTi`:Ba&B!B$BleC GazG[&L/&L!oL*Lm.L.Ls/#LudLv Mb-c~Ndi-e Ng_Ni{dN}#PoQueRdin()nSt_TanU`Xof.3Cc~CoC_#C%DGu*IsL=LvaMa`M?l-d-<rNalN^P  P@Qui(RieRm.Rv*S,%S~TaT,%V!oXoX#3D[Es%E)G=G'Lab/b L,c$L]Mbo=M$R,aS)maT$Tu 5B_C$D$LLap/{&Le{dLi&Lt Luc~Mbr-de}i&No+NrisaPaPl P^)R&Rp_s()oS)nTa'5AveB*Ce<D^Eg[E=E'Er)Fr*Je#L%nM P! Pl*P.!P_moRR>Re'Rg*S#T?:Ba>BiqueB]BuCoC#JoL L>L,#Ll/.Ma'Mb^Ng}quePaPe)P@P.Qu?l(deRe(if(je%RotR+R%TuajeU+ZaZ.3At+|oC]CnicaJa&J!Ji&L/efo'MaM^Mp=NazNd!N!NisN<Ori(api(>Rmi'Rnur(+rSisSo+StigoT!aX#Z3B$Bu+nEmpoEn{Er[E<G_J!/deMb_Mi&M}%OPi>PoR(.TanT!eTu=Za5Al]B?=C Ci'DoG/&M N}#P PeQueRaxR!oRm,%RneoRoRpe&R_R<RtugaSS>S!Xi>2AbajoAc#rA!Afi>AgoAjeAmoAnceA#AumaAz EbolEguaEin%EnEp EsIbuIgoIpaIs)IunfoOfeoOmpaOn>OpaO)OzoU>Ue'Ufa2B!@BoEr#MbaM^NelNic(bin(ismoR'T^:0Ic 9C!a0B[l0I{dIrIv!<OT A3Ba'BeG,)Na0ArU $0IlOp@1A:CaC$Cu`G GoI`J?l/eLi&LleL^Lvu]Mp*oR(i R.So3Ci'C#rHicu=In)JezL/!oLozN-c!Nd-e'Ng N*N%NusRRa'RboRdeRed(j(<Rt!3AAjeBr C$CtimaDaDeoDr$EjoErnesG^LLl-ag_N}e&OlinRalRgoRtudS^Sp!aS%Tami`U&VazV!oV*Vo5LcanLum,Lv!RazT ToZ5E=Lg :::C!Te3GuaM('So9DoGaGur:F*}jaPa#Rza93N(+5MoR&";
var accents = "aeiou7695@@BZWWavwUJkO@Y-Kn))YEGq#E@O)cI@#ZkMHv$e*))M!!)D**$GW!oKm*Acoh^k&It-pi^SYW)$^n!G)bO!Wkzam(jS#X)Og*^l^RW!bQ#QygBKXfzE))hti!Qm)Cng%%c)mJiI*HJWbmYniCLwNdYyY%WKO^bnT$PuGOr!IvHu&G(GKbtBuhiW&!eO@XMeoYQeCa#!MrTJCq!OW&CHG(WCcW%%)$rfrIegu$)w!G)JGmWWw)MnD%SXXWIT^LWAZuVWB^W)eTL^x&$WGHW(nKWEMA)#$F$x$Waekqs,n7715)W*HM-$WAcCiu(a))VCZ)GG%(*CWWdW%$D!UCO$M";
var checksum3 = "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300";
var wordlist4 = null;

class LangEs extends WordlistOwlA {
  constructor() {
    super("es", words3, accents, checksum3);
  }
  static wordlist() {
    if (wordlist4 == null) {
      wordlist4 = new LangEs;
    }
    return wordlist4;
  }
}

// node_modules/ethers/lib.esm/wordlists/lang-fr.js
var words4 = "0erreleontiteurinueiriet cegeanseali medenel q)eniluxaus ch0Ais}And$Diqu E`#Ol*Ord Ou%rOy RasifReuv Ri,Rog RuptS_-SoluS'@UsifYss=0A@m+AjouAr+nCab]Cep,Clam Cola@Cro~eCu}ErbeHatHe,Idu]I Omp&Qu *R$y?Te'TifT)l0Ep&EquatHesifJec%fJug Mett!M* Op,Or Ouc*Res<RoitUl&V be0R R$ef0Fai!Fec,Fi~eF!{Fub]0Ac Enc I#I,Raf Reab#Ru?1D Gu`#L>Mab#S/-0Ou,Us,1Arm Chim+Er&Geb!G)I_ I?ntLeg Lia.Lou Lum O'd*PagaTes<Veo#0A&'BiguB!Enag Ertu?Id$Ir=Orc O'Ovib#Phib+P#'Us/t0Aly<Apho!Ar~+Atom+C+nE/%rG#Gois<Gu#{Im=Nex N$-N)lOd(Om=+Ony?Orm=T_[Tido&X+{1Ai}Eri%fL/*Olog+Pa!`Pe]Por,Puy 0UariumUeduc0Bit!Bus&De'Doi<G_tLequ(Matu!Me?ntMoi!Mu!P_,Ra~ Riv Ro}S_icT +lTic#0PectPh=&P* S|tS v*S+t&Soc>S' TicotT!Tu-0El>O?RiumRo-Ta^T_%fT* Trap 0Ba(eB .Da-Dib#G' Ro!Tom[Tru~e0A]Anc Ari-En*Er<Eug#Ia&'I@I$I}O(eOu R`1I=Io?:D.Fou Ga.G)t&Igna@L/c Lc$Le(eLisa.Mb(Ncai!Nda.Nl+)Nn>eNqu>Rb>R`R$R^Rra.Ss(S%$Ta`#Te|T,+Udr>Vard 3Let&L>Lo&Nefi-R-|Rg Rl(eRmudaSa-Sog[Ta`Ur!3B $Cyc#Du#JouL/L(g)LlardNai!Olog+Ops+OtypeScuitS$Sto'iTu?Zar!2AfardAg)An~*Ess/tInd OndOqu Ous$2BardB(eI!I}Li@Nb$Nd*Nhe'Nif>NusRdu!R[T&Uc#Ue{Ug+Ul$Uqu(Ur<Usso#U%^Xe'2An~eAs>AveEbisE~eEuva.Ico]Iga@Ill/tIo~eI^O~u!Od Onz Ous<Oye'U?Us^Ut=Uy/t2Ff#Iss$L#%nRe|R(S% T( To*Vab#Vet&:B/$B(eChet&De|D!Fe(eIllouIss$Lcu]Lep(Lib!Lm Lomn+Lvai!Mara@M aMi$Mpag[N=Net$N$N%[NularPab#Por=Pri-Psu#P,Pu~eRab(eRb$eRes}RibouRna.Rot&R!|Rt$Sca@S>S^Ssu!U}U%$V=>V [Viar3D`#Intu!Les&Llu#Ndr>Ns' Ntr=Rc#Rebr=Ri<Rn Rve|S}2Agr(Ai<A#'Amb!An-Apit!Arb$As<'At$Auss$Av* Emi<En`#Equ>Er~ Ev=I_Iff!Ign$Im eIotLoru!OcolatOis*O<O)t&Ro?U&0Ga!Gog[M_,NemaNtr Rcu]R R^T [Toy_Tr$V`2A*$A?'Aqu As<Av>I_tIgn ImatIva.O~eOna.Opor&2B=tBraCas<Co% D Dif>Ff!Gn Hesi$Iff Inc L eLibriLl(eLma,L$elMbatMed+Mm/@MpactNc tNdui!Nf>N.]Nno,Ns$[NtactNvexePa(P+Ra`Rbe|Rda.Rni~eRpusR!ctR&.Smi^Stu?T$U@Upu!Ura.U&|Uvr*Yo&2AbeA(&Ava&Ay$Eatu!Edi,E?{Eu}Evet&Ib]I Ist=I,eOi!Oqu Ota#Uci=UelYp,2Bi^E`l*Il]eIs(eIv!Lm( L%v Mu]Pi@Ra%fR<'3Anu!C#L(d!Ni^:Ign M>Ng N<'Uph(3Batt!Bi,Bord Brid But/tC= Cemb!Ch* Cid Clar Cor Cri!Cup]Da#Duc%fEs<F_sifFi]Fray Gag Givr Glu%rGraf Jeun Li-Log M/d Me' Mol*Ni~ Nou N&l#Nud PartP_}Pha}Plac Po}R/g Rob Sast!S-n&S tSign Sobe*Ss( Str>Ta~ Tes,To' T!s<V/c V_*V( Vo*3Ab#Alog)Am/tC,Ff  G  Git=G[Lu M/~eM(u Oxy@Rec%fRig Scu,Spo}Ssip St/-V %rVi}5Ci#C&'G?IgtMa(eMici#Mp,Na&'Nj$Nn Pam(eRto*Ru!Sa.Se'Ss>Ta%$U/>Ub#U-'U,Y_2Ag$Ap Es}Ibb]Oitu!2P +P#xeRab#Rc*3Nas%e:0Lou*0Ar,HarpeHel#La* Lip<Lo!Lu<O#Onom+Or-Ou,Ra}Rem Riva(RouU?U!u`0If>Uqu 1Fac Fec%fFig+FortFray Fusi$0Ali}Ar 2Ec,1Abor Arg*Ectr$Eg/tEph/tEveIgib#I%s?O.Ucid Ud 0B=]Bell*Bry$Er|@Issi$M_ O%$Ouvo*P e'Ploy Por,Pri<Ulsi$0Cadr Ch eClaveCo~eDigu Dos}DroitDui!Erg+F/-F m Fou*Gag G(Glob Ig?Jamb JeuLev NemiNuye{Ri~*Roba.Seig[Tas}T_d!T>To' Trav Um  Vah*Viab#Voy Zy?0L+n0Aiss*Arg[At/tAu#Ic +I@m+I Ilog)I[Iso@ItapheO^ReuveRouv Uis/t0U !Uipe0Ig Osi$Re'Up%$0C=>Pad$Pe-P+g#Po*PritQuiv Say S_-S+uSor Ti?TomacTra@0Ag eA]An~eA%^E(d!Endo*Er[lH/olHi^Hn+Ir Off Oi#Onn/tO'd*R/.RoitU@0Phor+0Alu Asi$Enta`I@n-I,Olu%fOqu 1ActAg  Auc Cel]Cit/tClusifCu<Ecu,Emp#Erc H= Hor,I.n-I]Is,O%^Ped>Plor Po}Prim QuisT_sifTrai!Ul,:B#Bu#{Cet&Ci#Ctu!Ibl*Lai<Me{M`#R-'RfeluR(eRou~eSc( T=Tig)Uc$U%fVe'Vori3Bri#C$d D  L(M?M'Ndo*Od=Rm Ro-Rve'S%v=U`#Ut!Vr>3AscoCe]C%fDe#Gu!Latu!Leta.L>eL#ulLm LouLtr N/c N*O#R?Ssu!X 2A* Am?As^At&'E|E~eE'Exi$Oc$O!Uctu Ui@Uvi=2L+Nd +Ngib#Nta(eRc Rg $Rmu]Rtu[Ssi#Ud!Ug eU`]Ulu!Urmi2Agi#Ai<An~*App Aye'Ega&E( El$Em*E[s+E!Iab#Ic%$Iss$Ivo#OidOma.Ont=Ot,Uit2Gi%fI&Re'R+{R%fSi$T':Gn Lax+L +Mbad R/%rRd+nRn*Rrig)Zel#Z$3AntLa%[Lu#Ndar?N =N+NouN%lOlog+O?t!R/iumR?St)lY}3B>C]RafeV!2A-AiveIs}ObeOi!Or+{2Lfe'M?Nf]R.R`#Udr$Uff!UlotUp`#Urm/dUt&2Ad)lAffi%A(eAndApp(AtuitAv*EnatIffu!Il]Imp Ogn Ond Ot&OupeUg U% Uy e2EpardErr>I@Im|veIta!Sta%f3Mnas&Rostat:Bitu@Cho*L&Me|NgarN[t$RicotRm$+Rp$Sard3LiumMato?RbeRiss$Rm(eR$Si,U!{3B n BouLar/tStoi!V 5MardMma.Mo.[N['Nor N&{R@Riz$Rlo.Rm$eRrib#U#{Us<5BlotI#{Ma(Mb#Mi@Mo'R]3Dro?lG+[M[Pno<:2Yl#2Nor U/e4Lici&Lusi$0A.Bib I,M_<Mobi#Muab#PactP i=Plor Po}Prim Pu,0Carn C_d+Ci@ntCl( Colo!Dex Di-Duc%fEditEp%eExactF(iFlig Form Fusi$G  H= Hib Jec,Ju!No-ntOcu]Ond Scri!Sec&Sig[Soli&Sp* S%nctSul,TactT_<Ti?Trig)Tui%fU%#Vasi$V_,Vi,Voqu 3Oni^Rad>ReelRi,0O]2Oi!Res<:GuarIll*MbeNv>Rd(Ug U[Velot3Tab#T$UdiU[s<9Ind!N~ Ng]Ue'UissifUrn=Vi=Y|Ye{5Bi]Ge?ntNiorP$Ris&S%-Te{V_i#:Yak7M$oOs^:BelBi=Bo' C  Cto<Gu[I[Is}I% Mbe|Mel#MpeN-'Nga.N,[P(R.'R?Ur>VaboVo*3Ctu!G=G Gu?SsiveTt!V>Xi^Zard3As<B  B!C_-Cor[E.Ev!Gatu!Go,G)M Mi&M$a@Mpi@Neai!NgotOn-|Qui@S>eS,ThiumTi.Ttor=V!'5Gi^Inta(Is*MbricT +U UrdUt!UveY=5B+Ci@Cra%fE'Gub!Is/tM>eNai!NdiR$T,X){:Ch(eGas(G_taGi^Ig!Ill$In%_Ir+Is$Jor Lax Lefi-Lhe'Li-L#t&MmouthNda,Niab#Nqu/tN&|N)lRath$Rb!R~/dRdiRi%?R^'Rr$R&]Scot&SsifT +lT>eTra^Udi!Ussa@UveXim=3Ch/tC$nuDa`#Dec(Di,Du<Il#'L/.Lod+Mb!Moi!Nac N Nh*Ns$.NtorRc!diRi&R#Ssag Su!T=Teo!Tho@T>Ub#3Au]CrobeEt&Gn$Gr L+uLli$Mi^N-N =Nim=Nor Nu&Rac#Roi,Ssi#X&5Bi#D [El#{Ndi=Ni&'Nna+Not$eNst!Ntag[Nu?ntQ)'R-|Rsu!R% Te'TifU~eUf#Ul(Uss$Ut$Uv/t5L%p#Ni%$Ra`#Re[Rmu!Sc#SeumSic+nTa%$T T)l3Ria@R%l#S,eThi^:Ge'PpeRquoisRr Ta%$Ti$Tu!Ufra.U%^Vi!3Bu#{CtarFas&Ga%$Glig Goc>I.Rve{Ttoy Ur$eUtr$Veu3CheCkelTra&Ve|5B#CifCt'[Ir-'I<t&Ma@Mb!{Mm Rma%fTab#Tif>Toi!Urr*Uve|Va&'Vemb!Vi-5A.Anc I!Isib#M oP%=Q)Tri%f:0E*Jec%fLig Sc'S v Stac#T_*T' 0Casi$Cup E/Tob!Troy Tup]Ulai!0E'Or/t1F_}Fic>Fr*0Ive1Se|S`l$2Fac%fIv>0Bra.Ett!0Ct){Du]E!{Iri^1A#A^Er Ini$PortunPrim T Ti^1A.{An.Bi&D$n E`#G/eG)`Ifi-Ne?ntQ)T+0C`]Mo<Satu!0Ar+0Rag/Rs$T`Trag Vra.0A%$1Y@Y.[1O[:Isib#La-Lma!sLo'@Lp Na~eNdaNgol(Niqu N[|NoramaNt=$PayeP>Po,PyrusRadoxeR-l#Res<Rfum R]Ro#Rra(R<m Rtag Ru!Rv_*Ssi$S&^T [lT+n-Tr$V`l$Voi}Y Ysa.3Ig[Int!La.Lic/L#Lou<Lu~eNdu#Netr Nib#NsifN'+Pi&PlumRdrixRfor Rio@Rmu,Rp#xeRs`R&S Ta#TitTr*Up#2Ara$Ob+O^Ot$Ra<Ysi^0AnoCt'=E-Er!Euv!Lo&N-|Pet&Qu Rog)Sc(eSt$Vo,XelZza2AcardAf$dAis*An A^Astr$A&|E' ExusIa.OmbOng U+Uma.2Chet&Es+E&In&Ir>Iss$Iv!Lai!Lic>L#nLyg$eMma@Mp>Nct)lNd  NeyR%^Si%$S<d Stu!Tag Te|Ti$U-Ula(Um$Urp!Uss(Uvo*2A*+A%^Ec+{Edi!EfixeElu@EnomE<n-E&x&Evo*Imi%fIn-Is$Iv Ob#?O-d Odi.Of$dOg!sO+Oje,Olog)O?n Op!Osp eO&g O)s<Ov beU@n-U[|0Y~o<1BlicC $I}LpeLsarNai<Ni%fPit!Rif>Zz#3Rami@:99AsarE!l#Es%$Ietu@It,O%_t:C(eC$,D+{G$d(I@'Is(L_%rLl$.Mas}Pi@Sa.Tis}Vag V(Y$n 3Ac%fAg*Ali}Anim Cevo*Ci,Clam Col,Cru,Cu]Cyc]Dig Dou,Fai!F#xeForm Fra(Fu.G=+nGi$Gla.Gul>I, Je,Jou La%fLev L+fMar^Me@Mi<M$,Mpl*Mu NardNfortNif]N$c Ntr NvoiPl>Por,Pri<P%#Qu(S veS(e{Soud!SpectS,SultatTabl*T_*Ticu#Tomb Trac Uni$Uss*V/~eViv!Vol&Vulsif3Ches<De|E'Gi@Go]Nc Pos,Sib#S^T)lV=V>e5Che{M/-Mp!N-Nd(Se|S>Ta%fTorTu#U.U`#U#|U%[Y|?5B/BisCheEl#G){In Is<|S S%^3Th?:B]Bo,B!Co~eFariGes<Is*La@LiveL$Lu MediNc%$Ngl>Rcas?Rd(eT' Ug!nuUm$U,Uva.V/tV$n 1AlpelAnda#E]atEnarioEpt!HemaI_-Ind O!Ru%nUlp,1An-Cab#Ch Cou C!,Da%fDui!Ig['Jo'Lec%fMa(eMb]M_-M(=Na&'Nsib#N&n-Par Q)n-Re(R.ntR+{Rru!RumRvi-Sa?V*Vra.Xtup#3D =Ec#Eg Ff]G#Gn=L_-LiciumMp#Nc eNist!Ph$RopSmi^Tu 1I 3Ci=C#DiumIg[{LdatLe`Litu@Lub#Mb!M?`Mno]N@N.'N[t&No!Rc>R%rS+T%<Uc+{Udu!Uff#U#v UpapeUr-U%r Uv_*0Ac+{A%=Eci=H eIr=3Ab#A%$ErnumImulusIpu]RictUd+{Upe'Ylis&0Bli?BstratB%lBv_*C-sC!FfixeGg  Ive'Lfa&P bePpl>Rfa-Rica&R?n Rpri<Rs|tRv+Spect3LlabeMbo#Metr+Nap<NtaxeS&?:BacBl>C%#Il]L_tLism/L$n Mbo'Mi}Ngib#PisQu( Rd RifR%[S<TamiToua.UpeU!|X 3Mo(Mpo!lNa`#Nd!Ne'N*Nsi$Rm( R[Rrib#T(eX&2E?Eor+Erap+Orax0BiaE@Mi@Reli!Ro*SsuT/eT!Tub 5Bogg/L /tMa&Ni^N[|P$y?R~eRd!Rna@Rp`#R!ntR<Rt)TemU~ Urna.Us}X(e2Ac%$AficAgi^Ah*A(An~ Ava`Ef#Emp EsorEu`Ia.Ibun=Ico,Ilog+IompheIp]It' Ivi=Omb$eOncOpic=Oupe|2I#LipeMul&N[lRb(eTe'Toy Y|3Mp/Ph$Pi^R/:0Ues^9Ti?Tras$1Ani?If>I$I^Itai!Iv s3AniumBa(Tic/t0A.I[UelU!0I#Op+:Car?Cc(Gab$dG)Ill/tInc!Is<|Lab#Li<Ll$LveMpi!N`#Pe'R>Se{Ss=S&3C&'Det&Get=Hicu#InardLo-Nd!diN  Ng Ni?{Ntou<Rdu!R(Rn*RrouR}RtuSt$T /Tus&X/tX 3AducAn@Ctoi!D/.DeoG[t&G)'La(Lla.Naig!Ol$P eRe?ntRtuo<RusSa.Se'Si$S^{S)lT=Tes<Tico#Tr(eVa-Vipa!5Ca%$Gu I#Is(Itu!La`#Lc/L%g Lu?Ra-R&xT Ulo*Ya.Yel#:G$:3N$:Cht:3B!NithS&9Olog+";
var accents2 = "e7693&)U*o&)Ry^)*)W))))#X^))))@@)#Wf)m%)#!))AG)&IIAQIIIBIIHJNAgBIILIDJGo)))HIQIIIIA(IGgJHH(BIIxX#)Ou)@*IAAPIIIJHQJ)&QIQPYI(HYAQC%)!))QHJJ@)#)^f*^AXCJ))$%CP))%&m)u)@e^A#G#))W@!(IKK%!(I%))O@QA))@GG#e))))WHJIWh))my@IIBT^)!)HAYGETHI*))!QnUDG)))nBoKAC*HwyQh))$&)G&)UGO)G)))(BX#v**)%O,e7686)I))@)&)gdMP()))ud)p#L))I^FIHYdWG))D@DFV)QA)o%MyTh%*)Z)%)n(XANc^R)YS";
var checksum4 = "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045";
var wordlist5 = null;

class LangFr extends WordlistOwlA {
  constructor() {
    super("fr", words4, accents2, checksum4);
  }
  static wordlist() {
    if (wordlist5 == null) {
      wordlist5 = new LangFr;
    }
    return wordlist5;
  }
}

// node_modules/ethers/lib.esm/wordlists/lang-ja.js
function hex(word) {
  return hexlify(toUtf8Bytes(word));
}
function toString2(data12) {
  return toUtf8String(new Uint8Array(data12));
}
function loadWords() {
  if (_wordlist !== null) {
    return _wordlist;
  }
  const wordlist7 = [];
  const transform7 = {};
  transform7[toString2([227, 130, 154])] = false;
  transform7[toString2([227, 130, 153])] = false;
  transform7[toString2([227, 130, 133])] = toString2([227, 130, 134]);
  transform7[toString2([227, 129, 163])] = toString2([227, 129, 164]);
  transform7[toString2([227, 130, 131])] = toString2([227, 130, 132]);
  transform7[toString2([227, 130, 135])] = toString2([227, 130, 136]);
  function normalize(word) {
    let result = "";
    for (let i3 = 0;i3 < word.length; i3++) {
      let kana = word[i3];
      const target = transform7[kana];
      if (target === false) {
        continue;
      }
      if (target) {
        kana = target;
      }
      result += kana;
    }
    return result;
  }
  function sortJapanese(a, b3) {
    a = normalize(a);
    b3 = normalize(b3);
    if (a < b3) {
      return -1;
    }
    if (a > b3) {
      return 1;
    }
    return 0;
  }
  for (let length = 3;length <= 9; length++) {
    const d3 = data12[length - 3];
    for (let offset = 0;offset < d3.length; offset += length) {
      const word = [];
      for (let i3 = 0;i3 < length; i3++) {
        const k = mapping.indexOf(d3[offset + i3]);
        word.push(227);
        word.push(k & 64 ? 130 : 129);
        word.push((k & 63) + 128);
      }
      wordlist7.push(toString2(word));
    }
  }
  wordlist7.sort(sortJapanese);
  if (hex(wordlist7[442]) === KiYoKu && hex(wordlist7[443]) === KyoKu) {
    const tmp = wordlist7[442];
    wordlist7[442] = wordlist7[443];
    wordlist7[443] = tmp;
  }
  const checksum5 = id(wordlist7.join("\n") + "\n");
  if (checksum5 !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
    throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
  }
  _wordlist = wordlist7;
  return wordlist7;
}
var data12 = [
  "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
  "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
  "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
  "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
  "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
  "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
  "IJBEJqXZJ"
];
var mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
var _wordlist = null;
var KiYoKu = "0xe3818de38284e3818f";
var KyoKu = "0xe3818de38283e3818f";
var wordlist7 = null;

class LangJa extends Wordlist {
  constructor() {
    super("ja");
  }
  getWord(index2) {
    const words5 = loadWords();
    assertArgument(index2 >= 0 && index2 < words5.length, `invalid word index: ${index2}`, "index", index2);
    return words5[index2];
  }
  getWordIndex(word) {
    return loadWords().indexOf(word);
  }
  split(phrase) {
    return phrase.split(/(?:\u3000| )+/g);
  }
  join(words5) {
    return words5.join("\u3000");
  }
  static wordlist() {
    if (wordlist7 == null) {
      wordlist7 = new LangJa;
    }
    return wordlist7;
  }
}

// node_modules/ethers/lib.esm/wordlists/lang-ko.js
function getHangul(code) {
  if (code >= 40) {
    code = code + 168 - 40;
  } else if (code >= 19) {
    code = code + 97 - 19;
  }
  return toUtf8String(new Uint8Array([225, (code >> 6) + 132, (code & 63) + 128]));
}
function loadWords2() {
  if (_wordlist2 != null) {
    return _wordlist2;
  }
  const wordlist9 = [];
  data13.forEach((data13, length) => {
    length += 4;
    for (let i3 = 0;i3 < data13.length; i3 += length) {
      let word = "";
      for (let j = 0;j < length; j++) {
        word += getHangul(codes.indexOf(data13[i3 + j]));
      }
      wordlist9.push(word);
    }
  });
  wordlist9.sort();
  const checksum5 = id(wordlist9.join("\n") + "\n");
  if (checksum5 !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
    throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
  }
  _wordlist2 = wordlist9;
  return wordlist9;
}
var data13 = [
  "OYAa",
  "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8",
  "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6",
  "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv",
  "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo",
  "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg",
  "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb",
  "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"
];
var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
var _wordlist2 = null;
var wordlist9 = null;

class LangKo extends Wordlist {
  constructor() {
    super("ko");
  }
  getWord(index2) {
    const words5 = loadWords2();
    assertArgument(index2 >= 0 && index2 < words5.length, `invalid word index: ${index2}`, "index", index2);
    return words5[index2];
  }
  getWordIndex(word) {
    return loadWords2().indexOf(word);
  }
  static wordlist() {
    if (wordlist9 == null) {
      wordlist9 = new LangKo;
    }
    return wordlist9;
  }
}

// node_modules/ethers/lib.esm/wordlists/lang-it.js
var words5 = "0torea noica!iosorolotaleratelanena%oiadoencotivomai t ca%a0A]Bagl'Bin#E.Is(Oli!Rasi_Rog#0Cade!C[$Cus#E <Hil,I@QuaReRil>Roba+U 0Ag'Deb{DomeEgu#Eri!IpeOtt&Ul&1Fabi,Fe|Fis(F-n Oris`O(R~$0AveEn.E_,Ganc'I!It&OnismoR>*Rume Uzzo4AbardaA Bat)Ber#BoBumeCeCol>E|<FaGeb-Ian.IbiIm[ Lag#Leg)Lie_Lo@/Lusi_Me$Oge$Pa}Pest!Ta,=Ter$T%c'T)veUn$Veo*Z&0Alga`Ani+A!=B{Br#EbaEr~E^s+I]Mas(M[daMir&Mon{O!P'Pli&U, 0A}r@Ag-feAlis+Arch?At-CaCel/Co-D&D!aEl*Ge*Gol&Gus I`Neg&Nid#NoNunc'OnimoT%ipoZi1At>Ertu-OdePari!Pe^ Pogg'P)@Pun Ri,1Ab~AchideAgos+Ald~Anc'Atu-AzzoBit)Chiv'D{Eni,G[ Gi<Gu IaMon?NeseRed#RingaRos S[>SoTef%eZil*0Ciu|Col EpsiEtt>Fal I$O/Pir#P)Sagg'SeSolu Sur@TaT[u T%eT-|0Av>EismoOm>O$TesaTiv&Tor$Tr{Tua,0Sil'Str?Tis+To$moTun$0Anz#E!V[i!Vi(Volge!3Io<O ZimoZur):Be,C}$Ci$CoDessaDi/+Gn#I+L]<L@Le=L/+Lza$Mbi$Ndi!RaondaRba)R}R{$RlumeRoc]Sil>S(Tos+Ttu U,VaVosa3C]FfaLg'LvaNdaNe_,Nig$Nzi=ReRli=Ta3Bi+CiDo<Fi@GaLanc?MboNo]*O*goPedePol&Rban.R-S]|Ses S$n$Son.SturiZzar)2An@At+2Ll{Nif>R@S]Tan>T^$Zzo*2Acc'AdipoA`An}Avu-E.l/Eve|EzzaIgl?Il/n.Ind&Oc]*O@Onzi=Ul*U$2Bbo<CaDi$Ffo<IoLboO$R*<R-s}S(/S+:De|Du]La`)L]*LesseLib)LmoLor?MbusaMe-+M%?Mmi$Mo/Mpa,NapaNde/NeNi$No|N^=PacePel*P{*Pogi)Ppe)P-Psu/RapaceR}ssaR@Ris`Rova=R!|R li=Sacc'S}+Ser`SoS(<S.l*Sua,Tas+Te=T-meU Vil*3Dibi,D-+Fa*Leb!Llul&NaNo<N.simoRam~Rc&R RumeRvel*So?SpoTo2E/Ia)Ic}Iede!Ime-I=IrurgoI+r-0AoClismoFr&G$Lind)O|*R}R)siTr>T+di$UffoVet+Vi,2Ass>In~O)2C]Dar@D%eE!n.G$meLl&Lm#Lo!Lpo(L^v#LzaMaMe+M`n@Mo@Mpu.rMu<Nci(Ndur!Nfer`Ngel&NiugeN<s(Nosce!NsumoN^nuoNveg$Per P'<Pp?Pr~poRazzaRda+R%#Rn%eRol/RpoR!@Rs?R.seSm>S+n.Ttu-V#2A.!Avat+E#Ede!Emo(Esci+E+Ice I=,IsiIt>OceO=}Os++Uc?,Us}2Ci!Cu*Gi$Ll#Po/R#!R(!R_Sci$S de:DoI$L`+Meri$Nie/N$(Nz&T#Van^Vve)3Bu|C[n'Ci(Cli$Col*C! D%#Fin{FormeG$Leg&Lfi$Lir'L+M[zaNot#Nt)Pos{Rapa+Riv&RogaScri|Ser Sider'Sume!Tersi_Vo 3Amet)Cemb!Ed)Fe(Ffu(Geri!Gi+,Luv'Nam>N=nziPin P*`Po*Rad&ReRo|RupoSag'Sc! Sf&Sge*Spos S+nzaSu`$ToVa$Vel Vide!Vor#5B*<C[.Ga=,G`LceM#M[~Min&N@*NoRmi!TeT !Vu Zzi=2AgoUi@2Bb'Bit&Ca,NaOmoPl%eRatu):0A$0Ces(CoLissiO$m?0E-I]/I,I r?Uc&2Emon?LiOismoReg'4Abor#Argi!Egan.Enc#E|Ev&F>I}MoSaU(0An#B,`Es(I)O^_Oz'<Pir>U*0Dem>Du)Erg?FasiO.}Tr&Zi`1A^.I*goI(d'O},Pu!0U#!0Ar'BaBo(EdeEmi+Ige!Met>OeOsi_Ran.0Ago$AmeAnimeAudi!CaEmp'Erc{Ib{Ig[.Is.!I OfagoOrt#O(Pan(P!s(S[zaSoTe(Tim&Ton?T)(Ult&0Il>N>Rus]To0ClideoRopa0A(Id[zaIt#Olu Viva:Bbr~Cc[daChi)L]Migl?Na,Nfa-NgoN+s`ReRfal/Ri$(R`]Sc?S (Sul*T%&ToVo*(3Bb!Co/DeG#LpaLt)Mmi=Nde!Nome$Rm[ R)R^,Ssu-S^_T+U@3AbaDuc?FaGur#LoNanzaNest-Ni!O!S},S>Ume2A]<Am[]EboEm`Ori@U[.Uo)2B>Cacc?Co(Der#Gl'La+Lc*!Lgo!Nd[.Net>N?N+=Rb{Rchet+Res+Rm~R='RoR.zzaRz&Sf#S(2A}s(A=Assi$A.l*Eccet+E=+Es]IgoOlli$OndeUga,Ut+2Ci/+Cs?Gg[.Lmi<L_Man.Me|Mo(NeNz'<O]RboRgo<Ro!SoTi,:Bb?$FfeLa.oLli=LoppoMbe)M`Ranz?RboRofa$Rzo<S@|Sol'Str>T Ud'ZeboZzel/3CoLa^=L(Mel*Mm#NeN{!N='No^poRgo2Epar@Iacc'Isa0Al*LdaNep)Oc&Oiel*Or$OveR#Ro<T++Udiz'Ur#Us 2Obu*U^<1Omo0BbaLfM{Mmo<Nf'N=Ver$2Aci,A@Af>AmmoAndeAtt&A_(Az?E}EggeIfo<Ig'InzaOt+Uppo2Adag$A'An Ard&FoId&::0Ern#0O=0Ent>Ill'O*RaR>Roge$2Ie<Na)Nor#4A!Le(Log>Lude!0Bal*Bevu Boc]Bu Ma<Mer(Mol#Pac]Pe PiegoPor P)n+0Al&Arc&At^_Can C[d'Chi$Cisi_Clu(Cont)C)c'CuboDagi<D?Do,Ed{Fat^Fil&Fli|Gagg'Geg$G,seGor@G)s(Nes]O@!Oltr&Ond#Sa$Se|SiemeSonn?Suli=Tas#Te)To=]Tu{Umidi!Vali@VeceV{1Erbo,Not>O.siP~1IdeLandaOn>Rig#Ror&0Ol#O poTer>Titu Tr%e0Al?Er&:::Bb)Birin C}Cer#Cri`Cu=D@veGoMpoNcet+N.r=R@(RgaRingeSt-T[zaTi$TtugaVag=Vo)3Ga,Gge)MboN.zzaNzaO<P!Si_Ss#S T.-,VaVig#3Be)DoEv{L/Matu-Mit&Mpi@Ne&NguaQui@RaR~S}TeTig'V!a5CandaDeG~Mb&Nd-Nge_QuaceR[zoToT.r?5CeCid#Ma}Mi$(NgoPoPpo*SingaS(T :Cab)Cchi=Ce)Cin#Da`G>Gl?G<.G)Iol~LafedeLg-@Lin.(Lsa$L Lumo!NaNc?N@r/Ngi&Nifes N=)Nov-NsardaN^deNubr'PpaR#=Rci!Ret+RmoRsup'Sche-Ssa?S^$Te-s(Tr>/T <Tu)Zur}3And)C}n>Ce=.DesimoDit&GaLassaLisLod?NingeNoN(/Rcur'R[daR*Schi$SeSse!S *Tal*To@T.!3Agol&CaCel'Che,C)boDol*E,Gl'!La$Li.MosaNe-,NiNo!Ri$R^l*Sce/SsivaS Sur&TezzaTig&T-T.n.4Emon>0Del*Dif~Du*Ga$G'LeLos(Nas.)N]Ndi=Ne+r'Ni,No $N(<Nt#Nvi(RaRde!Rs%#St)Tiv#TosegaT V[zaVim[ Zzo5C}CosaFfaGhe|G='La|Li<l*L^p*Mm?N Ove!Ra,SaS]*S~Te_,To:BabboF+Nomet)Rci(R%eRr#Sce!Str&Tu-,Ut~Vigl'3Bu*saC)siGa^_Goz'Mme$Ofi+Re|R_Ssu$Ttu$Ut-,VeV)t>3Cch?NfaTi@5Bi,Ci_DoMeMi=Rd>R`,RvegeseSt-$T&Tiz?Ttur$Vel/5C,oL/Me)O_Tri!Vo/Z?,:Si0Bedi!BligoElis]L'O*So, 0Cas'<Ch'Cid[.Cor!!Cult&RaUl#0Ier$Or&1Fer+Fri!Fusc#0Ge|GiNu$4AndeseFa|I#IvaOg-m`T!0Agg'Bel>B-EgaIss'<0Do(E!IceNi_)O!_,Ta1Er#In'<Pos 1A]*AfoDi<Ecchi$Ef%eFa$Gan>Igi<Izzon.MaMegg'Na^_O*g'R[@Ribi,T[s?T~Za+Zo0A!Cur&MosiPeda,Pi.SaSid&Ta]*Te0I.ReTago$TimoTob!1A,EstI$Ipa)Oc{UnqueVi&3Io:Cche|CeCif>Del/D)<EseGaGi=Lazzi=Les&Lli@LoLudeN@)N<l*O*O=zzoPr~Rabo/Rcel/Re!Rgo*RiRl#Ro/R^!Rv[zaRz?,Ssi_St%}Tac}To*g?TtumeVo<3Cc#Dal&Do=,Gg'Lo(N&Nd%eNi(/Nnu Nomb-Ns&N /PePi+Rbe<R]r(R@n#Rfor&Rgame=R'@Rmes(R$Rp,s(Rsua(Rtug'Rva(S#!Sis+SoS^fe)Ta*T^<Tu/n.Zzo3Ace!An+At^$Cci$CozzaEgaEt-Ffe)G?`Gol'G)LaLife)L*/Lo+Mpan.Ne+N=No*Ogg?OmboRamideRet>Ri.RolisiTo<Zz>2AceboAn&As`A+$E=r'2ChezzaDe)(DismoEs?Ggi&L[+Ligo$Ll%eLmoni.Lpet+L(Lt)=Lve!M%eMo@)N.Po*(Rfi@Ro(Rpo-R!R++SaSi^_Sses(Stul#Tass'Te!2AnzoAssiAt~Eclu(Ed~Efis(Egi#Elie_Eme!E$t&Epar#Es[zaE.s Eval(I`IncipeIv#Ob,`Ocu-Odur!OfumoOge|OlungaOmessaO$meOpos+O)gaO.(OvaUd[.Ug=Ur{0Iche1Bbl>D~Gil#G$LceL{Lsan.Nt&PazzoPil/Ro:99Ad)Al]saAsiE!/O+:C]l D@pp'D~,Dun#Ff~GazzoG'<G$Mar)MingoMoNdag'N l&P#Pi=Pp!(Satu-Schi#S[.Sseg=St!l*TaVvedu 3A,Cepi!Cin Clu+Cond{Cupe)Dd{Dime!Gal#Gist)Go/G!s(Laz'<M&Mo N=Pl~Prime!Put&SaSid[.Spon(S+u)TeTi=Tor~T^f~Voc#3Assun Badi!Bel,B!zzoCar~C]Ceve!C%l#Cor@C!du D>*Dur!Fas&F,s(For`Fug'G&Gett#Ghel*Lass#Lev#Ma<!MbalzoMed'Morch'Nasci+N})NforzoN$_Nom#Nsav{N c]Nunc?Nv[i!Par#Petu Pie$Port&P!saPuli!Sa+Sch'ServaSibi,SoSpe|S )Sult#S_l Tar@Teg$Tm>T)_Un'<VaVer(Vinci+Vol Zo`5BaBot>Bus Cc?CoDagg'De!D{!G{Ll'Mant>Mpe!Nz'Sol&SpoTan.Ton@Tu/Vesc'5BizzoBr~GaLli$Mi<Mo)(O*PeSs&St>:B#Bbi&Bot#Go`Las(Ldatu-Lgem`Liv&Lmo<Lo<Lt&Lu L_Pe!Pi@Por{Race$R}smoR S((Telli.Ti-Tol*Tur$Va=V'Zi#0Adigl'AlzoAnc#Ar-At.!Av&End&Irci&Locc#Occi#Rin&Ruffo<Uff&0Ab)(Ad[zaA/Ambi&Anda*Apo/Ar(A.n&Av#El En>Ett)HedaHie=IarpaI[zaInde!IppoI)ppoI_*Ler&Odel/Olp{Ompar Onfor Opri!Or+Os(<OzzeseRibaRoll&Ru^n'Uder?Ul !Uo/U)Us&0Ebit&Ogan&0C}tu-Con@Da$Gg'/G=l#G!g#Gu{Lci#Let^_L/Lvagg'Mafo)Mbr&MeMin#Mp!N(N^!Pol Qu[zaRa+Rb#Re$R'Rp[.R-gl'Rvi!S^=To/T^`=0Ace*Ald&Am#Arzo(At%#E-IdaIl#IngeOc#Oder&OgoOl^!Orz#Ra|Rutt#Ugg{Um&U(0Abel*Arb#Onfi&Orb'Rass#Uar@1Bi*C]meEr-G/G$!L[z'L/baMbo*Mpat>Mul#Nfon?Ngo*Nist)NoN.siNu(idePar'S`S ,Tu#2It+Ogatu-Ove$0Arr{Emor#En^ E-l@IlzoOnt&Ott#Uss#0Elli!Erv#O@0BbalzoBr'C]r(C?,Da,Ffi|G$Ld#L[<Li@L/zzoLoLubi,Lv[.Mat>M`NdaNe|Nnife)Pi!Ppe(P-Rge!Rpas(Rri(R(R.gg'R_l#Spi)S+T^,0AdaAl/Arge!A /Av[ Azzo/EcieEdi!Eg<!E/tu-E-nzaEs(!Ett-,Ezz#IaIgo*(Ill#I$(I-,L[di@Or^_O(RangaRec&Ron#RuzzoUn^$0Uil*0Ad%&O l#1Abi,Ac]AffaAgn&Amp#Ant'Arnu Ase-Atu E*EppaErzoI,|I`IrpeIva,Izzo(On#Or>RappoReg#Ridu*Rozz&Ru|Ucc&UfoUp[@0B[t)C](Do!Gger{GoL+$On&PerboPpor Rgel#R)g#Ssur)Tu-0Ag&EdeseEgl'El&Enu Ez?IluppoIs+Izze-Ol+Uot&:Bac]Bul#Cci&Citur$LeLis`$Mpo<Nni$RaRdi_Rg#RiffaRp&R+rugaS Tt>Ver=Vo/+Zza3CaCn>Lefo$Me-r'MpoMu N@<Ne)Ns'<N+]*O!`RmeR-zzoRze|SiSser#St#T)T ?3F&Gel/Mb)N P>Pog-foRagg'RoTan'To*Tuban.Z'Zzo<5Cc&L,r&L Mbo/MoNfoNsil/Paz'Po*g?PpaRbaRn&R)<R -S}$Ssi!S+tu-Ta$2Aboc]AcheaAfi/Aged?Alc'Amon Ans{Apa$Ar!As*]Att#AveEcc?Emol'Espo*Ibu Iche]Ifogl'Il*InceaIoIs.zzaItur#Ivel/OmbaO$OppoO|/Ov&Ucc#2Batu-Ff#Lipa$Mul Nis?Rb&Rchi$TaTe/:0Ic#0Cel*Ci(!0I!I^_1FaF%'0Ua,4IsseTim#0A$I,Orismo0Ci<|Ge!Ghe!seI]r$If%#I($I+r'Te0Vo0Upa1Aga$G[zaLo0AnzaA C{Ig$*U-'0Ensi,IlizzoOp?:Can.Ccin#Gabon@Gli#LangaLgoL>L,t+Lo)(Lut&L_/Mpa+Ng&N{(NoN+gg'Nve-Po!Ra$Rc#R?n.S}3Det+DovaDu Ge+,I]*Lc)Li=Llu LoceN#Ndemm?N RaceRba,Rgog=Rif~RoRru}Rt~,Sc~Ssil*S+,Te-$Tri=Tus 3Andan.B-n.C[daChingoCi=nzaDim&Gil?G< Go!LeL/$MiniNc{!O/Pe-Rgo/Ro*goRu,n S](S'<SpoSsu Su-TaTel*T^`VandaVi@Zi&5CeGaLa^,Le!LpeRagi<5L}$::::Mpog=N=Pp#T.-Vor-3Fi)Lan.LoNze)Rbi$3Be|N]R]<T 5L/T>5Cche)Fo*LuPpa";
var checksum5 = "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620";
var wordlist10 = null;

class LangIt extends WordlistOwl {
  constructor() {
    super("it", words5, checksum5);
  }
  static wordlist() {
    if (wordlist10 == null) {
      wordlist10 = new LangIt;
    }
    return wordlist10;
  }
}

// node_modules/ethers/lib.esm/wordlists/lang-pt.js
var words6 = "0arad!ototealirertainrasoent hoandoaR#riareha!aroele'oronul0Aca%AixoAl A%rDuz'El]Er$IsmoO$ R<g(Revi Rig Rup$S*$Solu$Sur=Ut[0Ab#Alm Amp Anh A,Ei.El( En ErvoEss E$naHa.IdezImaI}#Irr Lam LiveOlhidaOmod Opl Ord Um~ Us?0Ap.EgaEnt_Ep$Equ Er-%EsivoEusI<%ItivoJetivoJun$M' Or Qu''UboV(,Vog#0R}ave0As.Er'EtivoIn?Iv` Li$Lu-%R}.0Ach Arr As&/Enci Iliz Io)It#O+R! Res%Rup U d Ul]2O`h Ud Us.1AmedaArmeAstr Av<caB(gueB*oCat+De@EcrimEgr@Er.FaceF*e%GumHeioI Ica%I- Inh Ivi Mof^Oc Pis%T( TitudeUc* Ug UnoUsivoVo0Aci A=rA[loAss BasBi-%EixaEniz I=Is$,Iz!eOl?On$ O_,Ost+P  Pli Pola0Ag+maAlis Arqu@A$m@DaimeElExoG~ Im JoOm&@Ot#Sio,T(i|Uid!eUnci Zol1Ag?Alp Anh#EgoEli=Ert^Es Eti%I$Lau,Lic^OioOn.Os)R-dizRov 0Uec(0AmeAn]A+C^D-%E@Ej Eni$Es)Gilo,GolaMaQuivoRai&Reba%Risc Rob>um S-&T(i&TigoVo[=0F&.Il#P' S?S* So&/Sun$Tr&0Ac#Adu+Al/A[f E End(Er_EuIng'Ir?IvoOl{oRac Revi=RizU&Um0Di$rM-.R>o+TismoT|@Tu 0Ali An%Ar@Ent&Es,I?Is Ul,1Ila1Ar E=Ei%Ulejo:B BosaC&]uCh `C@GagemI<oIl I}e)Ir_Ixis)J~ Le@LizaLsaN&Nd{aN/N'Nque%Ra$Rb#R}es>+c>~/Se#S)n%Ta)Te=rTidaTomTuc Unil]3B(IjoIr^IsebolLd!eLezaLgaLisc Ndi$Ng&aNz(RimbauRl*d>_Sou_XigaZ(_3CoCu=En&Foc&Furc G|naLhe%Mest[Mo$rOlog@OmboOsf(aPol Rr-$Scoi$Sne$SpoSsex$TolaZ _2Ind#OcoOque 2A$BagemC#CejoChec]Ico.L^LetimL]LoMb{oNdeNecoNi)Rb~h>d>e&R+c]V*oXe?2AncoAsaAvezaEuIgaIl/Inc OaOchu+Onze O$Uxo2C]DismoF LeRacoScaS$Z*a:B<aB`oBideBoBri$CauCet^C/r_CiqueDast_De#Fez&IaqueIp'aIxo%J#JuLafrioLc~ Ld{aLibr Lm<%Lo)M^Mbis)MisaMomilaMp<]Mufl Navi&Nc` Ne)NguruN/$Nive%NoaNs#N.Nu=Pac/P`aP* Po.Pric/Pt?PuzRacolRb}oRde&Rec>imb Rn{oRpe%R['>)zRv&/SacoScaSeb[S%loS~oT a)Tiv UleUs?U%l V&oV(na3BolaDil]G}]Lebr L~ Nou+N,N%ioRc Rr#R%'oRvejaTimV^2Aco)Al{aAm#Ap^ArmeAticeAveEfeEg^E'oEqueIco%If[In`oOc&/Ov(UmboU.Uva0CatrizCl}eD!eD['aEn%G<aM-$N$Nz><d>cui$Rurg@T 2A[zaE_Ic OneUbe2A=Ag'Ba@B($rBr C^El/Ent_E,Gum`oIb'IfaIo%L L{aLh(Lid'Lme@L}oLunaM<=Mb* M-.MitivaMov(MplexoMumNc]N=rNec.Nfu,Ng` Nhec(Njug Nsum'Nt+$Nvi%Op( P{oPi?PoQue%lRagemRdi&Rne)R}h>p|&R[ioR%joRuj>voSs-oS%laT}e%U_UveVilZ*]2A%+AvoEcheE=rEmeErEspoI^Im*&Io~oIseItic Os)UaUz{o2B<oEcaId#JoLat+Lm* Lp Ltu+Mpr'Nh#Pi=RativoRr&Rs R$Sp'S% T`o:MascoT 3Ba%rBi.BocheB~h C&queCim&CliveCo%C[.D&Dic#Duz'FesaFum G`oG+uGus.It#Ix La$rLeg#L*e L}gaM<daMit'Moli=Ntis)P-#Pil PoisP[ssaPur Riv>+m SafioSbo.Sc<,S-/Sfi#Sgas%Sigu&SlizeSmam SovaSpesaS)queSvi T&h T-$rT} Tri$UsaV(Vi=Vot#Z-a3Ag+maAle$Da)Fu,Gi.Lat#Lu-%M*u'Nast@Nh{oOceseRe$Sc[)Sf ceSp oSque%Ssip S)n%T?UrnoV(,Vi,rV~g Z(5Br?L|i=M?M*#NativoNz`>m-%Rs&SagemUr#U$r2EnagemIbleOg @2El EndeE$PloQues><%Vi=,:1Lod'O Olog@0Ific It&Uc#1Ei$Etiv 3E.1Ab| Eg(Ei$rEncoEv?Im* Ogi 0B goBol#Br~/Buti=EndaErg'Is,rPat@P-/P*#Polg P[goPurr Ul?0CaixeC-#Ch-%C}t_Deus Doss Faix Fei%FimGaj#G-/Glob Gom#G+x Gu@Jo La.Qu<$Raiz Rol#Rug SaioSe^S*oSop#T<$Te#Tid!eT|.Tr^T~/V(g Vi#Volv(XameX($Xof[Xu$1Id(me0Uip 0E$Gui=Ra)VaVil]0B<j B`$CamaColaCri)Cu)F*geFol F[g Fum#GrimaM&%P<$P`/PigaP}jaP[i)Pum Qu(daTacaT{aTic Tof#T[laTu=Vazi 0AnolIque)0F|i>opeu0Acu Ap| AsivoEntu&Id-%Olu'1Ag(oAl Am* A$Aus$Ces,Ci.Clam Ecu.EmploIb'Ig-%On( P<d'P`'P' Pl< Pos$P[s,P~s T(noT*$T+$:Bric B~o,Ce)Ci&DaDigaIxaL L)Mili Nd<goNf +N$cheRd#R`oR*h>of>p>tu+T@T|V|i)X*aZ-da3Ch#Ijo^I+n%L*oM**oNdaNoR>i#RrugemRv(S%j T&Ud&3ApoB_seC Ch{oGur#L{aL/LmeLtr RmezaSg^Ssu+TaV`aX?Xo2AcidezAm*goAn`aEch^O+Utu Uxo2C&C*/Foc GoGue%IceLg#Lhe$Rj Rmig>noR%ScoSsa2Aga)AldaAngoAscoA%rnoE'aEn%E.IezaI,Itu+On]Ustr U%'a2G'L<oLigemNd NgoNilR?Rio,Tebol:B i$B*e%DoIa$IolaIvo)LegaL/L*]Loc]Nh RagemRfoRg&oRimpoRoup>+faSodu$S$TaTil/Ve)Z`a3L#Le@LoM^M(Mi=N(o,NgivaNi&NomaN_Ologi>?Rm* S,S$r3Nas)Nc<aNg#Raf>*o2Aci&IcoseOb&Orio,2ElaIabaLfeLpe Rdu+Rje)R_S$,T{aV(n 2AcejoAdu&Afi%Al]AmpoAn^Atui$Ave$AxaEgoElh EveIloIs&/I.@Os,O%scoUd#Unhi=U)2AcheA+niAx*imEr[ I Inc/Is#LaLo,Ru:Bi.Rm}@S%V(3C.eRd Res@Si.3A$B(n D+.EnaNoPismoPnosePo%ca5JeLofo%MemNes$Nr#Rm}&Sped 5M|#:Te2E@O,2N|#RejaU<a4E,HaUdi=Um* Ustr 0AgemEd@$En,ErsivoIn-%It?Ort&Pac$Ped'Pl<%P|Pr-saPuneUniz 0Al?Ap$AtivoC-,Ch Cid'Clu'Col|Deci,D'e$Du$rEficazEr-%F<tilFes.F*i$Flam F|m&F+$rG('Ibi=Ici&ImigoJe.Oc-%O=_Ov?OxQuie$Scri$Se$Sist'Spe$rSt& S~$Tac$Tegr&Tim Toc#TrigaVa,rV(noVic$Voc 0Gur%2Ani<oOniz Re&Rit#0CaEn$Ol#Qu{o0Ali<o:N{oNg^N)R ac>dimR_SmimToV&iZida3Jum9An*]Elh^G?I>n&Rr Vem5BaDeuDocaIzLg?L/R#Ris)RoS)::B edaB|&C[C)n%Dril/G )GoaJeMb(M-.M* MpejoNchePid P,R<j>{>gu+S<]St_T(&Ti=V<daVou+Vr?X<%Z(3Ald!eB[G#G-d Gis)IgoIlo Itu+Mb[%MeNh?Ntil]OaSmaS%TivoT['oV VezaVi.3B(&Bi=D( G G{oMi.Mo{oMp?NdaNe N]gemQuidezS)gemSu+T|&V_XaX{a5C?Cu$rJis)MboNaNgeNt+RdeT#T(@Ucu+UsaUv 5ArCidezC_Ne)St[T?Va:CacoCe%Ch#CioD{aDr*]Gna)G[zaI|IsL<d_L]Lo%LucoMiloMo{oMu%N^Nc]Nda$NequimN/,Niv`aNobr NsaN%rNuse Pe#Qu* Rc?Resi>fimRgemR*/Rmi)Ro$RquiseR[coR%loRujoSco%Sm|+SsagemStig Tag&T(noT*&Tu.Xil 3D&]DidaDusaGaf}eIgaL<c@L/rMb_M|i&N*oNosNsagemNt&Rec(Rg~/S^Scl SmoSqui)St[T!eTeo_T+gemX(Xic<o3C_G&]Gr Lag[L- Lh M#N( N/caNist_N|@OloR<%RtiloStur 5Cid!eD(noD~ EdaErIn/I)Ldu+LezaL/L*e%LuscoN)n]Quec><goRcegoR=moR-aSaicoSque%S.daT`TimToTriz5DaI$La)Lh(L.Ndi&Ni=R&h>c/Sc~ SeuSic&:Ci}&D?JaMo_R*>r#Sc(TivaTu[zaV&]Veg Vio3Bl*aB~o,GativaGoci Gri$Rvo,TaUr&VascaVo{o3N N/TidezV` 5B[zaI%IvaMe M*&Rdes%R% T Tici TurnoV`oVil/Vo5Bl#DezM(&Pci&Tr'Vem:0Cec#Edec(JetivoRig#Scu_S%t+T(Tur 0Id-%Io,Orr(Ulis)Up#2Eg<%EnsivaEr-daIc*aUsc#0Iva4Ar@Eo,H Iv{a0B_Ele%Is,It'0D~#E_,Tem1Ci}&Er?On-%OrtunoOs$1ArBi.DemD*&F<a$GasmoG~/I-t&IgemIun=LaTo=xoV&/0Cil S^SoT-.0Imismo0S!@T}oTub_Vi=0El]Ul 1Id Ig- :Ca$Ci-%Co%Ctu D @Dr*/G GodeIn`Ir IsagemLav+Lest+Lhe)Li$Lm^Lpi.Nc^N`aNfle$NquecaN)n&PagaioP`^P'oRaf*>ci&Rd&RedeRtidaSmoSs#S%lTam T-%T* T_noUl^Us 3C~i D& Dest[D@t+D+G^I$r&IxeLeLic<oNcaNdur N{aN]scoNs?N%Rceb(Rfei$Rgun)Ri$Rmit'Rn>plexoRsi<>%nceRucaSc#SquisaS,aTisc 3AdaC#Ed!eGm-$Last+Lh#Lo.M-)Nc`NguimN]No%N.On{oPocaQue%R<h>esRue)Sc S$laT<gaVe%2An)Aque)At*aEbeuUmagemUvi&1Eu0DaE'aEtisaLeg^Lici Lu-%Lvil/M MbaNd( N.@P~o,R)Ssu'St&TeUp U,Vo 2A@Anc]A$AxeEceEd?Efei$Emi Ens Ep  Esil]E%x$Ev-'Ez Ima)IncesaIsmaIv#Oces,Odu$Ofe)Oibi=Oje$Ome%rOpag OsaO%$rOv?2Blic DimL Lm} Ls{aNh&N'PiloRezaX?:99Ad+Ant@Ar$AseEbr EdaEijoEn%Eri=Im}oInaIosque:B<^BiscoCh Ci} Di&I In]IoIvaJ^L#M&Ng(Nhu+P!u+P`PidezPosaQue%Rid!eS<%Scun/Sg Sp?S%'aSur Taz<aTo{a3AlezaAnim Av(Baix B`deBol C#C-%CheioCiboC|d Cru.Cu DeDim'D}daDuzidaEnvioF* Flet'Fog F[scoFugi G&@GimeG+In#I$rJei.LativoM?M-=M|,Nov#P oP`'Ple$Pol/P[saPudi Qu((S-]Sfri Sga.Sid'Solv(Spei$SsacaS)n%Sum'T&/T(T' Tom^T+.V` Vi,rVol)3Ac/CaGidezGo_,M NgueS^ScoS}/5B&oChe=D^DeioDov@E=rLe)M<oNc S#S{aS$TaT{oT*aT~ UcoUpaXo5B_Gi=Go,IvoMoPest[S,:B|Ci ColaCud'DioF'aGaGr^Ib_L^L{oLg#LivaLpic Lsic]L.Lv?Mb Mu+iN Nf}aNgueNid!ePa$Rd>g-$Rje)Tur Ud!eXof}eZ}&3C C~ DaD-$Di#Do,Du$rGm-$G[=Gun=IvaLe$LvagemM<&M-%N?N/rNsu&Nt#P #Rei>*g>+RvoTemb_T|3GiloLhue)Lic}eMetr@Mpat@M~ N&Nc(oNg~ NopseN$ni>-eRiTu#5B(<oB+C|_G_JaLdaLetr L%'oMbrioNa)Nd Neg Nh?NoP+noQue%Rr'R%ioSsegoTaqueT(r V#Z*/5Aviz BidaBm(,B,loBt+'Ca)Ces,CoDes%FixoG?G('Jei$Lfa$M'OrP(i|Plic Pos$Prim'Rd*>fis)Rp[s>[&Rt'Sp'oS%n$:B`aBle%Bu^C/G `aLh(LoLvezM</Mb|imMpaNg-%N$P Pioc>dioRef>j>+xaTuagemUr*oXativoXis)3Atr&C(Ci=Cl#Dio,IaIm Lef}eLh#Mp(oN-%N,rN.Rm&RnoRr-oSeSou+St#ToXtu+Xugo3A+G`aJoloMbr MidezNgi=N%'oRagemT~ 5Al]C]L( LiceM^Mil/N`Ntu+Pe%R>ci=RneioRqueRr!>$S.UcaUp{aX*a2Ab&/Acej Adu$rAfeg Aje$AmaAnc ApoAs{oAt?Av E*oEm(Epid EvoIagemIboIcicloId-%Ilog@Ind!eIploItur Iunf&Oc Ombe)OvaUnfoUque2B~ C<oDoLipaPiRboRm>quesaT` T|i&:7V 3Bigo0HaId!eIf|me3Olog@SoTigaUbu0A=InaUfru':C*aDi G o,I=,LaL-%Lid!eLo[sN)gemQu{oR<d>e)Rr(Sc~ Sil]S,u+Z Zio3A=D Ge.Ic~ L{oLhiceLu=Nce=rNdav&N( Nt[Rb&Rd!eRe?Rg}h>m`/RnizRs R%n%SpaSti=T|i&3Adu$AgemAj Atu+Br?D{aDr @ElaGaG-%Gi G| L ejoNcoNhe)NilOle)R!>tudeSi.S$Tr&V{oZ*/5A=rArG&L<%LeibolL)gemLumo,Nt!e5L$Vuz`a::D[zRope3QueRe.Rife3Ng ::Ng#Rp 3BuL?9Mb Olog@5Mbi=";
var checksum6 = "0x2219000926df7b50d8aa0a3d495826b988287df4657fbd100e6fe596c8f737ac";
var wordlist11 = null;

class LangPt extends WordlistOwl {
  constructor() {
    super("pt", words6, checksum6);
  }
  static wordlist() {
    if (wordlist11 == null) {
      wordlist11 = new LangPt;
    }
    return wordlist11;
  }
}

// node_modules/ethers/lib.esm/wordlists/lang-zh.js
function loadWords3(locale) {
  if (_wordlist3[locale] != null) {
    return _wordlist3[locale];
  }
  const wordlist13 = [];
  let deltaOffset = 0;
  for (let i3 = 0;i3 < 2048; i3++) {
    const s3 = style.indexOf(data14[i3 * 3]);
    const bytes5 = [
      228 + (s3 >> 2),
      128 + codes2.indexOf(data14[i3 * 3 + 1]),
      128 + codes2.indexOf(data14[i3 * 3 + 2])
    ];
    if (locale === "zh_tw") {
      const common = s3 % 4;
      for (let i4 = common;i4 < 3; i4++) {
        bytes5[i4] = codes2.indexOf(deltaData[deltaOffset++]) + (i4 == 0 ? 228 : 128);
      }
    }
    wordlist13.push(toUtf8String(new Uint8Array(bytes5)));
  }
  const checksum7 = id(wordlist13.join("\n") + "\n");
  if (checksum7 !== Checks[locale]) {
    throw new Error(`BIP39 Wordlist for ${locale} (Chinese) FAILED`);
  }
  _wordlist3[locale] = wordlist13;
  return wordlist13;
}
var data14 = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
var deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
var _wordlist3 = {
  zh_cn: null,
  zh_tw: null
};
var Checks = {
  zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
  zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
};
var codes2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var style = "~!@#$%^&*_-=[]{}|;:,.()<>?";
var wordlists = {};

class LangZh extends Wordlist {
  constructor(dialect) {
    super("zh_" + dialect);
  }
  getWord(index2) {
    const words7 = loadWords3(this.locale);
    assertArgument(index2 >= 0 && index2 < words7.length, `invalid word index: ${index2}`, "index", index2);
    return words7[index2];
  }
  getWordIndex(word) {
    return loadWords3(this.locale).indexOf(word);
  }
  split(phrase) {
    phrase = phrase.replace(/(?:\u3000| )+/g, "");
    return phrase.split("");
  }
  static wordlist(dialect) {
    if (wordlists[dialect] == null) {
      wordlists[dialect] = new LangZh(dialect);
    }
    return wordlists[dialect];
  }
}

// node_modules/ethers/lib.esm/wordlists/wordlists.js
var wordlists2 = {
  cz: LangCz.wordlist(),
  en: LangEn.wordlist(),
  es: LangEs.wordlist(),
  fr: LangFr.wordlist(),
  it: LangIt.wordlist(),
  pt: LangPt.wordlist(),
  ja: LangJa.wordlist(),
  ko: LangKo.wordlist(),
  zh_cn: LangZh.wordlist("cn"),
  zh_tw: LangZh.wordlist("tw")
};
// src/api/controller/web3/index.ts
function getProvider2(network14 = "ethereum") {
  const rpcUrls = {
    ethereum: process.env.ETHEREUM_RPC_URL || "https://eth.llamarpc.com",
    polygon: process.env.POLYGON_RPC_URL || "https://polygon-rpc.com",
    bsc: process.env.BSC_RPC_URL || "https://bsc-dataseed.binance.org/",
    arbitrum: process.env.ARBITRUM_RPC_URL || "https://arb1.arbitrum.io/rpc",
    optimism: process.env.OPTIMISM_RPC_URL || "https://mainnet.optimism.io"
  };
  const rpcUrl = rpcUrls[network14.toLowerCase()] || rpcUrls.ethereum;
  return new exports_ethers.JsonRpcProvider(rpcUrl);
}
async function verifySignature(message, signature2, expectedAddress) {
  try {
    const recoveredAddress = exports_ethers.verifyMessage(message, signature2);
    return recoveredAddress.toLowerCase() === expectedAddress.toLowerCase();
  } catch (error23) {
    return false;
  }
}
async function fetchNFTMetadata(uri) {
  try {
    if (uri.startsWith("ipfs://")) {
      uri = uri.replace("ipfs://", "https://ipfs.io/ipfs/");
    }
    const response4 = await fetch(uri, {
      headers: {
        Accept: "application/json"
      }
    });
    if (!response4.ok) {
      return null;
    }
    return await response4.json();
  } catch (error23) {
    return null;
  }
}
var web3_default = createElysia().get("/", async () => {
  return {
    message: "Web3/Blockchain Integration API",
    endpoints: {
      walletInfo: "GET /wallet/:address - Get wallet information",
      verifySignature: "POST /verify-signature - Verify wallet signature",
      nftMetadata: "GET /nft/:contract/:tokenId - Get NFT metadata",
      gasPrice: "GET /gas-price?network=ethereum - Get current gas prices"
    },
    supportedNetworks: [
      "Ethereum",
      "Polygon",
      "BSC (Binance Smart Chain)",
      "Arbitrum",
      "Optimism"
    ],
    recommendations: {
      libraries: [
        "ethers.js - Ethereum library and wallet implementation",
        "web3.js - Ethereum JavaScript API",
        "viem - TypeScript-first Ethereum library",
        "wagmi - React hooks for Ethereum"
      ],
      services: [
        "Alchemy - Blockchain development platform",
        "Infura - Ethereum API",
        "Moralis - Web3 development platform",
        "QuickNode - Blockchain infrastructure"
      ],
      tools: [
        "WalletConnect - Connect wallets to dApps",
        "RainbowKit - Wallet connection UI",
        "MetaMask - Browser extension wallet"
      ]
    },
    note: "Install ethers.js: npm install ethers"
  };
}, {
  detail: {
    tags: ["Web3"],
    summary: "Web3 API Information"
  }
}).get("/wallet/:address", async ({ params, query }) => {
  const { address: address24 } = params;
  const { network: network14 = "ethereum" } = query;
  if (!/^0x[a-fA-F0-9]{40}$/.test(address24)) {
    return {
      success: false,
      error: "Invalid Ethereum address format"
    };
  }
  try {
    const provider5 = getProvider2(network14);
    const balance = await provider5.getBalance(address24);
    const networkInfo = await provider5.getNetwork();
    const walletInfo = {
      address: address24,
      balance: balance.toString(),
      balanceInEth: exports_ethers.formatEther(balance),
      network: network14,
      chainId: Number(networkInfo.chainId)
    };
    return {
      success: true,
      data: walletInfo
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to fetch wallet information"
    };
  }
}, {
  params: C.Object({
    address: C.String({ pattern: "^0x[a-fA-F0-9]{40}$" })
  }),
  query: C.Object({
    network: C.Optional(C.String())
  }),
  detail: {
    tags: ["Web3"],
    summary: "Get wallet information",
    description: "Retrieves balance and information for an Ethereum address"
  }
}).post("/verify-signature", async ({ body }) => {
  const { message, signature: signature2, address: address24 } = body;
  try {
    const isValid2 = await verifySignature(message, signature2, address24);
    return {
      success: true,
      valid: isValid2,
      address: address24,
      message: isValid2 ? "Signature verified successfully" : "Invalid signature"
    };
  } catch (error23) {
    return {
      success: false,
      valid: false,
      error: error23.message || "Failed to verify signature"
    };
  }
}, {
  body: C.Object({
    message: C.String(),
    signature: C.String(),
    address: C.String({ pattern: "^0x[a-fA-F0-9]{40}$" })
  }),
  detail: {
    tags: ["Web3"],
    summary: "Verify wallet signature",
    description: "Verifies a signed message from a wallet (for authentication)"
  }
}).get("/nft/:contract/:tokenId", async ({ params, query }) => {
  const { contract: contract5, tokenId } = params;
  const { network: network14 = "ethereum" } = query;
  if (!/^0x[a-fA-F0-9]{40}$/.test(contract5)) {
    return {
      success: false,
      error: "Invalid contract address"
    };
  }
  try {
    const provider5 = getProvider2(network14);
    const erc721Abi = [
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function name() view returns (string)",
      "function symbol() view returns (string)",
      "function ownerOf(uint256 tokenId) view returns (address)"
    ];
    const nftContract = new exports_ethers.Contract(contract5, erc721Abi, provider5);
    const [tokenURI, name, symbol5, owner] = await Promise.allSettled([
      nftContract.tokenURI(tokenId),
      nftContract.name(),
      nftContract.symbol(),
      nftContract.ownerOf(tokenId)
    ]);
    let metadata = null;
    if (tokenURI.status === "fulfilled" && tokenURI.value) {
      metadata = await fetchNFTMetadata(tokenURI.value);
    }
    return {
      success: true,
      data: {
        contract: contract5,
        tokenId,
        network: network14,
        contractInfo: {
          name: name.status === "fulfilled" ? name.value : "Unknown",
          symbol: symbol5.status === "fulfilled" ? symbol5.value : "Unknown"
        },
        owner: owner.status === "fulfilled" ? owner.value : null,
        tokenURI: tokenURI.status === "fulfilled" ? tokenURI.value : null,
        metadata: metadata || {
          note: "Metadata not available or invalid tokenURI"
        }
      }
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to fetch NFT metadata"
    };
  }
}, {
  params: C.Object({
    contract: C.String({ pattern: "^0x[a-fA-F0-9]{40}$" }),
    tokenId: C.String()
  }),
  query: C.Object({
    network: C.Optional(C.String())
  }),
  detail: {
    tags: ["Web3"],
    summary: "Get NFT metadata",
    description: "Retrieves metadata for an NFT token from ERC-721 contract"
  }
}).get("/gas-price", async ({ query }) => {
  const { network: network14 = "ethereum" } = query;
  try {
    const provider5 = getProvider2(network14);
    const feeData = await provider5.getFeeData();
    return {
      success: true,
      network: network14,
      data: {
        gasPrice: feeData.gasPrice ? exports_ethers.formatUnits(feeData.gasPrice, "gwei") : null,
        maxFeePerGas: feeData.maxFeePerGas ? exports_ethers.formatUnits(feeData.maxFeePerGas, "gwei") : null,
        maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? exports_ethers.formatUnits(feeData.maxPriorityFeePerGas, "gwei") : null,
        unit: "Gwei",
        timestamp: new Date().toISOString()
      }
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to fetch gas prices"
    };
  }
}, {
  query: C.Object({
    network: C.Optional(C.String())
  }),
  detail: {
    tags: ["Web3"],
    summary: "Get current gas prices",
    description: "Retrieves current gas prices for specified network (EIP-1559)"
  }
}).get("/transaction/:txHash", async ({ params, query }) => {
  const { txHash } = params;
  const { network: network14 = "ethereum" } = query;
  if (!/^0x[a-fA-F0-9]{64}$/.test(txHash)) {
    return {
      success: false,
      error: "Invalid transaction hash"
    };
  }
  try {
    const provider5 = getProvider2(network14);
    const [tx, receipt] = await Promise.all([
      provider5.getTransaction(txHash),
      provider5.getTransactionReceipt(txHash)
    ]);
    if (!tx) {
      return {
        success: false,
        error: "Transaction not found"
      };
    }
    let timestamp;
    if (tx.blockNumber) {
      const block = await provider5.getBlock(tx.blockNumber);
      timestamp = block?.timestamp;
    }
    const txDetails = {
      hash: tx.hash,
      from: tx.from,
      to: tx.to,
      value: exports_ethers.formatEther(tx.value),
      gasPrice: tx.gasPrice ? exports_ethers.formatUnits(tx.gasPrice, "gwei") : "0",
      gasLimit: tx.gasLimit.toString(),
      nonce: tx.nonce,
      blockNumber: tx.blockNumber,
      blockHash: tx.blockHash,
      timestamp,
      confirmations: await tx.confirmations(),
      status: receipt?.status ?? undefined
    };
    return {
      success: true,
      data: txDetails
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to fetch transaction"
    };
  }
}, {
  params: C.Object({
    txHash: C.String({ pattern: "^0x[a-fA-F0-9]{64}$" })
  }),
  query: C.Object({
    network: C.Optional(C.String())
  }),
  detail: {
    tags: ["Web3"],
    summary: "Get transaction details",
    description: "Retrieves details for a blockchain transaction including confirmations and status"
  }
}).get("/ens/:name", async ({ params }) => {
  const { name } = params;
  try {
    const provider5 = getProvider2("ethereum");
    const address24 = await provider5.resolveName(name);
    if (!address24) {
      return {
        success: false,
        error: "ENS name not found or not registered"
      };
    }
    let reverseName = null;
    try {
      reverseName = await provider5.lookupAddress(address24);
    } catch (e) {
    }
    return {
      success: true,
      data: {
        name,
        address: address24,
        reverseName,
        verified: reverseName?.toLowerCase() === name.toLowerCase()
      }
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to resolve ENS name"
    };
  }
}, {
  params: C.Object({
    name: C.String()
  }),
  detail: {
    tags: ["Web3"],
    summary: "Resolve ENS name",
    description: "Resolves an Ethereum Name Service (ENS) name to an address and performs reverse lookup"
  }
}).get("/ens-reverse/:address", async ({ params }) => {
  const { address: address24 } = params;
  if (!/^0x[a-fA-F0-9]{40}$/.test(address24)) {
    return {
      success: false,
      error: "Invalid Ethereum address format"
    };
  }
  try {
    const provider5 = getProvider2("ethereum");
    const ensName = await provider5.lookupAddress(address24);
    if (!ensName) {
      return {
        success: false,
        error: "No ENS name found for this address"
      };
    }
    const resolvedAddress = await provider5.resolveName(ensName);
    return {
      success: true,
      data: {
        address: address24,
        ensName,
        verified: resolvedAddress?.toLowerCase() === address24.toLowerCase()
      }
    };
  } catch (error23) {
    return {
      success: false,
      error: error23.message || "Failed to perform reverse ENS lookup"
    };
  }
}, {
  params: C.Object({
    address: C.String({ pattern: "^0x[a-fA-F0-9]{40}$" })
  }),
  detail: {
    tags: ["Web3"],
    summary: "Reverse ENS lookup",
    description: "Looks up the ENS name for an Ethereum address"
  }
});

// src/api/index.ts
var apiRoutes = createElysia({ prefix: "/v3" }).group("/auth", (api) => api.use(signup_default).use(login_default).use(logout_default).use(provider_default).use(providerCallback_default)).group("/project", (api) => api.use(createProject_default).use(getAllProject_default).use(getProjectById_default).use(updateProject_default).use(deleteProject_default)).group("/work", (api) => api.use(createWork_default).use(getAllWork_default).use(getWorkById_default).use(updateWork_default).use(deleteWork_default)).group("/education", (api) => api.use(createEducation_default).use(getAllEducation_default).use(getEducationById_default).use(updateEducation_default).use(deleteEducation_default)).group("/ai", (api) => api.use(requestAIChat_default).use(getAIChat_default)).group("/me", (api) => api.use(getUser_default).use(updateUser_default).use(uploadAvatar_default).use(uploadBanner_default).use(deleteAvatar_default).use(deleteBanner_default).use(getAvatar_default).use(getBanner_default)).group("/asset", (api) => api.use(cloudinaryUpload_default).use(minioUpload_default).use(minioDownload_default)).group("/tools", (api) => api.use(getYoutubeDownloader_default).use(getKodeWilayahPos_default).use(getAnime_default).use(getPokemon_default).use(getFacebookDownloader_default).use(getInstagramDownloader_default).use(getTiktokDownloader_default).use(getXDownloader_default)).group("/spotify", (api) => api.use(getSpotify_default)).group("/linkedin", (api) => api.use(getLinkedIn_default)).group("/duolingo", (api) => api.use(getDuolingo_default)).group("/japanese-quiz", (api) => api.use(getJapaneseQuiz_default)).use(publicChat_default).group("/analytics", (api) => api.use(analytics_default)).group("/web3", (api) => api.use(web3_default));
var api_default = apiRoutes;

// node_modules/@elysiajs/swagger/dist/index.mjs
function isSchemaObject(schema3) {
  return "type" in schema3 || "properties" in schema3 || "items" in schema3;
}
function isDateTimeProperty(key, schema3) {
  return (key === "createdAt" || key === "updatedAt") && "anyOf" in schema3 && Array.isArray(schema3.anyOf);
}
function transformDateProperties(schema3) {
  if (!isSchemaObject(schema3) || typeof schema3 !== "object" || schema3 === null) {
    return schema3;
  }
  const newSchema = { ...schema3 };
  Object.entries(newSchema).forEach(([key, value15]) => {
    if (isSchemaObject(value15)) {
      if (isDateTimeProperty(key, value15)) {
        const dateTimeFormat = value15.anyOf?.find((item) => isSchemaObject(item) && item.format === "date-time");
        if (dateTimeFormat) {
          const dateTimeSchema = {
            type: "string",
            format: "date-time",
            default: dateTimeFormat.default
          };
          newSchema[key] = dateTimeSchema;
        }
      } else {
        newSchema[key] = transformDateProperties(value15);
      }
    }
  });
  return newSchema;
}

// node_modules/@scalar/themes/dist/presets/alternate.css2.js
var a = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode,
.light-mode .dark-mode {
  --scalar-background-1: #f9f9f9;
  --scalar-background-2: #f1f1f1;
  --scalar-background-3: #e7e7e7;
  --scalar-background-card: #fff;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: var(--scalar-background-3);

  --scalar-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --scalar-background-1: #131313;
  --scalar-background-2: #1d1d1d;
  --scalar-background-3: #272727;
  --scalar-background-card: #1d1d1d;

  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: var(--scalar-background-3);

  --scalar-border-color: #2a2b2a;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
/* advanced */
.light-mode .dark-mode,
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dd2f2c;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}

.scalar-api-client__item,
.scalar-card,
.dark-mode .dark-mode.scalar-card {
  --scalar-background-1: var(--scalar-background-card);
  --scalar-background-2: var(--scalar-background-1);
  --scalar-background-3: var(--scalar-background-1);
}
.dark-mode .dark-mode.scalar-card {
  --scalar-background-3: var(--scalar-background-3);
}
.t-doc__sidebar {
  --scalar-color-green: var(--scalar-color-1);
  --scalar-color-red: var(--scalar-color-1);
  --scalar-color-yellow: var(--scalar-color-1);
  --scalar-color-blue: var(--scalar-color-1);
  --scalar-color-orange: var(--scalar-color-1);
  --scalar-color-purple: var(--scalar-color-1);
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/bluePlanet.css2.js
var a3 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-background-1: #f0f2f5;
  --scalar-background-2: #eaecf0;
  --scalar-background-3: #e0e2e6;
  --scalar-border-color: rgb(213 213 213);

  --scalar-color-1: rgb(9, 9, 11);
  --scalar-color-2: rgb(113, 113, 122);
  --scalar-color-3: rgba(25, 25, 28, 0.5);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: #8ab4f81f;
}
.light-mode .scalar-card.dark-mode,
.dark-mode {
  --scalar-background-1: #000e23;
  --scalar-background-2: #01132e;
  --scalar-background-3: #03193b;
  --scalar-border-color: #2e394c;

  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: #8ab4f81f;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  z-index: 1;
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-search-background: white;
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom theme */
/* Document header */
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
/* Hero Section Flare */
.section-flare-item:nth-of-type(1) {
  --c1: #ffffff;
  --c2: #babfd8;
  --c3: #2e8bb2;
  --c4: #1a8593;
  --c5: #0a143e;
  --c6: #0a0f52;
  --c7: #2341b8;

  --solid: var(--c1), var(--c2), var(--c3), var(--c4), var(--c5), var(--c6), var(--c7);
  --solid-wrap: var(--solid), var(--c1);
  --trans:
    var(--c1), transparent, var(--c2), transparent, var(--c3),
    transparent, var(--c4), transparent, var(--c5), transparent, var(--c6),
    transparent, var(--c7);
  --trans-wrap: var(--trans), transparent, var(--c1);

  background: radial-gradient(circle, var(--trans)), conic-gradient(from 180deg, var(--trans-wrap)),
    radial-gradient(circle, var(--trans)), conic-gradient(var(--solid-wrap));
  width: 70vw;
  height: 700px;
  border-radius: 50%;
  filter: blur(100px);
  z-index: 0;
  right: 0;
  position: absolute;
  transform: rotate(-45deg);
  top: -300px;
  opacity: 0.3;
}
.section-flare-item:nth-of-type(3) {
  --star-color: #6b9acc;
  --star-color2: #446b8d;
  --star-color3: #3e5879;
  background-image: radial-gradient(2px 2px at 20px 30px, var(--star-color2), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 160px 120px, var(--star-color3), rgba(0, 0, 0, 0));
  background-repeat: repeat;
  background-size: 200px 200px;
  width: 100%;
  height: 100%;
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
}
.section-flare {
  top: -150px !important;
  height: 100vh;
  background: linear-gradient(#000, var(--scalar-background-1));
  width: 100vw;
  overflow-x: hidden;
}
.light-mode .section-flare {
  display: none;
}
.light-mode .scalar-card {
  --scalar-background-1: #fff;
  --scalar-background-2: #fff;
  --scalar-background-3: #fff;
}

*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 60%);
}
`;

// node_modules/@scalar/themes/dist/presets/deepSpace.css2.js
var a5 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-color-1: rgb(9, 9, 11);
  --scalar-color-2: rgb(113, 113, 122);
  --scalar-color-3: rgba(25, 25, 28, 0.5);
  --scalar-color-accent: var(--scalar-color-1);

  --scalar-background-1: #fff;
  --scalar-background-2: #f4f4f5;
  --scalar-background-3: #e3e3e6;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: rgb(228, 228, 231);
  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
.dark-mode {
  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);
  --scalar-color-accent: var(--scalar-color-1);

  --scalar-background-1: #09090b;
  --scalar-background-2: #18181b;
  --scalar-background-3: #2c2c30;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: rgba(255, 255, 255, 0.16);
  --scalar-code-language-color-supersede: var(--scalar-color-1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-item-active-background: var(--scalar-background-2);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.examples .scalar-card-footer {
  --scalar-background-3: transparent;
  padding-top: 0;
}
/* Hero section flare */
.section-flare {
  width: 100vw;
  height: 550px;
  position: absolute;
}
.section-flare-item:nth-of-type(1) {
  position: absolute;
  width: 100vw;
  height: 550px;
  --stripesDark: repeating-linear-gradient(100deg, #000 0%, #000 7%, transparent 10%, transparent 12%, #000 16%);
  --rainbow: repeating-linear-gradient(100deg, #fff 10%, #fff 16%, #fff 22%, #fff 30%);
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.07;
}
.dark-mode .section-flare-item:nth-of-type(1) {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
  height: 350px;
}
.section-flare-item:nth-of-type(1):after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
.section-flare-item:nth-of-type(2) {
  --star-color: #fff;
  --star-color2: #fff;
  --star-color3: #fff;
  width: 100%;
  height: 100%;
  position: absolute;
  background-image: radial-gradient(2px 2px at 20px 30px, var(--star-color2), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 160px 120px, var(--star-color3), rgba(0, 0, 0, 0));
  background-repeat: repeat;
  background-size: 200px 200px;
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  opacity: 0.2;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/default.css2.js
var r = `/* basic theme */
.light-mode {
  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;
  --scalar-background-accent: #8ab4f81f;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #0099ff;
  --scalar-border-color: #dfdfdf;
}
.dark-mode {
  --scalar-background-1: #0f0f0f;
  --scalar-background-2: #1a1a1a;
  --scalar-background-3: #272727;

  --scalar-color-1: #e7e7e7;
  --scalar-color-2: #a4a4a4;
  --scalar-color-3: #797979;

  --scalar-color-accent: #3ea6ff;
  --scalar-background-accent: #3ea6ff1f;

  --scalar-border-color: #2d2d2d;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-2);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-indent-border: var(--scalar-sidebar-border-color);
  --scalar-sidebar-indent-border-hover: var(--scalar-sidebar-border-color);
  --scalar-sidebar-indent-border-active: var(--scalar-sidebar-border-color);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);

  --scalar-color-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-color-1) 20%);

  --scalar-background-alert: color-mix(in srgb, var(--scalar-color-orange), var(--scalar-background-1) 95%);
  --scalar-background-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-background-1) 95%);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;

  --scalar-color-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-background-1) 20%);

  --scalar-background-alert: color-mix(in srgb, var(--scalar-color-orange), var(--scalar-background-1) 95%);
  --scalar-background-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-background-1) 95%);
}
@supports (color: color(display-p3 1 1 1)) {
  .light-mode {
    --scalar-color-accent: color(display-p3 0.0 0.6 1.0 / 1.0);
    --scalar-color-green: color(display-p3 0.023529 0.564706 0.380392 / 1.0);
    --scalar-color-red: color(display-p3 0.937255 0.0 0.023529 / 1.0);
    --scalar-color-yellow: color(display-p3 0.929412 0.745098 0.12549 / 1.0);
    --scalar-color-blue: color(display-p3 0.0 0.509804 0.815686 / 1.0);
    --scalar-color-orange: color(display-p3 0.984314 0.537255 0.172549 / 1.0);
    --scalar-color-purple: color(display-p3 0.321569 0.011765 0.819608 / 1.0);
  }
  .dark-mode {
    --scalar-color-accent: color(display-p3 0.243137 0.65098 1.0 / 1.0);
    --scalar-color-green: color(display-p3 0.0 0.713725 0.282353 / 1.0);
    --scalar-color-red: color(display-p3 0.862745 0.105882 0.098039 / 1.0);
    --scalar-color-yellow: color(display-p3 1.0 0.788235 0.05098 / 1.0);
    --scalar-color-blue: color(display-p3 0.305882 0.701961 0.92549 / 1.0);
    --scalar-color-orange: color(display-p3 1.0 0.552941 0.301961 / 1.0);
    --scalar-color-purple: color(display-p3 0.694118 0.568627 0.976471 / 1.0);
  }
}
`;

// node_modules/@scalar/themes/dist/presets/elysiajs.css2.js
var a6 = `.light-mode {
  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-accent: #f06292;

  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;

  --scalar-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(156, 163, 175, 1);
  --scalar-color-3: rgba(255, 255, 255, 0.44);
  --scalar-color-accent: #f06292;

  --scalar-background-1: #111728;
  --scalar-background-2: #1e293b;
  --scalar-background-3: #334155;
  --scalar-background-accent: #f062921f;

  --scalar-border-color: rgba(255, 255, 255, 0.1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: #f062921f;
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}

/* advanced */
.light-mode {
  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #a3ffa9;
  --scalar-color-red: #ffa3a3;
  --scalar-color-yellow: #fffca3;
  --scalar-color-blue: #a5d6ff;
  --scalar-color-orange: #e2ae83;
  --scalar-color-purple: #d2a8ff;

  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
.section-flare {
  width: 100%;
  height: 400px;
  position: absolute;
}
.section-flare-item:first-of-type:before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  --stripes: repeating-linear-gradient(100deg, #fff 0%, #fff 0%, transparent 2%, transparent 12%, #fff 17%);
  --stripesDark: repeating-linear-gradient(100deg, #000 0%, #000 0%, transparent 10%, transparent 12%, #000 17%);
  --rainbow: repeating-linear-gradient(100deg, #60a5fa 10%, #e879f9 16%, #5eead4 22%, #60a5fa 30%);
  contain: strict;
  contain-intrinsic-size: 100vw 40vh;
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: opacity(20%) saturate(200%);
  -webkit-mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
}
.section-flare-item:first-of-type:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
  background-image: var(--stripesDark), var(--rainbow);
  pointer-events: none;
}
.light-mode .section-flare-item:first-of-type:after,
.light-mode .section-flare-item:first-of-type:before {
  background-image: var(--stripes), var(--rainbow);
  filter: opacity(4%) saturate(200%);
}
`;

// node_modules/@scalar/themes/dist/presets/fastify.css2.js
var a7 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #1c1e21;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-disabled: #b4b1b1;
  --scalar-color-ghost: #a7a7a7;
  --scalar-color-accent: #2f8555;
  --scalar-background-1: #fff;
  --scalar-background-2: #f5f5f5;
  --scalar-background-3: #ededed;
  --scalar-background-4: rgba(0, 0, 0, 0.06);
  --scalar-background-accent: #2f85551f;

  --scalar-border-color: rgba(0, 0, 0, 0.1);
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px, rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-green: #007300;
  --scalar-color-red: #af272b;
  --scalar-color-yellow: #b38200;
  --scalar-color-blue: #3b8ba5;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);
  --scalar-color-disabled: rgba(255, 255, 255, 0.34);
  --scalar-color-ghost: rgba(255, 255, 255, 0.26);
  --scalar-color-accent: #27c2a0;
  --scalar-background-1: #1b1b1d;
  --scalar-background-2: #242526;
  --scalar-background-3: #3b3b3b;
  --scalar-background-4: rgba(255, 255, 255, 0.06);
  --scalar-background-accent: #27c2a01f;

  --scalar-border-color: rgba(255, 255, 255, 0.1);
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px, rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px
    rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #26b226;
  --scalar-color-red: #fb565b;
  --scalar-color-yellow: #ffc426;
  --scalar-color-blue: #6ecfef;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}
`;

// node_modules/@scalar/themes/dist/presets/kepler.css2.js
var a8 = `/* basic theme */
.light-mode {
  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-accent: #7070ff;

  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;
  --scalar-background-accent: #7070ff1f;

  --scalar-border-color: rgba(0, 0, 0, 0.1);

  --scalar-code-language-color-supersede: var(--scalar-color-3);
}
.dark-mode {
  --scalar-color-1: #f7f8f8;
  --scalar-color-2: rgb(180, 188, 208);
  --scalar-color-3: #b4bcd099;
  --scalar-color-accent: #828fff;

  --scalar-background-1: #000212;
  --scalar-background-2: #0d0f1e;
  --scalar-background-3: #232533;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: #313245;
  --scalar-code-language-color-supersede: var(--scalar-color-3);
}
/* Document Sidebar */
.light-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: rgba(0, 0, 0, 0.05);
  --scalar-sidebar-search-border-color: 1px solid rgba(0, 0, 0, 0.05);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-background-2: rgba(0, 0, 0, 0.03);
}
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-border-color: 1px solid rgba(255, 255, 255, 0.05);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom Theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.sidebar-search {
  backdrop-filter: blur(12px);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.dark-mode .scalar-card {
  background: rgba(255, 255, 255, 0.05) !important;
}
.dark-mode .scalar-card * {
  --scalar-background-2: transparent !important;
  --scalar-background-1: transparent !important;
}
.light-mode .dark-mode.scalar-card *,
.light-mode .dark-mode.scalar-card {
  --scalar-background-1: #0d0f1e !important;
  --scalar-background-2: #0d0f1e !important;
  --scalar-background-3: #191b29 !important;
}
.light-mode .dark-mode.scalar-card {
  background: #191b29 !important;
}
.badge {
  box-shadow: 0 0 0 1px var(--scalar-border-color);
  margin-right: 6px;
}

.table-row.required-parameter .table-row-item:nth-of-type(2):after {
  background: transparent;
  box-shadow: none;
}
/* Hero Section Flare */
.section-flare {
  width: 100vw;
  background: radial-gradient(ellipse 80% 50% at 50% -20%, rgba(120, 119, 198, 0.3), transparent);
  height: 100vh;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/mars.css2.js
var a9 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-background-1: #f9f6f0;
  --scalar-background-2: #f2efe8;
  --scalar-background-3: #e9e7e2;
  --scalar-border-color: rgba(203, 165, 156, 0.6);

  --scalar-color-1: #c75549;
  --scalar-color-2: #c75549;
  --scalar-color-3: #c75549;

  --scalar-color-accent: #c75549;
  --scalar-background-accent: #dcbfa81f;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
.dark-mode {
  --scalar-background-1: #140507;
  --scalar-background-2: #20090c;
  --scalar-background-3: #321116;
  --scalar-border-color: #3c3031;

  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);

  --scalar-color-accent: rgba(255, 255, 255, 0.9);
  --scalar-background-accent: #441313;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  z-index: 1;
}
/* advanced */
.light-mode {
  --scalar-color-green: #09533a;
  --scalar-color-red: #aa181d;
  --scalar-color-yellow: #ab8d2b;
  --scalar-color-blue: #19689a;
  --scalar-color-orange: #b26c34;
  --scalar-color-purple: #4c2191;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom Theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-search-background: white;
}
.examples .scalar-card-footer {
  --scalar-background-3: transparent;
  padding-top: 0;
}
/* Hero section flare */
.section-flare {
  overflow-x: hidden;
  height: 100vh;
  left: initial;
}
.section-flare-item:nth-of-type(1) {
  background: #d25019;
  position: relative;
  top: -150px;
  right: -400px;
  width: 80vw;
  height: 500px;
  margin-top: -150px;
  border-radius: 50%;
  filter: blur(100px);
  z-index: 0;
}
.light-mode .section-flare {
  display: none;
}
*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-red), transparent 75%);
}
`;

// node_modules/@scalar/themes/dist/presets/moon.css2.js
var a10 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #000000;
  --scalar-color-2: #000000;
  --scalar-color-3: #000000;
  --scalar-color-accent: #645b0f;
  --scalar-background-1: #ccc9b3;
  --scalar-background-2: #c2bfaa;
  --scalar-background-3: #b8b5a1;
  --scalar-background-accent: #000000;

  --scalar-border-color: rgba(0, 0, 0, 0.2);
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px, rgba(0, 0, 0, 0.08) 0px 3px 8px 0px,
    var(--scalar-border-color) 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-red: #b91c1c;
  --scalar-color-orange: #a16207;
  --scalar-color-green: #047857;
  --scalar-color-blue: #1d4ed8;
  --scalar-color-orange: #c2410c;
  --scalar-color-purple: #6d28d9;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: #fffef3;
  --scalar-color-2: #fffef3;
  --scalar-color-3: #fffef3;
  --scalar-color-accent: #c3b531;
  --scalar-background-1: #313332;
  --scalar-background-2: #393b3a;
  --scalar-background-3: #414342;
  --scalar-background-accent: #fffef3;

  --scalar-border-color: #505452;
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px, rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px
    rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}

/* Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 80%);
}
`;

// node_modules/@scalar/themes/dist/presets/purple.css2.js
var a11 = `/* basic theme */
.light-mode {
  --scalar-background-1: #fff;
  --scalar-background-2: #f5f6f8;
  --scalar-background-3: #eceef1;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #5469d4;
  --scalar-background-accent: #5469d41f;

  --scalar-border-color: rgba(215, 215, 206, 0.68);
}
.dark-mode {
  --scalar-background-1: #15171c;
  --scalar-background-2: #1c1e24;
  --scalar-background-3: #22252b;

  --scalar-color-1: #fafafa;
  --scalar-color-2: #c9ced8;
  --scalar-color-3: #8c99ad;

  --scalar-color-accent: #5469d4;
  --scalar-background-accent: #5469d41f;

  --scalar-border-color: #3f4145;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-3);

  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: var(--scalar-background-1);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}

/* advanced */
.light-mode {
  --scalar-color-green: #17803d;
  --scalar-color-red: #e10909;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #1763a6;
  --scalar-color-orange: #e25b09;
  --scalar-color-purple: #5c3993;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #30a159;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #eec644;
  --scalar-color-blue: #2b7abf;
  --scalar-color-orange: #f07528;
  --scalar-color-purple: #7a59b1;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/saturn.css2.js
var a12 = `/* basic theme */
.light-mode {
  --scalar-background-1: #f3f3ee;
  --scalar-background-2: #e8e8e3;
  --scalar-background-3: #e4e4df;
  --scalar-border-color: rgba(215, 215, 206, 0.85);

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #1763a6;
  --scalar-background-accent: #1f648e1f;
}
.dark-mode {
  --scalar-background-1: #09090b;
  --scalar-background-2: #18181b;
  --scalar-background-3: #2c2c30;
  --scalar-border-color: rgba(255, 255, 255, 0.17);

  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);

  --scalar-color-accent: #4eb3ec;
  --scalar-background-accent: #8ab4f81f;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-search-background: var(--scalar-background-1);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}

/* advanced */
.light-mode {
  --scalar-color-green: #17803d;
  --scalar-color-red: #e10909;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #1763a6;
  --scalar-color-orange: #e25b09;
  --scalar-color-purple: #5c3993;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #30a159;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #eec644;
  --scalar-color-blue: #2b7abf;
  --scalar-color-orange: #f07528;
  --scalar-color-purple: #7a59b1;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/solarized.css2.js
var a13 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #584c27;
  --scalar-color-2: #616161;
  --scalar-color-3: #a89f84;
  --scalar-color-accent: #b58900;
  --scalar-background-1: #fdf6e3;
  --scalar-background-2: #eee8d5;
  --scalar-background-3: #ddd6c1;
  --scalar-background-accent: #b589001f;

  --scalar-border-color: #ded8c8;
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px, rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-red: #b91c1c;
  --scalar-color-orange: #a16207;
  --scalar-color-green: #047857;
  --scalar-color-blue: #1d4ed8;
  --scalar-color-orange: #c2410c;
  --scalar-color-purple: #6d28d9;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: #fff;
  --scalar-color-2: #cccccc;
  --scalar-color-3: #6d8890;
  --scalar-color-accent: #007acc;
  --scalar-background-1: #00212b;
  --scalar-background-2: #012b36;
  --scalar-background-3: #004052;
  --scalar-background-accent: #015a6f;

  --scalar-border-color: #2f4851;
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px, rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px
    rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}

/* Sidebar */
.light-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: var(--scalar-background-2);
  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);
  --scalar-sidebar-search--color: var(--scalar-color-3);
}

.dark-mode .sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-sidebar-color-1);
  --scalar-sidebar-search-background: var(--scalar-background-2);
  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);
  --scalar-sidebar-search--color: var(--scalar-color-3);
}
*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
`;

// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/api-reference-plugin.js
var OpenApiExtensionSchema = z.object({
  name: z.string().regex(/^x-/),
  component: z.unknown()
});
var ApiReferencePluginSchema = z.function().returns(z.object({
  name: z.string(),
  extensions: z.array(OpenApiExtensionSchema)
}));

// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/helpers/migrate-theme-variables.js
function migrateThemeVariables(styles3) {
  const hasLegacyPrefixes = LEGACY_PREFIXES.some((p) => styles3.includes(p));
  if (!hasLegacyPrefixes) {
    return styles3;
  }
  console.warn(`DEPRECATION WARNING: It looks like you're using legacy CSS variables in your custom CSS string. Please migrate them to use the updated prefixes. See https://github.com/scalar/scalar/blob/main/documentation/themes.md#theme-prefix-changes`);
  return PREFIX_MIGRATIONS.reduce((s3, [o3, n4]) => s3.replaceAll(o3, n4), styles3);
}
var PREFIX_MIGRATIONS = [
  ["--theme-", "--scalar-"],
  ["--sidebar-", "--scalar-sidebar-"]
];
var LEGACY_PREFIXES = PREFIX_MIGRATIONS.map(([legacy]) => legacy);

// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/api-reference-configuration.js
var themeIdEnum = z.enum([
  "alternate",
  "default",
  "moon",
  "purple",
  "solarized",
  "bluePlanet",
  "deepSpace",
  "saturn",
  "kepler",
  "elysiajs",
  "fastify",
  "mars",
  "none"
]);
var searchHotKeyEnum = z.enum([
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z"
]);
var integrationEnum = z.enum([
  "adonisjs",
  "docusaurus",
  "dotnet",
  "elysiajs",
  "express",
  "fastapi",
  "fastify",
  "go",
  "hono",
  "html",
  "laravel",
  "litestar",
  "nestjs",
  "nextjs",
  "nitro",
  "nuxt",
  "platformatic",
  "react",
  "rust",
  "vue"
]).nullable();
var specConfigurationSchema = z.object({
  url: z.string().optional(),
  content: z.union([z.string(), z.record(z.any()), z.function().returns(z.record(z.any())), z.null()]).optional(),
  title: z.string().optional(),
  slug: z.string().optional()
});
var pathRoutingSchema = z.object({
  basePath: z.string()
});
var apiClientConfigurationSchema = z.object({
  url: z.string().optional(),
  content: z.union([z.string(), z.record(z.any()), z.function().returns(z.record(z.any())), z.null()]).optional(),
  title: z.string().optional(),
  slug: z.string().optional(),
  spec: specConfigurationSchema.optional(),
  authentication: z.any().optional(),
  baseServerURL: z.string().optional(),
  hideClientButton: z.boolean().optional().default(false).catch(false),
  proxyUrl: z.string().optional(),
  searchHotKey: searchHotKeyEnum.optional(),
  servers: z.array(z.any()).optional(),
  showSidebar: z.boolean().optional().default(true).catch(true),
  theme: themeIdEnum.optional().default("default").catch("default"),
  _integration: integrationEnum.optional(),
  onRequestSent: z.function().args(z.string()).returns(z.void()).optional()
});
var OLD_PROXY_URL = "https://api.scalar.com/request-proxy";
var NEW_PROXY_URL = "https://proxy.scalar.com";
var _apiReferenceConfigurationSchema = apiClientConfigurationSchema.merge(z.object({
  layout: z.enum(["modern", "classic"]).optional().default("modern").catch("modern"),
  proxy: z.string().optional(),
  plugins: z.array(ApiReferencePluginSchema).optional(),
  isEditable: z.boolean().optional().default(false).catch(false),
  isLoading: z.boolean().optional().default(false).catch(false),
  hideModels: z.boolean().optional().default(false).catch(false),
  hideDownloadButton: z.boolean().optional().default(false).catch(false),
  hideTestRequestButton: z.boolean().optional().default(false).catch(false),
  hideSearch: z.boolean().optional().default(false).catch(false),
  darkMode: z.boolean().optional(),
  forceDarkModeState: z.enum(["dark", "light"]).optional(),
  hideDarkModeToggle: z.boolean().optional().default(false).catch(false),
  metaData: z.any().optional(),
  favicon: z.string().optional(),
  hiddenClients: z.union([z.record(z.union([z.boolean(), z.array(z.string())])), z.array(z.string()), z.literal(true)]).optional(),
  defaultHttpClient: z.object({
    targetKey: z.custom(),
    clientKey: z.string()
  }).optional(),
  customCss: z.string().optional(),
  onSpecUpdate: z.function().args(z.string()).returns(z.void()).optional(),
  onServerChange: z.function().args(z.string()).returns(z.void()).optional(),
  onDocumentSelect: z.function().returns(z.void().or(z.void().promise())).optional(),
  onLoaded: z.function().returns(z.void().or(z.void().promise())).optional(),
  onShowMore: z.function().args(z.string()).returns(z.void().or(z.void().promise())).optional(),
  onSidebarClick: z.function().args(z.string()).returns(z.void().or(z.void().promise())).optional(),
  pathRouting: pathRoutingSchema.optional(),
  generateHeadingSlug: z.function().args(z.object({
    slug: z.string().default("headingSlug")
  })).returns(z.string()).optional(),
  generateModelSlug: z.function().args(z.object({
    name: z.string().default("modelName")
  })).returns(z.string()).optional(),
  generateTagSlug: z.function().args(z.object({
    name: z.string().default("tagName")
  })).returns(z.string()).optional(),
  generateOperationSlug: z.function().args(z.object({
    path: z.string(),
    operationId: z.string().optional(),
    method: z.string(),
    summary: z.string().optional()
  })).returns(z.string()).optional(),
  generateWebhookSlug: z.function().args(z.object({
    name: z.string(),
    method: z.string().optional()
  })).returns(z.string()).optional(),
  redirect: z.function().args(z.string()).returns(z.string().nullable().optional()).optional(),
  withDefaultFonts: z.boolean().optional().default(true).catch(true),
  defaultOpenAllTags: z.boolean().optional(),
  tagsSorter: z.union([z.literal("alpha"), z.function().args(z.any(), z.any()).returns(z.number())]).optional(),
  operationsSorter: z.union([z.literal("alpha"), z.literal("method"), z.function().args(z.any(), z.any()).returns(z.number())]).optional()
}));
var migrateConfiguration = (_configuration) => {
  const configuration = { ..._configuration };
  if (configuration.spec?.url) {
    console.warn(`[DEPRECATED] You're using the deprecated 'spec.url' attribute. Remove the spec prefix and move the 'url' attribute to the top level.`);
    configuration.url = configuration.spec.url;
    delete configuration.spec;
  }
  if (configuration.spec?.content) {
    console.warn(`[DEPRECATED] You're using the deprecated 'spec.content' attribute. Remove the spec prefix and move the 'content' attribute to the top level.`);
    configuration.content = configuration.spec.content;
    delete configuration.spec;
  }
  if (configuration.customCss) {
    configuration.customCss = migrateThemeVariables(configuration.customCss);
  }
  if (configuration.proxy) {
    console.warn(`[DEPRECATED] You're using the deprecated 'proxy' attribute, rename it to 'proxyUrl' or update the package.`);
    if (!configuration.proxyUrl) {
      configuration.proxyUrl = configuration.proxy;
    }
    delete configuration.proxy;
  }
  if (configuration.proxyUrl === OLD_PROXY_URL) {
    console.warn(`[DEPRECATED] Warning: configuration.proxyUrl points to our old proxy (${OLD_PROXY_URL}).`);
    console.warn(`[DEPRECATED] We are overwriting the value and use the new proxy URL (${NEW_PROXY_URL}) instead.`);
    console.warn(`[DEPRECATED] Action Required: You should manually update your configuration to use the new URL (${NEW_PROXY_URL}). Read more: https://github.com/scalar/scalar`);
    configuration.proxyUrl = NEW_PROXY_URL;
  }
  return configuration;
};
var apiReferenceConfigurationSchema = _apiReferenceConfigurationSchema.transform(migrateConfiguration);
// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/html-rendering-configuration.js
var htmlRenderingConfigurationSchema = z.object({
  cdn: z.string().optional().default("https://cdn.jsdelivr.net/npm/@scalar/api-reference"),
  pageTitle: z.string().optional().default("Scalar API Reference")
});
// node_modules/@scalar/themes/dist/index.js
var m3 = {
  alternate: a,
  default: r,
  moon: a10,
  elysiajs: a6,
  fastify: a7,
  purple: a11,
  solarized: a13,
  bluePlanet: a3,
  deepSpace: a5,
  saturn: a12,
  kepler: a8,
  mars: a9
};
var K6 = Object.keys(m3);

// node_modules/@elysiajs/swagger/dist/index.mjs
var SwaggerUIRender = (info, version2, theme, stringifiedSwaggerOptions, autoDarkMode) => {
  const swaggerOptions = JSON.parse(stringifiedSwaggerOptions);
  if (swaggerOptions.components && swaggerOptions.components.schemas) {
    swaggerOptions.components.schemas = Object.fromEntries(Object.entries(swaggerOptions.components.schemas).map(([key, schema3]) => [
      key,
      transformDateProperties(schema3)
    ]));
  }
  const transformedStringifiedSwaggerOptions = JSON.stringify(swaggerOptions);
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${autoDarkMode && typeof theme === "string" ? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>` : ""}
    ${typeof theme === "string" ? `<link rel="stylesheet" href="${theme}" />` : `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version2}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${transformedStringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;
};
var ScalarRender = (info, version2, config2, cdn) => `<!doctype html>
<html>
  <head>
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config2.customCss ?? a6}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config2.spec?.url}"
      data-configuration='${JSON.stringify(config2)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version2}/dist/browser/standalone.min.js`}" crossorigin></script>
  </body>
</html>`;
var TransformKind2 = Symbol.for("TypeBox.Transform");
var ReadonlyKind2 = Symbol.for("TypeBox.Readonly");
var OptionalKind2 = Symbol.for("TypeBox.Optional");
var Hint2 = Symbol.for("TypeBox.Hint");
var Kind2 = Symbol.for("TypeBox.Kind");
var toOpenAPIPath = (path2) => path2.split("/").map((x3) => {
  if (x3.startsWith(":")) {
    x3 = x3.slice(1, x3.length);
    if (x3.endsWith("?"))
      x3 = x3.slice(0, -1);
    x3 = `{${x3}}`;
  }
  return x3;
}).join("/");
var mapProperties = (name, schema3, models) => {
  if (schema3 === undefined)
    return [];
  if (typeof schema3 === "string")
    if (schema3 in models)
      schema3 = models[schema3];
    else
      throw new Error(`Can't find model ${schema3}`);
  return Object.entries(schema3?.properties ?? []).map(([key, value15]) => {
    const {
      type: valueType = undefined,
      description,
      examples,
      ...schemaKeywords
    } = value15;
    return {
      description,
      examples,
      schema: { type: valueType, ...schemaKeywords },
      in: name,
      name: key,
      required: schema3.required?.includes(key) ?? false
    };
  });
};
var mapTypesResponse = (types, schema3) => {
  if (typeof schema3 === "object" && ["void", "undefined", "null"].includes(schema3.type))
    return;
  const responses = {};
  for (const type50 of types) {
    responses[type50] = {
      schema: typeof schema3 === "string" ? {
        $ref: `#/components/schemas/${schema3}`
      } : ("$ref" in schema3) && (Kind2 in schema3) && schema3[Kind2] === "Ref" ? {
        ...schema3,
        $ref: `#/components/schemas/${schema3.$ref}`
      } : B2({ ...schema3 }, {
        from: C.Ref(""),
        to: ({ $ref, ...options }) => {
          if (!$ref.startsWith("#/components/schemas/"))
            return C.Ref(`#/components/schemas/${$ref}`, options);
          return C.Ref($ref, options);
        }
      })
    };
  }
  return responses;
};
var capitalize2 = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var generateOperationId = (method, paths) => {
  let operationId = method.toLowerCase();
  if (paths === "/")
    return operationId + "Index";
  for (const path2 of paths.split("/")) {
    if (path2.charCodeAt(0) === 123) {
      operationId += "By" + capitalize2(path2.slice(1, -1));
    } else {
      operationId += capitalize2(path2);
    }
  }
  return operationId;
};
var cloneHook = (hook) => {
  if (!hook)
    return;
  if (typeof hook === "string")
    return hook;
  if (Array.isArray(hook))
    return [...hook];
  return { ...hook };
};
var registerSchemaPath = ({
  schema: schema3,
  path: path2,
  method,
  hook,
  models
}) => {
  hook = cloneHook(hook);
  if (hook.parse && !Array.isArray(hook.parse))
    hook.parse = [hook.parse];
  let contentType = hook.parse?.map((x3) => {
    switch (typeof x3) {
      case "string":
        return x3;
      case "object":
        if (x3 && typeof x3?.fn !== "string")
          return;
        switch (x3?.fn) {
          case "json":
          case "application/json":
            return "application/json";
          case "text":
          case "text/plain":
            return "text/plain";
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            return "application/x-www-form-urlencoded";
          case "arrayBuffer":
          case "application/octet-stream":
            return "application/octet-stream";
          case "formdata":
          case "multipart/form-data":
            return "multipart/form-data";
        }
    }
  }).filter((x3) => x3 !== undefined);
  if (!contentType || contentType.length === 0)
    contentType = ["application/json", "multipart/form-data", "text/plain"];
  path2 = toOpenAPIPath(path2);
  const contentTypes = typeof contentType === "string" ? [contentType] : contentType ?? ["application/json"];
  const bodySchema = cloneHook(hook?.body);
  const paramsSchema = cloneHook(hook?.params);
  const headerSchema = cloneHook(hook?.headers);
  const querySchema = cloneHook(hook?.query);
  let responseSchema = cloneHook(hook?.response);
  if (typeof responseSchema === "object") {
    if (Kind2 in responseSchema) {
      const {
        type: type50,
        properties: properties7,
        required: required5,
        additionalProperties,
        patternProperties,
        $ref,
        ...rest4
      } = responseSchema;
      responseSchema = {
        "200": {
          ...rest4,
          description: rest4.description,
          content: mapTypesResponse(contentTypes, type50 === "object" || type50 === "array" ? {
            type: type50,
            properties: properties7,
            patternProperties,
            items: responseSchema.items,
            required: required5
          } : responseSchema)
        }
      };
    } else {
      Object.entries(responseSchema).forEach(([key, value15]) => {
        if (typeof value15 === "string") {
          if (!models[value15])
            return;
          const {
            type: type50,
            properties: properties7,
            required: required5,
            additionalProperties: _12,
            patternProperties: _22,
            ...rest4
          } = models[value15];
          responseSchema[key] = {
            ...rest4,
            description: rest4.description,
            content: mapTypesResponse(contentTypes, value15)
          };
        } else {
          const {
            type: type50,
            properties: properties7,
            required: required5,
            additionalProperties,
            patternProperties,
            ...rest4
          } = value15;
          responseSchema[key] = {
            ...rest4,
            description: rest4.description,
            content: mapTypesResponse(contentTypes, type50 === "object" || type50 === "array" ? {
              type: type50,
              properties: properties7,
              patternProperties,
              items: value15.items,
              required: required5
            } : value15)
          };
        }
      });
    }
  } else if (typeof responseSchema === "string") {
    if (!(responseSchema in models))
      return;
    const {
      type: type50,
      properties: properties7,
      required: required5,
      $ref,
      additionalProperties: _12,
      patternProperties: _22,
      ...rest4
    } = models[responseSchema];
    responseSchema = {
      "200": {
        ...rest4,
        content: mapTypesResponse(contentTypes, responseSchema)
      }
    };
  }
  const parameters4 = [
    ...mapProperties("header", headerSchema, models),
    ...mapProperties("path", paramsSchema, models),
    ...mapProperties("query", querySchema, models)
  ];
  schema3[path2] = {
    ...schema3[path2] ? schema3[path2] : {},
    [method.toLowerCase()]: {
      ...headerSchema || paramsSchema || querySchema || bodySchema ? { parameters: parameters4 } : {},
      ...responseSchema ? {
        responses: responseSchema
      } : {},
      operationId: hook?.detail?.operationId ?? generateOperationId(method, path2),
      ...hook?.detail,
      ...bodySchema ? {
        requestBody: {
          required: true,
          content: mapTypesResponse(contentTypes, typeof bodySchema === "string" ? {
            $ref: `#/components/schemas/${bodySchema}`
          } : bodySchema)
        }
      } : null
    }
  };
};
var filterPaths = (paths, {
  excludeStaticFile = true,
  exclude: exclude6 = []
}) => {
  const newPaths = {};
  for (const [key, value15] of Object.entries(paths))
    if (!exclude6.some((x3) => {
      if (typeof x3 === "string")
        return key === x3;
      return x3.test(key);
    }) && !key.includes("*") && (excludeStaticFile ? !key.includes(".") : true)) {
      Object.keys(value15).forEach((method) => {
        const schema3 = value15[method];
        if (key.includes("{")) {
          if (!schema3.parameters)
            schema3.parameters = [];
          schema3.parameters = [
            ...key.split("/").filter((x3) => x3.startsWith("{") && !schema3.parameters.find((params) => params.in === "path" && params.name === x3.slice(1, x3.length - 1))).map((x3) => ({
              schema: { type: "string" },
              in: "path",
              name: x3.slice(1, x3.length - 1),
              required: true
            })),
            ...schema3.parameters
          ];
        }
        if (!schema3.responses)
          schema3.responses = {
            200: {}
          };
      });
      newPaths[key] = value15;
    }
  return newPaths;
};
var swagger = ({
  provider: provider6 = "scalar",
  scalarVersion = "latest",
  scalarCDN = "",
  scalarConfig = {},
  documentation = {},
  version: version2 = "5.9.0",
  excludeStaticFile = true,
  path: path2 = "/swagger",
  specPath = `${path2}/json`,
  exclude: exclude6 = [],
  swaggerOptions = {},
  theme = `https://unpkg.com/swagger-ui-dist@${version2}/swagger-ui.css`,
  autoDarkMode = true,
  excludeMethods = ["OPTIONS"],
  excludeTags = []
} = {}) => {
  const schema3 = {};
  let totalRoutes = 0;
  if (!version2)
    version2 = `https://unpkg.com/swagger-ui-dist@${version2}/swagger-ui.css`;
  const info = {
    title: "Elysia Documentation",
    description: "Development documentation",
    version: "0.0.0",
    ...documentation.info
  };
  const relativePath = specPath.startsWith("/") ? specPath.slice(1) : specPath;
  const app = new j0({ name: "@elysiajs/swagger" });
  const page = new Response(provider6 === "swagger-ui" ? SwaggerUIRender(info, version2, theme, JSON.stringify({
    url: relativePath,
    dom_id: "#swagger-ui",
    ...swaggerOptions
  }, (_5, value15) => typeof value15 === "function" ? undefined : value15), autoDarkMode) : ScalarRender(info, scalarVersion, {
    spec: {
      url: relativePath,
      ...scalarConfig.spec
    },
    ...scalarConfig,
    _integration: "elysiajs"
  }, scalarCDN), {
    headers: {
      "content-type": "text/html; charset=utf8"
    }
  });
  app.get(path2, page, {
    detail: {
      hide: true
    }
  }).get(specPath, function openAPISchema() {
    const routes = app.getGlobalRoutes();
    if (routes.length !== totalRoutes) {
      const ALLOWED_METHODS = [
        "GET",
        "PUT",
        "POST",
        "DELETE",
        "OPTIONS",
        "HEAD",
        "PATCH",
        "TRACE"
      ];
      totalRoutes = routes.length;
      routes.forEach((route) => {
        if (route.hooks?.detail?.hide === true)
          return;
        if (excludeMethods.includes(route.method))
          return;
        if (ALLOWED_METHODS.includes(route.method) === false && route.method !== "ALL")
          return;
        if (route.method === "ALL")
          ALLOWED_METHODS.forEach((method) => {
            registerSchemaPath({
              schema: schema3,
              hook: route.hooks,
              method,
              path: route.path,
              models: app.getGlobalDefinitions?.().type,
              contentType: route.hooks.type
            });
          });
        else
          registerSchemaPath({
            schema: schema3,
            hook: route.hooks,
            method: route.method,
            path: route.path,
            models: app.getGlobalDefinitions?.().type,
            contentType: route.hooks.type
          });
      });
    }
    return {
      openapi: "3.0.3",
      ...{
        ...documentation,
        tags: documentation.tags?.filter((tag) => !excludeTags?.includes(tag?.name)),
        info: {
          title: "Elysia Documentation",
          description: "Development documentation",
          version: "0.0.0",
          ...documentation.info
        }
      },
      paths: {
        ...filterPaths(schema3, {
          excludeStaticFile,
          exclude: Array.isArray(exclude6) ? exclude6 : [exclude6]
        }),
        ...documentation.paths
      },
      components: {
        ...documentation.components,
        schemas: {
          ...app.getGlobalDefinitions?.().type,
          ...documentation.components?.schemas
        }
      }
    };
  }, {
    detail: {
      hide: true
    }
  });
  return app;
};
var index_default = swagger;

// src/libs/swagger.ts
var docs = index_default({
  path: "/docs",
  provider: "scalar",
  scalarConfig: {
    theme: "purple",
    darkMode: true
  },
  documentation: {
    info: {
      title: "Portfolio v3 API - Comprehensive Backend Services",
      version: "3.1.0",
      description: `
# Portfolio v3 API Documentation

A modern, feature-rich backend API built with Elysia.js and Bun, providing comprehensive services for portfolio management, social media integration, Web3 functionality, and more.

## Features

- \uD83D\uDD10 **Multi-Provider OAuth Authentication** (Google, GitHub, Discord, Facebook)
- \uD83D\uDC65 **Role-Based Access Control** (Admin, User, Guest)
- \uD83D\uDCAC **Public Chat System** with rate limiting
- \uD83D\uDCCA **Cursor-Based Pagination** for all list endpoints
- \uD83D\uDDBC\uFE0F **Image Management** with Minio storage
- \uD83C\uDFAE **Pokemon Database** integration
- \uD83C\uDF10 **Web3 Support** (wallet checking, crypto prices, NFTs)
- \uD83D\uDCF1 **Social Media Downloaders** (YouTube, TikTok, Instagram, Facebook, X/Twitter)
- \uD83D\uDCC8 **Analytics & Monitoring** with Grafana Loki
- \uD83C\uDFAF **Project Portfolio Management**
- \uD83D\uDCDA **Education & Work Experience Management**

## Authentication

Most endpoints require authentication via Bearer token or session cookie.

### OAuth Providers
- Google: \`/v3/auth/google\`
- GitHub: \`/v3/auth/github\`
- Discord: \`/v3/auth/discord\`
- Facebook: \`/v3/auth/facebook\`

## Rate Limits

- Public Chat: 1 post per day per user
- API calls: Standard rate limiting applies

## Pagination

All list endpoints support cursor-based pagination:
- \`cursor\`: Optional cursor for pagination
- \`limit\`: Items per page (default: 10, max: 50)
      `,
      contact: {
        name: "API Support",
        email: "rizkyhaksono@gmail.com"
      },
      license: {
        name: "MIT"
      }
    },
    servers: [
      {
        url: `http://localhost:${"3005"}`,
        description: "Development server"
      },
      {
        url: "https://api.natee.my.id",
        description: "Natee's production server - my.id domain"
      },
      {
        url: "https://api.nateee.com",
        description: "Natee's production server - .com domain"
      }
    ],
    tags: [
      {
        name: "Authentication",
        description: "Multi-provider OAuth authentication (Google, GitHub, Discord, Facebook), traditional login/signup, and session management. Supports email conflict prevention across providers."
      },
      {
        name: "Public Chat",
        description: "Community chat system where authenticated users can post once per day, edit their posts, and view all public messages with pagination."
      },
      {
        name: "User",
        description: "User profile management including avatar/banner uploads, profile updates, and user information retrieval."
      },
      {
        name: "Project",
        description: "Portfolio project management with full CRUD operations and cursor-based pagination. Showcase your work with images, descriptions, and links."
      },
      {
        name: "Work",
        description: "Work experience management with full CRUD operations and pagination. Track job titles, companies, durations, and descriptions."
      },
      {
        name: "Education",
        description: "Educational background management with full CRUD operations and pagination. Manage degrees, institutions, and academic achievements."
      },
      {
        name: "AI",
        description: "AI-powered chat endpoints using Google Generative AI for intelligent conversations and assistance."
      },
      {
        name: "Asset",
        description: "Image and file management with support for Cloudinary and Minio storage backends."
      },
      {
        name: "Pokemon",
        description: "Pokemon database integration with paginated listings and detailed Pokemon information from PokeAPI."
      },
      {
        name: "Social Media Downloaders",
        description: "Download videos and media from various social platforms: YouTube, TikTok, Instagram, Facebook, and X/Twitter."
      },
      {
        name: "Web3",
        description: "Blockchain integration for wallet balance checking, cryptocurrency price tracking, NFT data, and gas price monitoring across multiple networks (Ethereum, Polygon, BSC, etc.)."
      },
      {
        name: "YouTube Downloader",
        description: "YouTube content processing for extracting video metadata and downloading videos in various formats (MP4/audio)."
      },
      {
        name: "Spotify",
        description: "Spotify integration for retrieving currently playing tracks, recently played songs, and top tracks."
      },
      {
        name: "LinkedIn",
        description: "LinkedIn integration for scraping and managing professional certifications and licenses."
      },
      {
        name: "Duolingo",
        description: "Duolingo progress tracking for monitoring language learning streaks, XP, and daily goals."
      },
      {
        name: "Japanese Quiz",
        description: "Japanese vocabulary quiz system with JLPT N5-N1 levels for learning Kotoba (words)."
      },
      {
        name: "Analytics",
        description: "Website analytics and performance metrics for tracking page views, visitor statistics, and real-time data."
      }
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          bearerFormat: "JWT",
          description: "Enter your session token"
        },
        cookieAuth: {
          type: "apiKey",
          in: "cookie",
          name: "auth_session",
          description: "Session cookie authentication"
        }
      }
    },
    security: [
      {
        bearerAuth: []
      },
      {
        cookieAuth: []
      }
    ]
  }
});

// src/index.ts
var api2 = baseElysia().use(src_default({
  origin: [
    "https://rizkyhaksono.vercel.app",
    "rizkyhaksono.vercel.app",
    "https://rizkyhaksono.natee.my.id",
    "rizkyhaksono.natee.my.id",
    "https://nateee.com",
    "nateee.com",
    "https://natee.my.id",
    "natee.my.id",
    "http://localhost:3000",
    "localhost:3000"
  ],
  allowedHeaders: ["Content-Type", "Authorization"]
})).use(docs).use(api_default).get("/", () => "Up and running! \uD83D\uDDFF").get("/ping", ({ request: request27, headers }) => {
  const userAgent = headers["user-agent"] ?? "Unknown";
  const ip = headers["x-forwarded-for"] ?? headers["x-real-ip"] ?? "Unknown";
  const host = headers["host"] ?? "Unknown";
  const referer = headers["referer"] ?? "Direct access";
  const acceptLanguage = headers["accept-language"] ?? "Unknown";
  return {
    status: 200,
    message: "pong \uD83C\uDFD3",
    timestamp: new Date().toISOString(),
    user_info: {
      ip_address: ip,
      user_agent: userAgent,
      host,
      referer,
      language: acceptLanguage,
      method: request27.method,
      url: request27.url
    }
  };
}).listen("3005");
console.log(`\uD83E\uDD8A Elysia is running at ${"http://"}${api2.server?.hostname}:${api2.server?.port}`);
